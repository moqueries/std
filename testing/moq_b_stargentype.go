// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package testing

import (
	"fmt"
	"math/bits"
	"sync/atomic"
	"testing"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that testing.B_starGenType is mocked
// completely
var _ B_starGenType = (*MoqB_starGenType_mock)(nil)

// B_starGenType is the fabricated implementation type of this mock (emitted
// when mocking a collections of methods directly and not from an interface
// type)
type B_starGenType interface {
	StartTimer()
	StopTimer()
	ResetTimer()
	SetBytes(n int64)
	ReportAllocs()
	ReportMetric(n float64, unit string)
	Run(name string, f func(b *testing.B)) bool
	RunParallel(body func(*testing.PB))
	SetParallelism(p int)
}

// MoqB_starGenType holds the state of a moq of the B_starGenType type
type MoqB_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqB_starGenType_mock

	ResultsByParams_StartTimer     []MoqB_starGenType_StartTimer_resultsByParams
	ResultsByParams_StopTimer      []MoqB_starGenType_StopTimer_resultsByParams
	ResultsByParams_ResetTimer     []MoqB_starGenType_ResetTimer_resultsByParams
	ResultsByParams_SetBytes       []MoqB_starGenType_SetBytes_resultsByParams
	ResultsByParams_ReportAllocs   []MoqB_starGenType_ReportAllocs_resultsByParams
	ResultsByParams_ReportMetric   []MoqB_starGenType_ReportMetric_resultsByParams
	ResultsByParams_Run            []MoqB_starGenType_Run_resultsByParams
	ResultsByParams_RunParallel    []MoqB_starGenType_RunParallel_resultsByParams
	ResultsByParams_SetParallelism []MoqB_starGenType_SetParallelism_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			StartTimer struct{}
			StopTimer  struct{}
			ResetTimer struct{}
			SetBytes   struct {
				N moq.ParamIndexing
			}
			ReportAllocs struct{}
			ReportMetric struct {
				N    moq.ParamIndexing
				Unit moq.ParamIndexing
			}
			Run struct {
				Name moq.ParamIndexing
				F    moq.ParamIndexing
			}
			RunParallel struct {
				Body moq.ParamIndexing
			}
			SetParallelism struct {
				P moq.ParamIndexing
			}
		}
	}
	// MoqB_starGenType_mock isolates the mock interface of the B_starGenType type
}

type MoqB_starGenType_mock struct {
	Moq *MoqB_starGenType
}

// MoqB_starGenType_recorder isolates the recorder interface of the
// B_starGenType type
type MoqB_starGenType_recorder struct {
	Moq *MoqB_starGenType
}

// MoqB_starGenType_StartTimer_params holds the params of the B_starGenType
// type
type MoqB_starGenType_StartTimer_params struct{}

// MoqB_starGenType_StartTimer_paramsKey holds the map key params of the
// B_starGenType type
type MoqB_starGenType_StartTimer_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqB_starGenType_StartTimer_resultsByParams contains the results for a given
// set of parameters for the B_starGenType type
type MoqB_starGenType_StartTimer_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqB_starGenType_StartTimer_paramsKey]*MoqB_starGenType_StartTimer_results
}

// MoqB_starGenType_StartTimer_doFn defines the type of function needed when
// calling AndDo for the B_starGenType type
type MoqB_starGenType_StartTimer_doFn func()

// MoqB_starGenType_StartTimer_doReturnFn defines the type of function needed
// when calling DoReturnResults for the B_starGenType type
type MoqB_starGenType_StartTimer_doReturnFn func()

// MoqB_starGenType_StartTimer_results holds the results of the B_starGenType
// type
type MoqB_starGenType_StartTimer_results struct {
	Params  MoqB_starGenType_StartTimer_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_StartTimer_doFn
		DoReturnFn MoqB_starGenType_StartTimer_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqB_starGenType_StartTimer_fnRecorder routes recorded function calls to the
// MoqB_starGenType moq
type MoqB_starGenType_StartTimer_fnRecorder struct {
	Params    MoqB_starGenType_StartTimer_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqB_starGenType_StartTimer_results
	Moq       *MoqB_starGenType
}

// MoqB_starGenType_StartTimer_anyParams isolates the any params functions of
// the B_starGenType type
type MoqB_starGenType_StartTimer_anyParams struct {
	Recorder *MoqB_starGenType_StartTimer_fnRecorder
}

// MoqB_starGenType_StopTimer_params holds the params of the B_starGenType type
type MoqB_starGenType_StopTimer_params struct{}

// MoqB_starGenType_StopTimer_paramsKey holds the map key params of the
// B_starGenType type
type MoqB_starGenType_StopTimer_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqB_starGenType_StopTimer_resultsByParams contains the results for a given
// set of parameters for the B_starGenType type
type MoqB_starGenType_StopTimer_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqB_starGenType_StopTimer_paramsKey]*MoqB_starGenType_StopTimer_results
}

// MoqB_starGenType_StopTimer_doFn defines the type of function needed when
// calling AndDo for the B_starGenType type
type MoqB_starGenType_StopTimer_doFn func()

// MoqB_starGenType_StopTimer_doReturnFn defines the type of function needed
// when calling DoReturnResults for the B_starGenType type
type MoqB_starGenType_StopTimer_doReturnFn func()

// MoqB_starGenType_StopTimer_results holds the results of the B_starGenType
// type
type MoqB_starGenType_StopTimer_results struct {
	Params  MoqB_starGenType_StopTimer_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_StopTimer_doFn
		DoReturnFn MoqB_starGenType_StopTimer_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqB_starGenType_StopTimer_fnRecorder routes recorded function calls to the
// MoqB_starGenType moq
type MoqB_starGenType_StopTimer_fnRecorder struct {
	Params    MoqB_starGenType_StopTimer_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqB_starGenType_StopTimer_results
	Moq       *MoqB_starGenType
}

// MoqB_starGenType_StopTimer_anyParams isolates the any params functions of
// the B_starGenType type
type MoqB_starGenType_StopTimer_anyParams struct {
	Recorder *MoqB_starGenType_StopTimer_fnRecorder
}

// MoqB_starGenType_ResetTimer_params holds the params of the B_starGenType
// type
type MoqB_starGenType_ResetTimer_params struct{}

// MoqB_starGenType_ResetTimer_paramsKey holds the map key params of the
// B_starGenType type
type MoqB_starGenType_ResetTimer_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqB_starGenType_ResetTimer_resultsByParams contains the results for a given
// set of parameters for the B_starGenType type
type MoqB_starGenType_ResetTimer_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqB_starGenType_ResetTimer_paramsKey]*MoqB_starGenType_ResetTimer_results
}

// MoqB_starGenType_ResetTimer_doFn defines the type of function needed when
// calling AndDo for the B_starGenType type
type MoqB_starGenType_ResetTimer_doFn func()

// MoqB_starGenType_ResetTimer_doReturnFn defines the type of function needed
// when calling DoReturnResults for the B_starGenType type
type MoqB_starGenType_ResetTimer_doReturnFn func()

// MoqB_starGenType_ResetTimer_results holds the results of the B_starGenType
// type
type MoqB_starGenType_ResetTimer_results struct {
	Params  MoqB_starGenType_ResetTimer_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_ResetTimer_doFn
		DoReturnFn MoqB_starGenType_ResetTimer_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqB_starGenType_ResetTimer_fnRecorder routes recorded function calls to the
// MoqB_starGenType moq
type MoqB_starGenType_ResetTimer_fnRecorder struct {
	Params    MoqB_starGenType_ResetTimer_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqB_starGenType_ResetTimer_results
	Moq       *MoqB_starGenType
}

// MoqB_starGenType_ResetTimer_anyParams isolates the any params functions of
// the B_starGenType type
type MoqB_starGenType_ResetTimer_anyParams struct {
	Recorder *MoqB_starGenType_ResetTimer_fnRecorder
}

// MoqB_starGenType_SetBytes_params holds the params of the B_starGenType type
type MoqB_starGenType_SetBytes_params struct{ N int64 }

// MoqB_starGenType_SetBytes_paramsKey holds the map key params of the
// B_starGenType type
type MoqB_starGenType_SetBytes_paramsKey struct {
	Params struct{ N int64 }
	Hashes struct{ N hash.Hash }
}

// MoqB_starGenType_SetBytes_resultsByParams contains the results for a given
// set of parameters for the B_starGenType type
type MoqB_starGenType_SetBytes_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqB_starGenType_SetBytes_paramsKey]*MoqB_starGenType_SetBytes_results
}

// MoqB_starGenType_SetBytes_doFn defines the type of function needed when
// calling AndDo for the B_starGenType type
type MoqB_starGenType_SetBytes_doFn func(n int64)

// MoqB_starGenType_SetBytes_doReturnFn defines the type of function needed
// when calling DoReturnResults for the B_starGenType type
type MoqB_starGenType_SetBytes_doReturnFn func(n int64)

// MoqB_starGenType_SetBytes_results holds the results of the B_starGenType
// type
type MoqB_starGenType_SetBytes_results struct {
	Params  MoqB_starGenType_SetBytes_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_SetBytes_doFn
		DoReturnFn MoqB_starGenType_SetBytes_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqB_starGenType_SetBytes_fnRecorder routes recorded function calls to the
// MoqB_starGenType moq
type MoqB_starGenType_SetBytes_fnRecorder struct {
	Params    MoqB_starGenType_SetBytes_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqB_starGenType_SetBytes_results
	Moq       *MoqB_starGenType
}

// MoqB_starGenType_SetBytes_anyParams isolates the any params functions of the
// B_starGenType type
type MoqB_starGenType_SetBytes_anyParams struct {
	Recorder *MoqB_starGenType_SetBytes_fnRecorder
}

// MoqB_starGenType_ReportAllocs_params holds the params of the B_starGenType
// type
type MoqB_starGenType_ReportAllocs_params struct{}

// MoqB_starGenType_ReportAllocs_paramsKey holds the map key params of the
// B_starGenType type
type MoqB_starGenType_ReportAllocs_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqB_starGenType_ReportAllocs_resultsByParams contains the results for a
// given set of parameters for the B_starGenType type
type MoqB_starGenType_ReportAllocs_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqB_starGenType_ReportAllocs_paramsKey]*MoqB_starGenType_ReportAllocs_results
}

// MoqB_starGenType_ReportAllocs_doFn defines the type of function needed when
// calling AndDo for the B_starGenType type
type MoqB_starGenType_ReportAllocs_doFn func()

// MoqB_starGenType_ReportAllocs_doReturnFn defines the type of function needed
// when calling DoReturnResults for the B_starGenType type
type MoqB_starGenType_ReportAllocs_doReturnFn func()

// MoqB_starGenType_ReportAllocs_results holds the results of the B_starGenType
// type
type MoqB_starGenType_ReportAllocs_results struct {
	Params  MoqB_starGenType_ReportAllocs_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_ReportAllocs_doFn
		DoReturnFn MoqB_starGenType_ReportAllocs_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqB_starGenType_ReportAllocs_fnRecorder routes recorded function calls to
// the MoqB_starGenType moq
type MoqB_starGenType_ReportAllocs_fnRecorder struct {
	Params    MoqB_starGenType_ReportAllocs_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqB_starGenType_ReportAllocs_results
	Moq       *MoqB_starGenType
}

// MoqB_starGenType_ReportAllocs_anyParams isolates the any params functions of
// the B_starGenType type
type MoqB_starGenType_ReportAllocs_anyParams struct {
	Recorder *MoqB_starGenType_ReportAllocs_fnRecorder
}

// MoqB_starGenType_ReportMetric_params holds the params of the B_starGenType
// type
type MoqB_starGenType_ReportMetric_params struct {
	N    float64
	Unit string
}

// MoqB_starGenType_ReportMetric_paramsKey holds the map key params of the
// B_starGenType type
type MoqB_starGenType_ReportMetric_paramsKey struct {
	Params struct {
		N    float64
		Unit string
	}
	Hashes struct {
		N    hash.Hash
		Unit hash.Hash
	}
}

// MoqB_starGenType_ReportMetric_resultsByParams contains the results for a
// given set of parameters for the B_starGenType type
type MoqB_starGenType_ReportMetric_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqB_starGenType_ReportMetric_paramsKey]*MoqB_starGenType_ReportMetric_results
}

// MoqB_starGenType_ReportMetric_doFn defines the type of function needed when
// calling AndDo for the B_starGenType type
type MoqB_starGenType_ReportMetric_doFn func(n float64, unit string)

// MoqB_starGenType_ReportMetric_doReturnFn defines the type of function needed
// when calling DoReturnResults for the B_starGenType type
type MoqB_starGenType_ReportMetric_doReturnFn func(n float64, unit string)

// MoqB_starGenType_ReportMetric_results holds the results of the B_starGenType
// type
type MoqB_starGenType_ReportMetric_results struct {
	Params  MoqB_starGenType_ReportMetric_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_ReportMetric_doFn
		DoReturnFn MoqB_starGenType_ReportMetric_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqB_starGenType_ReportMetric_fnRecorder routes recorded function calls to
// the MoqB_starGenType moq
type MoqB_starGenType_ReportMetric_fnRecorder struct {
	Params    MoqB_starGenType_ReportMetric_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqB_starGenType_ReportMetric_results
	Moq       *MoqB_starGenType
}

// MoqB_starGenType_ReportMetric_anyParams isolates the any params functions of
// the B_starGenType type
type MoqB_starGenType_ReportMetric_anyParams struct {
	Recorder *MoqB_starGenType_ReportMetric_fnRecorder
}

// MoqB_starGenType_Run_params holds the params of the B_starGenType type
type MoqB_starGenType_Run_params struct {
	Name string
	F    func(b *testing.B)
}

// MoqB_starGenType_Run_paramsKey holds the map key params of the B_starGenType
// type
type MoqB_starGenType_Run_paramsKey struct {
	Params struct{ Name string }
	Hashes struct {
		Name hash.Hash
		F    hash.Hash
	}
}

// MoqB_starGenType_Run_resultsByParams contains the results for a given set of
// parameters for the B_starGenType type
type MoqB_starGenType_Run_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqB_starGenType_Run_paramsKey]*MoqB_starGenType_Run_results
}

// MoqB_starGenType_Run_doFn defines the type of function needed when calling
// AndDo for the B_starGenType type
type MoqB_starGenType_Run_doFn func(name string, f func(b *testing.B))

// MoqB_starGenType_Run_doReturnFn defines the type of function needed when
// calling DoReturnResults for the B_starGenType type
type MoqB_starGenType_Run_doReturnFn func(name string, f func(b *testing.B)) bool

// MoqB_starGenType_Run_results holds the results of the B_starGenType type
type MoqB_starGenType_Run_results struct {
	Params  MoqB_starGenType_Run_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqB_starGenType_Run_doFn
		DoReturnFn MoqB_starGenType_Run_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqB_starGenType_Run_fnRecorder routes recorded function calls to the
// MoqB_starGenType moq
type MoqB_starGenType_Run_fnRecorder struct {
	Params    MoqB_starGenType_Run_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqB_starGenType_Run_results
	Moq       *MoqB_starGenType
}

// MoqB_starGenType_Run_anyParams isolates the any params functions of the
// B_starGenType type
type MoqB_starGenType_Run_anyParams struct {
	Recorder *MoqB_starGenType_Run_fnRecorder
}

// MoqB_starGenType_RunParallel_params holds the params of the B_starGenType
// type
type MoqB_starGenType_RunParallel_params struct{ Body func(*testing.PB) }

// MoqB_starGenType_RunParallel_paramsKey holds the map key params of the
// B_starGenType type
type MoqB_starGenType_RunParallel_paramsKey struct {
	Params struct{}
	Hashes struct{ Body hash.Hash }
}

// MoqB_starGenType_RunParallel_resultsByParams contains the results for a
// given set of parameters for the B_starGenType type
type MoqB_starGenType_RunParallel_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqB_starGenType_RunParallel_paramsKey]*MoqB_starGenType_RunParallel_results
}

// MoqB_starGenType_RunParallel_doFn defines the type of function needed when
// calling AndDo for the B_starGenType type
type MoqB_starGenType_RunParallel_doFn func(body func(*testing.PB))

// MoqB_starGenType_RunParallel_doReturnFn defines the type of function needed
// when calling DoReturnResults for the B_starGenType type
type MoqB_starGenType_RunParallel_doReturnFn func(body func(*testing.PB))

// MoqB_starGenType_RunParallel_results holds the results of the B_starGenType
// type
type MoqB_starGenType_RunParallel_results struct {
	Params  MoqB_starGenType_RunParallel_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_RunParallel_doFn
		DoReturnFn MoqB_starGenType_RunParallel_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqB_starGenType_RunParallel_fnRecorder routes recorded function calls to
// the MoqB_starGenType moq
type MoqB_starGenType_RunParallel_fnRecorder struct {
	Params    MoqB_starGenType_RunParallel_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqB_starGenType_RunParallel_results
	Moq       *MoqB_starGenType
}

// MoqB_starGenType_RunParallel_anyParams isolates the any params functions of
// the B_starGenType type
type MoqB_starGenType_RunParallel_anyParams struct {
	Recorder *MoqB_starGenType_RunParallel_fnRecorder
}

// MoqB_starGenType_SetParallelism_params holds the params of the B_starGenType
// type
type MoqB_starGenType_SetParallelism_params struct{ P int }

// MoqB_starGenType_SetParallelism_paramsKey holds the map key params of the
// B_starGenType type
type MoqB_starGenType_SetParallelism_paramsKey struct {
	Params struct{ P int }
	Hashes struct{ P hash.Hash }
}

// MoqB_starGenType_SetParallelism_resultsByParams contains the results for a
// given set of parameters for the B_starGenType type
type MoqB_starGenType_SetParallelism_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqB_starGenType_SetParallelism_paramsKey]*MoqB_starGenType_SetParallelism_results
}

// MoqB_starGenType_SetParallelism_doFn defines the type of function needed
// when calling AndDo for the B_starGenType type
type MoqB_starGenType_SetParallelism_doFn func(p int)

// MoqB_starGenType_SetParallelism_doReturnFn defines the type of function
// needed when calling DoReturnResults for the B_starGenType type
type MoqB_starGenType_SetParallelism_doReturnFn func(p int)

// MoqB_starGenType_SetParallelism_results holds the results of the
// B_starGenType type
type MoqB_starGenType_SetParallelism_results struct {
	Params  MoqB_starGenType_SetParallelism_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_SetParallelism_doFn
		DoReturnFn MoqB_starGenType_SetParallelism_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqB_starGenType_SetParallelism_fnRecorder routes recorded function calls to
// the MoqB_starGenType moq
type MoqB_starGenType_SetParallelism_fnRecorder struct {
	Params    MoqB_starGenType_SetParallelism_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqB_starGenType_SetParallelism_results
	Moq       *MoqB_starGenType
}

// MoqB_starGenType_SetParallelism_anyParams isolates the any params functions
// of the B_starGenType type
type MoqB_starGenType_SetParallelism_anyParams struct {
	Recorder *MoqB_starGenType_SetParallelism_fnRecorder
}

// NewMoqB_starGenType creates a new moq of the B_starGenType type
func NewMoqB_starGenType(scene *moq.Scene, config *moq.Config) *MoqB_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqB_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqB_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				StartTimer struct{}
				StopTimer  struct{}
				ResetTimer struct{}
				SetBytes   struct {
					N moq.ParamIndexing
				}
				ReportAllocs struct{}
				ReportMetric struct {
					N    moq.ParamIndexing
					Unit moq.ParamIndexing
				}
				Run struct {
					Name moq.ParamIndexing
					F    moq.ParamIndexing
				}
				RunParallel struct {
					Body moq.ParamIndexing
				}
				SetParallelism struct {
					P moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			StartTimer struct{}
			StopTimer  struct{}
			ResetTimer struct{}
			SetBytes   struct {
				N moq.ParamIndexing
			}
			ReportAllocs struct{}
			ReportMetric struct {
				N    moq.ParamIndexing
				Unit moq.ParamIndexing
			}
			Run struct {
				Name moq.ParamIndexing
				F    moq.ParamIndexing
			}
			RunParallel struct {
				Body moq.ParamIndexing
			}
			SetParallelism struct {
				P moq.ParamIndexing
			}
		}{
			StartTimer: struct{}{},
			StopTimer:  struct{}{},
			ResetTimer: struct{}{},
			SetBytes: struct {
				N moq.ParamIndexing
			}{
				N: moq.ParamIndexByValue,
			},
			ReportAllocs: struct{}{},
			ReportMetric: struct {
				N    moq.ParamIndexing
				Unit moq.ParamIndexing
			}{
				N:    moq.ParamIndexByValue,
				Unit: moq.ParamIndexByValue,
			},
			Run: struct {
				Name moq.ParamIndexing
				F    moq.ParamIndexing
			}{
				Name: moq.ParamIndexByValue,
				F:    moq.ParamIndexByHash,
			},
			RunParallel: struct {
				Body moq.ParamIndexing
			}{
				Body: moq.ParamIndexByHash,
			},
			SetParallelism: struct {
				P moq.ParamIndexing
			}{
				P: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the B_starGenType type
func (m *MoqB_starGenType) Mock() *MoqB_starGenType_mock { return m.Moq }

func (m *MoqB_starGenType_mock) StartTimer() {
	m.Moq.Scene.T.Helper()
	params := MoqB_starGenType_StartTimer_params{}
	var results *MoqB_starGenType_StartTimer_results
	for _, resultsByParams := range m.Moq.ResultsByParams_StartTimer {
		paramsKey := m.Moq.ParamsKey_StartTimer(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_StartTimer(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_StartTimer(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_StartTimer(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqB_starGenType_mock) StopTimer() {
	m.Moq.Scene.T.Helper()
	params := MoqB_starGenType_StopTimer_params{}
	var results *MoqB_starGenType_StopTimer_results
	for _, resultsByParams := range m.Moq.ResultsByParams_StopTimer {
		paramsKey := m.Moq.ParamsKey_StopTimer(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_StopTimer(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_StopTimer(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_StopTimer(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqB_starGenType_mock) ResetTimer() {
	m.Moq.Scene.T.Helper()
	params := MoqB_starGenType_ResetTimer_params{}
	var results *MoqB_starGenType_ResetTimer_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ResetTimer {
		paramsKey := m.Moq.ParamsKey_ResetTimer(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ResetTimer(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ResetTimer(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ResetTimer(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqB_starGenType_mock) SetBytes(n int64) {
	m.Moq.Scene.T.Helper()
	params := MoqB_starGenType_SetBytes_params{
		N: n,
	}
	var results *MoqB_starGenType_SetBytes_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetBytes {
		paramsKey := m.Moq.ParamsKey_SetBytes(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetBytes(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetBytes(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetBytes(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(n)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(n)
	}
	return
}

func (m *MoqB_starGenType_mock) ReportAllocs() {
	m.Moq.Scene.T.Helper()
	params := MoqB_starGenType_ReportAllocs_params{}
	var results *MoqB_starGenType_ReportAllocs_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReportAllocs {
		paramsKey := m.Moq.ParamsKey_ReportAllocs(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReportAllocs(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReportAllocs(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReportAllocs(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqB_starGenType_mock) ReportMetric(n float64, unit string) {
	m.Moq.Scene.T.Helper()
	params := MoqB_starGenType_ReportMetric_params{
		N:    n,
		Unit: unit,
	}
	var results *MoqB_starGenType_ReportMetric_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReportMetric {
		paramsKey := m.Moq.ParamsKey_ReportMetric(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReportMetric(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReportMetric(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReportMetric(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(n, unit)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(n, unit)
	}
	return
}

func (m *MoqB_starGenType_mock) Run(name string, f func(b *testing.B)) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqB_starGenType_Run_params{
		Name: name,
		F:    f,
	}
	var results *MoqB_starGenType_Run_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Run {
		paramsKey := m.Moq.ParamsKey_Run(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Run(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Run(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Run(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(name, f)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(name, f)
	}
	return
}

func (m *MoqB_starGenType_mock) RunParallel(body func(*testing.PB)) {
	m.Moq.Scene.T.Helper()
	params := MoqB_starGenType_RunParallel_params{
		Body: body,
	}
	var results *MoqB_starGenType_RunParallel_results
	for _, resultsByParams := range m.Moq.ResultsByParams_RunParallel {
		paramsKey := m.Moq.ParamsKey_RunParallel(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_RunParallel(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_RunParallel(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_RunParallel(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(body)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(body)
	}
	return
}

func (m *MoqB_starGenType_mock) SetParallelism(p int) {
	m.Moq.Scene.T.Helper()
	params := MoqB_starGenType_SetParallelism_params{
		P: p,
	}
	var results *MoqB_starGenType_SetParallelism_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetParallelism {
		paramsKey := m.Moq.ParamsKey_SetParallelism(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetParallelism(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetParallelism(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetParallelism(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(p)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(p)
	}
	return
}

// OnCall returns the recorder implementation of the B_starGenType type
func (m *MoqB_starGenType) OnCall() *MoqB_starGenType_recorder {
	return &MoqB_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqB_starGenType_recorder) StartTimer() *MoqB_starGenType_StartTimer_fnRecorder {
	return &MoqB_starGenType_StartTimer_fnRecorder{
		Params:   MoqB_starGenType_StartTimer_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqB_starGenType_StartTimer_fnRecorder) Any() *MoqB_starGenType_StartTimer_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StartTimer(r.Params))
		return nil
	}
	return &MoqB_starGenType_StartTimer_anyParams{Recorder: r}
}

func (r *MoqB_starGenType_StartTimer_fnRecorder) Seq() *MoqB_starGenType_StartTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StartTimer(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqB_starGenType_StartTimer_fnRecorder) NoSeq() *MoqB_starGenType_StartTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StartTimer(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqB_starGenType_StartTimer_fnRecorder) ReturnResults() *MoqB_starGenType_StartTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_StartTimer_doFn
		DoReturnFn MoqB_starGenType_StartTimer_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqB_starGenType_StartTimer_fnRecorder) AndDo(fn MoqB_starGenType_StartTimer_doFn) *MoqB_starGenType_StartTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqB_starGenType_StartTimer_fnRecorder) DoReturnResults(fn MoqB_starGenType_StartTimer_doReturnFn) *MoqB_starGenType_StartTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_StartTimer_doFn
		DoReturnFn MoqB_starGenType_StartTimer_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqB_starGenType_StartTimer_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqB_starGenType_StartTimer_resultsByParams
	for n, res := range r.Moq.ResultsByParams_StartTimer {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqB_starGenType_StartTimer_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqB_starGenType_StartTimer_paramsKey]*MoqB_starGenType_StartTimer_results{},
		}
		r.Moq.ResultsByParams_StartTimer = append(r.Moq.ResultsByParams_StartTimer, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_StartTimer) {
			copy(r.Moq.ResultsByParams_StartTimer[insertAt+1:], r.Moq.ResultsByParams_StartTimer[insertAt:0])
			r.Moq.ResultsByParams_StartTimer[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_StartTimer(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqB_starGenType_StartTimer_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqB_starGenType_StartTimer_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqB_starGenType_StartTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqB_starGenType_StartTimer_doFn
				DoReturnFn MoqB_starGenType_StartTimer_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqB_starGenType) PrettyParams_StartTimer(params MoqB_starGenType_StartTimer_params) string {
	return fmt.Sprintf("StartTimer()")
}

func (m *MoqB_starGenType) ParamsKey_StartTimer(params MoqB_starGenType_StartTimer_params, anyParams uint64) MoqB_starGenType_StartTimer_paramsKey {
	m.Scene.T.Helper()
	return MoqB_starGenType_StartTimer_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqB_starGenType_recorder) StopTimer() *MoqB_starGenType_StopTimer_fnRecorder {
	return &MoqB_starGenType_StopTimer_fnRecorder{
		Params:   MoqB_starGenType_StopTimer_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqB_starGenType_StopTimer_fnRecorder) Any() *MoqB_starGenType_StopTimer_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StopTimer(r.Params))
		return nil
	}
	return &MoqB_starGenType_StopTimer_anyParams{Recorder: r}
}

func (r *MoqB_starGenType_StopTimer_fnRecorder) Seq() *MoqB_starGenType_StopTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StopTimer(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqB_starGenType_StopTimer_fnRecorder) NoSeq() *MoqB_starGenType_StopTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StopTimer(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqB_starGenType_StopTimer_fnRecorder) ReturnResults() *MoqB_starGenType_StopTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_StopTimer_doFn
		DoReturnFn MoqB_starGenType_StopTimer_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqB_starGenType_StopTimer_fnRecorder) AndDo(fn MoqB_starGenType_StopTimer_doFn) *MoqB_starGenType_StopTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqB_starGenType_StopTimer_fnRecorder) DoReturnResults(fn MoqB_starGenType_StopTimer_doReturnFn) *MoqB_starGenType_StopTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_StopTimer_doFn
		DoReturnFn MoqB_starGenType_StopTimer_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqB_starGenType_StopTimer_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqB_starGenType_StopTimer_resultsByParams
	for n, res := range r.Moq.ResultsByParams_StopTimer {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqB_starGenType_StopTimer_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqB_starGenType_StopTimer_paramsKey]*MoqB_starGenType_StopTimer_results{},
		}
		r.Moq.ResultsByParams_StopTimer = append(r.Moq.ResultsByParams_StopTimer, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_StopTimer) {
			copy(r.Moq.ResultsByParams_StopTimer[insertAt+1:], r.Moq.ResultsByParams_StopTimer[insertAt:0])
			r.Moq.ResultsByParams_StopTimer[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_StopTimer(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqB_starGenType_StopTimer_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqB_starGenType_StopTimer_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqB_starGenType_StopTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqB_starGenType_StopTimer_doFn
				DoReturnFn MoqB_starGenType_StopTimer_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqB_starGenType) PrettyParams_StopTimer(params MoqB_starGenType_StopTimer_params) string {
	return fmt.Sprintf("StopTimer()")
}

func (m *MoqB_starGenType) ParamsKey_StopTimer(params MoqB_starGenType_StopTimer_params, anyParams uint64) MoqB_starGenType_StopTimer_paramsKey {
	m.Scene.T.Helper()
	return MoqB_starGenType_StopTimer_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqB_starGenType_recorder) ResetTimer() *MoqB_starGenType_ResetTimer_fnRecorder {
	return &MoqB_starGenType_ResetTimer_fnRecorder{
		Params:   MoqB_starGenType_ResetTimer_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqB_starGenType_ResetTimer_fnRecorder) Any() *MoqB_starGenType_ResetTimer_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ResetTimer(r.Params))
		return nil
	}
	return &MoqB_starGenType_ResetTimer_anyParams{Recorder: r}
}

func (r *MoqB_starGenType_ResetTimer_fnRecorder) Seq() *MoqB_starGenType_ResetTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ResetTimer(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqB_starGenType_ResetTimer_fnRecorder) NoSeq() *MoqB_starGenType_ResetTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ResetTimer(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqB_starGenType_ResetTimer_fnRecorder) ReturnResults() *MoqB_starGenType_ResetTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_ResetTimer_doFn
		DoReturnFn MoqB_starGenType_ResetTimer_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqB_starGenType_ResetTimer_fnRecorder) AndDo(fn MoqB_starGenType_ResetTimer_doFn) *MoqB_starGenType_ResetTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqB_starGenType_ResetTimer_fnRecorder) DoReturnResults(fn MoqB_starGenType_ResetTimer_doReturnFn) *MoqB_starGenType_ResetTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_ResetTimer_doFn
		DoReturnFn MoqB_starGenType_ResetTimer_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqB_starGenType_ResetTimer_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqB_starGenType_ResetTimer_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ResetTimer {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqB_starGenType_ResetTimer_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqB_starGenType_ResetTimer_paramsKey]*MoqB_starGenType_ResetTimer_results{},
		}
		r.Moq.ResultsByParams_ResetTimer = append(r.Moq.ResultsByParams_ResetTimer, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ResetTimer) {
			copy(r.Moq.ResultsByParams_ResetTimer[insertAt+1:], r.Moq.ResultsByParams_ResetTimer[insertAt:0])
			r.Moq.ResultsByParams_ResetTimer[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ResetTimer(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqB_starGenType_ResetTimer_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqB_starGenType_ResetTimer_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqB_starGenType_ResetTimer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqB_starGenType_ResetTimer_doFn
				DoReturnFn MoqB_starGenType_ResetTimer_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqB_starGenType) PrettyParams_ResetTimer(params MoqB_starGenType_ResetTimer_params) string {
	return fmt.Sprintf("ResetTimer()")
}

func (m *MoqB_starGenType) ParamsKey_ResetTimer(params MoqB_starGenType_ResetTimer_params, anyParams uint64) MoqB_starGenType_ResetTimer_paramsKey {
	m.Scene.T.Helper()
	return MoqB_starGenType_ResetTimer_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqB_starGenType_recorder) SetBytes(n int64) *MoqB_starGenType_SetBytes_fnRecorder {
	return &MoqB_starGenType_SetBytes_fnRecorder{
		Params: MoqB_starGenType_SetBytes_params{
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqB_starGenType_SetBytes_fnRecorder) Any() *MoqB_starGenType_SetBytes_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBytes(r.Params))
		return nil
	}
	return &MoqB_starGenType_SetBytes_anyParams{Recorder: r}
}

func (a *MoqB_starGenType_SetBytes_anyParams) N() *MoqB_starGenType_SetBytes_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqB_starGenType_SetBytes_fnRecorder) Seq() *MoqB_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBytes(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqB_starGenType_SetBytes_fnRecorder) NoSeq() *MoqB_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBytes(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqB_starGenType_SetBytes_fnRecorder) ReturnResults() *MoqB_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_SetBytes_doFn
		DoReturnFn MoqB_starGenType_SetBytes_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqB_starGenType_SetBytes_fnRecorder) AndDo(fn MoqB_starGenType_SetBytes_doFn) *MoqB_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqB_starGenType_SetBytes_fnRecorder) DoReturnResults(fn MoqB_starGenType_SetBytes_doReturnFn) *MoqB_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_SetBytes_doFn
		DoReturnFn MoqB_starGenType_SetBytes_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqB_starGenType_SetBytes_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqB_starGenType_SetBytes_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetBytes {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqB_starGenType_SetBytes_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqB_starGenType_SetBytes_paramsKey]*MoqB_starGenType_SetBytes_results{},
		}
		r.Moq.ResultsByParams_SetBytes = append(r.Moq.ResultsByParams_SetBytes, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetBytes) {
			copy(r.Moq.ResultsByParams_SetBytes[insertAt+1:], r.Moq.ResultsByParams_SetBytes[insertAt:0])
			r.Moq.ResultsByParams_SetBytes[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetBytes(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqB_starGenType_SetBytes_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqB_starGenType_SetBytes_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqB_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqB_starGenType_SetBytes_doFn
				DoReturnFn MoqB_starGenType_SetBytes_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqB_starGenType) PrettyParams_SetBytes(params MoqB_starGenType_SetBytes_params) string {
	return fmt.Sprintf("SetBytes(%#v)", params.N)
}

func (m *MoqB_starGenType) ParamsKey_SetBytes(params MoqB_starGenType_SetBytes_params, anyParams uint64) MoqB_starGenType_SetBytes_paramsKey {
	m.Scene.T.Helper()
	var nUsed int64
	var nUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetBytes.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqB_starGenType_SetBytes_paramsKey{
		Params: struct{ N int64 }{
			N: nUsed,
		},
		Hashes: struct{ N hash.Hash }{
			N: nUsedHash,
		},
	}
}

func (m *MoqB_starGenType_recorder) ReportAllocs() *MoqB_starGenType_ReportAllocs_fnRecorder {
	return &MoqB_starGenType_ReportAllocs_fnRecorder{
		Params:   MoqB_starGenType_ReportAllocs_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqB_starGenType_ReportAllocs_fnRecorder) Any() *MoqB_starGenType_ReportAllocs_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReportAllocs(r.Params))
		return nil
	}
	return &MoqB_starGenType_ReportAllocs_anyParams{Recorder: r}
}

func (r *MoqB_starGenType_ReportAllocs_fnRecorder) Seq() *MoqB_starGenType_ReportAllocs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReportAllocs(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqB_starGenType_ReportAllocs_fnRecorder) NoSeq() *MoqB_starGenType_ReportAllocs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReportAllocs(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqB_starGenType_ReportAllocs_fnRecorder) ReturnResults() *MoqB_starGenType_ReportAllocs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_ReportAllocs_doFn
		DoReturnFn MoqB_starGenType_ReportAllocs_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqB_starGenType_ReportAllocs_fnRecorder) AndDo(fn MoqB_starGenType_ReportAllocs_doFn) *MoqB_starGenType_ReportAllocs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqB_starGenType_ReportAllocs_fnRecorder) DoReturnResults(fn MoqB_starGenType_ReportAllocs_doReturnFn) *MoqB_starGenType_ReportAllocs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_ReportAllocs_doFn
		DoReturnFn MoqB_starGenType_ReportAllocs_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqB_starGenType_ReportAllocs_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqB_starGenType_ReportAllocs_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReportAllocs {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqB_starGenType_ReportAllocs_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqB_starGenType_ReportAllocs_paramsKey]*MoqB_starGenType_ReportAllocs_results{},
		}
		r.Moq.ResultsByParams_ReportAllocs = append(r.Moq.ResultsByParams_ReportAllocs, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReportAllocs) {
			copy(r.Moq.ResultsByParams_ReportAllocs[insertAt+1:], r.Moq.ResultsByParams_ReportAllocs[insertAt:0])
			r.Moq.ResultsByParams_ReportAllocs[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReportAllocs(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqB_starGenType_ReportAllocs_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqB_starGenType_ReportAllocs_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqB_starGenType_ReportAllocs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqB_starGenType_ReportAllocs_doFn
				DoReturnFn MoqB_starGenType_ReportAllocs_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqB_starGenType) PrettyParams_ReportAllocs(params MoqB_starGenType_ReportAllocs_params) string {
	return fmt.Sprintf("ReportAllocs()")
}

func (m *MoqB_starGenType) ParamsKey_ReportAllocs(params MoqB_starGenType_ReportAllocs_params, anyParams uint64) MoqB_starGenType_ReportAllocs_paramsKey {
	m.Scene.T.Helper()
	return MoqB_starGenType_ReportAllocs_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqB_starGenType_recorder) ReportMetric(n float64, unit string) *MoqB_starGenType_ReportMetric_fnRecorder {
	return &MoqB_starGenType_ReportMetric_fnRecorder{
		Params: MoqB_starGenType_ReportMetric_params{
			N:    n,
			Unit: unit,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqB_starGenType_ReportMetric_fnRecorder) Any() *MoqB_starGenType_ReportMetric_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReportMetric(r.Params))
		return nil
	}
	return &MoqB_starGenType_ReportMetric_anyParams{Recorder: r}
}

func (a *MoqB_starGenType_ReportMetric_anyParams) N() *MoqB_starGenType_ReportMetric_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqB_starGenType_ReportMetric_anyParams) Unit() *MoqB_starGenType_ReportMetric_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqB_starGenType_ReportMetric_fnRecorder) Seq() *MoqB_starGenType_ReportMetric_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReportMetric(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqB_starGenType_ReportMetric_fnRecorder) NoSeq() *MoqB_starGenType_ReportMetric_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReportMetric(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqB_starGenType_ReportMetric_fnRecorder) ReturnResults() *MoqB_starGenType_ReportMetric_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_ReportMetric_doFn
		DoReturnFn MoqB_starGenType_ReportMetric_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqB_starGenType_ReportMetric_fnRecorder) AndDo(fn MoqB_starGenType_ReportMetric_doFn) *MoqB_starGenType_ReportMetric_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqB_starGenType_ReportMetric_fnRecorder) DoReturnResults(fn MoqB_starGenType_ReportMetric_doReturnFn) *MoqB_starGenType_ReportMetric_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_ReportMetric_doFn
		DoReturnFn MoqB_starGenType_ReportMetric_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqB_starGenType_ReportMetric_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqB_starGenType_ReportMetric_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReportMetric {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqB_starGenType_ReportMetric_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqB_starGenType_ReportMetric_paramsKey]*MoqB_starGenType_ReportMetric_results{},
		}
		r.Moq.ResultsByParams_ReportMetric = append(r.Moq.ResultsByParams_ReportMetric, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReportMetric) {
			copy(r.Moq.ResultsByParams_ReportMetric[insertAt+1:], r.Moq.ResultsByParams_ReportMetric[insertAt:0])
			r.Moq.ResultsByParams_ReportMetric[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReportMetric(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqB_starGenType_ReportMetric_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqB_starGenType_ReportMetric_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqB_starGenType_ReportMetric_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqB_starGenType_ReportMetric_doFn
				DoReturnFn MoqB_starGenType_ReportMetric_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqB_starGenType) PrettyParams_ReportMetric(params MoqB_starGenType_ReportMetric_params) string {
	return fmt.Sprintf("ReportMetric(%#v, %#v)", params.N, params.Unit)
}

func (m *MoqB_starGenType) ParamsKey_ReportMetric(params MoqB_starGenType_ReportMetric_params, anyParams uint64) MoqB_starGenType_ReportMetric_paramsKey {
	m.Scene.T.Helper()
	var nUsed float64
	var nUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ReportMetric.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	var unitUsed string
	var unitUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ReportMetric.Unit == moq.ParamIndexByValue {
			unitUsed = params.Unit
		} else {
			unitUsedHash = hash.DeepHash(params.Unit)
		}
	}
	return MoqB_starGenType_ReportMetric_paramsKey{
		Params: struct {
			N    float64
			Unit string
		}{
			N:    nUsed,
			Unit: unitUsed,
		},
		Hashes: struct {
			N    hash.Hash
			Unit hash.Hash
		}{
			N:    nUsedHash,
			Unit: unitUsedHash,
		},
	}
}

func (m *MoqB_starGenType_recorder) Run(name string, f func(b *testing.B)) *MoqB_starGenType_Run_fnRecorder {
	return &MoqB_starGenType_Run_fnRecorder{
		Params: MoqB_starGenType_Run_params{
			Name: name,
			F:    f,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqB_starGenType_Run_fnRecorder) Any() *MoqB_starGenType_Run_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Run(r.Params))
		return nil
	}
	return &MoqB_starGenType_Run_anyParams{Recorder: r}
}

func (a *MoqB_starGenType_Run_anyParams) Name() *MoqB_starGenType_Run_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqB_starGenType_Run_anyParams) F() *MoqB_starGenType_Run_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqB_starGenType_Run_fnRecorder) Seq() *MoqB_starGenType_Run_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Run(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqB_starGenType_Run_fnRecorder) NoSeq() *MoqB_starGenType_Run_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Run(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqB_starGenType_Run_fnRecorder) ReturnResults(result1 bool) *MoqB_starGenType_Run_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqB_starGenType_Run_doFn
		DoReturnFn MoqB_starGenType_Run_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqB_starGenType_Run_fnRecorder) AndDo(fn MoqB_starGenType_Run_doFn) *MoqB_starGenType_Run_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqB_starGenType_Run_fnRecorder) DoReturnResults(fn MoqB_starGenType_Run_doReturnFn) *MoqB_starGenType_Run_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqB_starGenType_Run_doFn
		DoReturnFn MoqB_starGenType_Run_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqB_starGenType_Run_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqB_starGenType_Run_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Run {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqB_starGenType_Run_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqB_starGenType_Run_paramsKey]*MoqB_starGenType_Run_results{},
		}
		r.Moq.ResultsByParams_Run = append(r.Moq.ResultsByParams_Run, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Run) {
			copy(r.Moq.ResultsByParams_Run[insertAt+1:], r.Moq.ResultsByParams_Run[insertAt:0])
			r.Moq.ResultsByParams_Run[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Run(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqB_starGenType_Run_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqB_starGenType_Run_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqB_starGenType_Run_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqB_starGenType_Run_doFn
				DoReturnFn MoqB_starGenType_Run_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqB_starGenType) PrettyParams_Run(params MoqB_starGenType_Run_params) string {
	return fmt.Sprintf("Run(%#v, %#v)", params.Name, params.F)
}

func (m *MoqB_starGenType) ParamsKey_Run(params MoqB_starGenType_Run_params, anyParams uint64) MoqB_starGenType_Run_paramsKey {
	m.Scene.T.Helper()
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Run.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	var fUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Run.F == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The f parameter of the Run function can't be indexed by value")
		}
		fUsedHash = hash.DeepHash(params.F)
	}
	return MoqB_starGenType_Run_paramsKey{
		Params: struct{ Name string }{
			Name: nameUsed,
		},
		Hashes: struct {
			Name hash.Hash
			F    hash.Hash
		}{
			Name: nameUsedHash,
			F:    fUsedHash,
		},
	}
}

func (m *MoqB_starGenType_recorder) RunParallel(body func(*testing.PB)) *MoqB_starGenType_RunParallel_fnRecorder {
	return &MoqB_starGenType_RunParallel_fnRecorder{
		Params: MoqB_starGenType_RunParallel_params{
			Body: body,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqB_starGenType_RunParallel_fnRecorder) Any() *MoqB_starGenType_RunParallel_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RunParallel(r.Params))
		return nil
	}
	return &MoqB_starGenType_RunParallel_anyParams{Recorder: r}
}

func (a *MoqB_starGenType_RunParallel_anyParams) Body() *MoqB_starGenType_RunParallel_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqB_starGenType_RunParallel_fnRecorder) Seq() *MoqB_starGenType_RunParallel_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RunParallel(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqB_starGenType_RunParallel_fnRecorder) NoSeq() *MoqB_starGenType_RunParallel_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RunParallel(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqB_starGenType_RunParallel_fnRecorder) ReturnResults() *MoqB_starGenType_RunParallel_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_RunParallel_doFn
		DoReturnFn MoqB_starGenType_RunParallel_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqB_starGenType_RunParallel_fnRecorder) AndDo(fn MoqB_starGenType_RunParallel_doFn) *MoqB_starGenType_RunParallel_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqB_starGenType_RunParallel_fnRecorder) DoReturnResults(fn MoqB_starGenType_RunParallel_doReturnFn) *MoqB_starGenType_RunParallel_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_RunParallel_doFn
		DoReturnFn MoqB_starGenType_RunParallel_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqB_starGenType_RunParallel_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqB_starGenType_RunParallel_resultsByParams
	for n, res := range r.Moq.ResultsByParams_RunParallel {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqB_starGenType_RunParallel_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqB_starGenType_RunParallel_paramsKey]*MoqB_starGenType_RunParallel_results{},
		}
		r.Moq.ResultsByParams_RunParallel = append(r.Moq.ResultsByParams_RunParallel, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_RunParallel) {
			copy(r.Moq.ResultsByParams_RunParallel[insertAt+1:], r.Moq.ResultsByParams_RunParallel[insertAt:0])
			r.Moq.ResultsByParams_RunParallel[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_RunParallel(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqB_starGenType_RunParallel_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqB_starGenType_RunParallel_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqB_starGenType_RunParallel_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqB_starGenType_RunParallel_doFn
				DoReturnFn MoqB_starGenType_RunParallel_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqB_starGenType) PrettyParams_RunParallel(params MoqB_starGenType_RunParallel_params) string {
	return fmt.Sprintf("RunParallel(%#v)", params.Body)
}

func (m *MoqB_starGenType) ParamsKey_RunParallel(params MoqB_starGenType_RunParallel_params, anyParams uint64) MoqB_starGenType_RunParallel_paramsKey {
	m.Scene.T.Helper()
	var bodyUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.RunParallel.Body == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The body parameter of the RunParallel function can't be indexed by value")
		}
		bodyUsedHash = hash.DeepHash(params.Body)
	}
	return MoqB_starGenType_RunParallel_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Body hash.Hash }{
			Body: bodyUsedHash,
		},
	}
}

func (m *MoqB_starGenType_recorder) SetParallelism(p int) *MoqB_starGenType_SetParallelism_fnRecorder {
	return &MoqB_starGenType_SetParallelism_fnRecorder{
		Params: MoqB_starGenType_SetParallelism_params{
			P: p,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqB_starGenType_SetParallelism_fnRecorder) Any() *MoqB_starGenType_SetParallelism_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetParallelism(r.Params))
		return nil
	}
	return &MoqB_starGenType_SetParallelism_anyParams{Recorder: r}
}

func (a *MoqB_starGenType_SetParallelism_anyParams) P() *MoqB_starGenType_SetParallelism_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqB_starGenType_SetParallelism_fnRecorder) Seq() *MoqB_starGenType_SetParallelism_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetParallelism(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqB_starGenType_SetParallelism_fnRecorder) NoSeq() *MoqB_starGenType_SetParallelism_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetParallelism(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqB_starGenType_SetParallelism_fnRecorder) ReturnResults() *MoqB_starGenType_SetParallelism_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_SetParallelism_doFn
		DoReturnFn MoqB_starGenType_SetParallelism_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqB_starGenType_SetParallelism_fnRecorder) AndDo(fn MoqB_starGenType_SetParallelism_doFn) *MoqB_starGenType_SetParallelism_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqB_starGenType_SetParallelism_fnRecorder) DoReturnResults(fn MoqB_starGenType_SetParallelism_doReturnFn) *MoqB_starGenType_SetParallelism_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqB_starGenType_SetParallelism_doFn
		DoReturnFn MoqB_starGenType_SetParallelism_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqB_starGenType_SetParallelism_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqB_starGenType_SetParallelism_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetParallelism {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqB_starGenType_SetParallelism_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqB_starGenType_SetParallelism_paramsKey]*MoqB_starGenType_SetParallelism_results{},
		}
		r.Moq.ResultsByParams_SetParallelism = append(r.Moq.ResultsByParams_SetParallelism, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetParallelism) {
			copy(r.Moq.ResultsByParams_SetParallelism[insertAt+1:], r.Moq.ResultsByParams_SetParallelism[insertAt:0])
			r.Moq.ResultsByParams_SetParallelism[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetParallelism(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqB_starGenType_SetParallelism_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqB_starGenType_SetParallelism_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqB_starGenType_SetParallelism_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqB_starGenType_SetParallelism_doFn
				DoReturnFn MoqB_starGenType_SetParallelism_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqB_starGenType) PrettyParams_SetParallelism(params MoqB_starGenType_SetParallelism_params) string {
	return fmt.Sprintf("SetParallelism(%#v)", params.P)
}

func (m *MoqB_starGenType) ParamsKey_SetParallelism(params MoqB_starGenType_SetParallelism_params, anyParams uint64) MoqB_starGenType_SetParallelism_paramsKey {
	m.Scene.T.Helper()
	var pUsed int
	var pUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetParallelism.P == moq.ParamIndexByValue {
			pUsed = params.P
		} else {
			pUsedHash = hash.DeepHash(params.P)
		}
	}
	return MoqB_starGenType_SetParallelism_paramsKey{
		Params: struct{ P int }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqB_starGenType) Reset() {
	m.ResultsByParams_StartTimer = nil
	m.ResultsByParams_StopTimer = nil
	m.ResultsByParams_ResetTimer = nil
	m.ResultsByParams_SetBytes = nil
	m.ResultsByParams_ReportAllocs = nil
	m.ResultsByParams_ReportMetric = nil
	m.ResultsByParams_Run = nil
	m.ResultsByParams_RunParallel = nil
	m.ResultsByParams_SetParallelism = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqB_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_StartTimer {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_StartTimer(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_StopTimer {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_StopTimer(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ResetTimer {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ResetTimer(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetBytes {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetBytes(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReportAllocs {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReportAllocs(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReportMetric {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReportMetric(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Run {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Run(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_RunParallel {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_RunParallel(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetParallelism {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetParallelism(results.Params))
			}
		}
	}
}
