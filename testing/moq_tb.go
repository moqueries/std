// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package testing

import (
	"fmt"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that TB_reduced is mocked completely
var _ TB_reduced = (*MoqTB_mock)(nil)

// TB_reduced is the fabricated implementation type of this mock (emitted when
// the original interface contains non-exported methods)
type TB_reduced interface {
	Cleanup(func())
	Error(args ...interface{})
	Errorf(format string, args ...interface{})
	Fail()
	FailNow()
	Failed() bool
	Fatal(args ...interface{})
	Fatalf(format string, args ...interface{})
	Helper()
	Log(args ...interface{})
	Logf(format string, args ...interface{})
	Name() string
	Setenv(key, value string)
	Skip(args ...interface{})
	SkipNow()
	Skipf(format string, args ...interface{})
	Skipped() bool
	TempDir() string
}

// MoqTB holds the state of a moq of the TB_reduced type
type MoqTB struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqTB_mock

	ResultsByParams_Cleanup []MoqTB_Cleanup_resultsByParams
	ResultsByParams_Error   []MoqTB_Error_resultsByParams
	ResultsByParams_Errorf  []MoqTB_Errorf_resultsByParams
	ResultsByParams_Fail    []MoqTB_Fail_resultsByParams
	ResultsByParams_FailNow []MoqTB_FailNow_resultsByParams
	ResultsByParams_Failed  []MoqTB_Failed_resultsByParams
	ResultsByParams_Fatal   []MoqTB_Fatal_resultsByParams
	ResultsByParams_Fatalf  []MoqTB_Fatalf_resultsByParams
	ResultsByParams_Helper  []MoqTB_Helper_resultsByParams
	ResultsByParams_Log     []MoqTB_Log_resultsByParams
	ResultsByParams_Logf    []MoqTB_Logf_resultsByParams
	ResultsByParams_Name    []MoqTB_Name_resultsByParams
	ResultsByParams_Setenv  []MoqTB_Setenv_resultsByParams
	ResultsByParams_Skip    []MoqTB_Skip_resultsByParams
	ResultsByParams_SkipNow []MoqTB_SkipNow_resultsByParams
	ResultsByParams_Skipf   []MoqTB_Skipf_resultsByParams
	ResultsByParams_Skipped []MoqTB_Skipped_resultsByParams
	ResultsByParams_TempDir []MoqTB_TempDir_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Cleanup struct {
				Param1 moq.ParamIndexing
			}
			Error struct {
				Args moq.ParamIndexing
			}
			Errorf struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}
			Fail    struct{}
			FailNow struct{}
			Failed  struct{}
			Fatal   struct {
				Args moq.ParamIndexing
			}
			Fatalf struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}
			Helper struct{}
			Log    struct {
				Args moq.ParamIndexing
			}
			Logf struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}
			Name   struct{}
			Setenv struct {
				Key   moq.ParamIndexing
				Value moq.ParamIndexing
			}
			Skip struct {
				Args moq.ParamIndexing
			}
			SkipNow struct{}
			Skipf   struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}
			Skipped struct{}
			TempDir struct{}
		}
	}
}

// MoqTB_mock isolates the mock interface of the TB type
type MoqTB_mock struct {
	Moq *MoqTB
}

// MoqTB_recorder isolates the recorder interface of the TB type
type MoqTB_recorder struct {
	Moq *MoqTB
}

// MoqTB_Cleanup_params holds the params of the TB type
type MoqTB_Cleanup_params struct{ Param1 func() }

// MoqTB_Cleanup_paramsKey holds the map key params of the TB type
type MoqTB_Cleanup_paramsKey struct {
	Params struct{}
	Hashes struct{ Param1 hash.Hash }
}

// MoqTB_Cleanup_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Cleanup_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Cleanup_paramsKey]*MoqTB_Cleanup_results
}

// MoqTB_Cleanup_doFn defines the type of function needed when calling AndDo
// for the TB type
type MoqTB_Cleanup_doFn func(func())

// MoqTB_Cleanup_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Cleanup_doReturnFn func(func())

// MoqTB_Cleanup_results holds the results of the TB type
type MoqTB_Cleanup_results struct {
	Params  MoqTB_Cleanup_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Cleanup_doFn
		DoReturnFn MoqTB_Cleanup_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Cleanup_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Cleanup_fnRecorder struct {
	Params    MoqTB_Cleanup_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Cleanup_results
	Moq       *MoqTB
}

// MoqTB_Cleanup_anyParams isolates the any params functions of the TB type
type MoqTB_Cleanup_anyParams struct {
	Recorder *MoqTB_Cleanup_fnRecorder
}

// MoqTB_Error_params holds the params of the TB type
type MoqTB_Error_params struct{ Args []interface{} }

// MoqTB_Error_paramsKey holds the map key params of the TB type
type MoqTB_Error_paramsKey struct {
	Params struct{}
	Hashes struct{ Args hash.Hash }
}

// MoqTB_Error_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Error_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Error_paramsKey]*MoqTB_Error_results
}

// MoqTB_Error_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Error_doFn func(args ...interface{})

// MoqTB_Error_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Error_doReturnFn func(args ...interface{})

// MoqTB_Error_results holds the results of the TB type
type MoqTB_Error_results struct {
	Params  MoqTB_Error_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Error_doFn
		DoReturnFn MoqTB_Error_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Error_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Error_fnRecorder struct {
	Params    MoqTB_Error_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Error_results
	Moq       *MoqTB
}

// MoqTB_Error_anyParams isolates the any params functions of the TB type
type MoqTB_Error_anyParams struct {
	Recorder *MoqTB_Error_fnRecorder
}

// MoqTB_Errorf_params holds the params of the TB type
type MoqTB_Errorf_params struct {
	Format string
	Args   []interface{}
}

// MoqTB_Errorf_paramsKey holds the map key params of the TB type
type MoqTB_Errorf_paramsKey struct {
	Params struct{ Format string }
	Hashes struct {
		Format hash.Hash
		Args   hash.Hash
	}
}

// MoqTB_Errorf_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Errorf_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Errorf_paramsKey]*MoqTB_Errorf_results
}

// MoqTB_Errorf_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Errorf_doFn func(format string, args ...interface{})

// MoqTB_Errorf_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Errorf_doReturnFn func(format string, args ...interface{})

// MoqTB_Errorf_results holds the results of the TB type
type MoqTB_Errorf_results struct {
	Params  MoqTB_Errorf_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Errorf_doFn
		DoReturnFn MoqTB_Errorf_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Errorf_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Errorf_fnRecorder struct {
	Params    MoqTB_Errorf_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Errorf_results
	Moq       *MoqTB
}

// MoqTB_Errorf_anyParams isolates the any params functions of the TB type
type MoqTB_Errorf_anyParams struct {
	Recorder *MoqTB_Errorf_fnRecorder
}

// MoqTB_Fail_params holds the params of the TB type
type MoqTB_Fail_params struct{}

// MoqTB_Fail_paramsKey holds the map key params of the TB type
type MoqTB_Fail_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTB_Fail_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Fail_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Fail_paramsKey]*MoqTB_Fail_results
}

// MoqTB_Fail_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Fail_doFn func()

// MoqTB_Fail_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Fail_doReturnFn func()

// MoqTB_Fail_results holds the results of the TB type
type MoqTB_Fail_results struct {
	Params  MoqTB_Fail_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Fail_doFn
		DoReturnFn MoqTB_Fail_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Fail_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Fail_fnRecorder struct {
	Params    MoqTB_Fail_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Fail_results
	Moq       *MoqTB
}

// MoqTB_Fail_anyParams isolates the any params functions of the TB type
type MoqTB_Fail_anyParams struct {
	Recorder *MoqTB_Fail_fnRecorder
}

// MoqTB_FailNow_params holds the params of the TB type
type MoqTB_FailNow_params struct{}

// MoqTB_FailNow_paramsKey holds the map key params of the TB type
type MoqTB_FailNow_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTB_FailNow_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_FailNow_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_FailNow_paramsKey]*MoqTB_FailNow_results
}

// MoqTB_FailNow_doFn defines the type of function needed when calling AndDo
// for the TB type
type MoqTB_FailNow_doFn func()

// MoqTB_FailNow_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_FailNow_doReturnFn func()

// MoqTB_FailNow_results holds the results of the TB type
type MoqTB_FailNow_results struct {
	Params  MoqTB_FailNow_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_FailNow_doFn
		DoReturnFn MoqTB_FailNow_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_FailNow_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_FailNow_fnRecorder struct {
	Params    MoqTB_FailNow_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_FailNow_results
	Moq       *MoqTB
}

// MoqTB_FailNow_anyParams isolates the any params functions of the TB type
type MoqTB_FailNow_anyParams struct {
	Recorder *MoqTB_FailNow_fnRecorder
}

// MoqTB_Failed_params holds the params of the TB type
type MoqTB_Failed_params struct{}

// MoqTB_Failed_paramsKey holds the map key params of the TB type
type MoqTB_Failed_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTB_Failed_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Failed_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Failed_paramsKey]*MoqTB_Failed_results
}

// MoqTB_Failed_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Failed_doFn func()

// MoqTB_Failed_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Failed_doReturnFn func() bool

// MoqTB_Failed_results holds the results of the TB type
type MoqTB_Failed_results struct {
	Params  MoqTB_Failed_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTB_Failed_doFn
		DoReturnFn MoqTB_Failed_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Failed_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Failed_fnRecorder struct {
	Params    MoqTB_Failed_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Failed_results
	Moq       *MoqTB
}

// MoqTB_Failed_anyParams isolates the any params functions of the TB type
type MoqTB_Failed_anyParams struct {
	Recorder *MoqTB_Failed_fnRecorder
}

// MoqTB_Fatal_params holds the params of the TB type
type MoqTB_Fatal_params struct{ Args []interface{} }

// MoqTB_Fatal_paramsKey holds the map key params of the TB type
type MoqTB_Fatal_paramsKey struct {
	Params struct{}
	Hashes struct{ Args hash.Hash }
}

// MoqTB_Fatal_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Fatal_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Fatal_paramsKey]*MoqTB_Fatal_results
}

// MoqTB_Fatal_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Fatal_doFn func(args ...interface{})

// MoqTB_Fatal_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Fatal_doReturnFn func(args ...interface{})

// MoqTB_Fatal_results holds the results of the TB type
type MoqTB_Fatal_results struct {
	Params  MoqTB_Fatal_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Fatal_doFn
		DoReturnFn MoqTB_Fatal_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Fatal_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Fatal_fnRecorder struct {
	Params    MoqTB_Fatal_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Fatal_results
	Moq       *MoqTB
}

// MoqTB_Fatal_anyParams isolates the any params functions of the TB type
type MoqTB_Fatal_anyParams struct {
	Recorder *MoqTB_Fatal_fnRecorder
}

// MoqTB_Fatalf_params holds the params of the TB type
type MoqTB_Fatalf_params struct {
	Format string
	Args   []interface{}
}

// MoqTB_Fatalf_paramsKey holds the map key params of the TB type
type MoqTB_Fatalf_paramsKey struct {
	Params struct{ Format string }
	Hashes struct {
		Format hash.Hash
		Args   hash.Hash
	}
}

// MoqTB_Fatalf_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Fatalf_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Fatalf_paramsKey]*MoqTB_Fatalf_results
}

// MoqTB_Fatalf_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Fatalf_doFn func(format string, args ...interface{})

// MoqTB_Fatalf_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Fatalf_doReturnFn func(format string, args ...interface{})

// MoqTB_Fatalf_results holds the results of the TB type
type MoqTB_Fatalf_results struct {
	Params  MoqTB_Fatalf_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Fatalf_doFn
		DoReturnFn MoqTB_Fatalf_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Fatalf_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Fatalf_fnRecorder struct {
	Params    MoqTB_Fatalf_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Fatalf_results
	Moq       *MoqTB
}

// MoqTB_Fatalf_anyParams isolates the any params functions of the TB type
type MoqTB_Fatalf_anyParams struct {
	Recorder *MoqTB_Fatalf_fnRecorder
}

// MoqTB_Helper_params holds the params of the TB type
type MoqTB_Helper_params struct{}

// MoqTB_Helper_paramsKey holds the map key params of the TB type
type MoqTB_Helper_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTB_Helper_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Helper_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Helper_paramsKey]*MoqTB_Helper_results
}

// MoqTB_Helper_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Helper_doFn func()

// MoqTB_Helper_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Helper_doReturnFn func()

// MoqTB_Helper_results holds the results of the TB type
type MoqTB_Helper_results struct {
	Params  MoqTB_Helper_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Helper_doFn
		DoReturnFn MoqTB_Helper_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Helper_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Helper_fnRecorder struct {
	Params    MoqTB_Helper_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Helper_results
	Moq       *MoqTB
}

// MoqTB_Helper_anyParams isolates the any params functions of the TB type
type MoqTB_Helper_anyParams struct {
	Recorder *MoqTB_Helper_fnRecorder
}

// MoqTB_Log_params holds the params of the TB type
type MoqTB_Log_params struct{ Args []interface{} }

// MoqTB_Log_paramsKey holds the map key params of the TB type
type MoqTB_Log_paramsKey struct {
	Params struct{}
	Hashes struct{ Args hash.Hash }
}

// MoqTB_Log_resultsByParams contains the results for a given set of parameters
// for the TB type
type MoqTB_Log_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Log_paramsKey]*MoqTB_Log_results
}

// MoqTB_Log_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Log_doFn func(args ...interface{})

// MoqTB_Log_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Log_doReturnFn func(args ...interface{})

// MoqTB_Log_results holds the results of the TB type
type MoqTB_Log_results struct {
	Params  MoqTB_Log_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Log_doFn
		DoReturnFn MoqTB_Log_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Log_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Log_fnRecorder struct {
	Params    MoqTB_Log_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Log_results
	Moq       *MoqTB
}

// MoqTB_Log_anyParams isolates the any params functions of the TB type
type MoqTB_Log_anyParams struct {
	Recorder *MoqTB_Log_fnRecorder
}

// MoqTB_Logf_params holds the params of the TB type
type MoqTB_Logf_params struct {
	Format string
	Args   []interface{}
}

// MoqTB_Logf_paramsKey holds the map key params of the TB type
type MoqTB_Logf_paramsKey struct {
	Params struct{ Format string }
	Hashes struct {
		Format hash.Hash
		Args   hash.Hash
	}
}

// MoqTB_Logf_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Logf_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Logf_paramsKey]*MoqTB_Logf_results
}

// MoqTB_Logf_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Logf_doFn func(format string, args ...interface{})

// MoqTB_Logf_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Logf_doReturnFn func(format string, args ...interface{})

// MoqTB_Logf_results holds the results of the TB type
type MoqTB_Logf_results struct {
	Params  MoqTB_Logf_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Logf_doFn
		DoReturnFn MoqTB_Logf_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Logf_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Logf_fnRecorder struct {
	Params    MoqTB_Logf_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Logf_results
	Moq       *MoqTB
}

// MoqTB_Logf_anyParams isolates the any params functions of the TB type
type MoqTB_Logf_anyParams struct {
	Recorder *MoqTB_Logf_fnRecorder
}

// MoqTB_Name_params holds the params of the TB type
type MoqTB_Name_params struct{}

// MoqTB_Name_paramsKey holds the map key params of the TB type
type MoqTB_Name_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTB_Name_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Name_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Name_paramsKey]*MoqTB_Name_results
}

// MoqTB_Name_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Name_doFn func()

// MoqTB_Name_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Name_doReturnFn func() string

// MoqTB_Name_results holds the results of the TB type
type MoqTB_Name_results struct {
	Params  MoqTB_Name_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTB_Name_doFn
		DoReturnFn MoqTB_Name_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Name_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Name_fnRecorder struct {
	Params    MoqTB_Name_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Name_results
	Moq       *MoqTB
}

// MoqTB_Name_anyParams isolates the any params functions of the TB type
type MoqTB_Name_anyParams struct {
	Recorder *MoqTB_Name_fnRecorder
}

// MoqTB_Setenv_params holds the params of the TB type
type MoqTB_Setenv_params struct{ Key, Value string }

// MoqTB_Setenv_paramsKey holds the map key params of the TB type
type MoqTB_Setenv_paramsKey struct {
	Params struct{ Key, Value string }
	Hashes struct{ Key, Value hash.Hash }
}

// MoqTB_Setenv_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Setenv_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Setenv_paramsKey]*MoqTB_Setenv_results
}

// MoqTB_Setenv_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Setenv_doFn func(key, value string)

// MoqTB_Setenv_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Setenv_doReturnFn func(key, value string)

// MoqTB_Setenv_results holds the results of the TB type
type MoqTB_Setenv_results struct {
	Params  MoqTB_Setenv_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Setenv_doFn
		DoReturnFn MoqTB_Setenv_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Setenv_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Setenv_fnRecorder struct {
	Params    MoqTB_Setenv_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Setenv_results
	Moq       *MoqTB
}

// MoqTB_Setenv_anyParams isolates the any params functions of the TB type
type MoqTB_Setenv_anyParams struct {
	Recorder *MoqTB_Setenv_fnRecorder
}

// MoqTB_Skip_params holds the params of the TB type
type MoqTB_Skip_params struct{ Args []interface{} }

// MoqTB_Skip_paramsKey holds the map key params of the TB type
type MoqTB_Skip_paramsKey struct {
	Params struct{}
	Hashes struct{ Args hash.Hash }
}

// MoqTB_Skip_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Skip_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Skip_paramsKey]*MoqTB_Skip_results
}

// MoqTB_Skip_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Skip_doFn func(args ...interface{})

// MoqTB_Skip_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Skip_doReturnFn func(args ...interface{})

// MoqTB_Skip_results holds the results of the TB type
type MoqTB_Skip_results struct {
	Params  MoqTB_Skip_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Skip_doFn
		DoReturnFn MoqTB_Skip_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Skip_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Skip_fnRecorder struct {
	Params    MoqTB_Skip_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Skip_results
	Moq       *MoqTB
}

// MoqTB_Skip_anyParams isolates the any params functions of the TB type
type MoqTB_Skip_anyParams struct {
	Recorder *MoqTB_Skip_fnRecorder
}

// MoqTB_SkipNow_params holds the params of the TB type
type MoqTB_SkipNow_params struct{}

// MoqTB_SkipNow_paramsKey holds the map key params of the TB type
type MoqTB_SkipNow_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTB_SkipNow_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_SkipNow_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_SkipNow_paramsKey]*MoqTB_SkipNow_results
}

// MoqTB_SkipNow_doFn defines the type of function needed when calling AndDo
// for the TB type
type MoqTB_SkipNow_doFn func()

// MoqTB_SkipNow_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_SkipNow_doReturnFn func()

// MoqTB_SkipNow_results holds the results of the TB type
type MoqTB_SkipNow_results struct {
	Params  MoqTB_SkipNow_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_SkipNow_doFn
		DoReturnFn MoqTB_SkipNow_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_SkipNow_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_SkipNow_fnRecorder struct {
	Params    MoqTB_SkipNow_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_SkipNow_results
	Moq       *MoqTB
}

// MoqTB_SkipNow_anyParams isolates the any params functions of the TB type
type MoqTB_SkipNow_anyParams struct {
	Recorder *MoqTB_SkipNow_fnRecorder
}

// MoqTB_Skipf_params holds the params of the TB type
type MoqTB_Skipf_params struct {
	Format string
	Args   []interface{}
}

// MoqTB_Skipf_paramsKey holds the map key params of the TB type
type MoqTB_Skipf_paramsKey struct {
	Params struct{ Format string }
	Hashes struct {
		Format hash.Hash
		Args   hash.Hash
	}
}

// MoqTB_Skipf_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Skipf_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Skipf_paramsKey]*MoqTB_Skipf_results
}

// MoqTB_Skipf_doFn defines the type of function needed when calling AndDo for
// the TB type
type MoqTB_Skipf_doFn func(format string, args ...interface{})

// MoqTB_Skipf_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Skipf_doReturnFn func(format string, args ...interface{})

// MoqTB_Skipf_results holds the results of the TB type
type MoqTB_Skipf_results struct {
	Params  MoqTB_Skipf_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Skipf_doFn
		DoReturnFn MoqTB_Skipf_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Skipf_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Skipf_fnRecorder struct {
	Params    MoqTB_Skipf_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Skipf_results
	Moq       *MoqTB
}

// MoqTB_Skipf_anyParams isolates the any params functions of the TB type
type MoqTB_Skipf_anyParams struct {
	Recorder *MoqTB_Skipf_fnRecorder
}

// MoqTB_Skipped_params holds the params of the TB type
type MoqTB_Skipped_params struct{}

// MoqTB_Skipped_paramsKey holds the map key params of the TB type
type MoqTB_Skipped_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTB_Skipped_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_Skipped_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_Skipped_paramsKey]*MoqTB_Skipped_results
}

// MoqTB_Skipped_doFn defines the type of function needed when calling AndDo
// for the TB type
type MoqTB_Skipped_doFn func()

// MoqTB_Skipped_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_Skipped_doReturnFn func() bool

// MoqTB_Skipped_results holds the results of the TB type
type MoqTB_Skipped_results struct {
	Params  MoqTB_Skipped_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTB_Skipped_doFn
		DoReturnFn MoqTB_Skipped_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_Skipped_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_Skipped_fnRecorder struct {
	Params    MoqTB_Skipped_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_Skipped_results
	Moq       *MoqTB
}

// MoqTB_Skipped_anyParams isolates the any params functions of the TB type
type MoqTB_Skipped_anyParams struct {
	Recorder *MoqTB_Skipped_fnRecorder
}

// MoqTB_TempDir_params holds the params of the TB type
type MoqTB_TempDir_params struct{}

// MoqTB_TempDir_paramsKey holds the map key params of the TB type
type MoqTB_TempDir_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTB_TempDir_resultsByParams contains the results for a given set of
// parameters for the TB type
type MoqTB_TempDir_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTB_TempDir_paramsKey]*MoqTB_TempDir_results
}

// MoqTB_TempDir_doFn defines the type of function needed when calling AndDo
// for the TB type
type MoqTB_TempDir_doFn func()

// MoqTB_TempDir_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TB type
type MoqTB_TempDir_doReturnFn func() string

// MoqTB_TempDir_results holds the results of the TB type
type MoqTB_TempDir_results struct {
	Params  MoqTB_TempDir_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTB_TempDir_doFn
		DoReturnFn MoqTB_TempDir_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTB_TempDir_fnRecorder routes recorded function calls to the MoqTB moq
type MoqTB_TempDir_fnRecorder struct {
	Params    MoqTB_TempDir_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTB_TempDir_results
	Moq       *MoqTB
}

// MoqTB_TempDir_anyParams isolates the any params functions of the TB type
type MoqTB_TempDir_anyParams struct {
	Recorder *MoqTB_TempDir_fnRecorder
}

// NewMoqTB creates a new moq of the TB type
func NewMoqTB(scene *moq.Scene, config *moq.Config) *MoqTB {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqTB{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqTB_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Cleanup struct {
					Param1 moq.ParamIndexing
				}
				Error struct {
					Args moq.ParamIndexing
				}
				Errorf struct {
					Format moq.ParamIndexing
					Args   moq.ParamIndexing
				}
				Fail    struct{}
				FailNow struct{}
				Failed  struct{}
				Fatal   struct {
					Args moq.ParamIndexing
				}
				Fatalf struct {
					Format moq.ParamIndexing
					Args   moq.ParamIndexing
				}
				Helper struct{}
				Log    struct {
					Args moq.ParamIndexing
				}
				Logf struct {
					Format moq.ParamIndexing
					Args   moq.ParamIndexing
				}
				Name   struct{}
				Setenv struct {
					Key   moq.ParamIndexing
					Value moq.ParamIndexing
				}
				Skip struct {
					Args moq.ParamIndexing
				}
				SkipNow struct{}
				Skipf   struct {
					Format moq.ParamIndexing
					Args   moq.ParamIndexing
				}
				Skipped struct{}
				TempDir struct{}
			}
		}{ParameterIndexing: struct {
			Cleanup struct {
				Param1 moq.ParamIndexing
			}
			Error struct {
				Args moq.ParamIndexing
			}
			Errorf struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}
			Fail    struct{}
			FailNow struct{}
			Failed  struct{}
			Fatal   struct {
				Args moq.ParamIndexing
			}
			Fatalf struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}
			Helper struct{}
			Log    struct {
				Args moq.ParamIndexing
			}
			Logf struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}
			Name   struct{}
			Setenv struct {
				Key   moq.ParamIndexing
				Value moq.ParamIndexing
			}
			Skip struct {
				Args moq.ParamIndexing
			}
			SkipNow struct{}
			Skipf   struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}
			Skipped struct{}
			TempDir struct{}
		}{
			Cleanup: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByHash,
			},
			Error: struct {
				Args moq.ParamIndexing
			}{
				Args: moq.ParamIndexByHash,
			},
			Errorf: struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}{
				Format: moq.ParamIndexByValue,
				Args:   moq.ParamIndexByHash,
			},
			Fail:    struct{}{},
			FailNow: struct{}{},
			Failed:  struct{}{},
			Fatal: struct {
				Args moq.ParamIndexing
			}{
				Args: moq.ParamIndexByHash,
			},
			Fatalf: struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}{
				Format: moq.ParamIndexByValue,
				Args:   moq.ParamIndexByHash,
			},
			Helper: struct{}{},
			Log: struct {
				Args moq.ParamIndexing
			}{
				Args: moq.ParamIndexByHash,
			},
			Logf: struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}{
				Format: moq.ParamIndexByValue,
				Args:   moq.ParamIndexByHash,
			},
			Name: struct{}{},
			Setenv: struct {
				Key   moq.ParamIndexing
				Value moq.ParamIndexing
			}{
				Key:   moq.ParamIndexByValue,
				Value: moq.ParamIndexByValue,
			},
			Skip: struct {
				Args moq.ParamIndexing
			}{
				Args: moq.ParamIndexByHash,
			},
			SkipNow: struct{}{},
			Skipf: struct {
				Format moq.ParamIndexing
				Args   moq.ParamIndexing
			}{
				Format: moq.ParamIndexByValue,
				Args:   moq.ParamIndexByHash,
			},
			Skipped: struct{}{},
			TempDir: struct{}{},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the TB type
func (m *MoqTB) Mock() *MoqTB_mock { return m.Moq }

func (m *MoqTB_mock) Cleanup(param1 func()) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Cleanup_params{
		Param1: param1,
	}
	var results *MoqTB_Cleanup_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Cleanup {
		paramsKey := m.Moq.ParamsKey_Cleanup(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Cleanup(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Cleanup(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Cleanup(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(param1)
	}
	return
}

func (m *MoqTB_mock) Error(args ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Error_params{
		Args: args,
	}
	var results *MoqTB_Error_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Error {
		paramsKey := m.Moq.ParamsKey_Error(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Error(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Error(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Error(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(args...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(args...)
	}
	return
}

func (m *MoqTB_mock) Errorf(format string, args ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Errorf_params{
		Format: format,
		Args:   args,
	}
	var results *MoqTB_Errorf_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Errorf {
		paramsKey := m.Moq.ParamsKey_Errorf(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Errorf(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Errorf(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Errorf(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(format, args...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(format, args...)
	}
	return
}

func (m *MoqTB_mock) Fail() {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Fail_params{}
	var results *MoqTB_Fail_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Fail {
		paramsKey := m.Moq.ParamsKey_Fail(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Fail(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Fail(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Fail(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqTB_mock) FailNow() {
	m.Moq.Scene.T.Helper()
	params := MoqTB_FailNow_params{}
	var results *MoqTB_FailNow_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FailNow {
		paramsKey := m.Moq.ParamsKey_FailNow(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FailNow(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FailNow(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FailNow(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqTB_mock) Failed() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Failed_params{}
	var results *MoqTB_Failed_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Failed {
		paramsKey := m.Moq.ParamsKey_Failed(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Failed(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Failed(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Failed(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTB_mock) Fatal(args ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Fatal_params{
		Args: args,
	}
	var results *MoqTB_Fatal_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Fatal {
		paramsKey := m.Moq.ParamsKey_Fatal(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Fatal(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Fatal(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Fatal(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(args...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(args...)
	}
	return
}

func (m *MoqTB_mock) Fatalf(format string, args ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Fatalf_params{
		Format: format,
		Args:   args,
	}
	var results *MoqTB_Fatalf_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Fatalf {
		paramsKey := m.Moq.ParamsKey_Fatalf(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Fatalf(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Fatalf(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Fatalf(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(format, args...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(format, args...)
	}
	return
}

func (m *MoqTB_mock) Helper() {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Helper_params{}
	var results *MoqTB_Helper_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Helper {
		paramsKey := m.Moq.ParamsKey_Helper(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Helper(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Helper(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Helper(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqTB_mock) Log(args ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Log_params{
		Args: args,
	}
	var results *MoqTB_Log_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Log {
		paramsKey := m.Moq.ParamsKey_Log(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Log(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Log(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Log(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(args...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(args...)
	}
	return
}

func (m *MoqTB_mock) Logf(format string, args ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Logf_params{
		Format: format,
		Args:   args,
	}
	var results *MoqTB_Logf_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Logf {
		paramsKey := m.Moq.ParamsKey_Logf(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Logf(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Logf(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Logf(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(format, args...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(format, args...)
	}
	return
}

func (m *MoqTB_mock) Name() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Name_params{}
	var results *MoqTB_Name_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Name {
		paramsKey := m.Moq.ParamsKey_Name(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Name(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Name(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Name(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTB_mock) Setenv(key, value string) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Setenv_params{
		Key:   key,
		Value: value,
	}
	var results *MoqTB_Setenv_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Setenv {
		paramsKey := m.Moq.ParamsKey_Setenv(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Setenv(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Setenv(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Setenv(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(key, value)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(key, value)
	}
	return
}

func (m *MoqTB_mock) Skip(args ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Skip_params{
		Args: args,
	}
	var results *MoqTB_Skip_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Skip {
		paramsKey := m.Moq.ParamsKey_Skip(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Skip(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Skip(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Skip(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(args...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(args...)
	}
	return
}

func (m *MoqTB_mock) SkipNow() {
	m.Moq.Scene.T.Helper()
	params := MoqTB_SkipNow_params{}
	var results *MoqTB_SkipNow_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SkipNow {
		paramsKey := m.Moq.ParamsKey_SkipNow(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SkipNow(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SkipNow(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SkipNow(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqTB_mock) Skipf(format string, args ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Skipf_params{
		Format: format,
		Args:   args,
	}
	var results *MoqTB_Skipf_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Skipf {
		paramsKey := m.Moq.ParamsKey_Skipf(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Skipf(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Skipf(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Skipf(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(format, args...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(format, args...)
	}
	return
}

func (m *MoqTB_mock) Skipped() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_Skipped_params{}
	var results *MoqTB_Skipped_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Skipped {
		paramsKey := m.Moq.ParamsKey_Skipped(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Skipped(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Skipped(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Skipped(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTB_mock) TempDir() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqTB_TempDir_params{}
	var results *MoqTB_TempDir_results
	for _, resultsByParams := range m.Moq.ResultsByParams_TempDir {
		paramsKey := m.Moq.ParamsKey_TempDir(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_TempDir(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_TempDir(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_TempDir(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

// OnCall returns the recorder implementation of the TB type
func (m *MoqTB) OnCall() *MoqTB_recorder {
	return &MoqTB_recorder{
		Moq: m,
	}
}

func (m *MoqTB_recorder) Cleanup(param1 func()) *MoqTB_Cleanup_fnRecorder {
	return &MoqTB_Cleanup_fnRecorder{
		Params: MoqTB_Cleanup_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Cleanup_fnRecorder) Any() *MoqTB_Cleanup_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cleanup(r.Params))
		return nil
	}
	return &MoqTB_Cleanup_anyParams{Recorder: r}
}

func (a *MoqTB_Cleanup_anyParams) Param1() *MoqTB_Cleanup_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTB_Cleanup_fnRecorder) Seq() *MoqTB_Cleanup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cleanup(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Cleanup_fnRecorder) NoSeq() *MoqTB_Cleanup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cleanup(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Cleanup_fnRecorder) ReturnResults() *MoqTB_Cleanup_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Cleanup_doFn
		DoReturnFn MoqTB_Cleanup_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Cleanup_fnRecorder) AndDo(fn MoqTB_Cleanup_doFn) *MoqTB_Cleanup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Cleanup_fnRecorder) DoReturnResults(fn MoqTB_Cleanup_doReturnFn) *MoqTB_Cleanup_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Cleanup_doFn
		DoReturnFn MoqTB_Cleanup_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Cleanup_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Cleanup_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Cleanup {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Cleanup_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Cleanup_paramsKey]*MoqTB_Cleanup_results{},
		}
		r.Moq.ResultsByParams_Cleanup = append(r.Moq.ResultsByParams_Cleanup, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Cleanup) {
			copy(r.Moq.ResultsByParams_Cleanup[insertAt+1:], r.Moq.ResultsByParams_Cleanup[insertAt:0])
			r.Moq.ResultsByParams_Cleanup[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Cleanup(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Cleanup_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Cleanup_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Cleanup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Cleanup_doFn
				DoReturnFn MoqTB_Cleanup_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Cleanup(params MoqTB_Cleanup_params) string {
	return fmt.Sprintf("Cleanup(%#v)", params.Param1)
}

func (m *MoqTB) ParamsKey_Cleanup(params MoqTB_Cleanup_params, anyParams uint64) MoqTB_Cleanup_paramsKey {
	m.Scene.T.Helper()
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Cleanup.Param1 == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The param1 parameter of the Cleanup function can't be indexed by value")
		}
		param1UsedHash = hash.DeepHash(params.Param1)
	}
	return MoqTB_Cleanup_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqTB_recorder) Error(args ...interface{}) *MoqTB_Error_fnRecorder {
	return &MoqTB_Error_fnRecorder{
		Params: MoqTB_Error_params{
			Args: args,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Error_fnRecorder) Any() *MoqTB_Error_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Error(r.Params))
		return nil
	}
	return &MoqTB_Error_anyParams{Recorder: r}
}

func (a *MoqTB_Error_anyParams) Args() *MoqTB_Error_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTB_Error_fnRecorder) Seq() *MoqTB_Error_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Error(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Error_fnRecorder) NoSeq() *MoqTB_Error_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Error(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Error_fnRecorder) ReturnResults() *MoqTB_Error_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Error_doFn
		DoReturnFn MoqTB_Error_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Error_fnRecorder) AndDo(fn MoqTB_Error_doFn) *MoqTB_Error_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Error_fnRecorder) DoReturnResults(fn MoqTB_Error_doReturnFn) *MoqTB_Error_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Error_doFn
		DoReturnFn MoqTB_Error_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Error_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Error_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Error {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Error_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Error_paramsKey]*MoqTB_Error_results{},
		}
		r.Moq.ResultsByParams_Error = append(r.Moq.ResultsByParams_Error, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Error) {
			copy(r.Moq.ResultsByParams_Error[insertAt+1:], r.Moq.ResultsByParams_Error[insertAt:0])
			r.Moq.ResultsByParams_Error[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Error(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Error_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Error_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Error_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Error_doFn
				DoReturnFn MoqTB_Error_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Error(params MoqTB_Error_params) string {
	return fmt.Sprintf("Error(%#v)", params.Args)
}

func (m *MoqTB) ParamsKey_Error(params MoqTB_Error_params, anyParams uint64) MoqTB_Error_paramsKey {
	m.Scene.T.Helper()
	var argsUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Error.Args == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The args parameter of the Error function can't be indexed by value")
		}
		argsUsedHash = hash.DeepHash(params.Args)
	}
	return MoqTB_Error_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Args hash.Hash }{
			Args: argsUsedHash,
		},
	}
}

func (m *MoqTB_recorder) Errorf(format string, args ...interface{}) *MoqTB_Errorf_fnRecorder {
	return &MoqTB_Errorf_fnRecorder{
		Params: MoqTB_Errorf_params{
			Format: format,
			Args:   args,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Errorf_fnRecorder) Any() *MoqTB_Errorf_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Errorf(r.Params))
		return nil
	}
	return &MoqTB_Errorf_anyParams{Recorder: r}
}

func (a *MoqTB_Errorf_anyParams) Format() *MoqTB_Errorf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqTB_Errorf_anyParams) Args() *MoqTB_Errorf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqTB_Errorf_fnRecorder) Seq() *MoqTB_Errorf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Errorf(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Errorf_fnRecorder) NoSeq() *MoqTB_Errorf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Errorf(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Errorf_fnRecorder) ReturnResults() *MoqTB_Errorf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Errorf_doFn
		DoReturnFn MoqTB_Errorf_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Errorf_fnRecorder) AndDo(fn MoqTB_Errorf_doFn) *MoqTB_Errorf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Errorf_fnRecorder) DoReturnResults(fn MoqTB_Errorf_doReturnFn) *MoqTB_Errorf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Errorf_doFn
		DoReturnFn MoqTB_Errorf_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Errorf_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Errorf_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Errorf {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Errorf_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Errorf_paramsKey]*MoqTB_Errorf_results{},
		}
		r.Moq.ResultsByParams_Errorf = append(r.Moq.ResultsByParams_Errorf, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Errorf) {
			copy(r.Moq.ResultsByParams_Errorf[insertAt+1:], r.Moq.ResultsByParams_Errorf[insertAt:0])
			r.Moq.ResultsByParams_Errorf[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Errorf(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Errorf_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Errorf_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Errorf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Errorf_doFn
				DoReturnFn MoqTB_Errorf_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Errorf(params MoqTB_Errorf_params) string {
	return fmt.Sprintf("Errorf(%#v, %#v)", params.Format, params.Args)
}

func (m *MoqTB) ParamsKey_Errorf(params MoqTB_Errorf_params, anyParams uint64) MoqTB_Errorf_paramsKey {
	m.Scene.T.Helper()
	var formatUsed string
	var formatUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Errorf.Format == moq.ParamIndexByValue {
			formatUsed = params.Format
		} else {
			formatUsedHash = hash.DeepHash(params.Format)
		}
	}
	var argsUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Errorf.Args == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The args parameter of the Errorf function can't be indexed by value")
		}
		argsUsedHash = hash.DeepHash(params.Args)
	}
	return MoqTB_Errorf_paramsKey{
		Params: struct{ Format string }{
			Format: formatUsed,
		},
		Hashes: struct {
			Format hash.Hash
			Args   hash.Hash
		}{
			Format: formatUsedHash,
			Args:   argsUsedHash,
		},
	}
}

func (m *MoqTB_recorder) Fail() *MoqTB_Fail_fnRecorder {
	return &MoqTB_Fail_fnRecorder{
		Params:   MoqTB_Fail_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Fail_fnRecorder) Any() *MoqTB_Fail_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fail(r.Params))
		return nil
	}
	return &MoqTB_Fail_anyParams{Recorder: r}
}

func (r *MoqTB_Fail_fnRecorder) Seq() *MoqTB_Fail_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fail(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Fail_fnRecorder) NoSeq() *MoqTB_Fail_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fail(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Fail_fnRecorder) ReturnResults() *MoqTB_Fail_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Fail_doFn
		DoReturnFn MoqTB_Fail_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Fail_fnRecorder) AndDo(fn MoqTB_Fail_doFn) *MoqTB_Fail_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Fail_fnRecorder) DoReturnResults(fn MoqTB_Fail_doReturnFn) *MoqTB_Fail_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Fail_doFn
		DoReturnFn MoqTB_Fail_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Fail_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Fail_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Fail {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Fail_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Fail_paramsKey]*MoqTB_Fail_results{},
		}
		r.Moq.ResultsByParams_Fail = append(r.Moq.ResultsByParams_Fail, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Fail) {
			copy(r.Moq.ResultsByParams_Fail[insertAt+1:], r.Moq.ResultsByParams_Fail[insertAt:0])
			r.Moq.ResultsByParams_Fail[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Fail(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Fail_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Fail_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Fail_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Fail_doFn
				DoReturnFn MoqTB_Fail_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Fail(params MoqTB_Fail_params) string { return fmt.Sprintf("Fail()") }

func (m *MoqTB) ParamsKey_Fail(params MoqTB_Fail_params, anyParams uint64) MoqTB_Fail_paramsKey {
	m.Scene.T.Helper()
	return MoqTB_Fail_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTB_recorder) FailNow() *MoqTB_FailNow_fnRecorder {
	return &MoqTB_FailNow_fnRecorder{
		Params:   MoqTB_FailNow_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_FailNow_fnRecorder) Any() *MoqTB_FailNow_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FailNow(r.Params))
		return nil
	}
	return &MoqTB_FailNow_anyParams{Recorder: r}
}

func (r *MoqTB_FailNow_fnRecorder) Seq() *MoqTB_FailNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FailNow(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_FailNow_fnRecorder) NoSeq() *MoqTB_FailNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FailNow(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_FailNow_fnRecorder) ReturnResults() *MoqTB_FailNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_FailNow_doFn
		DoReturnFn MoqTB_FailNow_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_FailNow_fnRecorder) AndDo(fn MoqTB_FailNow_doFn) *MoqTB_FailNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_FailNow_fnRecorder) DoReturnResults(fn MoqTB_FailNow_doReturnFn) *MoqTB_FailNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_FailNow_doFn
		DoReturnFn MoqTB_FailNow_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_FailNow_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_FailNow_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FailNow {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_FailNow_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_FailNow_paramsKey]*MoqTB_FailNow_results{},
		}
		r.Moq.ResultsByParams_FailNow = append(r.Moq.ResultsByParams_FailNow, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FailNow) {
			copy(r.Moq.ResultsByParams_FailNow[insertAt+1:], r.Moq.ResultsByParams_FailNow[insertAt:0])
			r.Moq.ResultsByParams_FailNow[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FailNow(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_FailNow_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_FailNow_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_FailNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_FailNow_doFn
				DoReturnFn MoqTB_FailNow_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_FailNow(params MoqTB_FailNow_params) string {
	return fmt.Sprintf("FailNow()")
}

func (m *MoqTB) ParamsKey_FailNow(params MoqTB_FailNow_params, anyParams uint64) MoqTB_FailNow_paramsKey {
	m.Scene.T.Helper()
	return MoqTB_FailNow_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTB_recorder) Failed() *MoqTB_Failed_fnRecorder {
	return &MoqTB_Failed_fnRecorder{
		Params:   MoqTB_Failed_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Failed_fnRecorder) Any() *MoqTB_Failed_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Failed(r.Params))
		return nil
	}
	return &MoqTB_Failed_anyParams{Recorder: r}
}

func (r *MoqTB_Failed_fnRecorder) Seq() *MoqTB_Failed_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Failed(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Failed_fnRecorder) NoSeq() *MoqTB_Failed_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Failed(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Failed_fnRecorder) ReturnResults(result1 bool) *MoqTB_Failed_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTB_Failed_doFn
		DoReturnFn MoqTB_Failed_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Failed_fnRecorder) AndDo(fn MoqTB_Failed_doFn) *MoqTB_Failed_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Failed_fnRecorder) DoReturnResults(fn MoqTB_Failed_doReturnFn) *MoqTB_Failed_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTB_Failed_doFn
		DoReturnFn MoqTB_Failed_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Failed_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Failed_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Failed {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Failed_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Failed_paramsKey]*MoqTB_Failed_results{},
		}
		r.Moq.ResultsByParams_Failed = append(r.Moq.ResultsByParams_Failed, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Failed) {
			copy(r.Moq.ResultsByParams_Failed[insertAt+1:], r.Moq.ResultsByParams_Failed[insertAt:0])
			r.Moq.ResultsByParams_Failed[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Failed(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Failed_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Failed_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Failed_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqTB_Failed_doFn
				DoReturnFn MoqTB_Failed_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Failed(params MoqTB_Failed_params) string {
	return fmt.Sprintf("Failed()")
}

func (m *MoqTB) ParamsKey_Failed(params MoqTB_Failed_params, anyParams uint64) MoqTB_Failed_paramsKey {
	m.Scene.T.Helper()
	return MoqTB_Failed_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTB_recorder) Fatal(args ...interface{}) *MoqTB_Fatal_fnRecorder {
	return &MoqTB_Fatal_fnRecorder{
		Params: MoqTB_Fatal_params{
			Args: args,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Fatal_fnRecorder) Any() *MoqTB_Fatal_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatal(r.Params))
		return nil
	}
	return &MoqTB_Fatal_anyParams{Recorder: r}
}

func (a *MoqTB_Fatal_anyParams) Args() *MoqTB_Fatal_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTB_Fatal_fnRecorder) Seq() *MoqTB_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatal(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Fatal_fnRecorder) NoSeq() *MoqTB_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatal(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Fatal_fnRecorder) ReturnResults() *MoqTB_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Fatal_doFn
		DoReturnFn MoqTB_Fatal_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Fatal_fnRecorder) AndDo(fn MoqTB_Fatal_doFn) *MoqTB_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Fatal_fnRecorder) DoReturnResults(fn MoqTB_Fatal_doReturnFn) *MoqTB_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Fatal_doFn
		DoReturnFn MoqTB_Fatal_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Fatal_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Fatal_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Fatal {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Fatal_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Fatal_paramsKey]*MoqTB_Fatal_results{},
		}
		r.Moq.ResultsByParams_Fatal = append(r.Moq.ResultsByParams_Fatal, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Fatal) {
			copy(r.Moq.ResultsByParams_Fatal[insertAt+1:], r.Moq.ResultsByParams_Fatal[insertAt:0])
			r.Moq.ResultsByParams_Fatal[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Fatal(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Fatal_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Fatal_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Fatal_doFn
				DoReturnFn MoqTB_Fatal_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Fatal(params MoqTB_Fatal_params) string {
	return fmt.Sprintf("Fatal(%#v)", params.Args)
}

func (m *MoqTB) ParamsKey_Fatal(params MoqTB_Fatal_params, anyParams uint64) MoqTB_Fatal_paramsKey {
	m.Scene.T.Helper()
	var argsUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Fatal.Args == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The args parameter of the Fatal function can't be indexed by value")
		}
		argsUsedHash = hash.DeepHash(params.Args)
	}
	return MoqTB_Fatal_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Args hash.Hash }{
			Args: argsUsedHash,
		},
	}
}

func (m *MoqTB_recorder) Fatalf(format string, args ...interface{}) *MoqTB_Fatalf_fnRecorder {
	return &MoqTB_Fatalf_fnRecorder{
		Params: MoqTB_Fatalf_params{
			Format: format,
			Args:   args,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Fatalf_fnRecorder) Any() *MoqTB_Fatalf_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatalf(r.Params))
		return nil
	}
	return &MoqTB_Fatalf_anyParams{Recorder: r}
}

func (a *MoqTB_Fatalf_anyParams) Format() *MoqTB_Fatalf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqTB_Fatalf_anyParams) Args() *MoqTB_Fatalf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqTB_Fatalf_fnRecorder) Seq() *MoqTB_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatalf(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Fatalf_fnRecorder) NoSeq() *MoqTB_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatalf(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Fatalf_fnRecorder) ReturnResults() *MoqTB_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Fatalf_doFn
		DoReturnFn MoqTB_Fatalf_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Fatalf_fnRecorder) AndDo(fn MoqTB_Fatalf_doFn) *MoqTB_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Fatalf_fnRecorder) DoReturnResults(fn MoqTB_Fatalf_doReturnFn) *MoqTB_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Fatalf_doFn
		DoReturnFn MoqTB_Fatalf_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Fatalf_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Fatalf_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Fatalf {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Fatalf_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Fatalf_paramsKey]*MoqTB_Fatalf_results{},
		}
		r.Moq.ResultsByParams_Fatalf = append(r.Moq.ResultsByParams_Fatalf, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Fatalf) {
			copy(r.Moq.ResultsByParams_Fatalf[insertAt+1:], r.Moq.ResultsByParams_Fatalf[insertAt:0])
			r.Moq.ResultsByParams_Fatalf[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Fatalf(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Fatalf_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Fatalf_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Fatalf_doFn
				DoReturnFn MoqTB_Fatalf_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Fatalf(params MoqTB_Fatalf_params) string {
	return fmt.Sprintf("Fatalf(%#v, %#v)", params.Format, params.Args)
}

func (m *MoqTB) ParamsKey_Fatalf(params MoqTB_Fatalf_params, anyParams uint64) MoqTB_Fatalf_paramsKey {
	m.Scene.T.Helper()
	var formatUsed string
	var formatUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Fatalf.Format == moq.ParamIndexByValue {
			formatUsed = params.Format
		} else {
			formatUsedHash = hash.DeepHash(params.Format)
		}
	}
	var argsUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Fatalf.Args == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The args parameter of the Fatalf function can't be indexed by value")
		}
		argsUsedHash = hash.DeepHash(params.Args)
	}
	return MoqTB_Fatalf_paramsKey{
		Params: struct{ Format string }{
			Format: formatUsed,
		},
		Hashes: struct {
			Format hash.Hash
			Args   hash.Hash
		}{
			Format: formatUsedHash,
			Args:   argsUsedHash,
		},
	}
}

func (m *MoqTB_recorder) Helper() *MoqTB_Helper_fnRecorder {
	return &MoqTB_Helper_fnRecorder{
		Params:   MoqTB_Helper_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Helper_fnRecorder) Any() *MoqTB_Helper_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Helper(r.Params))
		return nil
	}
	return &MoqTB_Helper_anyParams{Recorder: r}
}

func (r *MoqTB_Helper_fnRecorder) Seq() *MoqTB_Helper_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Helper(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Helper_fnRecorder) NoSeq() *MoqTB_Helper_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Helper(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Helper_fnRecorder) ReturnResults() *MoqTB_Helper_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Helper_doFn
		DoReturnFn MoqTB_Helper_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Helper_fnRecorder) AndDo(fn MoqTB_Helper_doFn) *MoqTB_Helper_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Helper_fnRecorder) DoReturnResults(fn MoqTB_Helper_doReturnFn) *MoqTB_Helper_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Helper_doFn
		DoReturnFn MoqTB_Helper_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Helper_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Helper_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Helper {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Helper_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Helper_paramsKey]*MoqTB_Helper_results{},
		}
		r.Moq.ResultsByParams_Helper = append(r.Moq.ResultsByParams_Helper, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Helper) {
			copy(r.Moq.ResultsByParams_Helper[insertAt+1:], r.Moq.ResultsByParams_Helper[insertAt:0])
			r.Moq.ResultsByParams_Helper[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Helper(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Helper_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Helper_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Helper_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Helper_doFn
				DoReturnFn MoqTB_Helper_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Helper(params MoqTB_Helper_params) string {
	return fmt.Sprintf("Helper()")
}

func (m *MoqTB) ParamsKey_Helper(params MoqTB_Helper_params, anyParams uint64) MoqTB_Helper_paramsKey {
	m.Scene.T.Helper()
	return MoqTB_Helper_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTB_recorder) Log(args ...interface{}) *MoqTB_Log_fnRecorder {
	return &MoqTB_Log_fnRecorder{
		Params: MoqTB_Log_params{
			Args: args,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Log_fnRecorder) Any() *MoqTB_Log_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Log(r.Params))
		return nil
	}
	return &MoqTB_Log_anyParams{Recorder: r}
}

func (a *MoqTB_Log_anyParams) Args() *MoqTB_Log_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTB_Log_fnRecorder) Seq() *MoqTB_Log_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Log(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Log_fnRecorder) NoSeq() *MoqTB_Log_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Log(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Log_fnRecorder) ReturnResults() *MoqTB_Log_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Log_doFn
		DoReturnFn MoqTB_Log_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Log_fnRecorder) AndDo(fn MoqTB_Log_doFn) *MoqTB_Log_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Log_fnRecorder) DoReturnResults(fn MoqTB_Log_doReturnFn) *MoqTB_Log_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Log_doFn
		DoReturnFn MoqTB_Log_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Log_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Log_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Log {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Log_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Log_paramsKey]*MoqTB_Log_results{},
		}
		r.Moq.ResultsByParams_Log = append(r.Moq.ResultsByParams_Log, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Log) {
			copy(r.Moq.ResultsByParams_Log[insertAt+1:], r.Moq.ResultsByParams_Log[insertAt:0])
			r.Moq.ResultsByParams_Log[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Log(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Log_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Log_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Log_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Log_doFn
				DoReturnFn MoqTB_Log_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Log(params MoqTB_Log_params) string {
	return fmt.Sprintf("Log(%#v)", params.Args)
}

func (m *MoqTB) ParamsKey_Log(params MoqTB_Log_params, anyParams uint64) MoqTB_Log_paramsKey {
	m.Scene.T.Helper()
	var argsUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Log.Args == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The args parameter of the Log function can't be indexed by value")
		}
		argsUsedHash = hash.DeepHash(params.Args)
	}
	return MoqTB_Log_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Args hash.Hash }{
			Args: argsUsedHash,
		},
	}
}

func (m *MoqTB_recorder) Logf(format string, args ...interface{}) *MoqTB_Logf_fnRecorder {
	return &MoqTB_Logf_fnRecorder{
		Params: MoqTB_Logf_params{
			Format: format,
			Args:   args,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Logf_fnRecorder) Any() *MoqTB_Logf_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Logf(r.Params))
		return nil
	}
	return &MoqTB_Logf_anyParams{Recorder: r}
}

func (a *MoqTB_Logf_anyParams) Format() *MoqTB_Logf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqTB_Logf_anyParams) Args() *MoqTB_Logf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqTB_Logf_fnRecorder) Seq() *MoqTB_Logf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Logf(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Logf_fnRecorder) NoSeq() *MoqTB_Logf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Logf(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Logf_fnRecorder) ReturnResults() *MoqTB_Logf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Logf_doFn
		DoReturnFn MoqTB_Logf_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Logf_fnRecorder) AndDo(fn MoqTB_Logf_doFn) *MoqTB_Logf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Logf_fnRecorder) DoReturnResults(fn MoqTB_Logf_doReturnFn) *MoqTB_Logf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Logf_doFn
		DoReturnFn MoqTB_Logf_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Logf_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Logf_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Logf {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Logf_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Logf_paramsKey]*MoqTB_Logf_results{},
		}
		r.Moq.ResultsByParams_Logf = append(r.Moq.ResultsByParams_Logf, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Logf) {
			copy(r.Moq.ResultsByParams_Logf[insertAt+1:], r.Moq.ResultsByParams_Logf[insertAt:0])
			r.Moq.ResultsByParams_Logf[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Logf(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Logf_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Logf_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Logf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Logf_doFn
				DoReturnFn MoqTB_Logf_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Logf(params MoqTB_Logf_params) string {
	return fmt.Sprintf("Logf(%#v, %#v)", params.Format, params.Args)
}

func (m *MoqTB) ParamsKey_Logf(params MoqTB_Logf_params, anyParams uint64) MoqTB_Logf_paramsKey {
	m.Scene.T.Helper()
	var formatUsed string
	var formatUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Logf.Format == moq.ParamIndexByValue {
			formatUsed = params.Format
		} else {
			formatUsedHash = hash.DeepHash(params.Format)
		}
	}
	var argsUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Logf.Args == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The args parameter of the Logf function can't be indexed by value")
		}
		argsUsedHash = hash.DeepHash(params.Args)
	}
	return MoqTB_Logf_paramsKey{
		Params: struct{ Format string }{
			Format: formatUsed,
		},
		Hashes: struct {
			Format hash.Hash
			Args   hash.Hash
		}{
			Format: formatUsedHash,
			Args:   argsUsedHash,
		},
	}
}

func (m *MoqTB_recorder) Name() *MoqTB_Name_fnRecorder {
	return &MoqTB_Name_fnRecorder{
		Params:   MoqTB_Name_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Name_fnRecorder) Any() *MoqTB_Name_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	return &MoqTB_Name_anyParams{Recorder: r}
}

func (r *MoqTB_Name_fnRecorder) Seq() *MoqTB_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Name_fnRecorder) NoSeq() *MoqTB_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Name_fnRecorder) ReturnResults(result1 string) *MoqTB_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTB_Name_doFn
		DoReturnFn MoqTB_Name_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Name_fnRecorder) AndDo(fn MoqTB_Name_doFn) *MoqTB_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Name_fnRecorder) DoReturnResults(fn MoqTB_Name_doReturnFn) *MoqTB_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTB_Name_doFn
		DoReturnFn MoqTB_Name_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Name_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Name_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Name {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Name_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Name_paramsKey]*MoqTB_Name_results{},
		}
		r.Moq.ResultsByParams_Name = append(r.Moq.ResultsByParams_Name, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Name) {
			copy(r.Moq.ResultsByParams_Name[insertAt+1:], r.Moq.ResultsByParams_Name[insertAt:0])
			r.Moq.ResultsByParams_Name[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Name(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Name_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Name_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqTB_Name_doFn
				DoReturnFn MoqTB_Name_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Name(params MoqTB_Name_params) string { return fmt.Sprintf("Name()") }

func (m *MoqTB) ParamsKey_Name(params MoqTB_Name_params, anyParams uint64) MoqTB_Name_paramsKey {
	m.Scene.T.Helper()
	return MoqTB_Name_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTB_recorder) Setenv(key, value string) *MoqTB_Setenv_fnRecorder {
	return &MoqTB_Setenv_fnRecorder{
		Params: MoqTB_Setenv_params{
			Key:   key,
			Value: value,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Setenv_fnRecorder) Any() *MoqTB_Setenv_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Setenv(r.Params))
		return nil
	}
	return &MoqTB_Setenv_anyParams{Recorder: r}
}

func (a *MoqTB_Setenv_anyParams) Key() *MoqTB_Setenv_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqTB_Setenv_anyParams) Value() *MoqTB_Setenv_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqTB_Setenv_fnRecorder) Seq() *MoqTB_Setenv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Setenv(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Setenv_fnRecorder) NoSeq() *MoqTB_Setenv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Setenv(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Setenv_fnRecorder) ReturnResults() *MoqTB_Setenv_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Setenv_doFn
		DoReturnFn MoqTB_Setenv_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Setenv_fnRecorder) AndDo(fn MoqTB_Setenv_doFn) *MoqTB_Setenv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Setenv_fnRecorder) DoReturnResults(fn MoqTB_Setenv_doReturnFn) *MoqTB_Setenv_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Setenv_doFn
		DoReturnFn MoqTB_Setenv_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Setenv_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Setenv_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Setenv {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Setenv_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Setenv_paramsKey]*MoqTB_Setenv_results{},
		}
		r.Moq.ResultsByParams_Setenv = append(r.Moq.ResultsByParams_Setenv, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Setenv) {
			copy(r.Moq.ResultsByParams_Setenv[insertAt+1:], r.Moq.ResultsByParams_Setenv[insertAt:0])
			r.Moq.ResultsByParams_Setenv[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Setenv(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Setenv_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Setenv_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Setenv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Setenv_doFn
				DoReturnFn MoqTB_Setenv_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Setenv(params MoqTB_Setenv_params) string {
	return fmt.Sprintf("Setenv(%#v, %#v)", params.Key, params.Value)
}

func (m *MoqTB) ParamsKey_Setenv(params MoqTB_Setenv_params, anyParams uint64) MoqTB_Setenv_paramsKey {
	m.Scene.T.Helper()
	var keyUsed string
	var keyUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Setenv.Key == moq.ParamIndexByValue {
			keyUsed = params.Key
		} else {
			keyUsedHash = hash.DeepHash(params.Key)
		}
	}
	var valueUsed string
	var valueUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Setenv.Value == moq.ParamIndexByValue {
			valueUsed = params.Value
		} else {
			valueUsedHash = hash.DeepHash(params.Value)
		}
	}
	return MoqTB_Setenv_paramsKey{
		Params: struct{ Key, Value string }{
			Key:   keyUsed,
			Value: valueUsed,
		},
		Hashes: struct{ Key, Value hash.Hash }{
			Key:   keyUsedHash,
			Value: valueUsedHash,
		},
	}
}

func (m *MoqTB_recorder) Skip(args ...interface{}) *MoqTB_Skip_fnRecorder {
	return &MoqTB_Skip_fnRecorder{
		Params: MoqTB_Skip_params{
			Args: args,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Skip_fnRecorder) Any() *MoqTB_Skip_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Skip(r.Params))
		return nil
	}
	return &MoqTB_Skip_anyParams{Recorder: r}
}

func (a *MoqTB_Skip_anyParams) Args() *MoqTB_Skip_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTB_Skip_fnRecorder) Seq() *MoqTB_Skip_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Skip(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Skip_fnRecorder) NoSeq() *MoqTB_Skip_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Skip(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Skip_fnRecorder) ReturnResults() *MoqTB_Skip_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Skip_doFn
		DoReturnFn MoqTB_Skip_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Skip_fnRecorder) AndDo(fn MoqTB_Skip_doFn) *MoqTB_Skip_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Skip_fnRecorder) DoReturnResults(fn MoqTB_Skip_doReturnFn) *MoqTB_Skip_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Skip_doFn
		DoReturnFn MoqTB_Skip_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Skip_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Skip_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Skip {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Skip_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Skip_paramsKey]*MoqTB_Skip_results{},
		}
		r.Moq.ResultsByParams_Skip = append(r.Moq.ResultsByParams_Skip, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Skip) {
			copy(r.Moq.ResultsByParams_Skip[insertAt+1:], r.Moq.ResultsByParams_Skip[insertAt:0])
			r.Moq.ResultsByParams_Skip[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Skip(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Skip_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Skip_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Skip_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Skip_doFn
				DoReturnFn MoqTB_Skip_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Skip(params MoqTB_Skip_params) string {
	return fmt.Sprintf("Skip(%#v)", params.Args)
}

func (m *MoqTB) ParamsKey_Skip(params MoqTB_Skip_params, anyParams uint64) MoqTB_Skip_paramsKey {
	m.Scene.T.Helper()
	var argsUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Skip.Args == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The args parameter of the Skip function can't be indexed by value")
		}
		argsUsedHash = hash.DeepHash(params.Args)
	}
	return MoqTB_Skip_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Args hash.Hash }{
			Args: argsUsedHash,
		},
	}
}

func (m *MoqTB_recorder) SkipNow() *MoqTB_SkipNow_fnRecorder {
	return &MoqTB_SkipNow_fnRecorder{
		Params:   MoqTB_SkipNow_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_SkipNow_fnRecorder) Any() *MoqTB_SkipNow_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SkipNow(r.Params))
		return nil
	}
	return &MoqTB_SkipNow_anyParams{Recorder: r}
}

func (r *MoqTB_SkipNow_fnRecorder) Seq() *MoqTB_SkipNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SkipNow(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_SkipNow_fnRecorder) NoSeq() *MoqTB_SkipNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SkipNow(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_SkipNow_fnRecorder) ReturnResults() *MoqTB_SkipNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_SkipNow_doFn
		DoReturnFn MoqTB_SkipNow_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_SkipNow_fnRecorder) AndDo(fn MoqTB_SkipNow_doFn) *MoqTB_SkipNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_SkipNow_fnRecorder) DoReturnResults(fn MoqTB_SkipNow_doReturnFn) *MoqTB_SkipNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_SkipNow_doFn
		DoReturnFn MoqTB_SkipNow_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_SkipNow_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_SkipNow_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SkipNow {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_SkipNow_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_SkipNow_paramsKey]*MoqTB_SkipNow_results{},
		}
		r.Moq.ResultsByParams_SkipNow = append(r.Moq.ResultsByParams_SkipNow, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SkipNow) {
			copy(r.Moq.ResultsByParams_SkipNow[insertAt+1:], r.Moq.ResultsByParams_SkipNow[insertAt:0])
			r.Moq.ResultsByParams_SkipNow[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SkipNow(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_SkipNow_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_SkipNow_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_SkipNow_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_SkipNow_doFn
				DoReturnFn MoqTB_SkipNow_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_SkipNow(params MoqTB_SkipNow_params) string {
	return fmt.Sprintf("SkipNow()")
}

func (m *MoqTB) ParamsKey_SkipNow(params MoqTB_SkipNow_params, anyParams uint64) MoqTB_SkipNow_paramsKey {
	m.Scene.T.Helper()
	return MoqTB_SkipNow_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTB_recorder) Skipf(format string, args ...interface{}) *MoqTB_Skipf_fnRecorder {
	return &MoqTB_Skipf_fnRecorder{
		Params: MoqTB_Skipf_params{
			Format: format,
			Args:   args,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Skipf_fnRecorder) Any() *MoqTB_Skipf_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Skipf(r.Params))
		return nil
	}
	return &MoqTB_Skipf_anyParams{Recorder: r}
}

func (a *MoqTB_Skipf_anyParams) Format() *MoqTB_Skipf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqTB_Skipf_anyParams) Args() *MoqTB_Skipf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqTB_Skipf_fnRecorder) Seq() *MoqTB_Skipf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Skipf(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Skipf_fnRecorder) NoSeq() *MoqTB_Skipf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Skipf(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Skipf_fnRecorder) ReturnResults() *MoqTB_Skipf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Skipf_doFn
		DoReturnFn MoqTB_Skipf_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Skipf_fnRecorder) AndDo(fn MoqTB_Skipf_doFn) *MoqTB_Skipf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Skipf_fnRecorder) DoReturnResults(fn MoqTB_Skipf_doReturnFn) *MoqTB_Skipf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqTB_Skipf_doFn
		DoReturnFn MoqTB_Skipf_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Skipf_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Skipf_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Skipf {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Skipf_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Skipf_paramsKey]*MoqTB_Skipf_results{},
		}
		r.Moq.ResultsByParams_Skipf = append(r.Moq.ResultsByParams_Skipf, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Skipf) {
			copy(r.Moq.ResultsByParams_Skipf[insertAt+1:], r.Moq.ResultsByParams_Skipf[insertAt:0])
			r.Moq.ResultsByParams_Skipf[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Skipf(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Skipf_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Skipf_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Skipf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqTB_Skipf_doFn
				DoReturnFn MoqTB_Skipf_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Skipf(params MoqTB_Skipf_params) string {
	return fmt.Sprintf("Skipf(%#v, %#v)", params.Format, params.Args)
}

func (m *MoqTB) ParamsKey_Skipf(params MoqTB_Skipf_params, anyParams uint64) MoqTB_Skipf_paramsKey {
	m.Scene.T.Helper()
	var formatUsed string
	var formatUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Skipf.Format == moq.ParamIndexByValue {
			formatUsed = params.Format
		} else {
			formatUsedHash = hash.DeepHash(params.Format)
		}
	}
	var argsUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Skipf.Args == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The args parameter of the Skipf function can't be indexed by value")
		}
		argsUsedHash = hash.DeepHash(params.Args)
	}
	return MoqTB_Skipf_paramsKey{
		Params: struct{ Format string }{
			Format: formatUsed,
		},
		Hashes: struct {
			Format hash.Hash
			Args   hash.Hash
		}{
			Format: formatUsedHash,
			Args:   argsUsedHash,
		},
	}
}

func (m *MoqTB_recorder) Skipped() *MoqTB_Skipped_fnRecorder {
	return &MoqTB_Skipped_fnRecorder{
		Params:   MoqTB_Skipped_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_Skipped_fnRecorder) Any() *MoqTB_Skipped_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Skipped(r.Params))
		return nil
	}
	return &MoqTB_Skipped_anyParams{Recorder: r}
}

func (r *MoqTB_Skipped_fnRecorder) Seq() *MoqTB_Skipped_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Skipped(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_Skipped_fnRecorder) NoSeq() *MoqTB_Skipped_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Skipped(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_Skipped_fnRecorder) ReturnResults(result1 bool) *MoqTB_Skipped_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTB_Skipped_doFn
		DoReturnFn MoqTB_Skipped_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_Skipped_fnRecorder) AndDo(fn MoqTB_Skipped_doFn) *MoqTB_Skipped_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_Skipped_fnRecorder) DoReturnResults(fn MoqTB_Skipped_doReturnFn) *MoqTB_Skipped_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTB_Skipped_doFn
		DoReturnFn MoqTB_Skipped_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_Skipped_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_Skipped_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Skipped {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_Skipped_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_Skipped_paramsKey]*MoqTB_Skipped_results{},
		}
		r.Moq.ResultsByParams_Skipped = append(r.Moq.ResultsByParams_Skipped, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Skipped) {
			copy(r.Moq.ResultsByParams_Skipped[insertAt+1:], r.Moq.ResultsByParams_Skipped[insertAt:0])
			r.Moq.ResultsByParams_Skipped[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Skipped(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_Skipped_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_Skipped_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_Skipped_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqTB_Skipped_doFn
				DoReturnFn MoqTB_Skipped_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_Skipped(params MoqTB_Skipped_params) string {
	return fmt.Sprintf("Skipped()")
}

func (m *MoqTB) ParamsKey_Skipped(params MoqTB_Skipped_params, anyParams uint64) MoqTB_Skipped_paramsKey {
	m.Scene.T.Helper()
	return MoqTB_Skipped_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTB_recorder) TempDir() *MoqTB_TempDir_fnRecorder {
	return &MoqTB_TempDir_fnRecorder{
		Params:   MoqTB_TempDir_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTB_TempDir_fnRecorder) Any() *MoqTB_TempDir_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TempDir(r.Params))
		return nil
	}
	return &MoqTB_TempDir_anyParams{Recorder: r}
}

func (r *MoqTB_TempDir_fnRecorder) Seq() *MoqTB_TempDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TempDir(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTB_TempDir_fnRecorder) NoSeq() *MoqTB_TempDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TempDir(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTB_TempDir_fnRecorder) ReturnResults(result1 string) *MoqTB_TempDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTB_TempDir_doFn
		DoReturnFn MoqTB_TempDir_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTB_TempDir_fnRecorder) AndDo(fn MoqTB_TempDir_doFn) *MoqTB_TempDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTB_TempDir_fnRecorder) DoReturnResults(fn MoqTB_TempDir_doReturnFn) *MoqTB_TempDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTB_TempDir_doFn
		DoReturnFn MoqTB_TempDir_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTB_TempDir_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTB_TempDir_resultsByParams
	for n, res := range r.Moq.ResultsByParams_TempDir {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTB_TempDir_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTB_TempDir_paramsKey]*MoqTB_TempDir_results{},
		}
		r.Moq.ResultsByParams_TempDir = append(r.Moq.ResultsByParams_TempDir, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_TempDir) {
			copy(r.Moq.ResultsByParams_TempDir[insertAt+1:], r.Moq.ResultsByParams_TempDir[insertAt:0])
			r.Moq.ResultsByParams_TempDir[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_TempDir(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTB_TempDir_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTB_TempDir_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTB_TempDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqTB_TempDir_doFn
				DoReturnFn MoqTB_TempDir_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTB) PrettyParams_TempDir(params MoqTB_TempDir_params) string {
	return fmt.Sprintf("TempDir()")
}

func (m *MoqTB) ParamsKey_TempDir(params MoqTB_TempDir_params, anyParams uint64) MoqTB_TempDir_paramsKey {
	m.Scene.T.Helper()
	return MoqTB_TempDir_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqTB) Reset() {
	m.ResultsByParams_Cleanup = nil
	m.ResultsByParams_Error = nil
	m.ResultsByParams_Errorf = nil
	m.ResultsByParams_Fail = nil
	m.ResultsByParams_FailNow = nil
	m.ResultsByParams_Failed = nil
	m.ResultsByParams_Fatal = nil
	m.ResultsByParams_Fatalf = nil
	m.ResultsByParams_Helper = nil
	m.ResultsByParams_Log = nil
	m.ResultsByParams_Logf = nil
	m.ResultsByParams_Name = nil
	m.ResultsByParams_Setenv = nil
	m.ResultsByParams_Skip = nil
	m.ResultsByParams_SkipNow = nil
	m.ResultsByParams_Skipf = nil
	m.ResultsByParams_Skipped = nil
	m.ResultsByParams_TempDir = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqTB) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Cleanup {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Cleanup(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Error {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Error(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Errorf {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Errorf(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Fail {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Fail(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FailNow {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FailNow(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Failed {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Failed(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Fatal {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Fatal(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Fatalf {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Fatalf(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Helper {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Helper(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Log {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Log(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Logf {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Logf(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Name {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Name(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Setenv {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Setenv(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Skip {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Skip(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SkipNow {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SkipNow(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Skipf {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Skipf(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Skipped {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Skipped(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_TempDir {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_TempDir(results.Params))
			}
		}
	}
}
