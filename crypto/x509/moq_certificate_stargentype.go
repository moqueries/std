// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package x509

import (
	"crypto/x509"
	"crypto/x509/pkix"
	"fmt"
	"io"
	"math/bits"
	"sync/atomic"
	"time"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that x509.Certificate_starGenType is
// mocked completely
var _ Certificate_starGenType = (*MoqCertificate_starGenType_mock)(nil)

// Certificate_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Certificate_starGenType interface {
	Verify(opts x509.VerifyOptions) (chains [][]*x509.Certificate, err error)
	VerifyHostname(h string) error
	Equal(other *x509.Certificate) bool
	CheckSignatureFrom(parent *x509.Certificate) error
	CheckSignature(algo x509.SignatureAlgorithm, signed, signature []byte) error
	CheckCRLSignature(crl *pkix.CertificateList) error
	CreateCRL(rand io.Reader, priv any, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)
}

// MoqCertificate_starGenType holds the state of a moq of the
// Certificate_starGenType type
type MoqCertificate_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqCertificate_starGenType_mock

	ResultsByParams_Verify             []MoqCertificate_starGenType_Verify_resultsByParams
	ResultsByParams_VerifyHostname     []MoqCertificate_starGenType_VerifyHostname_resultsByParams
	ResultsByParams_Equal              []MoqCertificate_starGenType_Equal_resultsByParams
	ResultsByParams_CheckSignatureFrom []MoqCertificate_starGenType_CheckSignatureFrom_resultsByParams
	ResultsByParams_CheckSignature     []MoqCertificate_starGenType_CheckSignature_resultsByParams
	ResultsByParams_CheckCRLSignature  []MoqCertificate_starGenType_CheckCRLSignature_resultsByParams
	ResultsByParams_CreateCRL          []MoqCertificate_starGenType_CreateCRL_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Verify struct {
				Opts moq.ParamIndexing
			}
			VerifyHostname struct {
				H moq.ParamIndexing
			}
			Equal struct {
				Other moq.ParamIndexing
			}
			CheckSignatureFrom struct {
				Parent moq.ParamIndexing
			}
			CheckSignature struct {
				Algo      moq.ParamIndexing
				Signed    moq.ParamIndexing
				Signature moq.ParamIndexing
			}
			CheckCRLSignature struct {
				Crl moq.ParamIndexing
			}
			CreateCRL struct {
				Rand         moq.ParamIndexing
				Priv         moq.ParamIndexing
				RevokedCerts moq.ParamIndexing
				Now          moq.ParamIndexing
				Expiry       moq.ParamIndexing
			}
		}
	}
	// MoqCertificate_starGenType_mock isolates the mock interface of the
}

// Certificate_starGenType type
type MoqCertificate_starGenType_mock struct {
	Moq *MoqCertificate_starGenType
}

// MoqCertificate_starGenType_recorder isolates the recorder interface of the
// Certificate_starGenType type
type MoqCertificate_starGenType_recorder struct {
	Moq *MoqCertificate_starGenType
}

// MoqCertificate_starGenType_Verify_params holds the params of the
// Certificate_starGenType type
type MoqCertificate_starGenType_Verify_params struct{ Opts x509.VerifyOptions }

// MoqCertificate_starGenType_Verify_paramsKey holds the map key params of the
// Certificate_starGenType type
type MoqCertificate_starGenType_Verify_paramsKey struct {
	Params struct{}
	Hashes struct{ Opts hash.Hash }
}

// MoqCertificate_starGenType_Verify_resultsByParams contains the results for a
// given set of parameters for the Certificate_starGenType type
type MoqCertificate_starGenType_Verify_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqCertificate_starGenType_Verify_paramsKey]*MoqCertificate_starGenType_Verify_results
}

// MoqCertificate_starGenType_Verify_doFn defines the type of function needed
// when calling AndDo for the Certificate_starGenType type
type MoqCertificate_starGenType_Verify_doFn func(opts x509.VerifyOptions)

// MoqCertificate_starGenType_Verify_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Certificate_starGenType type
type MoqCertificate_starGenType_Verify_doReturnFn func(opts x509.VerifyOptions) (chains [][]*x509.Certificate, err error)

// MoqCertificate_starGenType_Verify_results holds the results of the
// Certificate_starGenType type
type MoqCertificate_starGenType_Verify_results struct {
	Params  MoqCertificate_starGenType_Verify_params
	Results []struct {
		Values *struct {
			Chains [][]*x509.Certificate
			Err    error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_Verify_doFn
		DoReturnFn MoqCertificate_starGenType_Verify_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqCertificate_starGenType_Verify_fnRecorder routes recorded function calls
// to the MoqCertificate_starGenType moq
type MoqCertificate_starGenType_Verify_fnRecorder struct {
	Params    MoqCertificate_starGenType_Verify_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqCertificate_starGenType_Verify_results
	Moq       *MoqCertificate_starGenType
}

// MoqCertificate_starGenType_Verify_anyParams isolates the any params
// functions of the Certificate_starGenType type
type MoqCertificate_starGenType_Verify_anyParams struct {
	Recorder *MoqCertificate_starGenType_Verify_fnRecorder
}

// MoqCertificate_starGenType_VerifyHostname_params holds the params of the
// Certificate_starGenType type
type MoqCertificate_starGenType_VerifyHostname_params struct{ H string }

// MoqCertificate_starGenType_VerifyHostname_paramsKey holds the map key params
// of the Certificate_starGenType type
type MoqCertificate_starGenType_VerifyHostname_paramsKey struct {
	Params struct{ H string }
	Hashes struct{ H hash.Hash }
}

// MoqCertificate_starGenType_VerifyHostname_resultsByParams contains the
// results for a given set of parameters for the Certificate_starGenType type
type MoqCertificate_starGenType_VerifyHostname_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqCertificate_starGenType_VerifyHostname_paramsKey]*MoqCertificate_starGenType_VerifyHostname_results
}

// MoqCertificate_starGenType_VerifyHostname_doFn defines the type of function
// needed when calling AndDo for the Certificate_starGenType type
type MoqCertificate_starGenType_VerifyHostname_doFn func(h string)

// MoqCertificate_starGenType_VerifyHostname_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Certificate_starGenType
// type
type MoqCertificate_starGenType_VerifyHostname_doReturnFn func(h string) error

// MoqCertificate_starGenType_VerifyHostname_results holds the results of the
// Certificate_starGenType type
type MoqCertificate_starGenType_VerifyHostname_results struct {
	Params  MoqCertificate_starGenType_VerifyHostname_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_VerifyHostname_doFn
		DoReturnFn MoqCertificate_starGenType_VerifyHostname_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqCertificate_starGenType_VerifyHostname_fnRecorder routes recorded
// function calls to the MoqCertificate_starGenType moq
type MoqCertificate_starGenType_VerifyHostname_fnRecorder struct {
	Params    MoqCertificate_starGenType_VerifyHostname_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqCertificate_starGenType_VerifyHostname_results
	Moq       *MoqCertificate_starGenType
}

// MoqCertificate_starGenType_VerifyHostname_anyParams isolates the any params
// functions of the Certificate_starGenType type
type MoqCertificate_starGenType_VerifyHostname_anyParams struct {
	Recorder *MoqCertificate_starGenType_VerifyHostname_fnRecorder
}

// MoqCertificate_starGenType_Equal_params holds the params of the
// Certificate_starGenType type
type MoqCertificate_starGenType_Equal_params struct{ Other *x509.Certificate }

// MoqCertificate_starGenType_Equal_paramsKey holds the map key params of the
// Certificate_starGenType type
type MoqCertificate_starGenType_Equal_paramsKey struct {
	Params struct{ Other *x509.Certificate }
	Hashes struct{ Other hash.Hash }
}

// MoqCertificate_starGenType_Equal_resultsByParams contains the results for a
// given set of parameters for the Certificate_starGenType type
type MoqCertificate_starGenType_Equal_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqCertificate_starGenType_Equal_paramsKey]*MoqCertificate_starGenType_Equal_results
}

// MoqCertificate_starGenType_Equal_doFn defines the type of function needed
// when calling AndDo for the Certificate_starGenType type
type MoqCertificate_starGenType_Equal_doFn func(other *x509.Certificate)

// MoqCertificate_starGenType_Equal_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Certificate_starGenType type
type MoqCertificate_starGenType_Equal_doReturnFn func(other *x509.Certificate) bool

// MoqCertificate_starGenType_Equal_results holds the results of the
// Certificate_starGenType type
type MoqCertificate_starGenType_Equal_results struct {
	Params  MoqCertificate_starGenType_Equal_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_Equal_doFn
		DoReturnFn MoqCertificate_starGenType_Equal_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqCertificate_starGenType_Equal_fnRecorder routes recorded function calls
// to the MoqCertificate_starGenType moq
type MoqCertificate_starGenType_Equal_fnRecorder struct {
	Params    MoqCertificate_starGenType_Equal_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqCertificate_starGenType_Equal_results
	Moq       *MoqCertificate_starGenType
}

// MoqCertificate_starGenType_Equal_anyParams isolates the any params functions
// of the Certificate_starGenType type
type MoqCertificate_starGenType_Equal_anyParams struct {
	Recorder *MoqCertificate_starGenType_Equal_fnRecorder
}

// MoqCertificate_starGenType_CheckSignatureFrom_params holds the params of the
// Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignatureFrom_params struct{ Parent *x509.Certificate }

// MoqCertificate_starGenType_CheckSignatureFrom_paramsKey holds the map key
// params of the Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignatureFrom_paramsKey struct {
	Params struct{ Parent *x509.Certificate }
	Hashes struct{ Parent hash.Hash }
}

// MoqCertificate_starGenType_CheckSignatureFrom_resultsByParams contains the
// results for a given set of parameters for the Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignatureFrom_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqCertificate_starGenType_CheckSignatureFrom_paramsKey]*MoqCertificate_starGenType_CheckSignatureFrom_results
}

// MoqCertificate_starGenType_CheckSignatureFrom_doFn defines the type of
// function needed when calling AndDo for the Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignatureFrom_doFn func(parent *x509.Certificate)

// MoqCertificate_starGenType_CheckSignatureFrom_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Certificate_starGenType
// type
type MoqCertificate_starGenType_CheckSignatureFrom_doReturnFn func(parent *x509.Certificate) error

// MoqCertificate_starGenType_CheckSignatureFrom_results holds the results of
// the Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignatureFrom_results struct {
	Params  MoqCertificate_starGenType_CheckSignatureFrom_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CheckSignatureFrom_doFn
		DoReturnFn MoqCertificate_starGenType_CheckSignatureFrom_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder routes recorded
// function calls to the MoqCertificate_starGenType moq
type MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder struct {
	Params    MoqCertificate_starGenType_CheckSignatureFrom_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqCertificate_starGenType_CheckSignatureFrom_results
	Moq       *MoqCertificate_starGenType
}

// MoqCertificate_starGenType_CheckSignatureFrom_anyParams isolates the any
// params functions of the Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignatureFrom_anyParams struct {
	Recorder *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder
}

// MoqCertificate_starGenType_CheckSignature_params holds the params of the
// Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignature_params struct {
	Algo              x509.SignatureAlgorithm
	Signed, Signature []byte
}

// MoqCertificate_starGenType_CheckSignature_paramsKey holds the map key params
// of the Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignature_paramsKey struct {
	Params struct{ Algo x509.SignatureAlgorithm }
	Hashes struct {
		Algo              hash.Hash
		Signed, Signature hash.Hash
	}
}

// MoqCertificate_starGenType_CheckSignature_resultsByParams contains the
// results for a given set of parameters for the Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignature_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqCertificate_starGenType_CheckSignature_paramsKey]*MoqCertificate_starGenType_CheckSignature_results
}

// MoqCertificate_starGenType_CheckSignature_doFn defines the type of function
// needed when calling AndDo for the Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignature_doFn func(algo x509.SignatureAlgorithm, signed, signature []byte)

// MoqCertificate_starGenType_CheckSignature_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Certificate_starGenType
// type
type MoqCertificate_starGenType_CheckSignature_doReturnFn func(algo x509.SignatureAlgorithm, signed, signature []byte) error

// MoqCertificate_starGenType_CheckSignature_results holds the results of the
// Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignature_results struct {
	Params  MoqCertificate_starGenType_CheckSignature_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CheckSignature_doFn
		DoReturnFn MoqCertificate_starGenType_CheckSignature_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqCertificate_starGenType_CheckSignature_fnRecorder routes recorded
// function calls to the MoqCertificate_starGenType moq
type MoqCertificate_starGenType_CheckSignature_fnRecorder struct {
	Params    MoqCertificate_starGenType_CheckSignature_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqCertificate_starGenType_CheckSignature_results
	Moq       *MoqCertificate_starGenType
}

// MoqCertificate_starGenType_CheckSignature_anyParams isolates the any params
// functions of the Certificate_starGenType type
type MoqCertificate_starGenType_CheckSignature_anyParams struct {
	Recorder *MoqCertificate_starGenType_CheckSignature_fnRecorder
}

// MoqCertificate_starGenType_CheckCRLSignature_params holds the params of the
// Certificate_starGenType type
type MoqCertificate_starGenType_CheckCRLSignature_params struct{ Crl *pkix.CertificateList }

// MoqCertificate_starGenType_CheckCRLSignature_paramsKey holds the map key
// params of the Certificate_starGenType type
type MoqCertificate_starGenType_CheckCRLSignature_paramsKey struct {
	Params struct{ Crl *pkix.CertificateList }
	Hashes struct{ Crl hash.Hash }
}

// MoqCertificate_starGenType_CheckCRLSignature_resultsByParams contains the
// results for a given set of parameters for the Certificate_starGenType type
type MoqCertificate_starGenType_CheckCRLSignature_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqCertificate_starGenType_CheckCRLSignature_paramsKey]*MoqCertificate_starGenType_CheckCRLSignature_results
}

// MoqCertificate_starGenType_CheckCRLSignature_doFn defines the type of
// function needed when calling AndDo for the Certificate_starGenType type
type MoqCertificate_starGenType_CheckCRLSignature_doFn func(crl *pkix.CertificateList)

// MoqCertificate_starGenType_CheckCRLSignature_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Certificate_starGenType
// type
type MoqCertificate_starGenType_CheckCRLSignature_doReturnFn func(crl *pkix.CertificateList) error

// MoqCertificate_starGenType_CheckCRLSignature_results holds the results of
// the Certificate_starGenType type
type MoqCertificate_starGenType_CheckCRLSignature_results struct {
	Params  MoqCertificate_starGenType_CheckCRLSignature_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CheckCRLSignature_doFn
		DoReturnFn MoqCertificate_starGenType_CheckCRLSignature_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqCertificate_starGenType_CheckCRLSignature_fnRecorder routes recorded
// function calls to the MoqCertificate_starGenType moq
type MoqCertificate_starGenType_CheckCRLSignature_fnRecorder struct {
	Params    MoqCertificate_starGenType_CheckCRLSignature_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqCertificate_starGenType_CheckCRLSignature_results
	Moq       *MoqCertificate_starGenType
}

// MoqCertificate_starGenType_CheckCRLSignature_anyParams isolates the any
// params functions of the Certificate_starGenType type
type MoqCertificate_starGenType_CheckCRLSignature_anyParams struct {
	Recorder *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder
}

// MoqCertificate_starGenType_CreateCRL_params holds the params of the
// Certificate_starGenType type
type MoqCertificate_starGenType_CreateCRL_params struct {
	Rand         io.Reader
	Priv         any
	RevokedCerts []pkix.RevokedCertificate
	Now, Expiry  time.Time
}

// MoqCertificate_starGenType_CreateCRL_paramsKey holds the map key params of
// the Certificate_starGenType type
type MoqCertificate_starGenType_CreateCRL_paramsKey struct {
	Params struct {
		Rand        io.Reader
		Priv        any
		Now, Expiry time.Time
	}
	Hashes struct {
		Rand         hash.Hash
		Priv         hash.Hash
		RevokedCerts hash.Hash
		Now, Expiry  hash.Hash
	}
}

// MoqCertificate_starGenType_CreateCRL_resultsByParams contains the results
// for a given set of parameters for the Certificate_starGenType type
type MoqCertificate_starGenType_CreateCRL_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqCertificate_starGenType_CreateCRL_paramsKey]*MoqCertificate_starGenType_CreateCRL_results
}

// MoqCertificate_starGenType_CreateCRL_doFn defines the type of function
// needed when calling AndDo for the Certificate_starGenType type
type MoqCertificate_starGenType_CreateCRL_doFn func(rand io.Reader, priv any, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time)

// MoqCertificate_starGenType_CreateCRL_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Certificate_starGenType type
type MoqCertificate_starGenType_CreateCRL_doReturnFn func(rand io.Reader, priv any, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)

// MoqCertificate_starGenType_CreateCRL_results holds the results of the
// Certificate_starGenType type
type MoqCertificate_starGenType_CreateCRL_results struct {
	Params  MoqCertificate_starGenType_CreateCRL_params
	Results []struct {
		Values *struct {
			CrlBytes []byte
			Err      error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CreateCRL_doFn
		DoReturnFn MoqCertificate_starGenType_CreateCRL_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqCertificate_starGenType_CreateCRL_fnRecorder routes recorded function
// calls to the MoqCertificate_starGenType moq
type MoqCertificate_starGenType_CreateCRL_fnRecorder struct {
	Params    MoqCertificate_starGenType_CreateCRL_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqCertificate_starGenType_CreateCRL_results
	Moq       *MoqCertificate_starGenType
}

// MoqCertificate_starGenType_CreateCRL_anyParams isolates the any params
// functions of the Certificate_starGenType type
type MoqCertificate_starGenType_CreateCRL_anyParams struct {
	Recorder *MoqCertificate_starGenType_CreateCRL_fnRecorder
}

// NewMoqCertificate_starGenType creates a new moq of the
// Certificate_starGenType type
func NewMoqCertificate_starGenType(scene *moq.Scene, config *moq.Config) *MoqCertificate_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqCertificate_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqCertificate_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Verify struct {
					Opts moq.ParamIndexing
				}
				VerifyHostname struct {
					H moq.ParamIndexing
				}
				Equal struct {
					Other moq.ParamIndexing
				}
				CheckSignatureFrom struct {
					Parent moq.ParamIndexing
				}
				CheckSignature struct {
					Algo      moq.ParamIndexing
					Signed    moq.ParamIndexing
					Signature moq.ParamIndexing
				}
				CheckCRLSignature struct {
					Crl moq.ParamIndexing
				}
				CreateCRL struct {
					Rand         moq.ParamIndexing
					Priv         moq.ParamIndexing
					RevokedCerts moq.ParamIndexing
					Now          moq.ParamIndexing
					Expiry       moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			Verify struct {
				Opts moq.ParamIndexing
			}
			VerifyHostname struct {
				H moq.ParamIndexing
			}
			Equal struct {
				Other moq.ParamIndexing
			}
			CheckSignatureFrom struct {
				Parent moq.ParamIndexing
			}
			CheckSignature struct {
				Algo      moq.ParamIndexing
				Signed    moq.ParamIndexing
				Signature moq.ParamIndexing
			}
			CheckCRLSignature struct {
				Crl moq.ParamIndexing
			}
			CreateCRL struct {
				Rand         moq.ParamIndexing
				Priv         moq.ParamIndexing
				RevokedCerts moq.ParamIndexing
				Now          moq.ParamIndexing
				Expiry       moq.ParamIndexing
			}
		}{
			Verify: struct {
				Opts moq.ParamIndexing
			}{
				Opts: moq.ParamIndexByHash,
			},
			VerifyHostname: struct {
				H moq.ParamIndexing
			}{
				H: moq.ParamIndexByValue,
			},
			Equal: struct {
				Other moq.ParamIndexing
			}{
				Other: moq.ParamIndexByHash,
			},
			CheckSignatureFrom: struct {
				Parent moq.ParamIndexing
			}{
				Parent: moq.ParamIndexByHash,
			},
			CheckSignature: struct {
				Algo      moq.ParamIndexing
				Signed    moq.ParamIndexing
				Signature moq.ParamIndexing
			}{
				Algo:      moq.ParamIndexByValue,
				Signed:    moq.ParamIndexByHash,
				Signature: moq.ParamIndexByHash,
			},
			CheckCRLSignature: struct {
				Crl moq.ParamIndexing
			}{
				Crl: moq.ParamIndexByHash,
			},
			CreateCRL: struct {
				Rand         moq.ParamIndexing
				Priv         moq.ParamIndexing
				RevokedCerts moq.ParamIndexing
				Now          moq.ParamIndexing
				Expiry       moq.ParamIndexing
			}{
				Rand:         moq.ParamIndexByHash,
				Priv:         moq.ParamIndexByValue,
				RevokedCerts: moq.ParamIndexByHash,
				Now:          moq.ParamIndexByHash,
				Expiry:       moq.ParamIndexByHash,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Certificate_starGenType type
func (m *MoqCertificate_starGenType) Mock() *MoqCertificate_starGenType_mock { return m.Moq }

func (m *MoqCertificate_starGenType_mock) Verify(opts x509.VerifyOptions) (chains [][]*x509.Certificate, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqCertificate_starGenType_Verify_params{
		Opts: opts,
	}
	var results *MoqCertificate_starGenType_Verify_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Verify {
		paramsKey := m.Moq.ParamsKey_Verify(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Verify(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Verify(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Verify(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(opts)
	}

	if result.Values != nil {
		chains = result.Values.Chains
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		chains, err = result.DoReturnFn(opts)
	}
	return
}

func (m *MoqCertificate_starGenType_mock) VerifyHostname(h string) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqCertificate_starGenType_VerifyHostname_params{
		H: h,
	}
	var results *MoqCertificate_starGenType_VerifyHostname_results
	for _, resultsByParams := range m.Moq.ResultsByParams_VerifyHostname {
		paramsKey := m.Moq.ParamsKey_VerifyHostname(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_VerifyHostname(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_VerifyHostname(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_VerifyHostname(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(h)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(h)
	}
	return
}

func (m *MoqCertificate_starGenType_mock) Equal(other *x509.Certificate) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqCertificate_starGenType_Equal_params{
		Other: other,
	}
	var results *MoqCertificate_starGenType_Equal_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Equal {
		paramsKey := m.Moq.ParamsKey_Equal(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Equal(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Equal(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Equal(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(other)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(other)
	}
	return
}

func (m *MoqCertificate_starGenType_mock) CheckSignatureFrom(parent *x509.Certificate) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqCertificate_starGenType_CheckSignatureFrom_params{
		Parent: parent,
	}
	var results *MoqCertificate_starGenType_CheckSignatureFrom_results
	for _, resultsByParams := range m.Moq.ResultsByParams_CheckSignatureFrom {
		paramsKey := m.Moq.ParamsKey_CheckSignatureFrom(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_CheckSignatureFrom(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_CheckSignatureFrom(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_CheckSignatureFrom(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(parent)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(parent)
	}
	return
}

func (m *MoqCertificate_starGenType_mock) CheckSignature(algo x509.SignatureAlgorithm, signed, signature []byte) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqCertificate_starGenType_CheckSignature_params{
		Algo:      algo,
		Signed:    signed,
		Signature: signature,
	}
	var results *MoqCertificate_starGenType_CheckSignature_results
	for _, resultsByParams := range m.Moq.ResultsByParams_CheckSignature {
		paramsKey := m.Moq.ParamsKey_CheckSignature(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_CheckSignature(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_CheckSignature(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_CheckSignature(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(algo, signed, signature)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(algo, signed, signature)
	}
	return
}

func (m *MoqCertificate_starGenType_mock) CheckCRLSignature(crl *pkix.CertificateList) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqCertificate_starGenType_CheckCRLSignature_params{
		Crl: crl,
	}
	var results *MoqCertificate_starGenType_CheckCRLSignature_results
	for _, resultsByParams := range m.Moq.ResultsByParams_CheckCRLSignature {
		paramsKey := m.Moq.ParamsKey_CheckCRLSignature(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_CheckCRLSignature(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_CheckCRLSignature(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_CheckCRLSignature(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(crl)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(crl)
	}
	return
}

func (m *MoqCertificate_starGenType_mock) CreateCRL(rand io.Reader, priv any, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqCertificate_starGenType_CreateCRL_params{
		Rand:         rand,
		Priv:         priv,
		RevokedCerts: revokedCerts,
		Now:          now,
		Expiry:       expiry,
	}
	var results *MoqCertificate_starGenType_CreateCRL_results
	for _, resultsByParams := range m.Moq.ResultsByParams_CreateCRL {
		paramsKey := m.Moq.ParamsKey_CreateCRL(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_CreateCRL(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_CreateCRL(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_CreateCRL(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(rand, priv, revokedCerts, now, expiry)
	}

	if result.Values != nil {
		crlBytes = result.Values.CrlBytes
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		crlBytes, err = result.DoReturnFn(rand, priv, revokedCerts, now, expiry)
	}
	return
}

// OnCall returns the recorder implementation of the Certificate_starGenType
// type
func (m *MoqCertificate_starGenType) OnCall() *MoqCertificate_starGenType_recorder {
	return &MoqCertificate_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqCertificate_starGenType_recorder) Verify(opts x509.VerifyOptions) *MoqCertificate_starGenType_Verify_fnRecorder {
	return &MoqCertificate_starGenType_Verify_fnRecorder{
		Params: MoqCertificate_starGenType_Verify_params{
			Opts: opts,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqCertificate_starGenType_Verify_fnRecorder) Any() *MoqCertificate_starGenType_Verify_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Verify(r.Params))
		return nil
	}
	return &MoqCertificate_starGenType_Verify_anyParams{Recorder: r}
}

func (a *MoqCertificate_starGenType_Verify_anyParams) Opts() *MoqCertificate_starGenType_Verify_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqCertificate_starGenType_Verify_fnRecorder) Seq() *MoqCertificate_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Verify(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqCertificate_starGenType_Verify_fnRecorder) NoSeq() *MoqCertificate_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Verify(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqCertificate_starGenType_Verify_fnRecorder) ReturnResults(chains [][]*x509.Certificate, err error) *MoqCertificate_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Chains [][]*x509.Certificate
			Err    error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_Verify_doFn
		DoReturnFn MoqCertificate_starGenType_Verify_doReturnFn
	}{
		Values: &struct {
			Chains [][]*x509.Certificate
			Err    error
		}{
			Chains: chains,
			Err:    err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqCertificate_starGenType_Verify_fnRecorder) AndDo(fn MoqCertificate_starGenType_Verify_doFn) *MoqCertificate_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqCertificate_starGenType_Verify_fnRecorder) DoReturnResults(fn MoqCertificate_starGenType_Verify_doReturnFn) *MoqCertificate_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Chains [][]*x509.Certificate
			Err    error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_Verify_doFn
		DoReturnFn MoqCertificate_starGenType_Verify_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqCertificate_starGenType_Verify_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqCertificate_starGenType_Verify_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Verify {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqCertificate_starGenType_Verify_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqCertificate_starGenType_Verify_paramsKey]*MoqCertificate_starGenType_Verify_results{},
		}
		r.Moq.ResultsByParams_Verify = append(r.Moq.ResultsByParams_Verify, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Verify) {
			copy(r.Moq.ResultsByParams_Verify[insertAt+1:], r.Moq.ResultsByParams_Verify[insertAt:0])
			r.Moq.ResultsByParams_Verify[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Verify(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqCertificate_starGenType_Verify_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqCertificate_starGenType_Verify_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqCertificate_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Chains [][]*x509.Certificate
					Err    error
				}
				Sequence   uint32
				DoFn       MoqCertificate_starGenType_Verify_doFn
				DoReturnFn MoqCertificate_starGenType_Verify_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqCertificate_starGenType) PrettyParams_Verify(params MoqCertificate_starGenType_Verify_params) string {
	return fmt.Sprintf("Verify(%#v)", params.Opts)
}

func (m *MoqCertificate_starGenType) ParamsKey_Verify(params MoqCertificate_starGenType_Verify_params, anyParams uint64) MoqCertificate_starGenType_Verify_paramsKey {
	m.Scene.T.Helper()
	var optsUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Verify.Opts == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The opts parameter of the Verify function can't be indexed by value")
		}
		optsUsedHash = hash.DeepHash(params.Opts)
	}
	return MoqCertificate_starGenType_Verify_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Opts hash.Hash }{
			Opts: optsUsedHash,
		},
	}
}

func (m *MoqCertificate_starGenType_recorder) VerifyHostname(h string) *MoqCertificate_starGenType_VerifyHostname_fnRecorder {
	return &MoqCertificate_starGenType_VerifyHostname_fnRecorder{
		Params: MoqCertificate_starGenType_VerifyHostname_params{
			H: h,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqCertificate_starGenType_VerifyHostname_fnRecorder) Any() *MoqCertificate_starGenType_VerifyHostname_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_VerifyHostname(r.Params))
		return nil
	}
	return &MoqCertificate_starGenType_VerifyHostname_anyParams{Recorder: r}
}

func (a *MoqCertificate_starGenType_VerifyHostname_anyParams) H() *MoqCertificate_starGenType_VerifyHostname_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqCertificate_starGenType_VerifyHostname_fnRecorder) Seq() *MoqCertificate_starGenType_VerifyHostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_VerifyHostname(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqCertificate_starGenType_VerifyHostname_fnRecorder) NoSeq() *MoqCertificate_starGenType_VerifyHostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_VerifyHostname(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqCertificate_starGenType_VerifyHostname_fnRecorder) ReturnResults(result1 error) *MoqCertificate_starGenType_VerifyHostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_VerifyHostname_doFn
		DoReturnFn MoqCertificate_starGenType_VerifyHostname_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqCertificate_starGenType_VerifyHostname_fnRecorder) AndDo(fn MoqCertificate_starGenType_VerifyHostname_doFn) *MoqCertificate_starGenType_VerifyHostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqCertificate_starGenType_VerifyHostname_fnRecorder) DoReturnResults(fn MoqCertificate_starGenType_VerifyHostname_doReturnFn) *MoqCertificate_starGenType_VerifyHostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_VerifyHostname_doFn
		DoReturnFn MoqCertificate_starGenType_VerifyHostname_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqCertificate_starGenType_VerifyHostname_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqCertificate_starGenType_VerifyHostname_resultsByParams
	for n, res := range r.Moq.ResultsByParams_VerifyHostname {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqCertificate_starGenType_VerifyHostname_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqCertificate_starGenType_VerifyHostname_paramsKey]*MoqCertificate_starGenType_VerifyHostname_results{},
		}
		r.Moq.ResultsByParams_VerifyHostname = append(r.Moq.ResultsByParams_VerifyHostname, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_VerifyHostname) {
			copy(r.Moq.ResultsByParams_VerifyHostname[insertAt+1:], r.Moq.ResultsByParams_VerifyHostname[insertAt:0])
			r.Moq.ResultsByParams_VerifyHostname[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_VerifyHostname(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqCertificate_starGenType_VerifyHostname_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqCertificate_starGenType_VerifyHostname_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqCertificate_starGenType_VerifyHostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqCertificate_starGenType_VerifyHostname_doFn
				DoReturnFn MoqCertificate_starGenType_VerifyHostname_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqCertificate_starGenType) PrettyParams_VerifyHostname(params MoqCertificate_starGenType_VerifyHostname_params) string {
	return fmt.Sprintf("VerifyHostname(%#v)", params.H)
}

func (m *MoqCertificate_starGenType) ParamsKey_VerifyHostname(params MoqCertificate_starGenType_VerifyHostname_params, anyParams uint64) MoqCertificate_starGenType_VerifyHostname_paramsKey {
	m.Scene.T.Helper()
	var hUsed string
	var hUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.VerifyHostname.H == moq.ParamIndexByValue {
			hUsed = params.H
		} else {
			hUsedHash = hash.DeepHash(params.H)
		}
	}
	return MoqCertificate_starGenType_VerifyHostname_paramsKey{
		Params: struct{ H string }{
			H: hUsed,
		},
		Hashes: struct{ H hash.Hash }{
			H: hUsedHash,
		},
	}
}

func (m *MoqCertificate_starGenType_recorder) Equal(other *x509.Certificate) *MoqCertificate_starGenType_Equal_fnRecorder {
	return &MoqCertificate_starGenType_Equal_fnRecorder{
		Params: MoqCertificate_starGenType_Equal_params{
			Other: other,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqCertificate_starGenType_Equal_fnRecorder) Any() *MoqCertificate_starGenType_Equal_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Equal(r.Params))
		return nil
	}
	return &MoqCertificate_starGenType_Equal_anyParams{Recorder: r}
}

func (a *MoqCertificate_starGenType_Equal_anyParams) Other() *MoqCertificate_starGenType_Equal_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqCertificate_starGenType_Equal_fnRecorder) Seq() *MoqCertificate_starGenType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Equal(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqCertificate_starGenType_Equal_fnRecorder) NoSeq() *MoqCertificate_starGenType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Equal(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqCertificate_starGenType_Equal_fnRecorder) ReturnResults(result1 bool) *MoqCertificate_starGenType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_Equal_doFn
		DoReturnFn MoqCertificate_starGenType_Equal_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqCertificate_starGenType_Equal_fnRecorder) AndDo(fn MoqCertificate_starGenType_Equal_doFn) *MoqCertificate_starGenType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqCertificate_starGenType_Equal_fnRecorder) DoReturnResults(fn MoqCertificate_starGenType_Equal_doReturnFn) *MoqCertificate_starGenType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_Equal_doFn
		DoReturnFn MoqCertificate_starGenType_Equal_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqCertificate_starGenType_Equal_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqCertificate_starGenType_Equal_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Equal {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqCertificate_starGenType_Equal_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqCertificate_starGenType_Equal_paramsKey]*MoqCertificate_starGenType_Equal_results{},
		}
		r.Moq.ResultsByParams_Equal = append(r.Moq.ResultsByParams_Equal, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Equal) {
			copy(r.Moq.ResultsByParams_Equal[insertAt+1:], r.Moq.ResultsByParams_Equal[insertAt:0])
			r.Moq.ResultsByParams_Equal[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Equal(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqCertificate_starGenType_Equal_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqCertificate_starGenType_Equal_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqCertificate_starGenType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqCertificate_starGenType_Equal_doFn
				DoReturnFn MoqCertificate_starGenType_Equal_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqCertificate_starGenType) PrettyParams_Equal(params MoqCertificate_starGenType_Equal_params) string {
	return fmt.Sprintf("Equal(%#v)", params.Other)
}

func (m *MoqCertificate_starGenType) ParamsKey_Equal(params MoqCertificate_starGenType_Equal_params, anyParams uint64) MoqCertificate_starGenType_Equal_paramsKey {
	m.Scene.T.Helper()
	var otherUsed *x509.Certificate
	var otherUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Equal.Other == moq.ParamIndexByValue {
			otherUsed = params.Other
		} else {
			otherUsedHash = hash.DeepHash(params.Other)
		}
	}
	return MoqCertificate_starGenType_Equal_paramsKey{
		Params: struct{ Other *x509.Certificate }{
			Other: otherUsed,
		},
		Hashes: struct{ Other hash.Hash }{
			Other: otherUsedHash,
		},
	}
}

func (m *MoqCertificate_starGenType_recorder) CheckSignatureFrom(parent *x509.Certificate) *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder {
	return &MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder{
		Params: MoqCertificate_starGenType_CheckSignatureFrom_params{
			Parent: parent,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder) Any() *MoqCertificate_starGenType_CheckSignatureFrom_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CheckSignatureFrom(r.Params))
		return nil
	}
	return &MoqCertificate_starGenType_CheckSignatureFrom_anyParams{Recorder: r}
}

func (a *MoqCertificate_starGenType_CheckSignatureFrom_anyParams) Parent() *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder) Seq() *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CheckSignatureFrom(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder) NoSeq() *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CheckSignatureFrom(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder) ReturnResults(result1 error) *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CheckSignatureFrom_doFn
		DoReturnFn MoqCertificate_starGenType_CheckSignatureFrom_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder) AndDo(fn MoqCertificate_starGenType_CheckSignatureFrom_doFn) *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder) DoReturnResults(fn MoqCertificate_starGenType_CheckSignatureFrom_doReturnFn) *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CheckSignatureFrom_doFn
		DoReturnFn MoqCertificate_starGenType_CheckSignatureFrom_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqCertificate_starGenType_CheckSignatureFrom_resultsByParams
	for n, res := range r.Moq.ResultsByParams_CheckSignatureFrom {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqCertificate_starGenType_CheckSignatureFrom_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqCertificate_starGenType_CheckSignatureFrom_paramsKey]*MoqCertificate_starGenType_CheckSignatureFrom_results{},
		}
		r.Moq.ResultsByParams_CheckSignatureFrom = append(r.Moq.ResultsByParams_CheckSignatureFrom, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_CheckSignatureFrom) {
			copy(r.Moq.ResultsByParams_CheckSignatureFrom[insertAt+1:], r.Moq.ResultsByParams_CheckSignatureFrom[insertAt:0])
			r.Moq.ResultsByParams_CheckSignatureFrom[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_CheckSignatureFrom(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqCertificate_starGenType_CheckSignatureFrom_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqCertificate_starGenType_CheckSignatureFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqCertificate_starGenType_CheckSignatureFrom_doFn
				DoReturnFn MoqCertificate_starGenType_CheckSignatureFrom_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqCertificate_starGenType) PrettyParams_CheckSignatureFrom(params MoqCertificate_starGenType_CheckSignatureFrom_params) string {
	return fmt.Sprintf("CheckSignatureFrom(%#v)", params.Parent)
}

func (m *MoqCertificate_starGenType) ParamsKey_CheckSignatureFrom(params MoqCertificate_starGenType_CheckSignatureFrom_params, anyParams uint64) MoqCertificate_starGenType_CheckSignatureFrom_paramsKey {
	m.Scene.T.Helper()
	var parentUsed *x509.Certificate
	var parentUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.CheckSignatureFrom.Parent == moq.ParamIndexByValue {
			parentUsed = params.Parent
		} else {
			parentUsedHash = hash.DeepHash(params.Parent)
		}
	}
	return MoqCertificate_starGenType_CheckSignatureFrom_paramsKey{
		Params: struct{ Parent *x509.Certificate }{
			Parent: parentUsed,
		},
		Hashes: struct{ Parent hash.Hash }{
			Parent: parentUsedHash,
		},
	}
}

func (m *MoqCertificate_starGenType_recorder) CheckSignature(algo x509.SignatureAlgorithm, signed, signature []byte) *MoqCertificate_starGenType_CheckSignature_fnRecorder {
	return &MoqCertificate_starGenType_CheckSignature_fnRecorder{
		Params: MoqCertificate_starGenType_CheckSignature_params{
			Algo:      algo,
			Signed:    signed,
			Signature: signature,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqCertificate_starGenType_CheckSignature_fnRecorder) Any() *MoqCertificate_starGenType_CheckSignature_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CheckSignature(r.Params))
		return nil
	}
	return &MoqCertificate_starGenType_CheckSignature_anyParams{Recorder: r}
}

func (a *MoqCertificate_starGenType_CheckSignature_anyParams) Algo() *MoqCertificate_starGenType_CheckSignature_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqCertificate_starGenType_CheckSignature_anyParams) Signed() *MoqCertificate_starGenType_CheckSignature_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqCertificate_starGenType_CheckSignature_anyParams) Signature() *MoqCertificate_starGenType_CheckSignature_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqCertificate_starGenType_CheckSignature_fnRecorder) Seq() *MoqCertificate_starGenType_CheckSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CheckSignature(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqCertificate_starGenType_CheckSignature_fnRecorder) NoSeq() *MoqCertificate_starGenType_CheckSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CheckSignature(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqCertificate_starGenType_CheckSignature_fnRecorder) ReturnResults(result1 error) *MoqCertificate_starGenType_CheckSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CheckSignature_doFn
		DoReturnFn MoqCertificate_starGenType_CheckSignature_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqCertificate_starGenType_CheckSignature_fnRecorder) AndDo(fn MoqCertificate_starGenType_CheckSignature_doFn) *MoqCertificate_starGenType_CheckSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqCertificate_starGenType_CheckSignature_fnRecorder) DoReturnResults(fn MoqCertificate_starGenType_CheckSignature_doReturnFn) *MoqCertificate_starGenType_CheckSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CheckSignature_doFn
		DoReturnFn MoqCertificate_starGenType_CheckSignature_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqCertificate_starGenType_CheckSignature_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqCertificate_starGenType_CheckSignature_resultsByParams
	for n, res := range r.Moq.ResultsByParams_CheckSignature {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqCertificate_starGenType_CheckSignature_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqCertificate_starGenType_CheckSignature_paramsKey]*MoqCertificate_starGenType_CheckSignature_results{},
		}
		r.Moq.ResultsByParams_CheckSignature = append(r.Moq.ResultsByParams_CheckSignature, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_CheckSignature) {
			copy(r.Moq.ResultsByParams_CheckSignature[insertAt+1:], r.Moq.ResultsByParams_CheckSignature[insertAt:0])
			r.Moq.ResultsByParams_CheckSignature[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_CheckSignature(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqCertificate_starGenType_CheckSignature_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqCertificate_starGenType_CheckSignature_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqCertificate_starGenType_CheckSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqCertificate_starGenType_CheckSignature_doFn
				DoReturnFn MoqCertificate_starGenType_CheckSignature_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqCertificate_starGenType) PrettyParams_CheckSignature(params MoqCertificate_starGenType_CheckSignature_params) string {
	return fmt.Sprintf("CheckSignature(%#v, %#v, %#v)", params.Algo, params.Signed, params.Signature)
}

func (m *MoqCertificate_starGenType) ParamsKey_CheckSignature(params MoqCertificate_starGenType_CheckSignature_params, anyParams uint64) MoqCertificate_starGenType_CheckSignature_paramsKey {
	m.Scene.T.Helper()
	var algoUsed x509.SignatureAlgorithm
	var algoUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.CheckSignature.Algo == moq.ParamIndexByValue {
			algoUsed = params.Algo
		} else {
			algoUsedHash = hash.DeepHash(params.Algo)
		}
	}
	var signedUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.CheckSignature.Signed == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The signed parameter of the CheckSignature function can't be indexed by value")
		}
		signedUsedHash = hash.DeepHash(params.Signed)
	}
	var signatureUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.CheckSignature.Signature == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The signature parameter of the CheckSignature function can't be indexed by value")
		}
		signatureUsedHash = hash.DeepHash(params.Signature)
	}
	return MoqCertificate_starGenType_CheckSignature_paramsKey{
		Params: struct{ Algo x509.SignatureAlgorithm }{
			Algo: algoUsed,
		},
		Hashes: struct {
			Algo              hash.Hash
			Signed, Signature hash.Hash
		}{
			Algo:      algoUsedHash,
			Signed:    signedUsedHash,
			Signature: signatureUsedHash,
		},
	}
}

func (m *MoqCertificate_starGenType_recorder) CheckCRLSignature(crl *pkix.CertificateList) *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder {
	return &MoqCertificate_starGenType_CheckCRLSignature_fnRecorder{
		Params: MoqCertificate_starGenType_CheckCRLSignature_params{
			Crl: crl,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder) Any() *MoqCertificate_starGenType_CheckCRLSignature_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CheckCRLSignature(r.Params))
		return nil
	}
	return &MoqCertificate_starGenType_CheckCRLSignature_anyParams{Recorder: r}
}

func (a *MoqCertificate_starGenType_CheckCRLSignature_anyParams) Crl() *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder) Seq() *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CheckCRLSignature(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder) NoSeq() *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CheckCRLSignature(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder) ReturnResults(result1 error) *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CheckCRLSignature_doFn
		DoReturnFn MoqCertificate_starGenType_CheckCRLSignature_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder) AndDo(fn MoqCertificate_starGenType_CheckCRLSignature_doFn) *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder) DoReturnResults(fn MoqCertificate_starGenType_CheckCRLSignature_doReturnFn) *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CheckCRLSignature_doFn
		DoReturnFn MoqCertificate_starGenType_CheckCRLSignature_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqCertificate_starGenType_CheckCRLSignature_resultsByParams
	for n, res := range r.Moq.ResultsByParams_CheckCRLSignature {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqCertificate_starGenType_CheckCRLSignature_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqCertificate_starGenType_CheckCRLSignature_paramsKey]*MoqCertificate_starGenType_CheckCRLSignature_results{},
		}
		r.Moq.ResultsByParams_CheckCRLSignature = append(r.Moq.ResultsByParams_CheckCRLSignature, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_CheckCRLSignature) {
			copy(r.Moq.ResultsByParams_CheckCRLSignature[insertAt+1:], r.Moq.ResultsByParams_CheckCRLSignature[insertAt:0])
			r.Moq.ResultsByParams_CheckCRLSignature[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_CheckCRLSignature(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqCertificate_starGenType_CheckCRLSignature_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqCertificate_starGenType_CheckCRLSignature_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqCertificate_starGenType_CheckCRLSignature_doFn
				DoReturnFn MoqCertificate_starGenType_CheckCRLSignature_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqCertificate_starGenType) PrettyParams_CheckCRLSignature(params MoqCertificate_starGenType_CheckCRLSignature_params) string {
	return fmt.Sprintf("CheckCRLSignature(%#v)", params.Crl)
}

func (m *MoqCertificate_starGenType) ParamsKey_CheckCRLSignature(params MoqCertificate_starGenType_CheckCRLSignature_params, anyParams uint64) MoqCertificate_starGenType_CheckCRLSignature_paramsKey {
	m.Scene.T.Helper()
	var crlUsed *pkix.CertificateList
	var crlUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.CheckCRLSignature.Crl == moq.ParamIndexByValue {
			crlUsed = params.Crl
		} else {
			crlUsedHash = hash.DeepHash(params.Crl)
		}
	}
	return MoqCertificate_starGenType_CheckCRLSignature_paramsKey{
		Params: struct{ Crl *pkix.CertificateList }{
			Crl: crlUsed,
		},
		Hashes: struct{ Crl hash.Hash }{
			Crl: crlUsedHash,
		},
	}
}

func (m *MoqCertificate_starGenType_recorder) CreateCRL(rand io.Reader, priv any, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	return &MoqCertificate_starGenType_CreateCRL_fnRecorder{
		Params: MoqCertificate_starGenType_CreateCRL_params{
			Rand:         rand,
			Priv:         priv,
			RevokedCerts: revokedCerts,
			Now:          now,
			Expiry:       expiry,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqCertificate_starGenType_CreateCRL_fnRecorder) Any() *MoqCertificate_starGenType_CreateCRL_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CreateCRL(r.Params))
		return nil
	}
	return &MoqCertificate_starGenType_CreateCRL_anyParams{Recorder: r}
}

func (a *MoqCertificate_starGenType_CreateCRL_anyParams) Rand() *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqCertificate_starGenType_CreateCRL_anyParams) Priv() *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqCertificate_starGenType_CreateCRL_anyParams) RevokedCerts() *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (a *MoqCertificate_starGenType_CreateCRL_anyParams) Now() *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	a.Recorder.AnyParams |= 1 << 3
	return a.Recorder
}

func (a *MoqCertificate_starGenType_CreateCRL_anyParams) Expiry() *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	a.Recorder.AnyParams |= 1 << 4
	return a.Recorder
}

func (r *MoqCertificate_starGenType_CreateCRL_fnRecorder) Seq() *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CreateCRL(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqCertificate_starGenType_CreateCRL_fnRecorder) NoSeq() *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CreateCRL(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqCertificate_starGenType_CreateCRL_fnRecorder) ReturnResults(crlBytes []byte, err error) *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			CrlBytes []byte
			Err      error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CreateCRL_doFn
		DoReturnFn MoqCertificate_starGenType_CreateCRL_doReturnFn
	}{
		Values: &struct {
			CrlBytes []byte
			Err      error
		}{
			CrlBytes: crlBytes,
			Err:      err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqCertificate_starGenType_CreateCRL_fnRecorder) AndDo(fn MoqCertificate_starGenType_CreateCRL_doFn) *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqCertificate_starGenType_CreateCRL_fnRecorder) DoReturnResults(fn MoqCertificate_starGenType_CreateCRL_doReturnFn) *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			CrlBytes []byte
			Err      error
		}
		Sequence   uint32
		DoFn       MoqCertificate_starGenType_CreateCRL_doFn
		DoReturnFn MoqCertificate_starGenType_CreateCRL_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqCertificate_starGenType_CreateCRL_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqCertificate_starGenType_CreateCRL_resultsByParams
	for n, res := range r.Moq.ResultsByParams_CreateCRL {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqCertificate_starGenType_CreateCRL_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqCertificate_starGenType_CreateCRL_paramsKey]*MoqCertificate_starGenType_CreateCRL_results{},
		}
		r.Moq.ResultsByParams_CreateCRL = append(r.Moq.ResultsByParams_CreateCRL, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_CreateCRL) {
			copy(r.Moq.ResultsByParams_CreateCRL[insertAt+1:], r.Moq.ResultsByParams_CreateCRL[insertAt:0])
			r.Moq.ResultsByParams_CreateCRL[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_CreateCRL(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqCertificate_starGenType_CreateCRL_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqCertificate_starGenType_CreateCRL_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqCertificate_starGenType_CreateCRL_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					CrlBytes []byte
					Err      error
				}
				Sequence   uint32
				DoFn       MoqCertificate_starGenType_CreateCRL_doFn
				DoReturnFn MoqCertificate_starGenType_CreateCRL_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqCertificate_starGenType) PrettyParams_CreateCRL(params MoqCertificate_starGenType_CreateCRL_params) string {
	return fmt.Sprintf("CreateCRL(%#v, %#v, %#v, %#v, %#v)", params.Rand, params.Priv, params.RevokedCerts, params.Now, params.Expiry)
}

func (m *MoqCertificate_starGenType) ParamsKey_CreateCRL(params MoqCertificate_starGenType_CreateCRL_params, anyParams uint64) MoqCertificate_starGenType_CreateCRL_paramsKey {
	m.Scene.T.Helper()
	var randUsed io.Reader
	var randUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.CreateCRL.Rand == moq.ParamIndexByValue {
			randUsed = params.Rand
		} else {
			randUsedHash = hash.DeepHash(params.Rand)
		}
	}
	var privUsed any
	var privUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.CreateCRL.Priv == moq.ParamIndexByValue {
			privUsed = params.Priv
		} else {
			privUsedHash = hash.DeepHash(params.Priv)
		}
	}
	var revokedCertsUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.CreateCRL.RevokedCerts == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The revokedCerts parameter of the CreateCRL function can't be indexed by value")
		}
		revokedCertsUsedHash = hash.DeepHash(params.RevokedCerts)
	}
	var nowUsed time.Time
	var nowUsedHash hash.Hash
	if anyParams&(1<<3) == 0 {
		if m.Runtime.ParameterIndexing.CreateCRL.Now == moq.ParamIndexByValue {
			nowUsed = params.Now
		} else {
			nowUsedHash = hash.DeepHash(params.Now)
		}
	}
	var expiryUsed time.Time
	var expiryUsedHash hash.Hash
	if anyParams&(1<<4) == 0 {
		if m.Runtime.ParameterIndexing.CreateCRL.Expiry == moq.ParamIndexByValue {
			expiryUsed = params.Expiry
		} else {
			expiryUsedHash = hash.DeepHash(params.Expiry)
		}
	}
	return MoqCertificate_starGenType_CreateCRL_paramsKey{
		Params: struct {
			Rand        io.Reader
			Priv        any
			Now, Expiry time.Time
		}{
			Rand:   randUsed,
			Priv:   privUsed,
			Now:    nowUsed,
			Expiry: expiryUsed,
		},
		Hashes: struct {
			Rand         hash.Hash
			Priv         hash.Hash
			RevokedCerts hash.Hash
			Now, Expiry  hash.Hash
		}{
			Rand:         randUsedHash,
			Priv:         privUsedHash,
			RevokedCerts: revokedCertsUsedHash,
			Now:          nowUsedHash,
			Expiry:       expiryUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqCertificate_starGenType) Reset() {
	m.ResultsByParams_Verify = nil
	m.ResultsByParams_VerifyHostname = nil
	m.ResultsByParams_Equal = nil
	m.ResultsByParams_CheckSignatureFrom = nil
	m.ResultsByParams_CheckSignature = nil
	m.ResultsByParams_CheckCRLSignature = nil
	m.ResultsByParams_CreateCRL = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqCertificate_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Verify {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Verify(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_VerifyHostname {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_VerifyHostname(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Equal {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Equal(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_CheckSignatureFrom {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_CheckSignatureFrom(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_CheckSignature {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_CheckSignature(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_CheckCRLSignature {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_CheckCRLSignature(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_CreateCRL {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_CreateCRL(results.Params))
			}
		}
	}
}
