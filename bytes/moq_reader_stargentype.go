// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package bytes

import (
	"fmt"
	"io"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that bytes.Reader_starGenType is mocked
// completely
var _ Reader_starGenType = (*MoqReader_starGenType_mock)(nil)

// Reader_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Reader_starGenType interface {
	Len() int
	Size() int64
	Read(b []byte) (n int, err error)
	ReadAt(b []byte, off int64) (n int, err error)
	ReadByte() (byte, error)
	UnreadByte() error
	ReadRune() (ch rune, size int, err error)
	UnreadRune() error
	Seek(offset int64, whence int) (int64, error)
	WriteTo(w io.Writer) (n int64, err error)
	Reset(b []byte)
}

// MoqReader_starGenType holds the state of a moq of the Reader_starGenType
// type
type MoqReader_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqReader_starGenType_mock

	ResultsByParams_Len        []MoqReader_starGenType_Len_resultsByParams
	ResultsByParams_Size       []MoqReader_starGenType_Size_resultsByParams
	ResultsByParams_Read       []MoqReader_starGenType_Read_resultsByParams
	ResultsByParams_ReadAt     []MoqReader_starGenType_ReadAt_resultsByParams
	ResultsByParams_ReadByte   []MoqReader_starGenType_ReadByte_resultsByParams
	ResultsByParams_UnreadByte []MoqReader_starGenType_UnreadByte_resultsByParams
	ResultsByParams_ReadRune   []MoqReader_starGenType_ReadRune_resultsByParams
	ResultsByParams_UnreadRune []MoqReader_starGenType_UnreadRune_resultsByParams
	ResultsByParams_Seek       []MoqReader_starGenType_Seek_resultsByParams
	ResultsByParams_WriteTo    []MoqReader_starGenType_WriteTo_resultsByParams
	ResultsByParams_Reset      []MoqReader_starGenType_Reset_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Len  struct{}
			Size struct{}
			Read struct {
				B moq.ParamIndexing
			}
			ReadAt struct {
				B   moq.ParamIndexing
				Off moq.ParamIndexing
			}
			ReadByte   struct{}
			UnreadByte struct{}
			ReadRune   struct{}
			UnreadRune struct{}
			Seek       struct {
				Offset moq.ParamIndexing
				Whence moq.ParamIndexing
			}
			WriteTo struct {
				W moq.ParamIndexing
			}
			Reset struct {
				B moq.ParamIndexing
			}
		}
	}
	// MoqReader_starGenType_mock isolates the mock interface of the
}

// Reader_starGenType type
type MoqReader_starGenType_mock struct {
	Moq *MoqReader_starGenType
}

// MoqReader_starGenType_recorder isolates the recorder interface of the
// Reader_starGenType type
type MoqReader_starGenType_recorder struct {
	Moq *MoqReader_starGenType
}

// MoqReader_starGenType_Len_params holds the params of the Reader_starGenType
// type
type MoqReader_starGenType_Len_params struct{}

// MoqReader_starGenType_Len_paramsKey holds the map key params of the
// Reader_starGenType type
type MoqReader_starGenType_Len_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqReader_starGenType_Len_resultsByParams contains the results for a given
// set of parameters for the Reader_starGenType type
type MoqReader_starGenType_Len_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqReader_starGenType_Len_paramsKey]*MoqReader_starGenType_Len_results
}

// MoqReader_starGenType_Len_doFn defines the type of function needed when
// calling AndDo for the Reader_starGenType type
type MoqReader_starGenType_Len_doFn func()

// MoqReader_starGenType_Len_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Reader_starGenType type
type MoqReader_starGenType_Len_doReturnFn func() int

// MoqReader_starGenType_Len_results holds the results of the
// Reader_starGenType type
type MoqReader_starGenType_Len_results struct {
	Params  MoqReader_starGenType_Len_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Len_doFn
		DoReturnFn MoqReader_starGenType_Len_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqReader_starGenType_Len_fnRecorder routes recorded function calls to the
// MoqReader_starGenType moq
type MoqReader_starGenType_Len_fnRecorder struct {
	Params    MoqReader_starGenType_Len_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqReader_starGenType_Len_results
	Moq       *MoqReader_starGenType
}

// MoqReader_starGenType_Len_anyParams isolates the any params functions of the
// Reader_starGenType type
type MoqReader_starGenType_Len_anyParams struct {
	Recorder *MoqReader_starGenType_Len_fnRecorder
}

// MoqReader_starGenType_Size_params holds the params of the Reader_starGenType
// type
type MoqReader_starGenType_Size_params struct{}

// MoqReader_starGenType_Size_paramsKey holds the map key params of the
// Reader_starGenType type
type MoqReader_starGenType_Size_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqReader_starGenType_Size_resultsByParams contains the results for a given
// set of parameters for the Reader_starGenType type
type MoqReader_starGenType_Size_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqReader_starGenType_Size_paramsKey]*MoqReader_starGenType_Size_results
}

// MoqReader_starGenType_Size_doFn defines the type of function needed when
// calling AndDo for the Reader_starGenType type
type MoqReader_starGenType_Size_doFn func()

// MoqReader_starGenType_Size_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Reader_starGenType type
type MoqReader_starGenType_Size_doReturnFn func() int64

// MoqReader_starGenType_Size_results holds the results of the
// Reader_starGenType type
type MoqReader_starGenType_Size_results struct {
	Params  MoqReader_starGenType_Size_params
	Results []struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Size_doFn
		DoReturnFn MoqReader_starGenType_Size_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqReader_starGenType_Size_fnRecorder routes recorded function calls to the
// MoqReader_starGenType moq
type MoqReader_starGenType_Size_fnRecorder struct {
	Params    MoqReader_starGenType_Size_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqReader_starGenType_Size_results
	Moq       *MoqReader_starGenType
}

// MoqReader_starGenType_Size_anyParams isolates the any params functions of
// the Reader_starGenType type
type MoqReader_starGenType_Size_anyParams struct {
	Recorder *MoqReader_starGenType_Size_fnRecorder
}

// MoqReader_starGenType_Read_params holds the params of the Reader_starGenType
// type
type MoqReader_starGenType_Read_params struct{ B []byte }

// MoqReader_starGenType_Read_paramsKey holds the map key params of the
// Reader_starGenType type
type MoqReader_starGenType_Read_paramsKey struct {
	Params struct{}
	Hashes struct{ B hash.Hash }
}

// MoqReader_starGenType_Read_resultsByParams contains the results for a given
// set of parameters for the Reader_starGenType type
type MoqReader_starGenType_Read_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqReader_starGenType_Read_paramsKey]*MoqReader_starGenType_Read_results
}

// MoqReader_starGenType_Read_doFn defines the type of function needed when
// calling AndDo for the Reader_starGenType type
type MoqReader_starGenType_Read_doFn func(b []byte)

// MoqReader_starGenType_Read_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Reader_starGenType type
type MoqReader_starGenType_Read_doReturnFn func(b []byte) (n int, err error)

// MoqReader_starGenType_Read_results holds the results of the
// Reader_starGenType type
type MoqReader_starGenType_Read_results struct {
	Params  MoqReader_starGenType_Read_params
	Results []struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Read_doFn
		DoReturnFn MoqReader_starGenType_Read_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqReader_starGenType_Read_fnRecorder routes recorded function calls to the
// MoqReader_starGenType moq
type MoqReader_starGenType_Read_fnRecorder struct {
	Params    MoqReader_starGenType_Read_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqReader_starGenType_Read_results
	Moq       *MoqReader_starGenType
}

// MoqReader_starGenType_Read_anyParams isolates the any params functions of
// the Reader_starGenType type
type MoqReader_starGenType_Read_anyParams struct {
	Recorder *MoqReader_starGenType_Read_fnRecorder
}

// MoqReader_starGenType_ReadAt_params holds the params of the
// Reader_starGenType type
type MoqReader_starGenType_ReadAt_params struct {
	B   []byte
	Off int64
}

// MoqReader_starGenType_ReadAt_paramsKey holds the map key params of the
// Reader_starGenType type
type MoqReader_starGenType_ReadAt_paramsKey struct {
	Params struct{ Off int64 }
	Hashes struct {
		B   hash.Hash
		Off hash.Hash
	}
}

// MoqReader_starGenType_ReadAt_resultsByParams contains the results for a
// given set of parameters for the Reader_starGenType type
type MoqReader_starGenType_ReadAt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqReader_starGenType_ReadAt_paramsKey]*MoqReader_starGenType_ReadAt_results
}

// MoqReader_starGenType_ReadAt_doFn defines the type of function needed when
// calling AndDo for the Reader_starGenType type
type MoqReader_starGenType_ReadAt_doFn func(b []byte, off int64)

// MoqReader_starGenType_ReadAt_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Reader_starGenType type
type MoqReader_starGenType_ReadAt_doReturnFn func(b []byte, off int64) (n int, err error)

// MoqReader_starGenType_ReadAt_results holds the results of the
// Reader_starGenType type
type MoqReader_starGenType_ReadAt_results struct {
	Params  MoqReader_starGenType_ReadAt_params
	Results []struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_ReadAt_doFn
		DoReturnFn MoqReader_starGenType_ReadAt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqReader_starGenType_ReadAt_fnRecorder routes recorded function calls to
// the MoqReader_starGenType moq
type MoqReader_starGenType_ReadAt_fnRecorder struct {
	Params    MoqReader_starGenType_ReadAt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqReader_starGenType_ReadAt_results
	Moq       *MoqReader_starGenType
}

// MoqReader_starGenType_ReadAt_anyParams isolates the any params functions of
// the Reader_starGenType type
type MoqReader_starGenType_ReadAt_anyParams struct {
	Recorder *MoqReader_starGenType_ReadAt_fnRecorder
}

// MoqReader_starGenType_ReadByte_params holds the params of the
// Reader_starGenType type
type MoqReader_starGenType_ReadByte_params struct{}

// MoqReader_starGenType_ReadByte_paramsKey holds the map key params of the
// Reader_starGenType type
type MoqReader_starGenType_ReadByte_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqReader_starGenType_ReadByte_resultsByParams contains the results for a
// given set of parameters for the Reader_starGenType type
type MoqReader_starGenType_ReadByte_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqReader_starGenType_ReadByte_paramsKey]*MoqReader_starGenType_ReadByte_results
}

// MoqReader_starGenType_ReadByte_doFn defines the type of function needed when
// calling AndDo for the Reader_starGenType type
type MoqReader_starGenType_ReadByte_doFn func()

// MoqReader_starGenType_ReadByte_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Reader_starGenType type
type MoqReader_starGenType_ReadByte_doReturnFn func() (byte, error)

// MoqReader_starGenType_ReadByte_results holds the results of the
// Reader_starGenType type
type MoqReader_starGenType_ReadByte_results struct {
	Params  MoqReader_starGenType_ReadByte_params
	Results []struct {
		Values *struct {
			Result1 byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_ReadByte_doFn
		DoReturnFn MoqReader_starGenType_ReadByte_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqReader_starGenType_ReadByte_fnRecorder routes recorded function calls to
// the MoqReader_starGenType moq
type MoqReader_starGenType_ReadByte_fnRecorder struct {
	Params    MoqReader_starGenType_ReadByte_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqReader_starGenType_ReadByte_results
	Moq       *MoqReader_starGenType
}

// MoqReader_starGenType_ReadByte_anyParams isolates the any params functions
// of the Reader_starGenType type
type MoqReader_starGenType_ReadByte_anyParams struct {
	Recorder *MoqReader_starGenType_ReadByte_fnRecorder
}

// MoqReader_starGenType_UnreadByte_params holds the params of the
// Reader_starGenType type
type MoqReader_starGenType_UnreadByte_params struct{}

// MoqReader_starGenType_UnreadByte_paramsKey holds the map key params of the
// Reader_starGenType type
type MoqReader_starGenType_UnreadByte_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqReader_starGenType_UnreadByte_resultsByParams contains the results for a
// given set of parameters for the Reader_starGenType type
type MoqReader_starGenType_UnreadByte_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqReader_starGenType_UnreadByte_paramsKey]*MoqReader_starGenType_UnreadByte_results
}

// MoqReader_starGenType_UnreadByte_doFn defines the type of function needed
// when calling AndDo for the Reader_starGenType type
type MoqReader_starGenType_UnreadByte_doFn func()

// MoqReader_starGenType_UnreadByte_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Reader_starGenType type
type MoqReader_starGenType_UnreadByte_doReturnFn func() error

// MoqReader_starGenType_UnreadByte_results holds the results of the
// Reader_starGenType type
type MoqReader_starGenType_UnreadByte_results struct {
	Params  MoqReader_starGenType_UnreadByte_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_UnreadByte_doFn
		DoReturnFn MoqReader_starGenType_UnreadByte_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqReader_starGenType_UnreadByte_fnRecorder routes recorded function calls
// to the MoqReader_starGenType moq
type MoqReader_starGenType_UnreadByte_fnRecorder struct {
	Params    MoqReader_starGenType_UnreadByte_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqReader_starGenType_UnreadByte_results
	Moq       *MoqReader_starGenType
}

// MoqReader_starGenType_UnreadByte_anyParams isolates the any params functions
// of the Reader_starGenType type
type MoqReader_starGenType_UnreadByte_anyParams struct {
	Recorder *MoqReader_starGenType_UnreadByte_fnRecorder
}

// MoqReader_starGenType_ReadRune_params holds the params of the
// Reader_starGenType type
type MoqReader_starGenType_ReadRune_params struct{}

// MoqReader_starGenType_ReadRune_paramsKey holds the map key params of the
// Reader_starGenType type
type MoqReader_starGenType_ReadRune_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqReader_starGenType_ReadRune_resultsByParams contains the results for a
// given set of parameters for the Reader_starGenType type
type MoqReader_starGenType_ReadRune_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqReader_starGenType_ReadRune_paramsKey]*MoqReader_starGenType_ReadRune_results
}

// MoqReader_starGenType_ReadRune_doFn defines the type of function needed when
// calling AndDo for the Reader_starGenType type
type MoqReader_starGenType_ReadRune_doFn func()

// MoqReader_starGenType_ReadRune_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Reader_starGenType type
type MoqReader_starGenType_ReadRune_doReturnFn func() (ch rune, size int, err error)

// MoqReader_starGenType_ReadRune_results holds the results of the
// Reader_starGenType type
type MoqReader_starGenType_ReadRune_results struct {
	Params  MoqReader_starGenType_ReadRune_params
	Results []struct {
		Values *struct {
			Ch   rune
			Size int
			Err  error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_ReadRune_doFn
		DoReturnFn MoqReader_starGenType_ReadRune_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqReader_starGenType_ReadRune_fnRecorder routes recorded function calls to
// the MoqReader_starGenType moq
type MoqReader_starGenType_ReadRune_fnRecorder struct {
	Params    MoqReader_starGenType_ReadRune_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqReader_starGenType_ReadRune_results
	Moq       *MoqReader_starGenType
}

// MoqReader_starGenType_ReadRune_anyParams isolates the any params functions
// of the Reader_starGenType type
type MoqReader_starGenType_ReadRune_anyParams struct {
	Recorder *MoqReader_starGenType_ReadRune_fnRecorder
}

// MoqReader_starGenType_UnreadRune_params holds the params of the
// Reader_starGenType type
type MoqReader_starGenType_UnreadRune_params struct{}

// MoqReader_starGenType_UnreadRune_paramsKey holds the map key params of the
// Reader_starGenType type
type MoqReader_starGenType_UnreadRune_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqReader_starGenType_UnreadRune_resultsByParams contains the results for a
// given set of parameters for the Reader_starGenType type
type MoqReader_starGenType_UnreadRune_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqReader_starGenType_UnreadRune_paramsKey]*MoqReader_starGenType_UnreadRune_results
}

// MoqReader_starGenType_UnreadRune_doFn defines the type of function needed
// when calling AndDo for the Reader_starGenType type
type MoqReader_starGenType_UnreadRune_doFn func()

// MoqReader_starGenType_UnreadRune_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Reader_starGenType type
type MoqReader_starGenType_UnreadRune_doReturnFn func() error

// MoqReader_starGenType_UnreadRune_results holds the results of the
// Reader_starGenType type
type MoqReader_starGenType_UnreadRune_results struct {
	Params  MoqReader_starGenType_UnreadRune_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_UnreadRune_doFn
		DoReturnFn MoqReader_starGenType_UnreadRune_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqReader_starGenType_UnreadRune_fnRecorder routes recorded function calls
// to the MoqReader_starGenType moq
type MoqReader_starGenType_UnreadRune_fnRecorder struct {
	Params    MoqReader_starGenType_UnreadRune_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqReader_starGenType_UnreadRune_results
	Moq       *MoqReader_starGenType
}

// MoqReader_starGenType_UnreadRune_anyParams isolates the any params functions
// of the Reader_starGenType type
type MoqReader_starGenType_UnreadRune_anyParams struct {
	Recorder *MoqReader_starGenType_UnreadRune_fnRecorder
}

// MoqReader_starGenType_Seek_params holds the params of the Reader_starGenType
// type
type MoqReader_starGenType_Seek_params struct {
	Offset int64
	Whence int
}

// MoqReader_starGenType_Seek_paramsKey holds the map key params of the
// Reader_starGenType type
type MoqReader_starGenType_Seek_paramsKey struct {
	Params struct {
		Offset int64
		Whence int
	}
	Hashes struct {
		Offset hash.Hash
		Whence hash.Hash
	}
}

// MoqReader_starGenType_Seek_resultsByParams contains the results for a given
// set of parameters for the Reader_starGenType type
type MoqReader_starGenType_Seek_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqReader_starGenType_Seek_paramsKey]*MoqReader_starGenType_Seek_results
}

// MoqReader_starGenType_Seek_doFn defines the type of function needed when
// calling AndDo for the Reader_starGenType type
type MoqReader_starGenType_Seek_doFn func(offset int64, whence int)

// MoqReader_starGenType_Seek_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Reader_starGenType type
type MoqReader_starGenType_Seek_doReturnFn func(offset int64, whence int) (int64, error)

// MoqReader_starGenType_Seek_results holds the results of the
// Reader_starGenType type
type MoqReader_starGenType_Seek_results struct {
	Params  MoqReader_starGenType_Seek_params
	Results []struct {
		Values *struct {
			Result1 int64
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Seek_doFn
		DoReturnFn MoqReader_starGenType_Seek_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqReader_starGenType_Seek_fnRecorder routes recorded function calls to the
// MoqReader_starGenType moq
type MoqReader_starGenType_Seek_fnRecorder struct {
	Params    MoqReader_starGenType_Seek_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqReader_starGenType_Seek_results
	Moq       *MoqReader_starGenType
}

// MoqReader_starGenType_Seek_anyParams isolates the any params functions of
// the Reader_starGenType type
type MoqReader_starGenType_Seek_anyParams struct {
	Recorder *MoqReader_starGenType_Seek_fnRecorder
}

// MoqReader_starGenType_WriteTo_params holds the params of the
// Reader_starGenType type
type MoqReader_starGenType_WriteTo_params struct{ W io.Writer }

// MoqReader_starGenType_WriteTo_paramsKey holds the map key params of the
// Reader_starGenType type
type MoqReader_starGenType_WriteTo_paramsKey struct {
	Params struct{ W io.Writer }
	Hashes struct{ W hash.Hash }
}

// MoqReader_starGenType_WriteTo_resultsByParams contains the results for a
// given set of parameters for the Reader_starGenType type
type MoqReader_starGenType_WriteTo_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqReader_starGenType_WriteTo_paramsKey]*MoqReader_starGenType_WriteTo_results
}

// MoqReader_starGenType_WriteTo_doFn defines the type of function needed when
// calling AndDo for the Reader_starGenType type
type MoqReader_starGenType_WriteTo_doFn func(w io.Writer)

// MoqReader_starGenType_WriteTo_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Reader_starGenType type
type MoqReader_starGenType_WriteTo_doReturnFn func(w io.Writer) (n int64, err error)

// MoqReader_starGenType_WriteTo_results holds the results of the
// Reader_starGenType type
type MoqReader_starGenType_WriteTo_results struct {
	Params  MoqReader_starGenType_WriteTo_params
	Results []struct {
		Values *struct {
			N   int64
			Err error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_WriteTo_doFn
		DoReturnFn MoqReader_starGenType_WriteTo_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqReader_starGenType_WriteTo_fnRecorder routes recorded function calls to
// the MoqReader_starGenType moq
type MoqReader_starGenType_WriteTo_fnRecorder struct {
	Params    MoqReader_starGenType_WriteTo_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqReader_starGenType_WriteTo_results
	Moq       *MoqReader_starGenType
}

// MoqReader_starGenType_WriteTo_anyParams isolates the any params functions of
// the Reader_starGenType type
type MoqReader_starGenType_WriteTo_anyParams struct {
	Recorder *MoqReader_starGenType_WriteTo_fnRecorder
}

// MoqReader_starGenType_Reset_params holds the params of the
// Reader_starGenType type
type MoqReader_starGenType_Reset_params struct{ B []byte }

// MoqReader_starGenType_Reset_paramsKey holds the map key params of the
// Reader_starGenType type
type MoqReader_starGenType_Reset_paramsKey struct {
	Params struct{}
	Hashes struct{ B hash.Hash }
}

// MoqReader_starGenType_Reset_resultsByParams contains the results for a given
// set of parameters for the Reader_starGenType type
type MoqReader_starGenType_Reset_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqReader_starGenType_Reset_paramsKey]*MoqReader_starGenType_Reset_results
}

// MoqReader_starGenType_Reset_doFn defines the type of function needed when
// calling AndDo for the Reader_starGenType type
type MoqReader_starGenType_Reset_doFn func(b []byte)

// MoqReader_starGenType_Reset_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Reader_starGenType type
type MoqReader_starGenType_Reset_doReturnFn func(b []byte)

// MoqReader_starGenType_Reset_results holds the results of the
// Reader_starGenType type
type MoqReader_starGenType_Reset_results struct {
	Params  MoqReader_starGenType_Reset_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Reset_doFn
		DoReturnFn MoqReader_starGenType_Reset_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqReader_starGenType_Reset_fnRecorder routes recorded function calls to the
// MoqReader_starGenType moq
type MoqReader_starGenType_Reset_fnRecorder struct {
	Params    MoqReader_starGenType_Reset_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqReader_starGenType_Reset_results
	Moq       *MoqReader_starGenType
}

// MoqReader_starGenType_Reset_anyParams isolates the any params functions of
// the Reader_starGenType type
type MoqReader_starGenType_Reset_anyParams struct {
	Recorder *MoqReader_starGenType_Reset_fnRecorder
}

// NewMoqReader_starGenType creates a new moq of the Reader_starGenType type
func NewMoqReader_starGenType(scene *moq.Scene, config *moq.Config) *MoqReader_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqReader_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqReader_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Len  struct{}
				Size struct{}
				Read struct {
					B moq.ParamIndexing
				}
				ReadAt struct {
					B   moq.ParamIndexing
					Off moq.ParamIndexing
				}
				ReadByte   struct{}
				UnreadByte struct{}
				ReadRune   struct{}
				UnreadRune struct{}
				Seek       struct {
					Offset moq.ParamIndexing
					Whence moq.ParamIndexing
				}
				WriteTo struct {
					W moq.ParamIndexing
				}
				Reset struct {
					B moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			Len  struct{}
			Size struct{}
			Read struct {
				B moq.ParamIndexing
			}
			ReadAt struct {
				B   moq.ParamIndexing
				Off moq.ParamIndexing
			}
			ReadByte   struct{}
			UnreadByte struct{}
			ReadRune   struct{}
			UnreadRune struct{}
			Seek       struct {
				Offset moq.ParamIndexing
				Whence moq.ParamIndexing
			}
			WriteTo struct {
				W moq.ParamIndexing
			}
			Reset struct {
				B moq.ParamIndexing
			}
		}{
			Len:  struct{}{},
			Size: struct{}{},
			Read: struct {
				B moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
			},
			ReadAt: struct {
				B   moq.ParamIndexing
				Off moq.ParamIndexing
			}{
				B:   moq.ParamIndexByHash,
				Off: moq.ParamIndexByValue,
			},
			ReadByte:   struct{}{},
			UnreadByte: struct{}{},
			ReadRune:   struct{}{},
			UnreadRune: struct{}{},
			Seek: struct {
				Offset moq.ParamIndexing
				Whence moq.ParamIndexing
			}{
				Offset: moq.ParamIndexByValue,
				Whence: moq.ParamIndexByValue,
			},
			WriteTo: struct {
				W moq.ParamIndexing
			}{
				W: moq.ParamIndexByHash,
			},
			Reset: struct {
				B moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Reader_starGenType type
func (m *MoqReader_starGenType) Mock() *MoqReader_starGenType_mock { return m.Moq }

func (m *MoqReader_starGenType_mock) Len() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqReader_starGenType_Len_params{}
	var results *MoqReader_starGenType_Len_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Len {
		paramsKey := m.Moq.ParamsKey_Len(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Len(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Len(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Len(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqReader_starGenType_mock) Size() (result1 int64) {
	m.Moq.Scene.T.Helper()
	params := MoqReader_starGenType_Size_params{}
	var results *MoqReader_starGenType_Size_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Size {
		paramsKey := m.Moq.ParamsKey_Size(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Size(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Size(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Size(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqReader_starGenType_mock) Read(b []byte) (n int, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqReader_starGenType_Read_params{
		B: b,
	}
	var results *MoqReader_starGenType_Read_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Read {
		paramsKey := m.Moq.ParamsKey_Read(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Read(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Read(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Read(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b)
	}

	if result.Values != nil {
		n = result.Values.N
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		n, err = result.DoReturnFn(b)
	}
	return
}

func (m *MoqReader_starGenType_mock) ReadAt(b []byte, off int64) (n int, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqReader_starGenType_ReadAt_params{
		B:   b,
		Off: off,
	}
	var results *MoqReader_starGenType_ReadAt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReadAt {
		paramsKey := m.Moq.ParamsKey_ReadAt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReadAt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReadAt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReadAt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b, off)
	}

	if result.Values != nil {
		n = result.Values.N
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		n, err = result.DoReturnFn(b, off)
	}
	return
}

func (m *MoqReader_starGenType_mock) ReadByte() (result1 byte, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqReader_starGenType_ReadByte_params{}
	var results *MoqReader_starGenType_ReadByte_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReadByte {
		paramsKey := m.Moq.ParamsKey_ReadByte(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReadByte(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReadByte(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReadByte(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqReader_starGenType_mock) UnreadByte() (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqReader_starGenType_UnreadByte_params{}
	var results *MoqReader_starGenType_UnreadByte_results
	for _, resultsByParams := range m.Moq.ResultsByParams_UnreadByte {
		paramsKey := m.Moq.ParamsKey_UnreadByte(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_UnreadByte(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_UnreadByte(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_UnreadByte(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqReader_starGenType_mock) ReadRune() (ch rune, size int, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqReader_starGenType_ReadRune_params{}
	var results *MoqReader_starGenType_ReadRune_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReadRune {
		paramsKey := m.Moq.ParamsKey_ReadRune(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReadRune(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReadRune(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReadRune(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		ch = result.Values.Ch
		size = result.Values.Size
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		ch, size, err = result.DoReturnFn()
	}
	return
}

func (m *MoqReader_starGenType_mock) UnreadRune() (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqReader_starGenType_UnreadRune_params{}
	var results *MoqReader_starGenType_UnreadRune_results
	for _, resultsByParams := range m.Moq.ResultsByParams_UnreadRune {
		paramsKey := m.Moq.ParamsKey_UnreadRune(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_UnreadRune(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_UnreadRune(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_UnreadRune(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqReader_starGenType_mock) Seek(offset int64, whence int) (result1 int64, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqReader_starGenType_Seek_params{
		Offset: offset,
		Whence: whence,
	}
	var results *MoqReader_starGenType_Seek_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Seek {
		paramsKey := m.Moq.ParamsKey_Seek(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Seek(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Seek(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Seek(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(offset, whence)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(offset, whence)
	}
	return
}

func (m *MoqReader_starGenType_mock) WriteTo(w io.Writer) (n int64, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqReader_starGenType_WriteTo_params{
		W: w,
	}
	var results *MoqReader_starGenType_WriteTo_results
	for _, resultsByParams := range m.Moq.ResultsByParams_WriteTo {
		paramsKey := m.Moq.ParamsKey_WriteTo(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_WriteTo(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_WriteTo(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_WriteTo(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(w)
	}

	if result.Values != nil {
		n = result.Values.N
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		n, err = result.DoReturnFn(w)
	}
	return
}

func (m *MoqReader_starGenType_mock) Reset(b []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqReader_starGenType_Reset_params{
		B: b,
	}
	var results *MoqReader_starGenType_Reset_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Reset {
		paramsKey := m.Moq.ParamsKey_Reset(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Reset(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Reset(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Reset(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(b)
	}
	return
}

// OnCall returns the recorder implementation of the Reader_starGenType type
func (m *MoqReader_starGenType) OnCall() *MoqReader_starGenType_recorder {
	return &MoqReader_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqReader_starGenType_recorder) Len() *MoqReader_starGenType_Len_fnRecorder {
	return &MoqReader_starGenType_Len_fnRecorder{
		Params:   MoqReader_starGenType_Len_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqReader_starGenType_Len_fnRecorder) Any() *MoqReader_starGenType_Len_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	return &MoqReader_starGenType_Len_anyParams{Recorder: r}
}

func (r *MoqReader_starGenType_Len_fnRecorder) Seq() *MoqReader_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqReader_starGenType_Len_fnRecorder) NoSeq() *MoqReader_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqReader_starGenType_Len_fnRecorder) ReturnResults(result1 int) *MoqReader_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Len_doFn
		DoReturnFn MoqReader_starGenType_Len_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqReader_starGenType_Len_fnRecorder) AndDo(fn MoqReader_starGenType_Len_doFn) *MoqReader_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqReader_starGenType_Len_fnRecorder) DoReturnResults(fn MoqReader_starGenType_Len_doReturnFn) *MoqReader_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Len_doFn
		DoReturnFn MoqReader_starGenType_Len_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqReader_starGenType_Len_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqReader_starGenType_Len_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Len {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqReader_starGenType_Len_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqReader_starGenType_Len_paramsKey]*MoqReader_starGenType_Len_results{},
		}
		r.Moq.ResultsByParams_Len = append(r.Moq.ResultsByParams_Len, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Len) {
			copy(r.Moq.ResultsByParams_Len[insertAt+1:], r.Moq.ResultsByParams_Len[insertAt:0])
			r.Moq.ResultsByParams_Len[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Len(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqReader_starGenType_Len_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqReader_starGenType_Len_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqReader_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqReader_starGenType_Len_doFn
				DoReturnFn MoqReader_starGenType_Len_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqReader_starGenType) PrettyParams_Len(params MoqReader_starGenType_Len_params) string {
	return fmt.Sprintf("Len()")
}

func (m *MoqReader_starGenType) ParamsKey_Len(params MoqReader_starGenType_Len_params, anyParams uint64) MoqReader_starGenType_Len_paramsKey {
	m.Scene.T.Helper()
	return MoqReader_starGenType_Len_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqReader_starGenType_recorder) Size() *MoqReader_starGenType_Size_fnRecorder {
	return &MoqReader_starGenType_Size_fnRecorder{
		Params:   MoqReader_starGenType_Size_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqReader_starGenType_Size_fnRecorder) Any() *MoqReader_starGenType_Size_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	return &MoqReader_starGenType_Size_anyParams{Recorder: r}
}

func (r *MoqReader_starGenType_Size_fnRecorder) Seq() *MoqReader_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqReader_starGenType_Size_fnRecorder) NoSeq() *MoqReader_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqReader_starGenType_Size_fnRecorder) ReturnResults(result1 int64) *MoqReader_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Size_doFn
		DoReturnFn MoqReader_starGenType_Size_doReturnFn
	}{
		Values: &struct {
			Result1 int64
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqReader_starGenType_Size_fnRecorder) AndDo(fn MoqReader_starGenType_Size_doFn) *MoqReader_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqReader_starGenType_Size_fnRecorder) DoReturnResults(fn MoqReader_starGenType_Size_doReturnFn) *MoqReader_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Size_doFn
		DoReturnFn MoqReader_starGenType_Size_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqReader_starGenType_Size_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqReader_starGenType_Size_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Size {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqReader_starGenType_Size_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqReader_starGenType_Size_paramsKey]*MoqReader_starGenType_Size_results{},
		}
		r.Moq.ResultsByParams_Size = append(r.Moq.ResultsByParams_Size, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Size) {
			copy(r.Moq.ResultsByParams_Size[insertAt+1:], r.Moq.ResultsByParams_Size[insertAt:0])
			r.Moq.ResultsByParams_Size[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Size(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqReader_starGenType_Size_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqReader_starGenType_Size_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqReader_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int64
				}
				Sequence   uint32
				DoFn       MoqReader_starGenType_Size_doFn
				DoReturnFn MoqReader_starGenType_Size_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqReader_starGenType) PrettyParams_Size(params MoqReader_starGenType_Size_params) string {
	return fmt.Sprintf("Size()")
}

func (m *MoqReader_starGenType) ParamsKey_Size(params MoqReader_starGenType_Size_params, anyParams uint64) MoqReader_starGenType_Size_paramsKey {
	m.Scene.T.Helper()
	return MoqReader_starGenType_Size_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqReader_starGenType_recorder) Read(b []byte) *MoqReader_starGenType_Read_fnRecorder {
	return &MoqReader_starGenType_Read_fnRecorder{
		Params: MoqReader_starGenType_Read_params{
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqReader_starGenType_Read_fnRecorder) Any() *MoqReader_starGenType_Read_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Read(r.Params))
		return nil
	}
	return &MoqReader_starGenType_Read_anyParams{Recorder: r}
}

func (a *MoqReader_starGenType_Read_anyParams) B() *MoqReader_starGenType_Read_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqReader_starGenType_Read_fnRecorder) Seq() *MoqReader_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Read(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqReader_starGenType_Read_fnRecorder) NoSeq() *MoqReader_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Read(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqReader_starGenType_Read_fnRecorder) ReturnResults(n int, err error) *MoqReader_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Read_doFn
		DoReturnFn MoqReader_starGenType_Read_doReturnFn
	}{
		Values: &struct {
			N   int
			Err error
		}{
			N:   n,
			Err: err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqReader_starGenType_Read_fnRecorder) AndDo(fn MoqReader_starGenType_Read_doFn) *MoqReader_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqReader_starGenType_Read_fnRecorder) DoReturnResults(fn MoqReader_starGenType_Read_doReturnFn) *MoqReader_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Read_doFn
		DoReturnFn MoqReader_starGenType_Read_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqReader_starGenType_Read_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqReader_starGenType_Read_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Read {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqReader_starGenType_Read_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqReader_starGenType_Read_paramsKey]*MoqReader_starGenType_Read_results{},
		}
		r.Moq.ResultsByParams_Read = append(r.Moq.ResultsByParams_Read, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Read) {
			copy(r.Moq.ResultsByParams_Read[insertAt+1:], r.Moq.ResultsByParams_Read[insertAt:0])
			r.Moq.ResultsByParams_Read[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Read(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqReader_starGenType_Read_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqReader_starGenType_Read_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqReader_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					N   int
					Err error
				}
				Sequence   uint32
				DoFn       MoqReader_starGenType_Read_doFn
				DoReturnFn MoqReader_starGenType_Read_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqReader_starGenType) PrettyParams_Read(params MoqReader_starGenType_Read_params) string {
	return fmt.Sprintf("Read(%#v)", params.B)
}

func (m *MoqReader_starGenType) ParamsKey_Read(params MoqReader_starGenType_Read_params, anyParams uint64) MoqReader_starGenType_Read_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Read.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the Read function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	return MoqReader_starGenType_Read_paramsKey{
		Params: struct{}{},
		Hashes: struct{ B hash.Hash }{
			B: bUsedHash,
		},
	}
}

func (m *MoqReader_starGenType_recorder) ReadAt(b []byte, off int64) *MoqReader_starGenType_ReadAt_fnRecorder {
	return &MoqReader_starGenType_ReadAt_fnRecorder{
		Params: MoqReader_starGenType_ReadAt_params{
			B:   b,
			Off: off,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqReader_starGenType_ReadAt_fnRecorder) Any() *MoqReader_starGenType_ReadAt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadAt(r.Params))
		return nil
	}
	return &MoqReader_starGenType_ReadAt_anyParams{Recorder: r}
}

func (a *MoqReader_starGenType_ReadAt_anyParams) B() *MoqReader_starGenType_ReadAt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqReader_starGenType_ReadAt_anyParams) Off() *MoqReader_starGenType_ReadAt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqReader_starGenType_ReadAt_fnRecorder) Seq() *MoqReader_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadAt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqReader_starGenType_ReadAt_fnRecorder) NoSeq() *MoqReader_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadAt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqReader_starGenType_ReadAt_fnRecorder) ReturnResults(n int, err error) *MoqReader_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_ReadAt_doFn
		DoReturnFn MoqReader_starGenType_ReadAt_doReturnFn
	}{
		Values: &struct {
			N   int
			Err error
		}{
			N:   n,
			Err: err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqReader_starGenType_ReadAt_fnRecorder) AndDo(fn MoqReader_starGenType_ReadAt_doFn) *MoqReader_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqReader_starGenType_ReadAt_fnRecorder) DoReturnResults(fn MoqReader_starGenType_ReadAt_doReturnFn) *MoqReader_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_ReadAt_doFn
		DoReturnFn MoqReader_starGenType_ReadAt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqReader_starGenType_ReadAt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqReader_starGenType_ReadAt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReadAt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqReader_starGenType_ReadAt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqReader_starGenType_ReadAt_paramsKey]*MoqReader_starGenType_ReadAt_results{},
		}
		r.Moq.ResultsByParams_ReadAt = append(r.Moq.ResultsByParams_ReadAt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReadAt) {
			copy(r.Moq.ResultsByParams_ReadAt[insertAt+1:], r.Moq.ResultsByParams_ReadAt[insertAt:0])
			r.Moq.ResultsByParams_ReadAt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReadAt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqReader_starGenType_ReadAt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqReader_starGenType_ReadAt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqReader_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					N   int
					Err error
				}
				Sequence   uint32
				DoFn       MoqReader_starGenType_ReadAt_doFn
				DoReturnFn MoqReader_starGenType_ReadAt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqReader_starGenType) PrettyParams_ReadAt(params MoqReader_starGenType_ReadAt_params) string {
	return fmt.Sprintf("ReadAt(%#v, %#v)", params.B, params.Off)
}

func (m *MoqReader_starGenType) ParamsKey_ReadAt(params MoqReader_starGenType_ReadAt_params, anyParams uint64) MoqReader_starGenType_ReadAt_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ReadAt.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the ReadAt function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	var offUsed int64
	var offUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ReadAt.Off == moq.ParamIndexByValue {
			offUsed = params.Off
		} else {
			offUsedHash = hash.DeepHash(params.Off)
		}
	}
	return MoqReader_starGenType_ReadAt_paramsKey{
		Params: struct{ Off int64 }{
			Off: offUsed,
		},
		Hashes: struct {
			B   hash.Hash
			Off hash.Hash
		}{
			B:   bUsedHash,
			Off: offUsedHash,
		},
	}
}

func (m *MoqReader_starGenType_recorder) ReadByte() *MoqReader_starGenType_ReadByte_fnRecorder {
	return &MoqReader_starGenType_ReadByte_fnRecorder{
		Params:   MoqReader_starGenType_ReadByte_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqReader_starGenType_ReadByte_fnRecorder) Any() *MoqReader_starGenType_ReadByte_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadByte(r.Params))
		return nil
	}
	return &MoqReader_starGenType_ReadByte_anyParams{Recorder: r}
}

func (r *MoqReader_starGenType_ReadByte_fnRecorder) Seq() *MoqReader_starGenType_ReadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadByte(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqReader_starGenType_ReadByte_fnRecorder) NoSeq() *MoqReader_starGenType_ReadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadByte(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqReader_starGenType_ReadByte_fnRecorder) ReturnResults(result1 byte, result2 error) *MoqReader_starGenType_ReadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_ReadByte_doFn
		DoReturnFn MoqReader_starGenType_ReadByte_doReturnFn
	}{
		Values: &struct {
			Result1 byte
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqReader_starGenType_ReadByte_fnRecorder) AndDo(fn MoqReader_starGenType_ReadByte_doFn) *MoqReader_starGenType_ReadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqReader_starGenType_ReadByte_fnRecorder) DoReturnResults(fn MoqReader_starGenType_ReadByte_doReturnFn) *MoqReader_starGenType_ReadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_ReadByte_doFn
		DoReturnFn MoqReader_starGenType_ReadByte_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqReader_starGenType_ReadByte_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqReader_starGenType_ReadByte_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReadByte {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqReader_starGenType_ReadByte_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqReader_starGenType_ReadByte_paramsKey]*MoqReader_starGenType_ReadByte_results{},
		}
		r.Moq.ResultsByParams_ReadByte = append(r.Moq.ResultsByParams_ReadByte, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReadByte) {
			copy(r.Moq.ResultsByParams_ReadByte[insertAt+1:], r.Moq.ResultsByParams_ReadByte[insertAt:0])
			r.Moq.ResultsByParams_ReadByte[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReadByte(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqReader_starGenType_ReadByte_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqReader_starGenType_ReadByte_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqReader_starGenType_ReadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 byte
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqReader_starGenType_ReadByte_doFn
				DoReturnFn MoqReader_starGenType_ReadByte_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqReader_starGenType) PrettyParams_ReadByte(params MoqReader_starGenType_ReadByte_params) string {
	return fmt.Sprintf("ReadByte()")
}

func (m *MoqReader_starGenType) ParamsKey_ReadByte(params MoqReader_starGenType_ReadByte_params, anyParams uint64) MoqReader_starGenType_ReadByte_paramsKey {
	m.Scene.T.Helper()
	return MoqReader_starGenType_ReadByte_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqReader_starGenType_recorder) UnreadByte() *MoqReader_starGenType_UnreadByte_fnRecorder {
	return &MoqReader_starGenType_UnreadByte_fnRecorder{
		Params:   MoqReader_starGenType_UnreadByte_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqReader_starGenType_UnreadByte_fnRecorder) Any() *MoqReader_starGenType_UnreadByte_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnreadByte(r.Params))
		return nil
	}
	return &MoqReader_starGenType_UnreadByte_anyParams{Recorder: r}
}

func (r *MoqReader_starGenType_UnreadByte_fnRecorder) Seq() *MoqReader_starGenType_UnreadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnreadByte(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqReader_starGenType_UnreadByte_fnRecorder) NoSeq() *MoqReader_starGenType_UnreadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnreadByte(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqReader_starGenType_UnreadByte_fnRecorder) ReturnResults(result1 error) *MoqReader_starGenType_UnreadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_UnreadByte_doFn
		DoReturnFn MoqReader_starGenType_UnreadByte_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqReader_starGenType_UnreadByte_fnRecorder) AndDo(fn MoqReader_starGenType_UnreadByte_doFn) *MoqReader_starGenType_UnreadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqReader_starGenType_UnreadByte_fnRecorder) DoReturnResults(fn MoqReader_starGenType_UnreadByte_doReturnFn) *MoqReader_starGenType_UnreadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_UnreadByte_doFn
		DoReturnFn MoqReader_starGenType_UnreadByte_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqReader_starGenType_UnreadByte_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqReader_starGenType_UnreadByte_resultsByParams
	for n, res := range r.Moq.ResultsByParams_UnreadByte {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqReader_starGenType_UnreadByte_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqReader_starGenType_UnreadByte_paramsKey]*MoqReader_starGenType_UnreadByte_results{},
		}
		r.Moq.ResultsByParams_UnreadByte = append(r.Moq.ResultsByParams_UnreadByte, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_UnreadByte) {
			copy(r.Moq.ResultsByParams_UnreadByte[insertAt+1:], r.Moq.ResultsByParams_UnreadByte[insertAt:0])
			r.Moq.ResultsByParams_UnreadByte[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_UnreadByte(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqReader_starGenType_UnreadByte_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqReader_starGenType_UnreadByte_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqReader_starGenType_UnreadByte_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqReader_starGenType_UnreadByte_doFn
				DoReturnFn MoqReader_starGenType_UnreadByte_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqReader_starGenType) PrettyParams_UnreadByte(params MoqReader_starGenType_UnreadByte_params) string {
	return fmt.Sprintf("UnreadByte()")
}

func (m *MoqReader_starGenType) ParamsKey_UnreadByte(params MoqReader_starGenType_UnreadByte_params, anyParams uint64) MoqReader_starGenType_UnreadByte_paramsKey {
	m.Scene.T.Helper()
	return MoqReader_starGenType_UnreadByte_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqReader_starGenType_recorder) ReadRune() *MoqReader_starGenType_ReadRune_fnRecorder {
	return &MoqReader_starGenType_ReadRune_fnRecorder{
		Params:   MoqReader_starGenType_ReadRune_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqReader_starGenType_ReadRune_fnRecorder) Any() *MoqReader_starGenType_ReadRune_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadRune(r.Params))
		return nil
	}
	return &MoqReader_starGenType_ReadRune_anyParams{Recorder: r}
}

func (r *MoqReader_starGenType_ReadRune_fnRecorder) Seq() *MoqReader_starGenType_ReadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadRune(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqReader_starGenType_ReadRune_fnRecorder) NoSeq() *MoqReader_starGenType_ReadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadRune(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqReader_starGenType_ReadRune_fnRecorder) ReturnResults(ch rune, size int, err error) *MoqReader_starGenType_ReadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Ch   rune
			Size int
			Err  error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_ReadRune_doFn
		DoReturnFn MoqReader_starGenType_ReadRune_doReturnFn
	}{
		Values: &struct {
			Ch   rune
			Size int
			Err  error
		}{
			Ch:   ch,
			Size: size,
			Err:  err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqReader_starGenType_ReadRune_fnRecorder) AndDo(fn MoqReader_starGenType_ReadRune_doFn) *MoqReader_starGenType_ReadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqReader_starGenType_ReadRune_fnRecorder) DoReturnResults(fn MoqReader_starGenType_ReadRune_doReturnFn) *MoqReader_starGenType_ReadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Ch   rune
			Size int
			Err  error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_ReadRune_doFn
		DoReturnFn MoqReader_starGenType_ReadRune_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqReader_starGenType_ReadRune_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqReader_starGenType_ReadRune_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReadRune {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqReader_starGenType_ReadRune_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqReader_starGenType_ReadRune_paramsKey]*MoqReader_starGenType_ReadRune_results{},
		}
		r.Moq.ResultsByParams_ReadRune = append(r.Moq.ResultsByParams_ReadRune, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReadRune) {
			copy(r.Moq.ResultsByParams_ReadRune[insertAt+1:], r.Moq.ResultsByParams_ReadRune[insertAt:0])
			r.Moq.ResultsByParams_ReadRune[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReadRune(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqReader_starGenType_ReadRune_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqReader_starGenType_ReadRune_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqReader_starGenType_ReadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Ch   rune
					Size int
					Err  error
				}
				Sequence   uint32
				DoFn       MoqReader_starGenType_ReadRune_doFn
				DoReturnFn MoqReader_starGenType_ReadRune_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqReader_starGenType) PrettyParams_ReadRune(params MoqReader_starGenType_ReadRune_params) string {
	return fmt.Sprintf("ReadRune()")
}

func (m *MoqReader_starGenType) ParamsKey_ReadRune(params MoqReader_starGenType_ReadRune_params, anyParams uint64) MoqReader_starGenType_ReadRune_paramsKey {
	m.Scene.T.Helper()
	return MoqReader_starGenType_ReadRune_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqReader_starGenType_recorder) UnreadRune() *MoqReader_starGenType_UnreadRune_fnRecorder {
	return &MoqReader_starGenType_UnreadRune_fnRecorder{
		Params:   MoqReader_starGenType_UnreadRune_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqReader_starGenType_UnreadRune_fnRecorder) Any() *MoqReader_starGenType_UnreadRune_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnreadRune(r.Params))
		return nil
	}
	return &MoqReader_starGenType_UnreadRune_anyParams{Recorder: r}
}

func (r *MoqReader_starGenType_UnreadRune_fnRecorder) Seq() *MoqReader_starGenType_UnreadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnreadRune(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqReader_starGenType_UnreadRune_fnRecorder) NoSeq() *MoqReader_starGenType_UnreadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnreadRune(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqReader_starGenType_UnreadRune_fnRecorder) ReturnResults(result1 error) *MoqReader_starGenType_UnreadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_UnreadRune_doFn
		DoReturnFn MoqReader_starGenType_UnreadRune_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqReader_starGenType_UnreadRune_fnRecorder) AndDo(fn MoqReader_starGenType_UnreadRune_doFn) *MoqReader_starGenType_UnreadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqReader_starGenType_UnreadRune_fnRecorder) DoReturnResults(fn MoqReader_starGenType_UnreadRune_doReturnFn) *MoqReader_starGenType_UnreadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_UnreadRune_doFn
		DoReturnFn MoqReader_starGenType_UnreadRune_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqReader_starGenType_UnreadRune_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqReader_starGenType_UnreadRune_resultsByParams
	for n, res := range r.Moq.ResultsByParams_UnreadRune {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqReader_starGenType_UnreadRune_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqReader_starGenType_UnreadRune_paramsKey]*MoqReader_starGenType_UnreadRune_results{},
		}
		r.Moq.ResultsByParams_UnreadRune = append(r.Moq.ResultsByParams_UnreadRune, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_UnreadRune) {
			copy(r.Moq.ResultsByParams_UnreadRune[insertAt+1:], r.Moq.ResultsByParams_UnreadRune[insertAt:0])
			r.Moq.ResultsByParams_UnreadRune[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_UnreadRune(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqReader_starGenType_UnreadRune_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqReader_starGenType_UnreadRune_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqReader_starGenType_UnreadRune_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqReader_starGenType_UnreadRune_doFn
				DoReturnFn MoqReader_starGenType_UnreadRune_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqReader_starGenType) PrettyParams_UnreadRune(params MoqReader_starGenType_UnreadRune_params) string {
	return fmt.Sprintf("UnreadRune()")
}

func (m *MoqReader_starGenType) ParamsKey_UnreadRune(params MoqReader_starGenType_UnreadRune_params, anyParams uint64) MoqReader_starGenType_UnreadRune_paramsKey {
	m.Scene.T.Helper()
	return MoqReader_starGenType_UnreadRune_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqReader_starGenType_recorder) Seek(offset int64, whence int) *MoqReader_starGenType_Seek_fnRecorder {
	return &MoqReader_starGenType_Seek_fnRecorder{
		Params: MoqReader_starGenType_Seek_params{
			Offset: offset,
			Whence: whence,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqReader_starGenType_Seek_fnRecorder) Any() *MoqReader_starGenType_Seek_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Seek(r.Params))
		return nil
	}
	return &MoqReader_starGenType_Seek_anyParams{Recorder: r}
}

func (a *MoqReader_starGenType_Seek_anyParams) Offset() *MoqReader_starGenType_Seek_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqReader_starGenType_Seek_anyParams) Whence() *MoqReader_starGenType_Seek_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqReader_starGenType_Seek_fnRecorder) Seq() *MoqReader_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Seek(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqReader_starGenType_Seek_fnRecorder) NoSeq() *MoqReader_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Seek(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqReader_starGenType_Seek_fnRecorder) ReturnResults(result1 int64, result2 error) *MoqReader_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Seek_doFn
		DoReturnFn MoqReader_starGenType_Seek_doReturnFn
	}{
		Values: &struct {
			Result1 int64
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqReader_starGenType_Seek_fnRecorder) AndDo(fn MoqReader_starGenType_Seek_doFn) *MoqReader_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqReader_starGenType_Seek_fnRecorder) DoReturnResults(fn MoqReader_starGenType_Seek_doReturnFn) *MoqReader_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Seek_doFn
		DoReturnFn MoqReader_starGenType_Seek_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqReader_starGenType_Seek_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqReader_starGenType_Seek_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Seek {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqReader_starGenType_Seek_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqReader_starGenType_Seek_paramsKey]*MoqReader_starGenType_Seek_results{},
		}
		r.Moq.ResultsByParams_Seek = append(r.Moq.ResultsByParams_Seek, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Seek) {
			copy(r.Moq.ResultsByParams_Seek[insertAt+1:], r.Moq.ResultsByParams_Seek[insertAt:0])
			r.Moq.ResultsByParams_Seek[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Seek(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqReader_starGenType_Seek_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqReader_starGenType_Seek_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqReader_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int64
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqReader_starGenType_Seek_doFn
				DoReturnFn MoqReader_starGenType_Seek_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqReader_starGenType) PrettyParams_Seek(params MoqReader_starGenType_Seek_params) string {
	return fmt.Sprintf("Seek(%#v, %#v)", params.Offset, params.Whence)
}

func (m *MoqReader_starGenType) ParamsKey_Seek(params MoqReader_starGenType_Seek_params, anyParams uint64) MoqReader_starGenType_Seek_paramsKey {
	m.Scene.T.Helper()
	var offsetUsed int64
	var offsetUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Seek.Offset == moq.ParamIndexByValue {
			offsetUsed = params.Offset
		} else {
			offsetUsedHash = hash.DeepHash(params.Offset)
		}
	}
	var whenceUsed int
	var whenceUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Seek.Whence == moq.ParamIndexByValue {
			whenceUsed = params.Whence
		} else {
			whenceUsedHash = hash.DeepHash(params.Whence)
		}
	}
	return MoqReader_starGenType_Seek_paramsKey{
		Params: struct {
			Offset int64
			Whence int
		}{
			Offset: offsetUsed,
			Whence: whenceUsed,
		},
		Hashes: struct {
			Offset hash.Hash
			Whence hash.Hash
		}{
			Offset: offsetUsedHash,
			Whence: whenceUsedHash,
		},
	}
}

func (m *MoqReader_starGenType_recorder) WriteTo(w io.Writer) *MoqReader_starGenType_WriteTo_fnRecorder {
	return &MoqReader_starGenType_WriteTo_fnRecorder{
		Params: MoqReader_starGenType_WriteTo_params{
			W: w,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqReader_starGenType_WriteTo_fnRecorder) Any() *MoqReader_starGenType_WriteTo_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteTo(r.Params))
		return nil
	}
	return &MoqReader_starGenType_WriteTo_anyParams{Recorder: r}
}

func (a *MoqReader_starGenType_WriteTo_anyParams) W() *MoqReader_starGenType_WriteTo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqReader_starGenType_WriteTo_fnRecorder) Seq() *MoqReader_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteTo(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqReader_starGenType_WriteTo_fnRecorder) NoSeq() *MoqReader_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteTo(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqReader_starGenType_WriteTo_fnRecorder) ReturnResults(n int64, err error) *MoqReader_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int64
			Err error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_WriteTo_doFn
		DoReturnFn MoqReader_starGenType_WriteTo_doReturnFn
	}{
		Values: &struct {
			N   int64
			Err error
		}{
			N:   n,
			Err: err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqReader_starGenType_WriteTo_fnRecorder) AndDo(fn MoqReader_starGenType_WriteTo_doFn) *MoqReader_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqReader_starGenType_WriteTo_fnRecorder) DoReturnResults(fn MoqReader_starGenType_WriteTo_doReturnFn) *MoqReader_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int64
			Err error
		}
		Sequence   uint32
		DoFn       MoqReader_starGenType_WriteTo_doFn
		DoReturnFn MoqReader_starGenType_WriteTo_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqReader_starGenType_WriteTo_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqReader_starGenType_WriteTo_resultsByParams
	for n, res := range r.Moq.ResultsByParams_WriteTo {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqReader_starGenType_WriteTo_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqReader_starGenType_WriteTo_paramsKey]*MoqReader_starGenType_WriteTo_results{},
		}
		r.Moq.ResultsByParams_WriteTo = append(r.Moq.ResultsByParams_WriteTo, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_WriteTo) {
			copy(r.Moq.ResultsByParams_WriteTo[insertAt+1:], r.Moq.ResultsByParams_WriteTo[insertAt:0])
			r.Moq.ResultsByParams_WriteTo[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_WriteTo(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqReader_starGenType_WriteTo_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqReader_starGenType_WriteTo_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqReader_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					N   int64
					Err error
				}
				Sequence   uint32
				DoFn       MoqReader_starGenType_WriteTo_doFn
				DoReturnFn MoqReader_starGenType_WriteTo_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqReader_starGenType) PrettyParams_WriteTo(params MoqReader_starGenType_WriteTo_params) string {
	return fmt.Sprintf("WriteTo(%#v)", params.W)
}

func (m *MoqReader_starGenType) ParamsKey_WriteTo(params MoqReader_starGenType_WriteTo_params, anyParams uint64) MoqReader_starGenType_WriteTo_paramsKey {
	m.Scene.T.Helper()
	var wUsed io.Writer
	var wUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.WriteTo.W == moq.ParamIndexByValue {
			wUsed = params.W
		} else {
			wUsedHash = hash.DeepHash(params.W)
		}
	}
	return MoqReader_starGenType_WriteTo_paramsKey{
		Params: struct{ W io.Writer }{
			W: wUsed,
		},
		Hashes: struct{ W hash.Hash }{
			W: wUsedHash,
		},
	}
}

func (m *MoqReader_starGenType_recorder) Reset(b []byte) *MoqReader_starGenType_Reset_fnRecorder {
	return &MoqReader_starGenType_Reset_fnRecorder{
		Params: MoqReader_starGenType_Reset_params{
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqReader_starGenType_Reset_fnRecorder) Any() *MoqReader_starGenType_Reset_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Reset(r.Params))
		return nil
	}
	return &MoqReader_starGenType_Reset_anyParams{Recorder: r}
}

func (a *MoqReader_starGenType_Reset_anyParams) B() *MoqReader_starGenType_Reset_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqReader_starGenType_Reset_fnRecorder) Seq() *MoqReader_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Reset(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqReader_starGenType_Reset_fnRecorder) NoSeq() *MoqReader_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Reset(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqReader_starGenType_Reset_fnRecorder) ReturnResults() *MoqReader_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Reset_doFn
		DoReturnFn MoqReader_starGenType_Reset_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqReader_starGenType_Reset_fnRecorder) AndDo(fn MoqReader_starGenType_Reset_doFn) *MoqReader_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqReader_starGenType_Reset_fnRecorder) DoReturnResults(fn MoqReader_starGenType_Reset_doReturnFn) *MoqReader_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqReader_starGenType_Reset_doFn
		DoReturnFn MoqReader_starGenType_Reset_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqReader_starGenType_Reset_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqReader_starGenType_Reset_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Reset {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqReader_starGenType_Reset_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqReader_starGenType_Reset_paramsKey]*MoqReader_starGenType_Reset_results{},
		}
		r.Moq.ResultsByParams_Reset = append(r.Moq.ResultsByParams_Reset, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Reset) {
			copy(r.Moq.ResultsByParams_Reset[insertAt+1:], r.Moq.ResultsByParams_Reset[insertAt:0])
			r.Moq.ResultsByParams_Reset[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Reset(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqReader_starGenType_Reset_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqReader_starGenType_Reset_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqReader_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqReader_starGenType_Reset_doFn
				DoReturnFn MoqReader_starGenType_Reset_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqReader_starGenType) PrettyParams_Reset(params MoqReader_starGenType_Reset_params) string {
	return fmt.Sprintf("Reset(%#v)", params.B)
}

func (m *MoqReader_starGenType) ParamsKey_Reset(params MoqReader_starGenType_Reset_params, anyParams uint64) MoqReader_starGenType_Reset_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Reset.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the Reset function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	return MoqReader_starGenType_Reset_paramsKey{
		Params: struct{}{},
		Hashes: struct{ B hash.Hash }{
			B: bUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqReader_starGenType) Reset() {
	m.ResultsByParams_Len = nil
	m.ResultsByParams_Size = nil
	m.ResultsByParams_Read = nil
	m.ResultsByParams_ReadAt = nil
	m.ResultsByParams_ReadByte = nil
	m.ResultsByParams_UnreadByte = nil
	m.ResultsByParams_ReadRune = nil
	m.ResultsByParams_UnreadRune = nil
	m.ResultsByParams_Seek = nil
	m.ResultsByParams_WriteTo = nil
	m.ResultsByParams_Reset = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqReader_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Len {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Len(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Size {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Size(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Read {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Read(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReadAt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReadAt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReadByte {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReadByte(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_UnreadByte {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_UnreadByte(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReadRune {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReadRune(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_UnreadRune {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_UnreadRune(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Seek {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Seek(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_WriteTo {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_WriteTo(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Reset {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Reset(results.Params))
			}
		}
	}
}
