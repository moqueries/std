// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package log

import (
	"fmt"
	"io"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that log.Logger_starGenType is mocked
// completely
var _ Logger_starGenType = (*MoqLogger_starGenType_mock)(nil)

// Logger_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Logger_starGenType interface {
	SetOutput(w io.Writer)
	Output(calldepth int, s string) error
	Printf(format string, v ...interface{})
	Print(v ...interface{})
	Println(v ...interface{})
	Fatal(v ...interface{})
	Fatalf(format string, v ...interface{})
	Fatalln(v ...interface{})
	Panic(v ...interface{})
	Panicf(format string, v ...interface{})
	Panicln(v ...interface{})
	Flags() int
	SetFlags(flag int)
	Prefix() string
	SetPrefix(prefix string)
	Writer() io.Writer
}

// MoqLogger_starGenType holds the state of a moq of the Logger_starGenType
// type
type MoqLogger_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqLogger_starGenType_mock

	ResultsByParams_SetOutput []MoqLogger_starGenType_SetOutput_resultsByParams
	ResultsByParams_Output    []MoqLogger_starGenType_Output_resultsByParams
	ResultsByParams_Printf    []MoqLogger_starGenType_Printf_resultsByParams
	ResultsByParams_Print     []MoqLogger_starGenType_Print_resultsByParams
	ResultsByParams_Println   []MoqLogger_starGenType_Println_resultsByParams
	ResultsByParams_Fatal     []MoqLogger_starGenType_Fatal_resultsByParams
	ResultsByParams_Fatalf    []MoqLogger_starGenType_Fatalf_resultsByParams
	ResultsByParams_Fatalln   []MoqLogger_starGenType_Fatalln_resultsByParams
	ResultsByParams_Panic     []MoqLogger_starGenType_Panic_resultsByParams
	ResultsByParams_Panicf    []MoqLogger_starGenType_Panicf_resultsByParams
	ResultsByParams_Panicln   []MoqLogger_starGenType_Panicln_resultsByParams
	ResultsByParams_Flags     []MoqLogger_starGenType_Flags_resultsByParams
	ResultsByParams_SetFlags  []MoqLogger_starGenType_SetFlags_resultsByParams
	ResultsByParams_Prefix    []MoqLogger_starGenType_Prefix_resultsByParams
	ResultsByParams_SetPrefix []MoqLogger_starGenType_SetPrefix_resultsByParams
	ResultsByParams_Writer    []MoqLogger_starGenType_Writer_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			SetOutput struct {
				W moq.ParamIndexing
			}
			Output struct {
				Calldepth moq.ParamIndexing
				S         moq.ParamIndexing
			}
			Printf struct {
				Format moq.ParamIndexing
				V      moq.ParamIndexing
			}
			Print struct {
				V moq.ParamIndexing
			}
			Println struct {
				V moq.ParamIndexing
			}
			Fatal struct {
				V moq.ParamIndexing
			}
			Fatalf struct {
				Format moq.ParamIndexing
				V      moq.ParamIndexing
			}
			Fatalln struct {
				V moq.ParamIndexing
			}
			Panic struct {
				V moq.ParamIndexing
			}
			Panicf struct {
				Format moq.ParamIndexing
				V      moq.ParamIndexing
			}
			Panicln struct {
				V moq.ParamIndexing
			}
			Flags    struct{}
			SetFlags struct {
				Flag moq.ParamIndexing
			}
			Prefix    struct{}
			SetPrefix struct {
				Prefix moq.ParamIndexing
			}
			Writer struct{}
		}
	}
}

// MoqLogger_starGenType_mock isolates the mock interface of the
// Logger_starGenType type
type MoqLogger_starGenType_mock struct {
	Moq *MoqLogger_starGenType
}

// MoqLogger_starGenType_recorder isolates the recorder interface of the
// Logger_starGenType type
type MoqLogger_starGenType_recorder struct {
	Moq *MoqLogger_starGenType
}

// MoqLogger_starGenType_SetOutput_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_SetOutput_params struct{ W io.Writer }

// MoqLogger_starGenType_SetOutput_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_SetOutput_paramsKey struct {
	Params struct{ W io.Writer }
	Hashes struct{ W hash.Hash }
}

// MoqLogger_starGenType_SetOutput_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_SetOutput_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_SetOutput_paramsKey]*MoqLogger_starGenType_SetOutput_results
}

// MoqLogger_starGenType_SetOutput_doFn defines the type of function needed
// when calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_SetOutput_doFn func(w io.Writer)

// MoqLogger_starGenType_SetOutput_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_SetOutput_doReturnFn func(w io.Writer)

// MoqLogger_starGenType_SetOutput_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_SetOutput_results struct {
	Params  MoqLogger_starGenType_SetOutput_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_SetOutput_doFn
		DoReturnFn MoqLogger_starGenType_SetOutput_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_SetOutput_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_SetOutput_fnRecorder struct {
	Params    MoqLogger_starGenType_SetOutput_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_SetOutput_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_SetOutput_anyParams isolates the any params functions
// of the Logger_starGenType type
type MoqLogger_starGenType_SetOutput_anyParams struct {
	Recorder *MoqLogger_starGenType_SetOutput_fnRecorder
}

// MoqLogger_starGenType_Output_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Output_params struct {
	Calldepth int
	S         string
}

// MoqLogger_starGenType_Output_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Output_paramsKey struct {
	Params struct {
		Calldepth int
		S         string
	}
	Hashes struct {
		Calldepth hash.Hash
		S         hash.Hash
	}
}

// MoqLogger_starGenType_Output_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Output_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Output_paramsKey]*MoqLogger_starGenType_Output_results
}

// MoqLogger_starGenType_Output_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Output_doFn func(calldepth int, s string)

// MoqLogger_starGenType_Output_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Output_doReturnFn func(calldepth int, s string) error

// MoqLogger_starGenType_Output_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Output_results struct {
	Params  MoqLogger_starGenType_Output_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Output_doFn
		DoReturnFn MoqLogger_starGenType_Output_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Output_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_Output_fnRecorder struct {
	Params    MoqLogger_starGenType_Output_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Output_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Output_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Output_anyParams struct {
	Recorder *MoqLogger_starGenType_Output_fnRecorder
}

// MoqLogger_starGenType_Printf_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Printf_params struct {
	Format string
	V      []interface{}
}

// MoqLogger_starGenType_Printf_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Printf_paramsKey struct {
	Params struct{ Format string }
	Hashes struct {
		Format hash.Hash
		V      hash.Hash
	}
}

// MoqLogger_starGenType_Printf_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Printf_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Printf_paramsKey]*MoqLogger_starGenType_Printf_results
}

// MoqLogger_starGenType_Printf_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Printf_doFn func(format string, v ...interface{})

// MoqLogger_starGenType_Printf_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Printf_doReturnFn func(format string, v ...interface{})

// MoqLogger_starGenType_Printf_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Printf_results struct {
	Params  MoqLogger_starGenType_Printf_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Printf_doFn
		DoReturnFn MoqLogger_starGenType_Printf_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Printf_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_Printf_fnRecorder struct {
	Params    MoqLogger_starGenType_Printf_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Printf_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Printf_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Printf_anyParams struct {
	Recorder *MoqLogger_starGenType_Printf_fnRecorder
}

// MoqLogger_starGenType_Print_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Print_params struct{ V []interface{} }

// MoqLogger_starGenType_Print_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Print_paramsKey struct {
	Params struct{}
	Hashes struct{ V hash.Hash }
}

// MoqLogger_starGenType_Print_resultsByParams contains the results for a given
// set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Print_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Print_paramsKey]*MoqLogger_starGenType_Print_results
}

// MoqLogger_starGenType_Print_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Print_doFn func(v ...interface{})

// MoqLogger_starGenType_Print_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Print_doReturnFn func(v ...interface{})

// MoqLogger_starGenType_Print_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Print_results struct {
	Params  MoqLogger_starGenType_Print_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Print_doFn
		DoReturnFn MoqLogger_starGenType_Print_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Print_fnRecorder routes recorded function calls to the
// MoqLogger_starGenType moq
type MoqLogger_starGenType_Print_fnRecorder struct {
	Params    MoqLogger_starGenType_Print_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Print_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Print_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Print_anyParams struct {
	Recorder *MoqLogger_starGenType_Print_fnRecorder
}

// MoqLogger_starGenType_Println_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Println_params struct{ V []interface{} }

// MoqLogger_starGenType_Println_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Println_paramsKey struct {
	Params struct{}
	Hashes struct{ V hash.Hash }
}

// MoqLogger_starGenType_Println_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Println_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Println_paramsKey]*MoqLogger_starGenType_Println_results
}

// MoqLogger_starGenType_Println_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Println_doFn func(v ...interface{})

// MoqLogger_starGenType_Println_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Println_doReturnFn func(v ...interface{})

// MoqLogger_starGenType_Println_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Println_results struct {
	Params  MoqLogger_starGenType_Println_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Println_doFn
		DoReturnFn MoqLogger_starGenType_Println_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Println_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_Println_fnRecorder struct {
	Params    MoqLogger_starGenType_Println_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Println_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Println_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Println_anyParams struct {
	Recorder *MoqLogger_starGenType_Println_fnRecorder
}

// MoqLogger_starGenType_Fatal_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Fatal_params struct{ V []interface{} }

// MoqLogger_starGenType_Fatal_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Fatal_paramsKey struct {
	Params struct{}
	Hashes struct{ V hash.Hash }
}

// MoqLogger_starGenType_Fatal_resultsByParams contains the results for a given
// set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Fatal_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Fatal_paramsKey]*MoqLogger_starGenType_Fatal_results
}

// MoqLogger_starGenType_Fatal_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Fatal_doFn func(v ...interface{})

// MoqLogger_starGenType_Fatal_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Fatal_doReturnFn func(v ...interface{})

// MoqLogger_starGenType_Fatal_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Fatal_results struct {
	Params  MoqLogger_starGenType_Fatal_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Fatal_doFn
		DoReturnFn MoqLogger_starGenType_Fatal_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Fatal_fnRecorder routes recorded function calls to the
// MoqLogger_starGenType moq
type MoqLogger_starGenType_Fatal_fnRecorder struct {
	Params    MoqLogger_starGenType_Fatal_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Fatal_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Fatal_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Fatal_anyParams struct {
	Recorder *MoqLogger_starGenType_Fatal_fnRecorder
}

// MoqLogger_starGenType_Fatalf_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Fatalf_params struct {
	Format string
	V      []interface{}
}

// MoqLogger_starGenType_Fatalf_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Fatalf_paramsKey struct {
	Params struct{ Format string }
	Hashes struct {
		Format hash.Hash
		V      hash.Hash
	}
}

// MoqLogger_starGenType_Fatalf_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Fatalf_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Fatalf_paramsKey]*MoqLogger_starGenType_Fatalf_results
}

// MoqLogger_starGenType_Fatalf_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Fatalf_doFn func(format string, v ...interface{})

// MoqLogger_starGenType_Fatalf_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Fatalf_doReturnFn func(format string, v ...interface{})

// MoqLogger_starGenType_Fatalf_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Fatalf_results struct {
	Params  MoqLogger_starGenType_Fatalf_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Fatalf_doFn
		DoReturnFn MoqLogger_starGenType_Fatalf_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Fatalf_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_Fatalf_fnRecorder struct {
	Params    MoqLogger_starGenType_Fatalf_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Fatalf_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Fatalf_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Fatalf_anyParams struct {
	Recorder *MoqLogger_starGenType_Fatalf_fnRecorder
}

// MoqLogger_starGenType_Fatalln_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Fatalln_params struct{ V []interface{} }

// MoqLogger_starGenType_Fatalln_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Fatalln_paramsKey struct {
	Params struct{}
	Hashes struct{ V hash.Hash }
}

// MoqLogger_starGenType_Fatalln_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Fatalln_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Fatalln_paramsKey]*MoqLogger_starGenType_Fatalln_results
}

// MoqLogger_starGenType_Fatalln_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Fatalln_doFn func(v ...interface{})

// MoqLogger_starGenType_Fatalln_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Fatalln_doReturnFn func(v ...interface{})

// MoqLogger_starGenType_Fatalln_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Fatalln_results struct {
	Params  MoqLogger_starGenType_Fatalln_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Fatalln_doFn
		DoReturnFn MoqLogger_starGenType_Fatalln_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Fatalln_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_Fatalln_fnRecorder struct {
	Params    MoqLogger_starGenType_Fatalln_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Fatalln_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Fatalln_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Fatalln_anyParams struct {
	Recorder *MoqLogger_starGenType_Fatalln_fnRecorder
}

// MoqLogger_starGenType_Panic_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Panic_params struct{ V []interface{} }

// MoqLogger_starGenType_Panic_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Panic_paramsKey struct {
	Params struct{}
	Hashes struct{ V hash.Hash }
}

// MoqLogger_starGenType_Panic_resultsByParams contains the results for a given
// set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Panic_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Panic_paramsKey]*MoqLogger_starGenType_Panic_results
}

// MoqLogger_starGenType_Panic_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Panic_doFn func(v ...interface{})

// MoqLogger_starGenType_Panic_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Panic_doReturnFn func(v ...interface{})

// MoqLogger_starGenType_Panic_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Panic_results struct {
	Params  MoqLogger_starGenType_Panic_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Panic_doFn
		DoReturnFn MoqLogger_starGenType_Panic_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Panic_fnRecorder routes recorded function calls to the
// MoqLogger_starGenType moq
type MoqLogger_starGenType_Panic_fnRecorder struct {
	Params    MoqLogger_starGenType_Panic_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Panic_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Panic_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Panic_anyParams struct {
	Recorder *MoqLogger_starGenType_Panic_fnRecorder
}

// MoqLogger_starGenType_Panicf_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Panicf_params struct {
	Format string
	V      []interface{}
}

// MoqLogger_starGenType_Panicf_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Panicf_paramsKey struct {
	Params struct{ Format string }
	Hashes struct {
		Format hash.Hash
		V      hash.Hash
	}
}

// MoqLogger_starGenType_Panicf_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Panicf_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Panicf_paramsKey]*MoqLogger_starGenType_Panicf_results
}

// MoqLogger_starGenType_Panicf_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Panicf_doFn func(format string, v ...interface{})

// MoqLogger_starGenType_Panicf_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Panicf_doReturnFn func(format string, v ...interface{})

// MoqLogger_starGenType_Panicf_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Panicf_results struct {
	Params  MoqLogger_starGenType_Panicf_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Panicf_doFn
		DoReturnFn MoqLogger_starGenType_Panicf_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Panicf_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_Panicf_fnRecorder struct {
	Params    MoqLogger_starGenType_Panicf_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Panicf_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Panicf_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Panicf_anyParams struct {
	Recorder *MoqLogger_starGenType_Panicf_fnRecorder
}

// MoqLogger_starGenType_Panicln_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Panicln_params struct{ V []interface{} }

// MoqLogger_starGenType_Panicln_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Panicln_paramsKey struct {
	Params struct{}
	Hashes struct{ V hash.Hash }
}

// MoqLogger_starGenType_Panicln_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Panicln_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Panicln_paramsKey]*MoqLogger_starGenType_Panicln_results
}

// MoqLogger_starGenType_Panicln_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Panicln_doFn func(v ...interface{})

// MoqLogger_starGenType_Panicln_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Panicln_doReturnFn func(v ...interface{})

// MoqLogger_starGenType_Panicln_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Panicln_results struct {
	Params  MoqLogger_starGenType_Panicln_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Panicln_doFn
		DoReturnFn MoqLogger_starGenType_Panicln_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Panicln_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_Panicln_fnRecorder struct {
	Params    MoqLogger_starGenType_Panicln_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Panicln_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Panicln_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Panicln_anyParams struct {
	Recorder *MoqLogger_starGenType_Panicln_fnRecorder
}

// MoqLogger_starGenType_Flags_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Flags_params struct{}

// MoqLogger_starGenType_Flags_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Flags_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqLogger_starGenType_Flags_resultsByParams contains the results for a given
// set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Flags_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Flags_paramsKey]*MoqLogger_starGenType_Flags_results
}

// MoqLogger_starGenType_Flags_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Flags_doFn func()

// MoqLogger_starGenType_Flags_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Flags_doReturnFn func() int

// MoqLogger_starGenType_Flags_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Flags_results struct {
	Params  MoqLogger_starGenType_Flags_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Flags_doFn
		DoReturnFn MoqLogger_starGenType_Flags_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Flags_fnRecorder routes recorded function calls to the
// MoqLogger_starGenType moq
type MoqLogger_starGenType_Flags_fnRecorder struct {
	Params    MoqLogger_starGenType_Flags_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Flags_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Flags_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Flags_anyParams struct {
	Recorder *MoqLogger_starGenType_Flags_fnRecorder
}

// MoqLogger_starGenType_SetFlags_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_SetFlags_params struct{ Flag int }

// MoqLogger_starGenType_SetFlags_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_SetFlags_paramsKey struct {
	Params struct{ Flag int }
	Hashes struct{ Flag hash.Hash }
}

// MoqLogger_starGenType_SetFlags_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_SetFlags_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_SetFlags_paramsKey]*MoqLogger_starGenType_SetFlags_results
}

// MoqLogger_starGenType_SetFlags_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_SetFlags_doFn func(flag int)

// MoqLogger_starGenType_SetFlags_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_SetFlags_doReturnFn func(flag int)

// MoqLogger_starGenType_SetFlags_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_SetFlags_results struct {
	Params  MoqLogger_starGenType_SetFlags_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_SetFlags_doFn
		DoReturnFn MoqLogger_starGenType_SetFlags_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_SetFlags_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_SetFlags_fnRecorder struct {
	Params    MoqLogger_starGenType_SetFlags_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_SetFlags_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_SetFlags_anyParams isolates the any params functions
// of the Logger_starGenType type
type MoqLogger_starGenType_SetFlags_anyParams struct {
	Recorder *MoqLogger_starGenType_SetFlags_fnRecorder
}

// MoqLogger_starGenType_Prefix_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Prefix_params struct{}

// MoqLogger_starGenType_Prefix_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Prefix_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqLogger_starGenType_Prefix_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Prefix_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Prefix_paramsKey]*MoqLogger_starGenType_Prefix_results
}

// MoqLogger_starGenType_Prefix_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Prefix_doFn func()

// MoqLogger_starGenType_Prefix_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Prefix_doReturnFn func() string

// MoqLogger_starGenType_Prefix_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Prefix_results struct {
	Params  MoqLogger_starGenType_Prefix_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Prefix_doFn
		DoReturnFn MoqLogger_starGenType_Prefix_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Prefix_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_Prefix_fnRecorder struct {
	Params    MoqLogger_starGenType_Prefix_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Prefix_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Prefix_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Prefix_anyParams struct {
	Recorder *MoqLogger_starGenType_Prefix_fnRecorder
}

// MoqLogger_starGenType_SetPrefix_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_SetPrefix_params struct{ Prefix string }

// MoqLogger_starGenType_SetPrefix_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_SetPrefix_paramsKey struct {
	Params struct{ Prefix string }
	Hashes struct{ Prefix hash.Hash }
}

// MoqLogger_starGenType_SetPrefix_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_SetPrefix_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_SetPrefix_paramsKey]*MoqLogger_starGenType_SetPrefix_results
}

// MoqLogger_starGenType_SetPrefix_doFn defines the type of function needed
// when calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_SetPrefix_doFn func(prefix string)

// MoqLogger_starGenType_SetPrefix_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_SetPrefix_doReturnFn func(prefix string)

// MoqLogger_starGenType_SetPrefix_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_SetPrefix_results struct {
	Params  MoqLogger_starGenType_SetPrefix_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_SetPrefix_doFn
		DoReturnFn MoqLogger_starGenType_SetPrefix_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_SetPrefix_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_SetPrefix_fnRecorder struct {
	Params    MoqLogger_starGenType_SetPrefix_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_SetPrefix_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_SetPrefix_anyParams isolates the any params functions
// of the Logger_starGenType type
type MoqLogger_starGenType_SetPrefix_anyParams struct {
	Recorder *MoqLogger_starGenType_SetPrefix_fnRecorder
}

// MoqLogger_starGenType_Writer_params holds the params of the
// Logger_starGenType type
type MoqLogger_starGenType_Writer_params struct{}

// MoqLogger_starGenType_Writer_paramsKey holds the map key params of the
// Logger_starGenType type
type MoqLogger_starGenType_Writer_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqLogger_starGenType_Writer_resultsByParams contains the results for a
// given set of parameters for the Logger_starGenType type
type MoqLogger_starGenType_Writer_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqLogger_starGenType_Writer_paramsKey]*MoqLogger_starGenType_Writer_results
}

// MoqLogger_starGenType_Writer_doFn defines the type of function needed when
// calling AndDo for the Logger_starGenType type
type MoqLogger_starGenType_Writer_doFn func()

// MoqLogger_starGenType_Writer_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Logger_starGenType type
type MoqLogger_starGenType_Writer_doReturnFn func() io.Writer

// MoqLogger_starGenType_Writer_results holds the results of the
// Logger_starGenType type
type MoqLogger_starGenType_Writer_results struct {
	Params  MoqLogger_starGenType_Writer_params
	Results []struct {
		Values *struct {
			Result1 io.Writer
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Writer_doFn
		DoReturnFn MoqLogger_starGenType_Writer_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqLogger_starGenType_Writer_fnRecorder routes recorded function calls to
// the MoqLogger_starGenType moq
type MoqLogger_starGenType_Writer_fnRecorder struct {
	Params    MoqLogger_starGenType_Writer_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqLogger_starGenType_Writer_results
	Moq       *MoqLogger_starGenType
}

// MoqLogger_starGenType_Writer_anyParams isolates the any params functions of
// the Logger_starGenType type
type MoqLogger_starGenType_Writer_anyParams struct {
	Recorder *MoqLogger_starGenType_Writer_fnRecorder
}

// NewMoqLogger_starGenType creates a new moq of the Logger_starGenType type
func NewMoqLogger_starGenType(scene *moq.Scene, config *moq.Config) *MoqLogger_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqLogger_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqLogger_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				SetOutput struct {
					W moq.ParamIndexing
				}
				Output struct {
					Calldepth moq.ParamIndexing
					S         moq.ParamIndexing
				}
				Printf struct {
					Format moq.ParamIndexing
					V      moq.ParamIndexing
				}
				Print struct {
					V moq.ParamIndexing
				}
				Println struct {
					V moq.ParamIndexing
				}
				Fatal struct {
					V moq.ParamIndexing
				}
				Fatalf struct {
					Format moq.ParamIndexing
					V      moq.ParamIndexing
				}
				Fatalln struct {
					V moq.ParamIndexing
				}
				Panic struct {
					V moq.ParamIndexing
				}
				Panicf struct {
					Format moq.ParamIndexing
					V      moq.ParamIndexing
				}
				Panicln struct {
					V moq.ParamIndexing
				}
				Flags    struct{}
				SetFlags struct {
					Flag moq.ParamIndexing
				}
				Prefix    struct{}
				SetPrefix struct {
					Prefix moq.ParamIndexing
				}
				Writer struct{}
			}
		}{ParameterIndexing: struct {
			SetOutput struct {
				W moq.ParamIndexing
			}
			Output struct {
				Calldepth moq.ParamIndexing
				S         moq.ParamIndexing
			}
			Printf struct {
				Format moq.ParamIndexing
				V      moq.ParamIndexing
			}
			Print struct {
				V moq.ParamIndexing
			}
			Println struct {
				V moq.ParamIndexing
			}
			Fatal struct {
				V moq.ParamIndexing
			}
			Fatalf struct {
				Format moq.ParamIndexing
				V      moq.ParamIndexing
			}
			Fatalln struct {
				V moq.ParamIndexing
			}
			Panic struct {
				V moq.ParamIndexing
			}
			Panicf struct {
				Format moq.ParamIndexing
				V      moq.ParamIndexing
			}
			Panicln struct {
				V moq.ParamIndexing
			}
			Flags    struct{}
			SetFlags struct {
				Flag moq.ParamIndexing
			}
			Prefix    struct{}
			SetPrefix struct {
				Prefix moq.ParamIndexing
			}
			Writer struct{}
		}{
			SetOutput: struct {
				W moq.ParamIndexing
			}{
				W: moq.ParamIndexByHash,
			},
			Output: struct {
				Calldepth moq.ParamIndexing
				S         moq.ParamIndexing
			}{
				Calldepth: moq.ParamIndexByValue,
				S:         moq.ParamIndexByValue,
			},
			Printf: struct {
				Format moq.ParamIndexing
				V      moq.ParamIndexing
			}{
				Format: moq.ParamIndexByValue,
				V:      moq.ParamIndexByHash,
			},
			Print: struct {
				V moq.ParamIndexing
			}{
				V: moq.ParamIndexByHash,
			},
			Println: struct {
				V moq.ParamIndexing
			}{
				V: moq.ParamIndexByHash,
			},
			Fatal: struct {
				V moq.ParamIndexing
			}{
				V: moq.ParamIndexByHash,
			},
			Fatalf: struct {
				Format moq.ParamIndexing
				V      moq.ParamIndexing
			}{
				Format: moq.ParamIndexByValue,
				V:      moq.ParamIndexByHash,
			},
			Fatalln: struct {
				V moq.ParamIndexing
			}{
				V: moq.ParamIndexByHash,
			},
			Panic: struct {
				V moq.ParamIndexing
			}{
				V: moq.ParamIndexByHash,
			},
			Panicf: struct {
				Format moq.ParamIndexing
				V      moq.ParamIndexing
			}{
				Format: moq.ParamIndexByValue,
				V:      moq.ParamIndexByHash,
			},
			Panicln: struct {
				V moq.ParamIndexing
			}{
				V: moq.ParamIndexByHash,
			},
			Flags: struct{}{},
			SetFlags: struct {
				Flag moq.ParamIndexing
			}{
				Flag: moq.ParamIndexByValue,
			},
			Prefix: struct{}{},
			SetPrefix: struct {
				Prefix moq.ParamIndexing
			}{
				Prefix: moq.ParamIndexByValue,
			},
			Writer: struct{}{},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Logger_starGenType type
func (m *MoqLogger_starGenType) Mock() *MoqLogger_starGenType_mock { return m.Moq }

func (m *MoqLogger_starGenType_mock) SetOutput(w io.Writer) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_SetOutput_params{
		W: w,
	}
	var results *MoqLogger_starGenType_SetOutput_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetOutput {
		paramsKey := m.Moq.ParamsKey_SetOutput(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetOutput(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetOutput(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetOutput(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(w)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(w)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Output(calldepth int, s string) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Output_params{
		Calldepth: calldepth,
		S:         s,
	}
	var results *MoqLogger_starGenType_Output_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Output {
		paramsKey := m.Moq.ParamsKey_Output(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Output(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Output(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Output(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(calldepth, s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(calldepth, s)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Printf(format string, v ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Printf_params{
		Format: format,
		V:      v,
	}
	var results *MoqLogger_starGenType_Printf_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Printf {
		paramsKey := m.Moq.ParamsKey_Printf(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Printf(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Printf(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Printf(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(format, v...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(format, v...)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Print(v ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Print_params{
		V: v,
	}
	var results *MoqLogger_starGenType_Print_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Print {
		paramsKey := m.Moq.ParamsKey_Print(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Print(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Print(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Print(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(v...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(v...)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Println(v ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Println_params{
		V: v,
	}
	var results *MoqLogger_starGenType_Println_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Println {
		paramsKey := m.Moq.ParamsKey_Println(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Println(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Println(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Println(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(v...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(v...)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Fatal(v ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Fatal_params{
		V: v,
	}
	var results *MoqLogger_starGenType_Fatal_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Fatal {
		paramsKey := m.Moq.ParamsKey_Fatal(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Fatal(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Fatal(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Fatal(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(v...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(v...)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Fatalf(format string, v ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Fatalf_params{
		Format: format,
		V:      v,
	}
	var results *MoqLogger_starGenType_Fatalf_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Fatalf {
		paramsKey := m.Moq.ParamsKey_Fatalf(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Fatalf(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Fatalf(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Fatalf(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(format, v...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(format, v...)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Fatalln(v ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Fatalln_params{
		V: v,
	}
	var results *MoqLogger_starGenType_Fatalln_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Fatalln {
		paramsKey := m.Moq.ParamsKey_Fatalln(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Fatalln(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Fatalln(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Fatalln(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(v...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(v...)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Panic(v ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Panic_params{
		V: v,
	}
	var results *MoqLogger_starGenType_Panic_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Panic {
		paramsKey := m.Moq.ParamsKey_Panic(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Panic(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Panic(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Panic(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(v...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(v...)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Panicf(format string, v ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Panicf_params{
		Format: format,
		V:      v,
	}
	var results *MoqLogger_starGenType_Panicf_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Panicf {
		paramsKey := m.Moq.ParamsKey_Panicf(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Panicf(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Panicf(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Panicf(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(format, v...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(format, v...)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Panicln(v ...interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Panicln_params{
		V: v,
	}
	var results *MoqLogger_starGenType_Panicln_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Panicln {
		paramsKey := m.Moq.ParamsKey_Panicln(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Panicln(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Panicln(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Panicln(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(v...)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(v...)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Flags() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Flags_params{}
	var results *MoqLogger_starGenType_Flags_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Flags {
		paramsKey := m.Moq.ParamsKey_Flags(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Flags(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Flags(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Flags(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqLogger_starGenType_mock) SetFlags(flag int) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_SetFlags_params{
		Flag: flag,
	}
	var results *MoqLogger_starGenType_SetFlags_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetFlags {
		paramsKey := m.Moq.ParamsKey_SetFlags(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetFlags(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetFlags(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetFlags(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(flag)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(flag)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Prefix() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Prefix_params{}
	var results *MoqLogger_starGenType_Prefix_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Prefix {
		paramsKey := m.Moq.ParamsKey_Prefix(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Prefix(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Prefix(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Prefix(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqLogger_starGenType_mock) SetPrefix(prefix string) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_SetPrefix_params{
		Prefix: prefix,
	}
	var results *MoqLogger_starGenType_SetPrefix_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetPrefix {
		paramsKey := m.Moq.ParamsKey_SetPrefix(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetPrefix(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetPrefix(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetPrefix(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(prefix)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(prefix)
	}
	return
}

func (m *MoqLogger_starGenType_mock) Writer() (result1 io.Writer) {
	m.Moq.Scene.T.Helper()
	params := MoqLogger_starGenType_Writer_params{}
	var results *MoqLogger_starGenType_Writer_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Writer {
		paramsKey := m.Moq.ParamsKey_Writer(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Writer(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Writer(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Writer(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

// OnCall returns the recorder implementation of the Logger_starGenType type
func (m *MoqLogger_starGenType) OnCall() *MoqLogger_starGenType_recorder {
	return &MoqLogger_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqLogger_starGenType_recorder) SetOutput(w io.Writer) *MoqLogger_starGenType_SetOutput_fnRecorder {
	return &MoqLogger_starGenType_SetOutput_fnRecorder{
		Params: MoqLogger_starGenType_SetOutput_params{
			W: w,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_SetOutput_fnRecorder) Any() *MoqLogger_starGenType_SetOutput_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetOutput(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_SetOutput_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_SetOutput_anyParams) W() *MoqLogger_starGenType_SetOutput_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqLogger_starGenType_SetOutput_fnRecorder) Seq() *MoqLogger_starGenType_SetOutput_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetOutput(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_SetOutput_fnRecorder) NoSeq() *MoqLogger_starGenType_SetOutput_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetOutput(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_SetOutput_fnRecorder) ReturnResults() *MoqLogger_starGenType_SetOutput_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_SetOutput_doFn
		DoReturnFn MoqLogger_starGenType_SetOutput_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_SetOutput_fnRecorder) AndDo(fn MoqLogger_starGenType_SetOutput_doFn) *MoqLogger_starGenType_SetOutput_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_SetOutput_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_SetOutput_doReturnFn) *MoqLogger_starGenType_SetOutput_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_SetOutput_doFn
		DoReturnFn MoqLogger_starGenType_SetOutput_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_SetOutput_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_SetOutput_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetOutput {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_SetOutput_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_SetOutput_paramsKey]*MoqLogger_starGenType_SetOutput_results{},
		}
		r.Moq.ResultsByParams_SetOutput = append(r.Moq.ResultsByParams_SetOutput, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetOutput) {
			copy(r.Moq.ResultsByParams_SetOutput[insertAt+1:], r.Moq.ResultsByParams_SetOutput[insertAt:0])
			r.Moq.ResultsByParams_SetOutput[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetOutput(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_SetOutput_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_SetOutput_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_SetOutput_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_SetOutput_doFn
				DoReturnFn MoqLogger_starGenType_SetOutput_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_SetOutput(params MoqLogger_starGenType_SetOutput_params) string {
	return fmt.Sprintf("SetOutput(%#v)", params.W)
}

func (m *MoqLogger_starGenType) ParamsKey_SetOutput(params MoqLogger_starGenType_SetOutput_params, anyParams uint64) MoqLogger_starGenType_SetOutput_paramsKey {
	m.Scene.T.Helper()
	var wUsed io.Writer
	var wUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetOutput.W == moq.ParamIndexByValue {
			wUsed = params.W
		} else {
			wUsedHash = hash.DeepHash(params.W)
		}
	}
	return MoqLogger_starGenType_SetOutput_paramsKey{
		Params: struct{ W io.Writer }{
			W: wUsed,
		},
		Hashes: struct{ W hash.Hash }{
			W: wUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Output(calldepth int, s string) *MoqLogger_starGenType_Output_fnRecorder {
	return &MoqLogger_starGenType_Output_fnRecorder{
		Params: MoqLogger_starGenType_Output_params{
			Calldepth: calldepth,
			S:         s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Output_fnRecorder) Any() *MoqLogger_starGenType_Output_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Output(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Output_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_Output_anyParams) Calldepth() *MoqLogger_starGenType_Output_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqLogger_starGenType_Output_anyParams) S() *MoqLogger_starGenType_Output_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqLogger_starGenType_Output_fnRecorder) Seq() *MoqLogger_starGenType_Output_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Output(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Output_fnRecorder) NoSeq() *MoqLogger_starGenType_Output_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Output(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Output_fnRecorder) ReturnResults(result1 error) *MoqLogger_starGenType_Output_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Output_doFn
		DoReturnFn MoqLogger_starGenType_Output_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Output_fnRecorder) AndDo(fn MoqLogger_starGenType_Output_doFn) *MoqLogger_starGenType_Output_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Output_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Output_doReturnFn) *MoqLogger_starGenType_Output_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Output_doFn
		DoReturnFn MoqLogger_starGenType_Output_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Output_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Output_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Output {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Output_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Output_paramsKey]*MoqLogger_starGenType_Output_results{},
		}
		r.Moq.ResultsByParams_Output = append(r.Moq.ResultsByParams_Output, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Output) {
			copy(r.Moq.ResultsByParams_Output[insertAt+1:], r.Moq.ResultsByParams_Output[insertAt:0])
			r.Moq.ResultsByParams_Output[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Output(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Output_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Output_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Output_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Output_doFn
				DoReturnFn MoqLogger_starGenType_Output_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Output(params MoqLogger_starGenType_Output_params) string {
	return fmt.Sprintf("Output(%#v, %#v)", params.Calldepth, params.S)
}

func (m *MoqLogger_starGenType) ParamsKey_Output(params MoqLogger_starGenType_Output_params, anyParams uint64) MoqLogger_starGenType_Output_paramsKey {
	m.Scene.T.Helper()
	var calldepthUsed int
	var calldepthUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Output.Calldepth == moq.ParamIndexByValue {
			calldepthUsed = params.Calldepth
		} else {
			calldepthUsedHash = hash.DeepHash(params.Calldepth)
		}
	}
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Output.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqLogger_starGenType_Output_paramsKey{
		Params: struct {
			Calldepth int
			S         string
		}{
			Calldepth: calldepthUsed,
			S:         sUsed,
		},
		Hashes: struct {
			Calldepth hash.Hash
			S         hash.Hash
		}{
			Calldepth: calldepthUsedHash,
			S:         sUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Printf(format string, v ...interface{}) *MoqLogger_starGenType_Printf_fnRecorder {
	return &MoqLogger_starGenType_Printf_fnRecorder{
		Params: MoqLogger_starGenType_Printf_params{
			Format: format,
			V:      v,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Printf_fnRecorder) Any() *MoqLogger_starGenType_Printf_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Printf(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Printf_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_Printf_anyParams) Format() *MoqLogger_starGenType_Printf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqLogger_starGenType_Printf_anyParams) V() *MoqLogger_starGenType_Printf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqLogger_starGenType_Printf_fnRecorder) Seq() *MoqLogger_starGenType_Printf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Printf(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Printf_fnRecorder) NoSeq() *MoqLogger_starGenType_Printf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Printf(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Printf_fnRecorder) ReturnResults() *MoqLogger_starGenType_Printf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Printf_doFn
		DoReturnFn MoqLogger_starGenType_Printf_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Printf_fnRecorder) AndDo(fn MoqLogger_starGenType_Printf_doFn) *MoqLogger_starGenType_Printf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Printf_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Printf_doReturnFn) *MoqLogger_starGenType_Printf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Printf_doFn
		DoReturnFn MoqLogger_starGenType_Printf_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Printf_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Printf_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Printf {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Printf_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Printf_paramsKey]*MoqLogger_starGenType_Printf_results{},
		}
		r.Moq.ResultsByParams_Printf = append(r.Moq.ResultsByParams_Printf, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Printf) {
			copy(r.Moq.ResultsByParams_Printf[insertAt+1:], r.Moq.ResultsByParams_Printf[insertAt:0])
			r.Moq.ResultsByParams_Printf[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Printf(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Printf_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Printf_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Printf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Printf_doFn
				DoReturnFn MoqLogger_starGenType_Printf_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Printf(params MoqLogger_starGenType_Printf_params) string {
	return fmt.Sprintf("Printf(%#v, %#v)", params.Format, params.V)
}

func (m *MoqLogger_starGenType) ParamsKey_Printf(params MoqLogger_starGenType_Printf_params, anyParams uint64) MoqLogger_starGenType_Printf_paramsKey {
	m.Scene.T.Helper()
	var formatUsed string
	var formatUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Printf.Format == moq.ParamIndexByValue {
			formatUsed = params.Format
		} else {
			formatUsedHash = hash.DeepHash(params.Format)
		}
	}
	var vUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Printf.V == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The v parameter of the Printf function can't be indexed by value")
		}
		vUsedHash = hash.DeepHash(params.V)
	}
	return MoqLogger_starGenType_Printf_paramsKey{
		Params: struct{ Format string }{
			Format: formatUsed,
		},
		Hashes: struct {
			Format hash.Hash
			V      hash.Hash
		}{
			Format: formatUsedHash,
			V:      vUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Print(v ...interface{}) *MoqLogger_starGenType_Print_fnRecorder {
	return &MoqLogger_starGenType_Print_fnRecorder{
		Params: MoqLogger_starGenType_Print_params{
			V: v,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Print_fnRecorder) Any() *MoqLogger_starGenType_Print_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Print(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Print_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_Print_anyParams) V() *MoqLogger_starGenType_Print_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqLogger_starGenType_Print_fnRecorder) Seq() *MoqLogger_starGenType_Print_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Print(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Print_fnRecorder) NoSeq() *MoqLogger_starGenType_Print_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Print(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Print_fnRecorder) ReturnResults() *MoqLogger_starGenType_Print_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Print_doFn
		DoReturnFn MoqLogger_starGenType_Print_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Print_fnRecorder) AndDo(fn MoqLogger_starGenType_Print_doFn) *MoqLogger_starGenType_Print_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Print_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Print_doReturnFn) *MoqLogger_starGenType_Print_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Print_doFn
		DoReturnFn MoqLogger_starGenType_Print_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Print_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Print_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Print {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Print_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Print_paramsKey]*MoqLogger_starGenType_Print_results{},
		}
		r.Moq.ResultsByParams_Print = append(r.Moq.ResultsByParams_Print, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Print) {
			copy(r.Moq.ResultsByParams_Print[insertAt+1:], r.Moq.ResultsByParams_Print[insertAt:0])
			r.Moq.ResultsByParams_Print[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Print(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Print_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Print_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Print_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Print_doFn
				DoReturnFn MoqLogger_starGenType_Print_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Print(params MoqLogger_starGenType_Print_params) string {
	return fmt.Sprintf("Print(%#v)", params.V)
}

func (m *MoqLogger_starGenType) ParamsKey_Print(params MoqLogger_starGenType_Print_params, anyParams uint64) MoqLogger_starGenType_Print_paramsKey {
	m.Scene.T.Helper()
	var vUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Print.V == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The v parameter of the Print function can't be indexed by value")
		}
		vUsedHash = hash.DeepHash(params.V)
	}
	return MoqLogger_starGenType_Print_paramsKey{
		Params: struct{}{},
		Hashes: struct{ V hash.Hash }{
			V: vUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Println(v ...interface{}) *MoqLogger_starGenType_Println_fnRecorder {
	return &MoqLogger_starGenType_Println_fnRecorder{
		Params: MoqLogger_starGenType_Println_params{
			V: v,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Println_fnRecorder) Any() *MoqLogger_starGenType_Println_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Println(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Println_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_Println_anyParams) V() *MoqLogger_starGenType_Println_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqLogger_starGenType_Println_fnRecorder) Seq() *MoqLogger_starGenType_Println_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Println(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Println_fnRecorder) NoSeq() *MoqLogger_starGenType_Println_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Println(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Println_fnRecorder) ReturnResults() *MoqLogger_starGenType_Println_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Println_doFn
		DoReturnFn MoqLogger_starGenType_Println_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Println_fnRecorder) AndDo(fn MoqLogger_starGenType_Println_doFn) *MoqLogger_starGenType_Println_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Println_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Println_doReturnFn) *MoqLogger_starGenType_Println_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Println_doFn
		DoReturnFn MoqLogger_starGenType_Println_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Println_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Println_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Println {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Println_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Println_paramsKey]*MoqLogger_starGenType_Println_results{},
		}
		r.Moq.ResultsByParams_Println = append(r.Moq.ResultsByParams_Println, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Println) {
			copy(r.Moq.ResultsByParams_Println[insertAt+1:], r.Moq.ResultsByParams_Println[insertAt:0])
			r.Moq.ResultsByParams_Println[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Println(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Println_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Println_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Println_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Println_doFn
				DoReturnFn MoqLogger_starGenType_Println_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Println(params MoqLogger_starGenType_Println_params) string {
	return fmt.Sprintf("Println(%#v)", params.V)
}

func (m *MoqLogger_starGenType) ParamsKey_Println(params MoqLogger_starGenType_Println_params, anyParams uint64) MoqLogger_starGenType_Println_paramsKey {
	m.Scene.T.Helper()
	var vUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Println.V == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The v parameter of the Println function can't be indexed by value")
		}
		vUsedHash = hash.DeepHash(params.V)
	}
	return MoqLogger_starGenType_Println_paramsKey{
		Params: struct{}{},
		Hashes: struct{ V hash.Hash }{
			V: vUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Fatal(v ...interface{}) *MoqLogger_starGenType_Fatal_fnRecorder {
	return &MoqLogger_starGenType_Fatal_fnRecorder{
		Params: MoqLogger_starGenType_Fatal_params{
			V: v,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Fatal_fnRecorder) Any() *MoqLogger_starGenType_Fatal_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatal(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Fatal_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_Fatal_anyParams) V() *MoqLogger_starGenType_Fatal_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqLogger_starGenType_Fatal_fnRecorder) Seq() *MoqLogger_starGenType_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatal(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Fatal_fnRecorder) NoSeq() *MoqLogger_starGenType_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatal(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Fatal_fnRecorder) ReturnResults() *MoqLogger_starGenType_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Fatal_doFn
		DoReturnFn MoqLogger_starGenType_Fatal_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Fatal_fnRecorder) AndDo(fn MoqLogger_starGenType_Fatal_doFn) *MoqLogger_starGenType_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Fatal_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Fatal_doReturnFn) *MoqLogger_starGenType_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Fatal_doFn
		DoReturnFn MoqLogger_starGenType_Fatal_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Fatal_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Fatal_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Fatal {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Fatal_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Fatal_paramsKey]*MoqLogger_starGenType_Fatal_results{},
		}
		r.Moq.ResultsByParams_Fatal = append(r.Moq.ResultsByParams_Fatal, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Fatal) {
			copy(r.Moq.ResultsByParams_Fatal[insertAt+1:], r.Moq.ResultsByParams_Fatal[insertAt:0])
			r.Moq.ResultsByParams_Fatal[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Fatal(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Fatal_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Fatal_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Fatal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Fatal_doFn
				DoReturnFn MoqLogger_starGenType_Fatal_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Fatal(params MoqLogger_starGenType_Fatal_params) string {
	return fmt.Sprintf("Fatal(%#v)", params.V)
}

func (m *MoqLogger_starGenType) ParamsKey_Fatal(params MoqLogger_starGenType_Fatal_params, anyParams uint64) MoqLogger_starGenType_Fatal_paramsKey {
	m.Scene.T.Helper()
	var vUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Fatal.V == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The v parameter of the Fatal function can't be indexed by value")
		}
		vUsedHash = hash.DeepHash(params.V)
	}
	return MoqLogger_starGenType_Fatal_paramsKey{
		Params: struct{}{},
		Hashes: struct{ V hash.Hash }{
			V: vUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Fatalf(format string, v ...interface{}) *MoqLogger_starGenType_Fatalf_fnRecorder {
	return &MoqLogger_starGenType_Fatalf_fnRecorder{
		Params: MoqLogger_starGenType_Fatalf_params{
			Format: format,
			V:      v,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Fatalf_fnRecorder) Any() *MoqLogger_starGenType_Fatalf_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatalf(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Fatalf_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_Fatalf_anyParams) Format() *MoqLogger_starGenType_Fatalf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqLogger_starGenType_Fatalf_anyParams) V() *MoqLogger_starGenType_Fatalf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqLogger_starGenType_Fatalf_fnRecorder) Seq() *MoqLogger_starGenType_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatalf(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Fatalf_fnRecorder) NoSeq() *MoqLogger_starGenType_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatalf(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Fatalf_fnRecorder) ReturnResults() *MoqLogger_starGenType_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Fatalf_doFn
		DoReturnFn MoqLogger_starGenType_Fatalf_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Fatalf_fnRecorder) AndDo(fn MoqLogger_starGenType_Fatalf_doFn) *MoqLogger_starGenType_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Fatalf_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Fatalf_doReturnFn) *MoqLogger_starGenType_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Fatalf_doFn
		DoReturnFn MoqLogger_starGenType_Fatalf_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Fatalf_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Fatalf_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Fatalf {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Fatalf_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Fatalf_paramsKey]*MoqLogger_starGenType_Fatalf_results{},
		}
		r.Moq.ResultsByParams_Fatalf = append(r.Moq.ResultsByParams_Fatalf, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Fatalf) {
			copy(r.Moq.ResultsByParams_Fatalf[insertAt+1:], r.Moq.ResultsByParams_Fatalf[insertAt:0])
			r.Moq.ResultsByParams_Fatalf[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Fatalf(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Fatalf_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Fatalf_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Fatalf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Fatalf_doFn
				DoReturnFn MoqLogger_starGenType_Fatalf_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Fatalf(params MoqLogger_starGenType_Fatalf_params) string {
	return fmt.Sprintf("Fatalf(%#v, %#v)", params.Format, params.V)
}

func (m *MoqLogger_starGenType) ParamsKey_Fatalf(params MoqLogger_starGenType_Fatalf_params, anyParams uint64) MoqLogger_starGenType_Fatalf_paramsKey {
	m.Scene.T.Helper()
	var formatUsed string
	var formatUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Fatalf.Format == moq.ParamIndexByValue {
			formatUsed = params.Format
		} else {
			formatUsedHash = hash.DeepHash(params.Format)
		}
	}
	var vUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Fatalf.V == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The v parameter of the Fatalf function can't be indexed by value")
		}
		vUsedHash = hash.DeepHash(params.V)
	}
	return MoqLogger_starGenType_Fatalf_paramsKey{
		Params: struct{ Format string }{
			Format: formatUsed,
		},
		Hashes: struct {
			Format hash.Hash
			V      hash.Hash
		}{
			Format: formatUsedHash,
			V:      vUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Fatalln(v ...interface{}) *MoqLogger_starGenType_Fatalln_fnRecorder {
	return &MoqLogger_starGenType_Fatalln_fnRecorder{
		Params: MoqLogger_starGenType_Fatalln_params{
			V: v,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Fatalln_fnRecorder) Any() *MoqLogger_starGenType_Fatalln_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatalln(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Fatalln_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_Fatalln_anyParams) V() *MoqLogger_starGenType_Fatalln_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqLogger_starGenType_Fatalln_fnRecorder) Seq() *MoqLogger_starGenType_Fatalln_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatalln(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Fatalln_fnRecorder) NoSeq() *MoqLogger_starGenType_Fatalln_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fatalln(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Fatalln_fnRecorder) ReturnResults() *MoqLogger_starGenType_Fatalln_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Fatalln_doFn
		DoReturnFn MoqLogger_starGenType_Fatalln_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Fatalln_fnRecorder) AndDo(fn MoqLogger_starGenType_Fatalln_doFn) *MoqLogger_starGenType_Fatalln_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Fatalln_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Fatalln_doReturnFn) *MoqLogger_starGenType_Fatalln_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Fatalln_doFn
		DoReturnFn MoqLogger_starGenType_Fatalln_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Fatalln_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Fatalln_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Fatalln {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Fatalln_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Fatalln_paramsKey]*MoqLogger_starGenType_Fatalln_results{},
		}
		r.Moq.ResultsByParams_Fatalln = append(r.Moq.ResultsByParams_Fatalln, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Fatalln) {
			copy(r.Moq.ResultsByParams_Fatalln[insertAt+1:], r.Moq.ResultsByParams_Fatalln[insertAt:0])
			r.Moq.ResultsByParams_Fatalln[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Fatalln(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Fatalln_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Fatalln_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Fatalln_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Fatalln_doFn
				DoReturnFn MoqLogger_starGenType_Fatalln_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Fatalln(params MoqLogger_starGenType_Fatalln_params) string {
	return fmt.Sprintf("Fatalln(%#v)", params.V)
}

func (m *MoqLogger_starGenType) ParamsKey_Fatalln(params MoqLogger_starGenType_Fatalln_params, anyParams uint64) MoqLogger_starGenType_Fatalln_paramsKey {
	m.Scene.T.Helper()
	var vUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Fatalln.V == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The v parameter of the Fatalln function can't be indexed by value")
		}
		vUsedHash = hash.DeepHash(params.V)
	}
	return MoqLogger_starGenType_Fatalln_paramsKey{
		Params: struct{}{},
		Hashes: struct{ V hash.Hash }{
			V: vUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Panic(v ...interface{}) *MoqLogger_starGenType_Panic_fnRecorder {
	return &MoqLogger_starGenType_Panic_fnRecorder{
		Params: MoqLogger_starGenType_Panic_params{
			V: v,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Panic_fnRecorder) Any() *MoqLogger_starGenType_Panic_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Panic(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Panic_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_Panic_anyParams) V() *MoqLogger_starGenType_Panic_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqLogger_starGenType_Panic_fnRecorder) Seq() *MoqLogger_starGenType_Panic_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Panic(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Panic_fnRecorder) NoSeq() *MoqLogger_starGenType_Panic_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Panic(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Panic_fnRecorder) ReturnResults() *MoqLogger_starGenType_Panic_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Panic_doFn
		DoReturnFn MoqLogger_starGenType_Panic_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Panic_fnRecorder) AndDo(fn MoqLogger_starGenType_Panic_doFn) *MoqLogger_starGenType_Panic_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Panic_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Panic_doReturnFn) *MoqLogger_starGenType_Panic_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Panic_doFn
		DoReturnFn MoqLogger_starGenType_Panic_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Panic_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Panic_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Panic {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Panic_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Panic_paramsKey]*MoqLogger_starGenType_Panic_results{},
		}
		r.Moq.ResultsByParams_Panic = append(r.Moq.ResultsByParams_Panic, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Panic) {
			copy(r.Moq.ResultsByParams_Panic[insertAt+1:], r.Moq.ResultsByParams_Panic[insertAt:0])
			r.Moq.ResultsByParams_Panic[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Panic(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Panic_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Panic_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Panic_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Panic_doFn
				DoReturnFn MoqLogger_starGenType_Panic_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Panic(params MoqLogger_starGenType_Panic_params) string {
	return fmt.Sprintf("Panic(%#v)", params.V)
}

func (m *MoqLogger_starGenType) ParamsKey_Panic(params MoqLogger_starGenType_Panic_params, anyParams uint64) MoqLogger_starGenType_Panic_paramsKey {
	m.Scene.T.Helper()
	var vUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Panic.V == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The v parameter of the Panic function can't be indexed by value")
		}
		vUsedHash = hash.DeepHash(params.V)
	}
	return MoqLogger_starGenType_Panic_paramsKey{
		Params: struct{}{},
		Hashes: struct{ V hash.Hash }{
			V: vUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Panicf(format string, v ...interface{}) *MoqLogger_starGenType_Panicf_fnRecorder {
	return &MoqLogger_starGenType_Panicf_fnRecorder{
		Params: MoqLogger_starGenType_Panicf_params{
			Format: format,
			V:      v,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Panicf_fnRecorder) Any() *MoqLogger_starGenType_Panicf_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Panicf(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Panicf_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_Panicf_anyParams) Format() *MoqLogger_starGenType_Panicf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqLogger_starGenType_Panicf_anyParams) V() *MoqLogger_starGenType_Panicf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqLogger_starGenType_Panicf_fnRecorder) Seq() *MoqLogger_starGenType_Panicf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Panicf(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Panicf_fnRecorder) NoSeq() *MoqLogger_starGenType_Panicf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Panicf(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Panicf_fnRecorder) ReturnResults() *MoqLogger_starGenType_Panicf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Panicf_doFn
		DoReturnFn MoqLogger_starGenType_Panicf_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Panicf_fnRecorder) AndDo(fn MoqLogger_starGenType_Panicf_doFn) *MoqLogger_starGenType_Panicf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Panicf_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Panicf_doReturnFn) *MoqLogger_starGenType_Panicf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Panicf_doFn
		DoReturnFn MoqLogger_starGenType_Panicf_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Panicf_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Panicf_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Panicf {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Panicf_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Panicf_paramsKey]*MoqLogger_starGenType_Panicf_results{},
		}
		r.Moq.ResultsByParams_Panicf = append(r.Moq.ResultsByParams_Panicf, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Panicf) {
			copy(r.Moq.ResultsByParams_Panicf[insertAt+1:], r.Moq.ResultsByParams_Panicf[insertAt:0])
			r.Moq.ResultsByParams_Panicf[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Panicf(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Panicf_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Panicf_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Panicf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Panicf_doFn
				DoReturnFn MoqLogger_starGenType_Panicf_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Panicf(params MoqLogger_starGenType_Panicf_params) string {
	return fmt.Sprintf("Panicf(%#v, %#v)", params.Format, params.V)
}

func (m *MoqLogger_starGenType) ParamsKey_Panicf(params MoqLogger_starGenType_Panicf_params, anyParams uint64) MoqLogger_starGenType_Panicf_paramsKey {
	m.Scene.T.Helper()
	var formatUsed string
	var formatUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Panicf.Format == moq.ParamIndexByValue {
			formatUsed = params.Format
		} else {
			formatUsedHash = hash.DeepHash(params.Format)
		}
	}
	var vUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Panicf.V == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The v parameter of the Panicf function can't be indexed by value")
		}
		vUsedHash = hash.DeepHash(params.V)
	}
	return MoqLogger_starGenType_Panicf_paramsKey{
		Params: struct{ Format string }{
			Format: formatUsed,
		},
		Hashes: struct {
			Format hash.Hash
			V      hash.Hash
		}{
			Format: formatUsedHash,
			V:      vUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Panicln(v ...interface{}) *MoqLogger_starGenType_Panicln_fnRecorder {
	return &MoqLogger_starGenType_Panicln_fnRecorder{
		Params: MoqLogger_starGenType_Panicln_params{
			V: v,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Panicln_fnRecorder) Any() *MoqLogger_starGenType_Panicln_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Panicln(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Panicln_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_Panicln_anyParams) V() *MoqLogger_starGenType_Panicln_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqLogger_starGenType_Panicln_fnRecorder) Seq() *MoqLogger_starGenType_Panicln_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Panicln(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Panicln_fnRecorder) NoSeq() *MoqLogger_starGenType_Panicln_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Panicln(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Panicln_fnRecorder) ReturnResults() *MoqLogger_starGenType_Panicln_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Panicln_doFn
		DoReturnFn MoqLogger_starGenType_Panicln_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Panicln_fnRecorder) AndDo(fn MoqLogger_starGenType_Panicln_doFn) *MoqLogger_starGenType_Panicln_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Panicln_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Panicln_doReturnFn) *MoqLogger_starGenType_Panicln_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Panicln_doFn
		DoReturnFn MoqLogger_starGenType_Panicln_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Panicln_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Panicln_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Panicln {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Panicln_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Panicln_paramsKey]*MoqLogger_starGenType_Panicln_results{},
		}
		r.Moq.ResultsByParams_Panicln = append(r.Moq.ResultsByParams_Panicln, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Panicln) {
			copy(r.Moq.ResultsByParams_Panicln[insertAt+1:], r.Moq.ResultsByParams_Panicln[insertAt:0])
			r.Moq.ResultsByParams_Panicln[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Panicln(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Panicln_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Panicln_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Panicln_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Panicln_doFn
				DoReturnFn MoqLogger_starGenType_Panicln_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Panicln(params MoqLogger_starGenType_Panicln_params) string {
	return fmt.Sprintf("Panicln(%#v)", params.V)
}

func (m *MoqLogger_starGenType) ParamsKey_Panicln(params MoqLogger_starGenType_Panicln_params, anyParams uint64) MoqLogger_starGenType_Panicln_paramsKey {
	m.Scene.T.Helper()
	var vUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Panicln.V == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The v parameter of the Panicln function can't be indexed by value")
		}
		vUsedHash = hash.DeepHash(params.V)
	}
	return MoqLogger_starGenType_Panicln_paramsKey{
		Params: struct{}{},
		Hashes: struct{ V hash.Hash }{
			V: vUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Flags() *MoqLogger_starGenType_Flags_fnRecorder {
	return &MoqLogger_starGenType_Flags_fnRecorder{
		Params:   MoqLogger_starGenType_Flags_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Flags_fnRecorder) Any() *MoqLogger_starGenType_Flags_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Flags(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Flags_anyParams{Recorder: r}
}

func (r *MoqLogger_starGenType_Flags_fnRecorder) Seq() *MoqLogger_starGenType_Flags_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Flags(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Flags_fnRecorder) NoSeq() *MoqLogger_starGenType_Flags_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Flags(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Flags_fnRecorder) ReturnResults(result1 int) *MoqLogger_starGenType_Flags_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Flags_doFn
		DoReturnFn MoqLogger_starGenType_Flags_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Flags_fnRecorder) AndDo(fn MoqLogger_starGenType_Flags_doFn) *MoqLogger_starGenType_Flags_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Flags_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Flags_doReturnFn) *MoqLogger_starGenType_Flags_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Flags_doFn
		DoReturnFn MoqLogger_starGenType_Flags_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Flags_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Flags_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Flags {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Flags_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Flags_paramsKey]*MoqLogger_starGenType_Flags_results{},
		}
		r.Moq.ResultsByParams_Flags = append(r.Moq.ResultsByParams_Flags, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Flags) {
			copy(r.Moq.ResultsByParams_Flags[insertAt+1:], r.Moq.ResultsByParams_Flags[insertAt:0])
			r.Moq.ResultsByParams_Flags[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Flags(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Flags_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Flags_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Flags_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Flags_doFn
				DoReturnFn MoqLogger_starGenType_Flags_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Flags(params MoqLogger_starGenType_Flags_params) string {
	return fmt.Sprintf("Flags()")
}

func (m *MoqLogger_starGenType) ParamsKey_Flags(params MoqLogger_starGenType_Flags_params, anyParams uint64) MoqLogger_starGenType_Flags_paramsKey {
	m.Scene.T.Helper()
	return MoqLogger_starGenType_Flags_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqLogger_starGenType_recorder) SetFlags(flag int) *MoqLogger_starGenType_SetFlags_fnRecorder {
	return &MoqLogger_starGenType_SetFlags_fnRecorder{
		Params: MoqLogger_starGenType_SetFlags_params{
			Flag: flag,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_SetFlags_fnRecorder) Any() *MoqLogger_starGenType_SetFlags_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFlags(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_SetFlags_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_SetFlags_anyParams) Flag() *MoqLogger_starGenType_SetFlags_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqLogger_starGenType_SetFlags_fnRecorder) Seq() *MoqLogger_starGenType_SetFlags_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFlags(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_SetFlags_fnRecorder) NoSeq() *MoqLogger_starGenType_SetFlags_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFlags(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_SetFlags_fnRecorder) ReturnResults() *MoqLogger_starGenType_SetFlags_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_SetFlags_doFn
		DoReturnFn MoqLogger_starGenType_SetFlags_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_SetFlags_fnRecorder) AndDo(fn MoqLogger_starGenType_SetFlags_doFn) *MoqLogger_starGenType_SetFlags_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_SetFlags_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_SetFlags_doReturnFn) *MoqLogger_starGenType_SetFlags_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_SetFlags_doFn
		DoReturnFn MoqLogger_starGenType_SetFlags_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_SetFlags_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_SetFlags_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetFlags {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_SetFlags_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_SetFlags_paramsKey]*MoqLogger_starGenType_SetFlags_results{},
		}
		r.Moq.ResultsByParams_SetFlags = append(r.Moq.ResultsByParams_SetFlags, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetFlags) {
			copy(r.Moq.ResultsByParams_SetFlags[insertAt+1:], r.Moq.ResultsByParams_SetFlags[insertAt:0])
			r.Moq.ResultsByParams_SetFlags[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetFlags(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_SetFlags_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_SetFlags_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_SetFlags_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_SetFlags_doFn
				DoReturnFn MoqLogger_starGenType_SetFlags_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_SetFlags(params MoqLogger_starGenType_SetFlags_params) string {
	return fmt.Sprintf("SetFlags(%#v)", params.Flag)
}

func (m *MoqLogger_starGenType) ParamsKey_SetFlags(params MoqLogger_starGenType_SetFlags_params, anyParams uint64) MoqLogger_starGenType_SetFlags_paramsKey {
	m.Scene.T.Helper()
	var flagUsed int
	var flagUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetFlags.Flag == moq.ParamIndexByValue {
			flagUsed = params.Flag
		} else {
			flagUsedHash = hash.DeepHash(params.Flag)
		}
	}
	return MoqLogger_starGenType_SetFlags_paramsKey{
		Params: struct{ Flag int }{
			Flag: flagUsed,
		},
		Hashes: struct{ Flag hash.Hash }{
			Flag: flagUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Prefix() *MoqLogger_starGenType_Prefix_fnRecorder {
	return &MoqLogger_starGenType_Prefix_fnRecorder{
		Params:   MoqLogger_starGenType_Prefix_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Prefix_fnRecorder) Any() *MoqLogger_starGenType_Prefix_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prefix(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Prefix_anyParams{Recorder: r}
}

func (r *MoqLogger_starGenType_Prefix_fnRecorder) Seq() *MoqLogger_starGenType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prefix(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Prefix_fnRecorder) NoSeq() *MoqLogger_starGenType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prefix(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Prefix_fnRecorder) ReturnResults(result1 string) *MoqLogger_starGenType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Prefix_doFn
		DoReturnFn MoqLogger_starGenType_Prefix_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Prefix_fnRecorder) AndDo(fn MoqLogger_starGenType_Prefix_doFn) *MoqLogger_starGenType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Prefix_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Prefix_doReturnFn) *MoqLogger_starGenType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Prefix_doFn
		DoReturnFn MoqLogger_starGenType_Prefix_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Prefix_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Prefix_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Prefix {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Prefix_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Prefix_paramsKey]*MoqLogger_starGenType_Prefix_results{},
		}
		r.Moq.ResultsByParams_Prefix = append(r.Moq.ResultsByParams_Prefix, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Prefix) {
			copy(r.Moq.ResultsByParams_Prefix[insertAt+1:], r.Moq.ResultsByParams_Prefix[insertAt:0])
			r.Moq.ResultsByParams_Prefix[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Prefix(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Prefix_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Prefix_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Prefix_doFn
				DoReturnFn MoqLogger_starGenType_Prefix_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Prefix(params MoqLogger_starGenType_Prefix_params) string {
	return fmt.Sprintf("Prefix()")
}

func (m *MoqLogger_starGenType) ParamsKey_Prefix(params MoqLogger_starGenType_Prefix_params, anyParams uint64) MoqLogger_starGenType_Prefix_paramsKey {
	m.Scene.T.Helper()
	return MoqLogger_starGenType_Prefix_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqLogger_starGenType_recorder) SetPrefix(prefix string) *MoqLogger_starGenType_SetPrefix_fnRecorder {
	return &MoqLogger_starGenType_SetPrefix_fnRecorder{
		Params: MoqLogger_starGenType_SetPrefix_params{
			Prefix: prefix,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_SetPrefix_fnRecorder) Any() *MoqLogger_starGenType_SetPrefix_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetPrefix(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_SetPrefix_anyParams{Recorder: r}
}

func (a *MoqLogger_starGenType_SetPrefix_anyParams) Prefix() *MoqLogger_starGenType_SetPrefix_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqLogger_starGenType_SetPrefix_fnRecorder) Seq() *MoqLogger_starGenType_SetPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetPrefix(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_SetPrefix_fnRecorder) NoSeq() *MoqLogger_starGenType_SetPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetPrefix(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_SetPrefix_fnRecorder) ReturnResults() *MoqLogger_starGenType_SetPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_SetPrefix_doFn
		DoReturnFn MoqLogger_starGenType_SetPrefix_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_SetPrefix_fnRecorder) AndDo(fn MoqLogger_starGenType_SetPrefix_doFn) *MoqLogger_starGenType_SetPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_SetPrefix_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_SetPrefix_doReturnFn) *MoqLogger_starGenType_SetPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_SetPrefix_doFn
		DoReturnFn MoqLogger_starGenType_SetPrefix_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_SetPrefix_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_SetPrefix_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetPrefix {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_SetPrefix_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_SetPrefix_paramsKey]*MoqLogger_starGenType_SetPrefix_results{},
		}
		r.Moq.ResultsByParams_SetPrefix = append(r.Moq.ResultsByParams_SetPrefix, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetPrefix) {
			copy(r.Moq.ResultsByParams_SetPrefix[insertAt+1:], r.Moq.ResultsByParams_SetPrefix[insertAt:0])
			r.Moq.ResultsByParams_SetPrefix[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetPrefix(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_SetPrefix_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_SetPrefix_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_SetPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_SetPrefix_doFn
				DoReturnFn MoqLogger_starGenType_SetPrefix_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_SetPrefix(params MoqLogger_starGenType_SetPrefix_params) string {
	return fmt.Sprintf("SetPrefix(%#v)", params.Prefix)
}

func (m *MoqLogger_starGenType) ParamsKey_SetPrefix(params MoqLogger_starGenType_SetPrefix_params, anyParams uint64) MoqLogger_starGenType_SetPrefix_paramsKey {
	m.Scene.T.Helper()
	var prefixUsed string
	var prefixUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetPrefix.Prefix == moq.ParamIndexByValue {
			prefixUsed = params.Prefix
		} else {
			prefixUsedHash = hash.DeepHash(params.Prefix)
		}
	}
	return MoqLogger_starGenType_SetPrefix_paramsKey{
		Params: struct{ Prefix string }{
			Prefix: prefixUsed,
		},
		Hashes: struct{ Prefix hash.Hash }{
			Prefix: prefixUsedHash,
		},
	}
}

func (m *MoqLogger_starGenType_recorder) Writer() *MoqLogger_starGenType_Writer_fnRecorder {
	return &MoqLogger_starGenType_Writer_fnRecorder{
		Params:   MoqLogger_starGenType_Writer_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqLogger_starGenType_Writer_fnRecorder) Any() *MoqLogger_starGenType_Writer_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Writer(r.Params))
		return nil
	}
	return &MoqLogger_starGenType_Writer_anyParams{Recorder: r}
}

func (r *MoqLogger_starGenType_Writer_fnRecorder) Seq() *MoqLogger_starGenType_Writer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Writer(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqLogger_starGenType_Writer_fnRecorder) NoSeq() *MoqLogger_starGenType_Writer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Writer(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqLogger_starGenType_Writer_fnRecorder) ReturnResults(result1 io.Writer) *MoqLogger_starGenType_Writer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 io.Writer
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Writer_doFn
		DoReturnFn MoqLogger_starGenType_Writer_doReturnFn
	}{
		Values: &struct {
			Result1 io.Writer
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqLogger_starGenType_Writer_fnRecorder) AndDo(fn MoqLogger_starGenType_Writer_doFn) *MoqLogger_starGenType_Writer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqLogger_starGenType_Writer_fnRecorder) DoReturnResults(fn MoqLogger_starGenType_Writer_doReturnFn) *MoqLogger_starGenType_Writer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 io.Writer
		}
		Sequence   uint32
		DoFn       MoqLogger_starGenType_Writer_doFn
		DoReturnFn MoqLogger_starGenType_Writer_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqLogger_starGenType_Writer_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqLogger_starGenType_Writer_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Writer {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqLogger_starGenType_Writer_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqLogger_starGenType_Writer_paramsKey]*MoqLogger_starGenType_Writer_results{},
		}
		r.Moq.ResultsByParams_Writer = append(r.Moq.ResultsByParams_Writer, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Writer) {
			copy(r.Moq.ResultsByParams_Writer[insertAt+1:], r.Moq.ResultsByParams_Writer[insertAt:0])
			r.Moq.ResultsByParams_Writer[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Writer(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqLogger_starGenType_Writer_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqLogger_starGenType_Writer_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqLogger_starGenType_Writer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 io.Writer
				}
				Sequence   uint32
				DoFn       MoqLogger_starGenType_Writer_doFn
				DoReturnFn MoqLogger_starGenType_Writer_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqLogger_starGenType) PrettyParams_Writer(params MoqLogger_starGenType_Writer_params) string {
	return fmt.Sprintf("Writer()")
}

func (m *MoqLogger_starGenType) ParamsKey_Writer(params MoqLogger_starGenType_Writer_params, anyParams uint64) MoqLogger_starGenType_Writer_paramsKey {
	m.Scene.T.Helper()
	return MoqLogger_starGenType_Writer_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqLogger_starGenType) Reset() {
	m.ResultsByParams_SetOutput = nil
	m.ResultsByParams_Output = nil
	m.ResultsByParams_Printf = nil
	m.ResultsByParams_Print = nil
	m.ResultsByParams_Println = nil
	m.ResultsByParams_Fatal = nil
	m.ResultsByParams_Fatalf = nil
	m.ResultsByParams_Fatalln = nil
	m.ResultsByParams_Panic = nil
	m.ResultsByParams_Panicf = nil
	m.ResultsByParams_Panicln = nil
	m.ResultsByParams_Flags = nil
	m.ResultsByParams_SetFlags = nil
	m.ResultsByParams_Prefix = nil
	m.ResultsByParams_SetPrefix = nil
	m.ResultsByParams_Writer = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqLogger_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_SetOutput {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetOutput(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Output {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Output(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Printf {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Printf(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Print {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Print(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Println {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Println(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Fatal {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Fatal(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Fatalf {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Fatalf(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Fatalln {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Fatalln(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Panic {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Panic(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Panicf {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Panicf(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Panicln {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Panicln(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Flags {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Flags(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetFlags {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetFlags(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Prefix {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Prefix(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetPrefix {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetPrefix(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Writer {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Writer(results.Params))
			}
		}
	}
}
