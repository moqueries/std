// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package big

import (
	"fmt"
	"math/big"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that big.Rat_starGenType is mocked
// completely
var _ Rat_starGenType = (*MoqRat_starGenType_mock)(nil)

// Rat_starGenType is the fabricated implementation type of this mock (emitted
// when mocking a collections of methods directly and not from an interface
// type)
type Rat_starGenType interface {
	SetFloat64(f float64) *big.Rat
	Float32() (f float32, exact bool)
	Float64() (f float64, exact bool)
	SetFrac(a, b *big.Int) *big.Rat
	SetFrac64(a, b int64) *big.Rat
	SetInt(x *big.Int) *big.Rat
	SetInt64(x int64) *big.Rat
	SetUint64(x uint64) *big.Rat
	Set(x *big.Rat) *big.Rat
	Abs(x *big.Rat) *big.Rat
	Neg(x *big.Rat) *big.Rat
	Inv(x *big.Rat) *big.Rat
	Sign() int
	IsInt() bool
	Num() *big.Int
	Denom() *big.Int
	Cmp(y *big.Rat) int
	Add(x, y *big.Rat) *big.Rat
	Sub(x, y *big.Rat) *big.Rat
	Mul(x, y *big.Rat) *big.Rat
	Quo(x, y *big.Rat) *big.Rat
	Scan(s fmt.ScanState, ch rune) error
	SetString(s string) (*big.Rat, bool)
	String() string
	RatString() string
	FloatString(prec int) string
	GobEncode() ([]byte, error)
	GobDecode(buf []byte) error
	MarshalText() (text []byte, err error)
	UnmarshalText(text []byte) error
}

// MoqRat_starGenType holds the state of a moq of the Rat_starGenType type
type MoqRat_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqRat_starGenType_mock

	ResultsByParams_SetFloat64    []MoqRat_starGenType_SetFloat64_resultsByParams
	ResultsByParams_Float32       []MoqRat_starGenType_Float32_resultsByParams
	ResultsByParams_Float64       []MoqRat_starGenType_Float64_resultsByParams
	ResultsByParams_SetFrac       []MoqRat_starGenType_SetFrac_resultsByParams
	ResultsByParams_SetFrac64     []MoqRat_starGenType_SetFrac64_resultsByParams
	ResultsByParams_SetInt        []MoqRat_starGenType_SetInt_resultsByParams
	ResultsByParams_SetInt64      []MoqRat_starGenType_SetInt64_resultsByParams
	ResultsByParams_SetUint64     []MoqRat_starGenType_SetUint64_resultsByParams
	ResultsByParams_Set           []MoqRat_starGenType_Set_resultsByParams
	ResultsByParams_Abs           []MoqRat_starGenType_Abs_resultsByParams
	ResultsByParams_Neg           []MoqRat_starGenType_Neg_resultsByParams
	ResultsByParams_Inv           []MoqRat_starGenType_Inv_resultsByParams
	ResultsByParams_Sign          []MoqRat_starGenType_Sign_resultsByParams
	ResultsByParams_IsInt         []MoqRat_starGenType_IsInt_resultsByParams
	ResultsByParams_Num           []MoqRat_starGenType_Num_resultsByParams
	ResultsByParams_Denom         []MoqRat_starGenType_Denom_resultsByParams
	ResultsByParams_Cmp           []MoqRat_starGenType_Cmp_resultsByParams
	ResultsByParams_Add           []MoqRat_starGenType_Add_resultsByParams
	ResultsByParams_Sub           []MoqRat_starGenType_Sub_resultsByParams
	ResultsByParams_Mul           []MoqRat_starGenType_Mul_resultsByParams
	ResultsByParams_Quo           []MoqRat_starGenType_Quo_resultsByParams
	ResultsByParams_Scan          []MoqRat_starGenType_Scan_resultsByParams
	ResultsByParams_SetString     []MoqRat_starGenType_SetString_resultsByParams
	ResultsByParams_String        []MoqRat_starGenType_String_resultsByParams
	ResultsByParams_RatString     []MoqRat_starGenType_RatString_resultsByParams
	ResultsByParams_FloatString   []MoqRat_starGenType_FloatString_resultsByParams
	ResultsByParams_GobEncode     []MoqRat_starGenType_GobEncode_resultsByParams
	ResultsByParams_GobDecode     []MoqRat_starGenType_GobDecode_resultsByParams
	ResultsByParams_MarshalText   []MoqRat_starGenType_MarshalText_resultsByParams
	ResultsByParams_UnmarshalText []MoqRat_starGenType_UnmarshalText_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			SetFloat64 struct {
				F moq.ParamIndexing
			}
			Float32 struct{}
			Float64 struct{}
			SetFrac struct {
				A moq.ParamIndexing
				B moq.ParamIndexing
			}
			SetFrac64 struct {
				A moq.ParamIndexing
				B moq.ParamIndexing
			}
			SetInt struct {
				X moq.ParamIndexing
			}
			SetInt64 struct {
				X moq.ParamIndexing
			}
			SetUint64 struct {
				X moq.ParamIndexing
			}
			Set struct {
				X moq.ParamIndexing
			}
			Abs struct {
				X moq.ParamIndexing
			}
			Neg struct {
				X moq.ParamIndexing
			}
			Inv struct {
				X moq.ParamIndexing
			}
			Sign  struct{}
			IsInt struct{}
			Num   struct{}
			Denom struct{}
			Cmp   struct {
				Y moq.ParamIndexing
			}
			Add struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Sub struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Mul struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Quo struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Scan struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}
			SetString struct {
				S moq.ParamIndexing
			}
			String      struct{}
			RatString   struct{}
			FloatString struct {
				Prec moq.ParamIndexing
			}
			GobEncode struct{}
			GobDecode struct {
				Buf moq.ParamIndexing
			}
			MarshalText   struct{}
			UnmarshalText struct {
				Text moq.ParamIndexing
			}
		}
	}
	// MoqRat_starGenType_mock isolates the mock interface of the Rat_starGenType
}

// type
type MoqRat_starGenType_mock struct {
	Moq *MoqRat_starGenType
}

// MoqRat_starGenType_recorder isolates the recorder interface of the
// Rat_starGenType type
type MoqRat_starGenType_recorder struct {
	Moq *MoqRat_starGenType
}

// MoqRat_starGenType_SetFloat64_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_SetFloat64_params struct{ F float64 }

// MoqRat_starGenType_SetFloat64_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_SetFloat64_paramsKey struct {
	Params struct{ F float64 }
	Hashes struct{ F hash.Hash }
}

// MoqRat_starGenType_SetFloat64_resultsByParams contains the results for a
// given set of parameters for the Rat_starGenType type
type MoqRat_starGenType_SetFloat64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_SetFloat64_paramsKey]*MoqRat_starGenType_SetFloat64_results
}

// MoqRat_starGenType_SetFloat64_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_SetFloat64_doFn func(f float64)

// MoqRat_starGenType_SetFloat64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_SetFloat64_doReturnFn func(f float64) *big.Rat

// MoqRat_starGenType_SetFloat64_results holds the results of the
// Rat_starGenType type
type MoqRat_starGenType_SetFloat64_results struct {
	Params  MoqRat_starGenType_SetFloat64_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetFloat64_doFn
		DoReturnFn MoqRat_starGenType_SetFloat64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_SetFloat64_fnRecorder routes recorded function calls to
// the MoqRat_starGenType moq
type MoqRat_starGenType_SetFloat64_fnRecorder struct {
	Params    MoqRat_starGenType_SetFloat64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_SetFloat64_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_SetFloat64_anyParams isolates the any params functions of
// the Rat_starGenType type
type MoqRat_starGenType_SetFloat64_anyParams struct {
	Recorder *MoqRat_starGenType_SetFloat64_fnRecorder
}

// MoqRat_starGenType_Float32_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_Float32_params struct{}

// MoqRat_starGenType_Float32_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Float32_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRat_starGenType_Float32_resultsByParams contains the results for a given
// set of parameters for the Rat_starGenType type
type MoqRat_starGenType_Float32_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Float32_paramsKey]*MoqRat_starGenType_Float32_results
}

// MoqRat_starGenType_Float32_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_Float32_doFn func()

// MoqRat_starGenType_Float32_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Float32_doReturnFn func() (f float32, exact bool)

// MoqRat_starGenType_Float32_results holds the results of the Rat_starGenType
// type
type MoqRat_starGenType_Float32_results struct {
	Params  MoqRat_starGenType_Float32_params
	Results []struct {
		Values *struct {
			F     float32
			Exact bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Float32_doFn
		DoReturnFn MoqRat_starGenType_Float32_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Float32_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Float32_fnRecorder struct {
	Params    MoqRat_starGenType_Float32_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Float32_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Float32_anyParams isolates the any params functions of
// the Rat_starGenType type
type MoqRat_starGenType_Float32_anyParams struct {
	Recorder *MoqRat_starGenType_Float32_fnRecorder
}

// MoqRat_starGenType_Float64_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_Float64_params struct{}

// MoqRat_starGenType_Float64_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Float64_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRat_starGenType_Float64_resultsByParams contains the results for a given
// set of parameters for the Rat_starGenType type
type MoqRat_starGenType_Float64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Float64_paramsKey]*MoqRat_starGenType_Float64_results
}

// MoqRat_starGenType_Float64_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_Float64_doFn func()

// MoqRat_starGenType_Float64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Float64_doReturnFn func() (f float64, exact bool)

// MoqRat_starGenType_Float64_results holds the results of the Rat_starGenType
// type
type MoqRat_starGenType_Float64_results struct {
	Params  MoqRat_starGenType_Float64_params
	Results []struct {
		Values *struct {
			F     float64
			Exact bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Float64_doFn
		DoReturnFn MoqRat_starGenType_Float64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Float64_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Float64_fnRecorder struct {
	Params    MoqRat_starGenType_Float64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Float64_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Float64_anyParams isolates the any params functions of
// the Rat_starGenType type
type MoqRat_starGenType_Float64_anyParams struct {
	Recorder *MoqRat_starGenType_Float64_fnRecorder
}

// MoqRat_starGenType_SetFrac_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_SetFrac_params struct{ A, B *big.Int }

// MoqRat_starGenType_SetFrac_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_SetFrac_paramsKey struct {
	Params struct{ A, B *big.Int }
	Hashes struct{ A, B hash.Hash }
}

// MoqRat_starGenType_SetFrac_resultsByParams contains the results for a given
// set of parameters for the Rat_starGenType type
type MoqRat_starGenType_SetFrac_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_SetFrac_paramsKey]*MoqRat_starGenType_SetFrac_results
}

// MoqRat_starGenType_SetFrac_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_SetFrac_doFn func(a, b *big.Int)

// MoqRat_starGenType_SetFrac_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_SetFrac_doReturnFn func(a, b *big.Int) *big.Rat

// MoqRat_starGenType_SetFrac_results holds the results of the Rat_starGenType
// type
type MoqRat_starGenType_SetFrac_results struct {
	Params  MoqRat_starGenType_SetFrac_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetFrac_doFn
		DoReturnFn MoqRat_starGenType_SetFrac_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_SetFrac_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_SetFrac_fnRecorder struct {
	Params    MoqRat_starGenType_SetFrac_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_SetFrac_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_SetFrac_anyParams isolates the any params functions of
// the Rat_starGenType type
type MoqRat_starGenType_SetFrac_anyParams struct {
	Recorder *MoqRat_starGenType_SetFrac_fnRecorder
}

// MoqRat_starGenType_SetFrac64_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_SetFrac64_params struct{ A, B int64 }

// MoqRat_starGenType_SetFrac64_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_SetFrac64_paramsKey struct {
	Params struct{ A, B int64 }
	Hashes struct{ A, B hash.Hash }
}

// MoqRat_starGenType_SetFrac64_resultsByParams contains the results for a
// given set of parameters for the Rat_starGenType type
type MoqRat_starGenType_SetFrac64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_SetFrac64_paramsKey]*MoqRat_starGenType_SetFrac64_results
}

// MoqRat_starGenType_SetFrac64_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_SetFrac64_doFn func(a, b int64)

// MoqRat_starGenType_SetFrac64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_SetFrac64_doReturnFn func(a, b int64) *big.Rat

// MoqRat_starGenType_SetFrac64_results holds the results of the
// Rat_starGenType type
type MoqRat_starGenType_SetFrac64_results struct {
	Params  MoqRat_starGenType_SetFrac64_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetFrac64_doFn
		DoReturnFn MoqRat_starGenType_SetFrac64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_SetFrac64_fnRecorder routes recorded function calls to
// the MoqRat_starGenType moq
type MoqRat_starGenType_SetFrac64_fnRecorder struct {
	Params    MoqRat_starGenType_SetFrac64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_SetFrac64_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_SetFrac64_anyParams isolates the any params functions of
// the Rat_starGenType type
type MoqRat_starGenType_SetFrac64_anyParams struct {
	Recorder *MoqRat_starGenType_SetFrac64_fnRecorder
}

// MoqRat_starGenType_SetInt_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_SetInt_params struct{ X *big.Int }

// MoqRat_starGenType_SetInt_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_SetInt_paramsKey struct {
	Params struct{ X *big.Int }
	Hashes struct{ X hash.Hash }
}

// MoqRat_starGenType_SetInt_resultsByParams contains the results for a given
// set of parameters for the Rat_starGenType type
type MoqRat_starGenType_SetInt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_SetInt_paramsKey]*MoqRat_starGenType_SetInt_results
}

// MoqRat_starGenType_SetInt_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_SetInt_doFn func(x *big.Int)

// MoqRat_starGenType_SetInt_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_SetInt_doReturnFn func(x *big.Int) *big.Rat

// MoqRat_starGenType_SetInt_results holds the results of the Rat_starGenType
// type
type MoqRat_starGenType_SetInt_results struct {
	Params  MoqRat_starGenType_SetInt_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetInt_doFn
		DoReturnFn MoqRat_starGenType_SetInt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_SetInt_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_SetInt_fnRecorder struct {
	Params    MoqRat_starGenType_SetInt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_SetInt_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_SetInt_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_SetInt_anyParams struct {
	Recorder *MoqRat_starGenType_SetInt_fnRecorder
}

// MoqRat_starGenType_SetInt64_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_SetInt64_params struct{ X int64 }

// MoqRat_starGenType_SetInt64_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_SetInt64_paramsKey struct {
	Params struct{ X int64 }
	Hashes struct{ X hash.Hash }
}

// MoqRat_starGenType_SetInt64_resultsByParams contains the results for a given
// set of parameters for the Rat_starGenType type
type MoqRat_starGenType_SetInt64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_SetInt64_paramsKey]*MoqRat_starGenType_SetInt64_results
}

// MoqRat_starGenType_SetInt64_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_SetInt64_doFn func(x int64)

// MoqRat_starGenType_SetInt64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_SetInt64_doReturnFn func(x int64) *big.Rat

// MoqRat_starGenType_SetInt64_results holds the results of the Rat_starGenType
// type
type MoqRat_starGenType_SetInt64_results struct {
	Params  MoqRat_starGenType_SetInt64_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetInt64_doFn
		DoReturnFn MoqRat_starGenType_SetInt64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_SetInt64_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_SetInt64_fnRecorder struct {
	Params    MoqRat_starGenType_SetInt64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_SetInt64_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_SetInt64_anyParams isolates the any params functions of
// the Rat_starGenType type
type MoqRat_starGenType_SetInt64_anyParams struct {
	Recorder *MoqRat_starGenType_SetInt64_fnRecorder
}

// MoqRat_starGenType_SetUint64_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_SetUint64_params struct{ X uint64 }

// MoqRat_starGenType_SetUint64_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_SetUint64_paramsKey struct {
	Params struct{ X uint64 }
	Hashes struct{ X hash.Hash }
}

// MoqRat_starGenType_SetUint64_resultsByParams contains the results for a
// given set of parameters for the Rat_starGenType type
type MoqRat_starGenType_SetUint64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_SetUint64_paramsKey]*MoqRat_starGenType_SetUint64_results
}

// MoqRat_starGenType_SetUint64_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_SetUint64_doFn func(x uint64)

// MoqRat_starGenType_SetUint64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_SetUint64_doReturnFn func(x uint64) *big.Rat

// MoqRat_starGenType_SetUint64_results holds the results of the
// Rat_starGenType type
type MoqRat_starGenType_SetUint64_results struct {
	Params  MoqRat_starGenType_SetUint64_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetUint64_doFn
		DoReturnFn MoqRat_starGenType_SetUint64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_SetUint64_fnRecorder routes recorded function calls to
// the MoqRat_starGenType moq
type MoqRat_starGenType_SetUint64_fnRecorder struct {
	Params    MoqRat_starGenType_SetUint64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_SetUint64_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_SetUint64_anyParams isolates the any params functions of
// the Rat_starGenType type
type MoqRat_starGenType_SetUint64_anyParams struct {
	Recorder *MoqRat_starGenType_SetUint64_fnRecorder
}

// MoqRat_starGenType_Set_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Set_params struct{ X *big.Rat }

// MoqRat_starGenType_Set_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Set_paramsKey struct {
	Params struct{ X *big.Rat }
	Hashes struct{ X hash.Hash }
}

// MoqRat_starGenType_Set_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Set_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Set_paramsKey]*MoqRat_starGenType_Set_results
}

// MoqRat_starGenType_Set_doFn defines the type of function needed when calling
// AndDo for the Rat_starGenType type
type MoqRat_starGenType_Set_doFn func(x *big.Rat)

// MoqRat_starGenType_Set_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Set_doReturnFn func(x *big.Rat) *big.Rat

// MoqRat_starGenType_Set_results holds the results of the Rat_starGenType type
type MoqRat_starGenType_Set_results struct {
	Params  MoqRat_starGenType_Set_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Set_doFn
		DoReturnFn MoqRat_starGenType_Set_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Set_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Set_fnRecorder struct {
	Params    MoqRat_starGenType_Set_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Set_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Set_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Set_anyParams struct {
	Recorder *MoqRat_starGenType_Set_fnRecorder
}

// MoqRat_starGenType_Abs_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Abs_params struct{ X *big.Rat }

// MoqRat_starGenType_Abs_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Abs_paramsKey struct {
	Params struct{ X *big.Rat }
	Hashes struct{ X hash.Hash }
}

// MoqRat_starGenType_Abs_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Abs_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Abs_paramsKey]*MoqRat_starGenType_Abs_results
}

// MoqRat_starGenType_Abs_doFn defines the type of function needed when calling
// AndDo for the Rat_starGenType type
type MoqRat_starGenType_Abs_doFn func(x *big.Rat)

// MoqRat_starGenType_Abs_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Abs_doReturnFn func(x *big.Rat) *big.Rat

// MoqRat_starGenType_Abs_results holds the results of the Rat_starGenType type
type MoqRat_starGenType_Abs_results struct {
	Params  MoqRat_starGenType_Abs_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Abs_doFn
		DoReturnFn MoqRat_starGenType_Abs_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Abs_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Abs_fnRecorder struct {
	Params    MoqRat_starGenType_Abs_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Abs_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Abs_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Abs_anyParams struct {
	Recorder *MoqRat_starGenType_Abs_fnRecorder
}

// MoqRat_starGenType_Neg_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Neg_params struct{ X *big.Rat }

// MoqRat_starGenType_Neg_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Neg_paramsKey struct {
	Params struct{ X *big.Rat }
	Hashes struct{ X hash.Hash }
}

// MoqRat_starGenType_Neg_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Neg_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Neg_paramsKey]*MoqRat_starGenType_Neg_results
}

// MoqRat_starGenType_Neg_doFn defines the type of function needed when calling
// AndDo for the Rat_starGenType type
type MoqRat_starGenType_Neg_doFn func(x *big.Rat)

// MoqRat_starGenType_Neg_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Neg_doReturnFn func(x *big.Rat) *big.Rat

// MoqRat_starGenType_Neg_results holds the results of the Rat_starGenType type
type MoqRat_starGenType_Neg_results struct {
	Params  MoqRat_starGenType_Neg_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Neg_doFn
		DoReturnFn MoqRat_starGenType_Neg_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Neg_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Neg_fnRecorder struct {
	Params    MoqRat_starGenType_Neg_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Neg_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Neg_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Neg_anyParams struct {
	Recorder *MoqRat_starGenType_Neg_fnRecorder
}

// MoqRat_starGenType_Inv_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Inv_params struct{ X *big.Rat }

// MoqRat_starGenType_Inv_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Inv_paramsKey struct {
	Params struct{ X *big.Rat }
	Hashes struct{ X hash.Hash }
}

// MoqRat_starGenType_Inv_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Inv_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Inv_paramsKey]*MoqRat_starGenType_Inv_results
}

// MoqRat_starGenType_Inv_doFn defines the type of function needed when calling
// AndDo for the Rat_starGenType type
type MoqRat_starGenType_Inv_doFn func(x *big.Rat)

// MoqRat_starGenType_Inv_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Inv_doReturnFn func(x *big.Rat) *big.Rat

// MoqRat_starGenType_Inv_results holds the results of the Rat_starGenType type
type MoqRat_starGenType_Inv_results struct {
	Params  MoqRat_starGenType_Inv_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Inv_doFn
		DoReturnFn MoqRat_starGenType_Inv_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Inv_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Inv_fnRecorder struct {
	Params    MoqRat_starGenType_Inv_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Inv_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Inv_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Inv_anyParams struct {
	Recorder *MoqRat_starGenType_Inv_fnRecorder
}

// MoqRat_starGenType_Sign_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Sign_params struct{}

// MoqRat_starGenType_Sign_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Sign_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRat_starGenType_Sign_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Sign_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Sign_paramsKey]*MoqRat_starGenType_Sign_results
}

// MoqRat_starGenType_Sign_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_Sign_doFn func()

// MoqRat_starGenType_Sign_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Sign_doReturnFn func() int

// MoqRat_starGenType_Sign_results holds the results of the Rat_starGenType
// type
type MoqRat_starGenType_Sign_results struct {
	Params  MoqRat_starGenType_Sign_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Sign_doFn
		DoReturnFn MoqRat_starGenType_Sign_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Sign_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Sign_fnRecorder struct {
	Params    MoqRat_starGenType_Sign_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Sign_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Sign_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Sign_anyParams struct {
	Recorder *MoqRat_starGenType_Sign_fnRecorder
}

// MoqRat_starGenType_IsInt_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_IsInt_params struct{}

// MoqRat_starGenType_IsInt_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_IsInt_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRat_starGenType_IsInt_resultsByParams contains the results for a given
// set of parameters for the Rat_starGenType type
type MoqRat_starGenType_IsInt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_IsInt_paramsKey]*MoqRat_starGenType_IsInt_results
}

// MoqRat_starGenType_IsInt_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_IsInt_doFn func()

// MoqRat_starGenType_IsInt_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_IsInt_doReturnFn func() bool

// MoqRat_starGenType_IsInt_results holds the results of the Rat_starGenType
// type
type MoqRat_starGenType_IsInt_results struct {
	Params  MoqRat_starGenType_IsInt_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_IsInt_doFn
		DoReturnFn MoqRat_starGenType_IsInt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_IsInt_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_IsInt_fnRecorder struct {
	Params    MoqRat_starGenType_IsInt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_IsInt_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_IsInt_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_IsInt_anyParams struct {
	Recorder *MoqRat_starGenType_IsInt_fnRecorder
}

// MoqRat_starGenType_Num_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Num_params struct{}

// MoqRat_starGenType_Num_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Num_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRat_starGenType_Num_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Num_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Num_paramsKey]*MoqRat_starGenType_Num_results
}

// MoqRat_starGenType_Num_doFn defines the type of function needed when calling
// AndDo for the Rat_starGenType type
type MoqRat_starGenType_Num_doFn func()

// MoqRat_starGenType_Num_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Num_doReturnFn func() *big.Int

// MoqRat_starGenType_Num_results holds the results of the Rat_starGenType type
type MoqRat_starGenType_Num_results struct {
	Params  MoqRat_starGenType_Num_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Num_doFn
		DoReturnFn MoqRat_starGenType_Num_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Num_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Num_fnRecorder struct {
	Params    MoqRat_starGenType_Num_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Num_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Num_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Num_anyParams struct {
	Recorder *MoqRat_starGenType_Num_fnRecorder
}

// MoqRat_starGenType_Denom_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Denom_params struct{}

// MoqRat_starGenType_Denom_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Denom_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRat_starGenType_Denom_resultsByParams contains the results for a given
// set of parameters for the Rat_starGenType type
type MoqRat_starGenType_Denom_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Denom_paramsKey]*MoqRat_starGenType_Denom_results
}

// MoqRat_starGenType_Denom_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_Denom_doFn func()

// MoqRat_starGenType_Denom_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Denom_doReturnFn func() *big.Int

// MoqRat_starGenType_Denom_results holds the results of the Rat_starGenType
// type
type MoqRat_starGenType_Denom_results struct {
	Params  MoqRat_starGenType_Denom_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Denom_doFn
		DoReturnFn MoqRat_starGenType_Denom_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Denom_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Denom_fnRecorder struct {
	Params    MoqRat_starGenType_Denom_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Denom_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Denom_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Denom_anyParams struct {
	Recorder *MoqRat_starGenType_Denom_fnRecorder
}

// MoqRat_starGenType_Cmp_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Cmp_params struct{ Y *big.Rat }

// MoqRat_starGenType_Cmp_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Cmp_paramsKey struct {
	Params struct{ Y *big.Rat }
	Hashes struct{ Y hash.Hash }
}

// MoqRat_starGenType_Cmp_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Cmp_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Cmp_paramsKey]*MoqRat_starGenType_Cmp_results
}

// MoqRat_starGenType_Cmp_doFn defines the type of function needed when calling
// AndDo for the Rat_starGenType type
type MoqRat_starGenType_Cmp_doFn func(y *big.Rat)

// MoqRat_starGenType_Cmp_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Cmp_doReturnFn func(y *big.Rat) int

// MoqRat_starGenType_Cmp_results holds the results of the Rat_starGenType type
type MoqRat_starGenType_Cmp_results struct {
	Params  MoqRat_starGenType_Cmp_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Cmp_doFn
		DoReturnFn MoqRat_starGenType_Cmp_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Cmp_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Cmp_fnRecorder struct {
	Params    MoqRat_starGenType_Cmp_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Cmp_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Cmp_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Cmp_anyParams struct {
	Recorder *MoqRat_starGenType_Cmp_fnRecorder
}

// MoqRat_starGenType_Add_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Add_params struct{ X, Y *big.Rat }

// MoqRat_starGenType_Add_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Add_paramsKey struct {
	Params struct{ X, Y *big.Rat }
	Hashes struct{ X, Y hash.Hash }
}

// MoqRat_starGenType_Add_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Add_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Add_paramsKey]*MoqRat_starGenType_Add_results
}

// MoqRat_starGenType_Add_doFn defines the type of function needed when calling
// AndDo for the Rat_starGenType type
type MoqRat_starGenType_Add_doFn func(x, y *big.Rat)

// MoqRat_starGenType_Add_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Add_doReturnFn func(x, y *big.Rat) *big.Rat

// MoqRat_starGenType_Add_results holds the results of the Rat_starGenType type
type MoqRat_starGenType_Add_results struct {
	Params  MoqRat_starGenType_Add_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Add_doFn
		DoReturnFn MoqRat_starGenType_Add_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Add_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Add_fnRecorder struct {
	Params    MoqRat_starGenType_Add_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Add_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Add_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Add_anyParams struct {
	Recorder *MoqRat_starGenType_Add_fnRecorder
}

// MoqRat_starGenType_Sub_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Sub_params struct{ X, Y *big.Rat }

// MoqRat_starGenType_Sub_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Sub_paramsKey struct {
	Params struct{ X, Y *big.Rat }
	Hashes struct{ X, Y hash.Hash }
}

// MoqRat_starGenType_Sub_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Sub_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Sub_paramsKey]*MoqRat_starGenType_Sub_results
}

// MoqRat_starGenType_Sub_doFn defines the type of function needed when calling
// AndDo for the Rat_starGenType type
type MoqRat_starGenType_Sub_doFn func(x, y *big.Rat)

// MoqRat_starGenType_Sub_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Sub_doReturnFn func(x, y *big.Rat) *big.Rat

// MoqRat_starGenType_Sub_results holds the results of the Rat_starGenType type
type MoqRat_starGenType_Sub_results struct {
	Params  MoqRat_starGenType_Sub_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Sub_doFn
		DoReturnFn MoqRat_starGenType_Sub_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Sub_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Sub_fnRecorder struct {
	Params    MoqRat_starGenType_Sub_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Sub_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Sub_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Sub_anyParams struct {
	Recorder *MoqRat_starGenType_Sub_fnRecorder
}

// MoqRat_starGenType_Mul_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Mul_params struct{ X, Y *big.Rat }

// MoqRat_starGenType_Mul_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Mul_paramsKey struct {
	Params struct{ X, Y *big.Rat }
	Hashes struct{ X, Y hash.Hash }
}

// MoqRat_starGenType_Mul_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Mul_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Mul_paramsKey]*MoqRat_starGenType_Mul_results
}

// MoqRat_starGenType_Mul_doFn defines the type of function needed when calling
// AndDo for the Rat_starGenType type
type MoqRat_starGenType_Mul_doFn func(x, y *big.Rat)

// MoqRat_starGenType_Mul_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Mul_doReturnFn func(x, y *big.Rat) *big.Rat

// MoqRat_starGenType_Mul_results holds the results of the Rat_starGenType type
type MoqRat_starGenType_Mul_results struct {
	Params  MoqRat_starGenType_Mul_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Mul_doFn
		DoReturnFn MoqRat_starGenType_Mul_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Mul_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Mul_fnRecorder struct {
	Params    MoqRat_starGenType_Mul_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Mul_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Mul_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Mul_anyParams struct {
	Recorder *MoqRat_starGenType_Mul_fnRecorder
}

// MoqRat_starGenType_Quo_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Quo_params struct{ X, Y *big.Rat }

// MoqRat_starGenType_Quo_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Quo_paramsKey struct {
	Params struct{ X, Y *big.Rat }
	Hashes struct{ X, Y hash.Hash }
}

// MoqRat_starGenType_Quo_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Quo_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Quo_paramsKey]*MoqRat_starGenType_Quo_results
}

// MoqRat_starGenType_Quo_doFn defines the type of function needed when calling
// AndDo for the Rat_starGenType type
type MoqRat_starGenType_Quo_doFn func(x, y *big.Rat)

// MoqRat_starGenType_Quo_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Quo_doReturnFn func(x, y *big.Rat) *big.Rat

// MoqRat_starGenType_Quo_results holds the results of the Rat_starGenType type
type MoqRat_starGenType_Quo_results struct {
	Params  MoqRat_starGenType_Quo_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Quo_doFn
		DoReturnFn MoqRat_starGenType_Quo_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Quo_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Quo_fnRecorder struct {
	Params    MoqRat_starGenType_Quo_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Quo_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Quo_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Quo_anyParams struct {
	Recorder *MoqRat_starGenType_Quo_fnRecorder
}

// MoqRat_starGenType_Scan_params holds the params of the Rat_starGenType type
type MoqRat_starGenType_Scan_params struct {
	S  fmt.ScanState
	Ch rune
}

// MoqRat_starGenType_Scan_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_Scan_paramsKey struct {
	Params struct {
		S  fmt.ScanState
		Ch rune
	}
	Hashes struct {
		S  hash.Hash
		Ch hash.Hash
	}
}

// MoqRat_starGenType_Scan_resultsByParams contains the results for a given set
// of parameters for the Rat_starGenType type
type MoqRat_starGenType_Scan_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_Scan_paramsKey]*MoqRat_starGenType_Scan_results
}

// MoqRat_starGenType_Scan_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_Scan_doFn func(s fmt.ScanState, ch rune)

// MoqRat_starGenType_Scan_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_Scan_doReturnFn func(s fmt.ScanState, ch rune) error

// MoqRat_starGenType_Scan_results holds the results of the Rat_starGenType
// type
type MoqRat_starGenType_Scan_results struct {
	Params  MoqRat_starGenType_Scan_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Scan_doFn
		DoReturnFn MoqRat_starGenType_Scan_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_Scan_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_Scan_fnRecorder struct {
	Params    MoqRat_starGenType_Scan_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_Scan_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_Scan_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_Scan_anyParams struct {
	Recorder *MoqRat_starGenType_Scan_fnRecorder
}

// MoqRat_starGenType_SetString_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_SetString_params struct{ S string }

// MoqRat_starGenType_SetString_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_SetString_paramsKey struct {
	Params struct{ S string }
	Hashes struct{ S hash.Hash }
}

// MoqRat_starGenType_SetString_resultsByParams contains the results for a
// given set of parameters for the Rat_starGenType type
type MoqRat_starGenType_SetString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_SetString_paramsKey]*MoqRat_starGenType_SetString_results
}

// MoqRat_starGenType_SetString_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_SetString_doFn func(s string)

// MoqRat_starGenType_SetString_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_SetString_doReturnFn func(s string) (*big.Rat, bool)

// MoqRat_starGenType_SetString_results holds the results of the
// Rat_starGenType type
type MoqRat_starGenType_SetString_results struct {
	Params  MoqRat_starGenType_SetString_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetString_doFn
		DoReturnFn MoqRat_starGenType_SetString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_SetString_fnRecorder routes recorded function calls to
// the MoqRat_starGenType moq
type MoqRat_starGenType_SetString_fnRecorder struct {
	Params    MoqRat_starGenType_SetString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_SetString_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_SetString_anyParams isolates the any params functions of
// the Rat_starGenType type
type MoqRat_starGenType_SetString_anyParams struct {
	Recorder *MoqRat_starGenType_SetString_fnRecorder
}

// MoqRat_starGenType_String_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_String_params struct{}

// MoqRat_starGenType_String_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRat_starGenType_String_resultsByParams contains the results for a given
// set of parameters for the Rat_starGenType type
type MoqRat_starGenType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_String_paramsKey]*MoqRat_starGenType_String_results
}

// MoqRat_starGenType_String_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_String_doFn func()

// MoqRat_starGenType_String_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_String_doReturnFn func() string

// MoqRat_starGenType_String_results holds the results of the Rat_starGenType
// type
type MoqRat_starGenType_String_results struct {
	Params  MoqRat_starGenType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_String_doFn
		DoReturnFn MoqRat_starGenType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_String_fnRecorder routes recorded function calls to the
// MoqRat_starGenType moq
type MoqRat_starGenType_String_fnRecorder struct {
	Params    MoqRat_starGenType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_String_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_String_anyParams isolates the any params functions of the
// Rat_starGenType type
type MoqRat_starGenType_String_anyParams struct {
	Recorder *MoqRat_starGenType_String_fnRecorder
}

// MoqRat_starGenType_RatString_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_RatString_params struct{}

// MoqRat_starGenType_RatString_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_RatString_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRat_starGenType_RatString_resultsByParams contains the results for a
// given set of parameters for the Rat_starGenType type
type MoqRat_starGenType_RatString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_RatString_paramsKey]*MoqRat_starGenType_RatString_results
}

// MoqRat_starGenType_RatString_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_RatString_doFn func()

// MoqRat_starGenType_RatString_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_RatString_doReturnFn func() string

// MoqRat_starGenType_RatString_results holds the results of the
// Rat_starGenType type
type MoqRat_starGenType_RatString_results struct {
	Params  MoqRat_starGenType_RatString_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_RatString_doFn
		DoReturnFn MoqRat_starGenType_RatString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_RatString_fnRecorder routes recorded function calls to
// the MoqRat_starGenType moq
type MoqRat_starGenType_RatString_fnRecorder struct {
	Params    MoqRat_starGenType_RatString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_RatString_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_RatString_anyParams isolates the any params functions of
// the Rat_starGenType type
type MoqRat_starGenType_RatString_anyParams struct {
	Recorder *MoqRat_starGenType_RatString_fnRecorder
}

// MoqRat_starGenType_FloatString_params holds the params of the
// Rat_starGenType type
type MoqRat_starGenType_FloatString_params struct{ Prec int }

// MoqRat_starGenType_FloatString_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_FloatString_paramsKey struct {
	Params struct{ Prec int }
	Hashes struct{ Prec hash.Hash }
}

// MoqRat_starGenType_FloatString_resultsByParams contains the results for a
// given set of parameters for the Rat_starGenType type
type MoqRat_starGenType_FloatString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_FloatString_paramsKey]*MoqRat_starGenType_FloatString_results
}

// MoqRat_starGenType_FloatString_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_FloatString_doFn func(prec int)

// MoqRat_starGenType_FloatString_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_FloatString_doReturnFn func(prec int) string

// MoqRat_starGenType_FloatString_results holds the results of the
// Rat_starGenType type
type MoqRat_starGenType_FloatString_results struct {
	Params  MoqRat_starGenType_FloatString_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_FloatString_doFn
		DoReturnFn MoqRat_starGenType_FloatString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_FloatString_fnRecorder routes recorded function calls to
// the MoqRat_starGenType moq
type MoqRat_starGenType_FloatString_fnRecorder struct {
	Params    MoqRat_starGenType_FloatString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_FloatString_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_FloatString_anyParams isolates the any params functions
// of the Rat_starGenType type
type MoqRat_starGenType_FloatString_anyParams struct {
	Recorder *MoqRat_starGenType_FloatString_fnRecorder
}

// MoqRat_starGenType_GobEncode_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_GobEncode_params struct{}

// MoqRat_starGenType_GobEncode_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_GobEncode_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRat_starGenType_GobEncode_resultsByParams contains the results for a
// given set of parameters for the Rat_starGenType type
type MoqRat_starGenType_GobEncode_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_GobEncode_paramsKey]*MoqRat_starGenType_GobEncode_results
}

// MoqRat_starGenType_GobEncode_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_GobEncode_doFn func()

// MoqRat_starGenType_GobEncode_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_GobEncode_doReturnFn func() ([]byte, error)

// MoqRat_starGenType_GobEncode_results holds the results of the
// Rat_starGenType type
type MoqRat_starGenType_GobEncode_results struct {
	Params  MoqRat_starGenType_GobEncode_params
	Results []struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_GobEncode_doFn
		DoReturnFn MoqRat_starGenType_GobEncode_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_GobEncode_fnRecorder routes recorded function calls to
// the MoqRat_starGenType moq
type MoqRat_starGenType_GobEncode_fnRecorder struct {
	Params    MoqRat_starGenType_GobEncode_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_GobEncode_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_GobEncode_anyParams isolates the any params functions of
// the Rat_starGenType type
type MoqRat_starGenType_GobEncode_anyParams struct {
	Recorder *MoqRat_starGenType_GobEncode_fnRecorder
}

// MoqRat_starGenType_GobDecode_params holds the params of the Rat_starGenType
// type
type MoqRat_starGenType_GobDecode_params struct{ Buf []byte }

// MoqRat_starGenType_GobDecode_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_GobDecode_paramsKey struct {
	Params struct{}
	Hashes struct{ Buf hash.Hash }
}

// MoqRat_starGenType_GobDecode_resultsByParams contains the results for a
// given set of parameters for the Rat_starGenType type
type MoqRat_starGenType_GobDecode_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_GobDecode_paramsKey]*MoqRat_starGenType_GobDecode_results
}

// MoqRat_starGenType_GobDecode_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_GobDecode_doFn func(buf []byte)

// MoqRat_starGenType_GobDecode_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_GobDecode_doReturnFn func(buf []byte) error

// MoqRat_starGenType_GobDecode_results holds the results of the
// Rat_starGenType type
type MoqRat_starGenType_GobDecode_results struct {
	Params  MoqRat_starGenType_GobDecode_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_GobDecode_doFn
		DoReturnFn MoqRat_starGenType_GobDecode_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_GobDecode_fnRecorder routes recorded function calls to
// the MoqRat_starGenType moq
type MoqRat_starGenType_GobDecode_fnRecorder struct {
	Params    MoqRat_starGenType_GobDecode_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_GobDecode_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_GobDecode_anyParams isolates the any params functions of
// the Rat_starGenType type
type MoqRat_starGenType_GobDecode_anyParams struct {
	Recorder *MoqRat_starGenType_GobDecode_fnRecorder
}

// MoqRat_starGenType_MarshalText_params holds the params of the
// Rat_starGenType type
type MoqRat_starGenType_MarshalText_params struct{}

// MoqRat_starGenType_MarshalText_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_MarshalText_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRat_starGenType_MarshalText_resultsByParams contains the results for a
// given set of parameters for the Rat_starGenType type
type MoqRat_starGenType_MarshalText_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_MarshalText_paramsKey]*MoqRat_starGenType_MarshalText_results
}

// MoqRat_starGenType_MarshalText_doFn defines the type of function needed when
// calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_MarshalText_doFn func()

// MoqRat_starGenType_MarshalText_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_MarshalText_doReturnFn func() (text []byte, err error)

// MoqRat_starGenType_MarshalText_results holds the results of the
// Rat_starGenType type
type MoqRat_starGenType_MarshalText_results struct {
	Params  MoqRat_starGenType_MarshalText_params
	Results []struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_MarshalText_doFn
		DoReturnFn MoqRat_starGenType_MarshalText_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_MarshalText_fnRecorder routes recorded function calls to
// the MoqRat_starGenType moq
type MoqRat_starGenType_MarshalText_fnRecorder struct {
	Params    MoqRat_starGenType_MarshalText_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_MarshalText_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_MarshalText_anyParams isolates the any params functions
// of the Rat_starGenType type
type MoqRat_starGenType_MarshalText_anyParams struct {
	Recorder *MoqRat_starGenType_MarshalText_fnRecorder
}

// MoqRat_starGenType_UnmarshalText_params holds the params of the
// Rat_starGenType type
type MoqRat_starGenType_UnmarshalText_params struct{ Text []byte }

// MoqRat_starGenType_UnmarshalText_paramsKey holds the map key params of the
// Rat_starGenType type
type MoqRat_starGenType_UnmarshalText_paramsKey struct {
	Params struct{}
	Hashes struct{ Text hash.Hash }
}

// MoqRat_starGenType_UnmarshalText_resultsByParams contains the results for a
// given set of parameters for the Rat_starGenType type
type MoqRat_starGenType_UnmarshalText_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRat_starGenType_UnmarshalText_paramsKey]*MoqRat_starGenType_UnmarshalText_results
}

// MoqRat_starGenType_UnmarshalText_doFn defines the type of function needed
// when calling AndDo for the Rat_starGenType type
type MoqRat_starGenType_UnmarshalText_doFn func(text []byte)

// MoqRat_starGenType_UnmarshalText_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Rat_starGenType type
type MoqRat_starGenType_UnmarshalText_doReturnFn func(text []byte) error

// MoqRat_starGenType_UnmarshalText_results holds the results of the
// Rat_starGenType type
type MoqRat_starGenType_UnmarshalText_results struct {
	Params  MoqRat_starGenType_UnmarshalText_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_UnmarshalText_doFn
		DoReturnFn MoqRat_starGenType_UnmarshalText_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRat_starGenType_UnmarshalText_fnRecorder routes recorded function calls
// to the MoqRat_starGenType moq
type MoqRat_starGenType_UnmarshalText_fnRecorder struct {
	Params    MoqRat_starGenType_UnmarshalText_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRat_starGenType_UnmarshalText_results
	Moq       *MoqRat_starGenType
}

// MoqRat_starGenType_UnmarshalText_anyParams isolates the any params functions
// of the Rat_starGenType type
type MoqRat_starGenType_UnmarshalText_anyParams struct {
	Recorder *MoqRat_starGenType_UnmarshalText_fnRecorder
}

// NewMoqRat_starGenType creates a new moq of the Rat_starGenType type
func NewMoqRat_starGenType(scene *moq.Scene, config *moq.Config) *MoqRat_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqRat_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqRat_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				SetFloat64 struct {
					F moq.ParamIndexing
				}
				Float32 struct{}
				Float64 struct{}
				SetFrac struct {
					A moq.ParamIndexing
					B moq.ParamIndexing
				}
				SetFrac64 struct {
					A moq.ParamIndexing
					B moq.ParamIndexing
				}
				SetInt struct {
					X moq.ParamIndexing
				}
				SetInt64 struct {
					X moq.ParamIndexing
				}
				SetUint64 struct {
					X moq.ParamIndexing
				}
				Set struct {
					X moq.ParamIndexing
				}
				Abs struct {
					X moq.ParamIndexing
				}
				Neg struct {
					X moq.ParamIndexing
				}
				Inv struct {
					X moq.ParamIndexing
				}
				Sign  struct{}
				IsInt struct{}
				Num   struct{}
				Denom struct{}
				Cmp   struct {
					Y moq.ParamIndexing
				}
				Add struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Sub struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Mul struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Quo struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Scan struct {
					S  moq.ParamIndexing
					Ch moq.ParamIndexing
				}
				SetString struct {
					S moq.ParamIndexing
				}
				String      struct{}
				RatString   struct{}
				FloatString struct {
					Prec moq.ParamIndexing
				}
				GobEncode struct{}
				GobDecode struct {
					Buf moq.ParamIndexing
				}
				MarshalText   struct{}
				UnmarshalText struct {
					Text moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			SetFloat64 struct {
				F moq.ParamIndexing
			}
			Float32 struct{}
			Float64 struct{}
			SetFrac struct {
				A moq.ParamIndexing
				B moq.ParamIndexing
			}
			SetFrac64 struct {
				A moq.ParamIndexing
				B moq.ParamIndexing
			}
			SetInt struct {
				X moq.ParamIndexing
			}
			SetInt64 struct {
				X moq.ParamIndexing
			}
			SetUint64 struct {
				X moq.ParamIndexing
			}
			Set struct {
				X moq.ParamIndexing
			}
			Abs struct {
				X moq.ParamIndexing
			}
			Neg struct {
				X moq.ParamIndexing
			}
			Inv struct {
				X moq.ParamIndexing
			}
			Sign  struct{}
			IsInt struct{}
			Num   struct{}
			Denom struct{}
			Cmp   struct {
				Y moq.ParamIndexing
			}
			Add struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Sub struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Mul struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Quo struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Scan struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}
			SetString struct {
				S moq.ParamIndexing
			}
			String      struct{}
			RatString   struct{}
			FloatString struct {
				Prec moq.ParamIndexing
			}
			GobEncode struct{}
			GobDecode struct {
				Buf moq.ParamIndexing
			}
			MarshalText   struct{}
			UnmarshalText struct {
				Text moq.ParamIndexing
			}
		}{
			SetFloat64: struct {
				F moq.ParamIndexing
			}{
				F: moq.ParamIndexByValue,
			},
			Float32: struct{}{},
			Float64: struct{}{},
			SetFrac: struct {
				A moq.ParamIndexing
				B moq.ParamIndexing
			}{
				A: moq.ParamIndexByHash,
				B: moq.ParamIndexByHash,
			},
			SetFrac64: struct {
				A moq.ParamIndexing
				B moq.ParamIndexing
			}{
				A: moq.ParamIndexByValue,
				B: moq.ParamIndexByValue,
			},
			SetInt: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			SetInt64: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			SetUint64: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			Set: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Abs: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Neg: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Inv: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Sign:  struct{}{},
			IsInt: struct{}{},
			Num:   struct{}{},
			Denom: struct{}{},
			Cmp: struct {
				Y moq.ParamIndexing
			}{
				Y: moq.ParamIndexByHash,
			},
			Add: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Sub: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Mul: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Quo: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Scan: struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}{
				S:  moq.ParamIndexByHash,
				Ch: moq.ParamIndexByValue,
			},
			SetString: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			String:    struct{}{},
			RatString: struct{}{},
			FloatString: struct {
				Prec moq.ParamIndexing
			}{
				Prec: moq.ParamIndexByValue,
			},
			GobEncode: struct{}{},
			GobDecode: struct {
				Buf moq.ParamIndexing
			}{
				Buf: moq.ParamIndexByHash,
			},
			MarshalText: struct{}{},
			UnmarshalText: struct {
				Text moq.ParamIndexing
			}{
				Text: moq.ParamIndexByHash,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Rat_starGenType type
func (m *MoqRat_starGenType) Mock() *MoqRat_starGenType_mock { return m.Moq }

func (m *MoqRat_starGenType_mock) SetFloat64(f float64) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_SetFloat64_params{
		F: f,
	}
	var results *MoqRat_starGenType_SetFloat64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetFloat64 {
		paramsKey := m.Moq.ParamsKey_SetFloat64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetFloat64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetFloat64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetFloat64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(f)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(f)
	}
	return
}

func (m *MoqRat_starGenType_mock) Float32() (f float32, exact bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Float32_params{}
	var results *MoqRat_starGenType_Float32_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Float32 {
		paramsKey := m.Moq.ParamsKey_Float32(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Float32(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Float32(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Float32(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		f = result.Values.F
		exact = result.Values.Exact
	}
	if result.DoReturnFn != nil {
		f, exact = result.DoReturnFn()
	}
	return
}

func (m *MoqRat_starGenType_mock) Float64() (f float64, exact bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Float64_params{}
	var results *MoqRat_starGenType_Float64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Float64 {
		paramsKey := m.Moq.ParamsKey_Float64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Float64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Float64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Float64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		f = result.Values.F
		exact = result.Values.Exact
	}
	if result.DoReturnFn != nil {
		f, exact = result.DoReturnFn()
	}
	return
}

func (m *MoqRat_starGenType_mock) SetFrac(a, b *big.Int) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_SetFrac_params{
		A: a,
		B: b,
	}
	var results *MoqRat_starGenType_SetFrac_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetFrac {
		paramsKey := m.Moq.ParamsKey_SetFrac(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetFrac(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetFrac(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetFrac(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(a, b)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(a, b)
	}
	return
}

func (m *MoqRat_starGenType_mock) SetFrac64(a, b int64) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_SetFrac64_params{
		A: a,
		B: b,
	}
	var results *MoqRat_starGenType_SetFrac64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetFrac64 {
		paramsKey := m.Moq.ParamsKey_SetFrac64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetFrac64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetFrac64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetFrac64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(a, b)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(a, b)
	}
	return
}

func (m *MoqRat_starGenType_mock) SetInt(x *big.Int) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_SetInt_params{
		X: x,
	}
	var results *MoqRat_starGenType_SetInt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetInt {
		paramsKey := m.Moq.ParamsKey_SetInt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetInt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetInt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetInt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqRat_starGenType_mock) SetInt64(x int64) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_SetInt64_params{
		X: x,
	}
	var results *MoqRat_starGenType_SetInt64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetInt64 {
		paramsKey := m.Moq.ParamsKey_SetInt64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetInt64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetInt64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetInt64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqRat_starGenType_mock) SetUint64(x uint64) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_SetUint64_params{
		X: x,
	}
	var results *MoqRat_starGenType_SetUint64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetUint64 {
		paramsKey := m.Moq.ParamsKey_SetUint64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetUint64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetUint64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetUint64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqRat_starGenType_mock) Set(x *big.Rat) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Set_params{
		X: x,
	}
	var results *MoqRat_starGenType_Set_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Set {
		paramsKey := m.Moq.ParamsKey_Set(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Set(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Set(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Set(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqRat_starGenType_mock) Abs(x *big.Rat) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Abs_params{
		X: x,
	}
	var results *MoqRat_starGenType_Abs_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Abs {
		paramsKey := m.Moq.ParamsKey_Abs(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Abs(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Abs(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Abs(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqRat_starGenType_mock) Neg(x *big.Rat) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Neg_params{
		X: x,
	}
	var results *MoqRat_starGenType_Neg_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Neg {
		paramsKey := m.Moq.ParamsKey_Neg(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Neg(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Neg(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Neg(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqRat_starGenType_mock) Inv(x *big.Rat) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Inv_params{
		X: x,
	}
	var results *MoqRat_starGenType_Inv_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Inv {
		paramsKey := m.Moq.ParamsKey_Inv(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Inv(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Inv(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Inv(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqRat_starGenType_mock) Sign() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Sign_params{}
	var results *MoqRat_starGenType_Sign_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Sign {
		paramsKey := m.Moq.ParamsKey_Sign(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Sign(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Sign(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Sign(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRat_starGenType_mock) IsInt() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_IsInt_params{}
	var results *MoqRat_starGenType_IsInt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsInt {
		paramsKey := m.Moq.ParamsKey_IsInt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsInt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsInt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsInt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRat_starGenType_mock) Num() (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Num_params{}
	var results *MoqRat_starGenType_Num_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Num {
		paramsKey := m.Moq.ParamsKey_Num(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Num(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Num(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Num(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRat_starGenType_mock) Denom() (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Denom_params{}
	var results *MoqRat_starGenType_Denom_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Denom {
		paramsKey := m.Moq.ParamsKey_Denom(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Denom(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Denom(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Denom(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRat_starGenType_mock) Cmp(y *big.Rat) (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Cmp_params{
		Y: y,
	}
	var results *MoqRat_starGenType_Cmp_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Cmp {
		paramsKey := m.Moq.ParamsKey_Cmp(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Cmp(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Cmp(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Cmp(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(y)
	}
	return
}

func (m *MoqRat_starGenType_mock) Add(x, y *big.Rat) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Add_params{
		X: x,
		Y: y,
	}
	var results *MoqRat_starGenType_Add_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Add {
		paramsKey := m.Moq.ParamsKey_Add(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Add(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Add(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Add(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqRat_starGenType_mock) Sub(x, y *big.Rat) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Sub_params{
		X: x,
		Y: y,
	}
	var results *MoqRat_starGenType_Sub_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Sub {
		paramsKey := m.Moq.ParamsKey_Sub(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Sub(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Sub(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Sub(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqRat_starGenType_mock) Mul(x, y *big.Rat) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Mul_params{
		X: x,
		Y: y,
	}
	var results *MoqRat_starGenType_Mul_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Mul {
		paramsKey := m.Moq.ParamsKey_Mul(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Mul(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Mul(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Mul(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqRat_starGenType_mock) Quo(x, y *big.Rat) (result1 *big.Rat) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Quo_params{
		X: x,
		Y: y,
	}
	var results *MoqRat_starGenType_Quo_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Quo {
		paramsKey := m.Moq.ParamsKey_Quo(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Quo(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Quo(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Quo(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqRat_starGenType_mock) Scan(s fmt.ScanState, ch rune) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_Scan_params{
		S:  s,
		Ch: ch,
	}
	var results *MoqRat_starGenType_Scan_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Scan {
		paramsKey := m.Moq.ParamsKey_Scan(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Scan(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Scan(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Scan(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, ch)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s, ch)
	}
	return
}

func (m *MoqRat_starGenType_mock) SetString(s string) (result1 *big.Rat, result2 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_SetString_params{
		S: s,
	}
	var results *MoqRat_starGenType_SetString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetString {
		paramsKey := m.Moq.ParamsKey_SetString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(s)
	}
	return
}

func (m *MoqRat_starGenType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_String_params{}
	var results *MoqRat_starGenType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRat_starGenType_mock) RatString() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_RatString_params{}
	var results *MoqRat_starGenType_RatString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_RatString {
		paramsKey := m.Moq.ParamsKey_RatString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_RatString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_RatString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_RatString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRat_starGenType_mock) FloatString(prec int) (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_FloatString_params{
		Prec: prec,
	}
	var results *MoqRat_starGenType_FloatString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FloatString {
		paramsKey := m.Moq.ParamsKey_FloatString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FloatString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FloatString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FloatString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(prec)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(prec)
	}
	return
}

func (m *MoqRat_starGenType_mock) GobEncode() (result1 []byte, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_GobEncode_params{}
	var results *MoqRat_starGenType_GobEncode_results
	for _, resultsByParams := range m.Moq.ResultsByParams_GobEncode {
		paramsKey := m.Moq.ParamsKey_GobEncode(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_GobEncode(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_GobEncode(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_GobEncode(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqRat_starGenType_mock) GobDecode(buf []byte) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_GobDecode_params{
		Buf: buf,
	}
	var results *MoqRat_starGenType_GobDecode_results
	for _, resultsByParams := range m.Moq.ResultsByParams_GobDecode {
		paramsKey := m.Moq.ParamsKey_GobDecode(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_GobDecode(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_GobDecode(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_GobDecode(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(buf)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(buf)
	}
	return
}

func (m *MoqRat_starGenType_mock) MarshalText() (text []byte, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_MarshalText_params{}
	var results *MoqRat_starGenType_MarshalText_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MarshalText {
		paramsKey := m.Moq.ParamsKey_MarshalText(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MarshalText(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MarshalText(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MarshalText(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		text = result.Values.Text
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		text, err = result.DoReturnFn()
	}
	return
}

func (m *MoqRat_starGenType_mock) UnmarshalText(text []byte) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqRat_starGenType_UnmarshalText_params{
		Text: text,
	}
	var results *MoqRat_starGenType_UnmarshalText_results
	for _, resultsByParams := range m.Moq.ResultsByParams_UnmarshalText {
		paramsKey := m.Moq.ParamsKey_UnmarshalText(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_UnmarshalText(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_UnmarshalText(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_UnmarshalText(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(text)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(text)
	}
	return
}

// OnCall returns the recorder implementation of the Rat_starGenType type
func (m *MoqRat_starGenType) OnCall() *MoqRat_starGenType_recorder {
	return &MoqRat_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqRat_starGenType_recorder) SetFloat64(f float64) *MoqRat_starGenType_SetFloat64_fnRecorder {
	return &MoqRat_starGenType_SetFloat64_fnRecorder{
		Params: MoqRat_starGenType_SetFloat64_params{
			F: f,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_SetFloat64_fnRecorder) Any() *MoqRat_starGenType_SetFloat64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFloat64(r.Params))
		return nil
	}
	return &MoqRat_starGenType_SetFloat64_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_SetFloat64_anyParams) F() *MoqRat_starGenType_SetFloat64_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_SetFloat64_fnRecorder) Seq() *MoqRat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFloat64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_SetFloat64_fnRecorder) NoSeq() *MoqRat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFloat64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_SetFloat64_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetFloat64_doFn
		DoReturnFn MoqRat_starGenType_SetFloat64_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_SetFloat64_fnRecorder) AndDo(fn MoqRat_starGenType_SetFloat64_doFn) *MoqRat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_SetFloat64_fnRecorder) DoReturnResults(fn MoqRat_starGenType_SetFloat64_doReturnFn) *MoqRat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetFloat64_doFn
		DoReturnFn MoqRat_starGenType_SetFloat64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_SetFloat64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_SetFloat64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetFloat64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_SetFloat64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_SetFloat64_paramsKey]*MoqRat_starGenType_SetFloat64_results{},
		}
		r.Moq.ResultsByParams_SetFloat64 = append(r.Moq.ResultsByParams_SetFloat64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetFloat64) {
			copy(r.Moq.ResultsByParams_SetFloat64[insertAt+1:], r.Moq.ResultsByParams_SetFloat64[insertAt:0])
			r.Moq.ResultsByParams_SetFloat64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetFloat64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_SetFloat64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_SetFloat64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_SetFloat64_doFn
				DoReturnFn MoqRat_starGenType_SetFloat64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_SetFloat64(params MoqRat_starGenType_SetFloat64_params) string {
	return fmt.Sprintf("SetFloat64(%#v)", params.F)
}

func (m *MoqRat_starGenType) ParamsKey_SetFloat64(params MoqRat_starGenType_SetFloat64_params, anyParams uint64) MoqRat_starGenType_SetFloat64_paramsKey {
	m.Scene.T.Helper()
	var fUsed float64
	var fUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetFloat64.F == moq.ParamIndexByValue {
			fUsed = params.F
		} else {
			fUsedHash = hash.DeepHash(params.F)
		}
	}
	return MoqRat_starGenType_SetFloat64_paramsKey{
		Params: struct{ F float64 }{
			F: fUsed,
		},
		Hashes: struct{ F hash.Hash }{
			F: fUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) Float32() *MoqRat_starGenType_Float32_fnRecorder {
	return &MoqRat_starGenType_Float32_fnRecorder{
		Params:   MoqRat_starGenType_Float32_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Float32_fnRecorder) Any() *MoqRat_starGenType_Float32_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float32(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Float32_anyParams{Recorder: r}
}

func (r *MoqRat_starGenType_Float32_fnRecorder) Seq() *MoqRat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float32(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Float32_fnRecorder) NoSeq() *MoqRat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float32(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Float32_fnRecorder) ReturnResults(f float32, exact bool) *MoqRat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			F     float32
			Exact bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Float32_doFn
		DoReturnFn MoqRat_starGenType_Float32_doReturnFn
	}{
		Values: &struct {
			F     float32
			Exact bool
		}{
			F:     f,
			Exact: exact,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Float32_fnRecorder) AndDo(fn MoqRat_starGenType_Float32_doFn) *MoqRat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Float32_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Float32_doReturnFn) *MoqRat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			F     float32
			Exact bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Float32_doFn
		DoReturnFn MoqRat_starGenType_Float32_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Float32_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Float32_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Float32 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Float32_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Float32_paramsKey]*MoqRat_starGenType_Float32_results{},
		}
		r.Moq.ResultsByParams_Float32 = append(r.Moq.ResultsByParams_Float32, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Float32) {
			copy(r.Moq.ResultsByParams_Float32[insertAt+1:], r.Moq.ResultsByParams_Float32[insertAt:0])
			r.Moq.ResultsByParams_Float32[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Float32(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Float32_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Float32_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					F     float32
					Exact bool
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Float32_doFn
				DoReturnFn MoqRat_starGenType_Float32_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Float32(params MoqRat_starGenType_Float32_params) string {
	return fmt.Sprintf("Float32()")
}

func (m *MoqRat_starGenType) ParamsKey_Float32(params MoqRat_starGenType_Float32_params, anyParams uint64) MoqRat_starGenType_Float32_paramsKey {
	m.Scene.T.Helper()
	return MoqRat_starGenType_Float32_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRat_starGenType_recorder) Float64() *MoqRat_starGenType_Float64_fnRecorder {
	return &MoqRat_starGenType_Float64_fnRecorder{
		Params:   MoqRat_starGenType_Float64_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Float64_fnRecorder) Any() *MoqRat_starGenType_Float64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float64(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Float64_anyParams{Recorder: r}
}

func (r *MoqRat_starGenType_Float64_fnRecorder) Seq() *MoqRat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Float64_fnRecorder) NoSeq() *MoqRat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Float64_fnRecorder) ReturnResults(f float64, exact bool) *MoqRat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			F     float64
			Exact bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Float64_doFn
		DoReturnFn MoqRat_starGenType_Float64_doReturnFn
	}{
		Values: &struct {
			F     float64
			Exact bool
		}{
			F:     f,
			Exact: exact,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Float64_fnRecorder) AndDo(fn MoqRat_starGenType_Float64_doFn) *MoqRat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Float64_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Float64_doReturnFn) *MoqRat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			F     float64
			Exact bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Float64_doFn
		DoReturnFn MoqRat_starGenType_Float64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Float64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Float64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Float64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Float64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Float64_paramsKey]*MoqRat_starGenType_Float64_results{},
		}
		r.Moq.ResultsByParams_Float64 = append(r.Moq.ResultsByParams_Float64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Float64) {
			copy(r.Moq.ResultsByParams_Float64[insertAt+1:], r.Moq.ResultsByParams_Float64[insertAt:0])
			r.Moq.ResultsByParams_Float64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Float64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Float64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Float64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					F     float64
					Exact bool
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Float64_doFn
				DoReturnFn MoqRat_starGenType_Float64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Float64(params MoqRat_starGenType_Float64_params) string {
	return fmt.Sprintf("Float64()")
}

func (m *MoqRat_starGenType) ParamsKey_Float64(params MoqRat_starGenType_Float64_params, anyParams uint64) MoqRat_starGenType_Float64_paramsKey {
	m.Scene.T.Helper()
	return MoqRat_starGenType_Float64_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRat_starGenType_recorder) SetFrac(a, b *big.Int) *MoqRat_starGenType_SetFrac_fnRecorder {
	return &MoqRat_starGenType_SetFrac_fnRecorder{
		Params: MoqRat_starGenType_SetFrac_params{
			A: a,
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_SetFrac_fnRecorder) Any() *MoqRat_starGenType_SetFrac_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFrac(r.Params))
		return nil
	}
	return &MoqRat_starGenType_SetFrac_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_SetFrac_anyParams) A() *MoqRat_starGenType_SetFrac_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRat_starGenType_SetFrac_anyParams) B() *MoqRat_starGenType_SetFrac_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRat_starGenType_SetFrac_fnRecorder) Seq() *MoqRat_starGenType_SetFrac_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFrac(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_SetFrac_fnRecorder) NoSeq() *MoqRat_starGenType_SetFrac_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFrac(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_SetFrac_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_SetFrac_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetFrac_doFn
		DoReturnFn MoqRat_starGenType_SetFrac_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_SetFrac_fnRecorder) AndDo(fn MoqRat_starGenType_SetFrac_doFn) *MoqRat_starGenType_SetFrac_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_SetFrac_fnRecorder) DoReturnResults(fn MoqRat_starGenType_SetFrac_doReturnFn) *MoqRat_starGenType_SetFrac_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetFrac_doFn
		DoReturnFn MoqRat_starGenType_SetFrac_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_SetFrac_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_SetFrac_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetFrac {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_SetFrac_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_SetFrac_paramsKey]*MoqRat_starGenType_SetFrac_results{},
		}
		r.Moq.ResultsByParams_SetFrac = append(r.Moq.ResultsByParams_SetFrac, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetFrac) {
			copy(r.Moq.ResultsByParams_SetFrac[insertAt+1:], r.Moq.ResultsByParams_SetFrac[insertAt:0])
			r.Moq.ResultsByParams_SetFrac[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetFrac(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_SetFrac_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_SetFrac_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_SetFrac_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_SetFrac_doFn
				DoReturnFn MoqRat_starGenType_SetFrac_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_SetFrac(params MoqRat_starGenType_SetFrac_params) string {
	return fmt.Sprintf("SetFrac(%#v, %#v)", params.A, params.B)
}

func (m *MoqRat_starGenType) ParamsKey_SetFrac(params MoqRat_starGenType_SetFrac_params, anyParams uint64) MoqRat_starGenType_SetFrac_paramsKey {
	m.Scene.T.Helper()
	var aUsed *big.Int
	var aUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetFrac.A == moq.ParamIndexByValue {
			aUsed = params.A
		} else {
			aUsedHash = hash.DeepHash(params.A)
		}
	}
	var bUsed *big.Int
	var bUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.SetFrac.B == moq.ParamIndexByValue {
			bUsed = params.B
		} else {
			bUsedHash = hash.DeepHash(params.B)
		}
	}
	return MoqRat_starGenType_SetFrac_paramsKey{
		Params: struct{ A, B *big.Int }{
			A: aUsed,
			B: bUsed,
		},
		Hashes: struct{ A, B hash.Hash }{
			A: aUsedHash,
			B: bUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) SetFrac64(a, b int64) *MoqRat_starGenType_SetFrac64_fnRecorder {
	return &MoqRat_starGenType_SetFrac64_fnRecorder{
		Params: MoqRat_starGenType_SetFrac64_params{
			A: a,
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_SetFrac64_fnRecorder) Any() *MoqRat_starGenType_SetFrac64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFrac64(r.Params))
		return nil
	}
	return &MoqRat_starGenType_SetFrac64_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_SetFrac64_anyParams) A() *MoqRat_starGenType_SetFrac64_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRat_starGenType_SetFrac64_anyParams) B() *MoqRat_starGenType_SetFrac64_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRat_starGenType_SetFrac64_fnRecorder) Seq() *MoqRat_starGenType_SetFrac64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFrac64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_SetFrac64_fnRecorder) NoSeq() *MoqRat_starGenType_SetFrac64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFrac64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_SetFrac64_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_SetFrac64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetFrac64_doFn
		DoReturnFn MoqRat_starGenType_SetFrac64_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_SetFrac64_fnRecorder) AndDo(fn MoqRat_starGenType_SetFrac64_doFn) *MoqRat_starGenType_SetFrac64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_SetFrac64_fnRecorder) DoReturnResults(fn MoqRat_starGenType_SetFrac64_doReturnFn) *MoqRat_starGenType_SetFrac64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetFrac64_doFn
		DoReturnFn MoqRat_starGenType_SetFrac64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_SetFrac64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_SetFrac64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetFrac64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_SetFrac64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_SetFrac64_paramsKey]*MoqRat_starGenType_SetFrac64_results{},
		}
		r.Moq.ResultsByParams_SetFrac64 = append(r.Moq.ResultsByParams_SetFrac64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetFrac64) {
			copy(r.Moq.ResultsByParams_SetFrac64[insertAt+1:], r.Moq.ResultsByParams_SetFrac64[insertAt:0])
			r.Moq.ResultsByParams_SetFrac64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetFrac64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_SetFrac64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_SetFrac64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_SetFrac64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_SetFrac64_doFn
				DoReturnFn MoqRat_starGenType_SetFrac64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_SetFrac64(params MoqRat_starGenType_SetFrac64_params) string {
	return fmt.Sprintf("SetFrac64(%#v, %#v)", params.A, params.B)
}

func (m *MoqRat_starGenType) ParamsKey_SetFrac64(params MoqRat_starGenType_SetFrac64_params, anyParams uint64) MoqRat_starGenType_SetFrac64_paramsKey {
	m.Scene.T.Helper()
	var aUsed int64
	var aUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetFrac64.A == moq.ParamIndexByValue {
			aUsed = params.A
		} else {
			aUsedHash = hash.DeepHash(params.A)
		}
	}
	var bUsed int64
	var bUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.SetFrac64.B == moq.ParamIndexByValue {
			bUsed = params.B
		} else {
			bUsedHash = hash.DeepHash(params.B)
		}
	}
	return MoqRat_starGenType_SetFrac64_paramsKey{
		Params: struct{ A, B int64 }{
			A: aUsed,
			B: bUsed,
		},
		Hashes: struct{ A, B hash.Hash }{
			A: aUsedHash,
			B: bUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) SetInt(x *big.Int) *MoqRat_starGenType_SetInt_fnRecorder {
	return &MoqRat_starGenType_SetInt_fnRecorder{
		Params: MoqRat_starGenType_SetInt_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_SetInt_fnRecorder) Any() *MoqRat_starGenType_SetInt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt(r.Params))
		return nil
	}
	return &MoqRat_starGenType_SetInt_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_SetInt_anyParams) X() *MoqRat_starGenType_SetInt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_SetInt_fnRecorder) Seq() *MoqRat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_SetInt_fnRecorder) NoSeq() *MoqRat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_SetInt_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetInt_doFn
		DoReturnFn MoqRat_starGenType_SetInt_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_SetInt_fnRecorder) AndDo(fn MoqRat_starGenType_SetInt_doFn) *MoqRat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_SetInt_fnRecorder) DoReturnResults(fn MoqRat_starGenType_SetInt_doReturnFn) *MoqRat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetInt_doFn
		DoReturnFn MoqRat_starGenType_SetInt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_SetInt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_SetInt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetInt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_SetInt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_SetInt_paramsKey]*MoqRat_starGenType_SetInt_results{},
		}
		r.Moq.ResultsByParams_SetInt = append(r.Moq.ResultsByParams_SetInt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetInt) {
			copy(r.Moq.ResultsByParams_SetInt[insertAt+1:], r.Moq.ResultsByParams_SetInt[insertAt:0])
			r.Moq.ResultsByParams_SetInt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetInt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_SetInt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_SetInt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_SetInt_doFn
				DoReturnFn MoqRat_starGenType_SetInt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_SetInt(params MoqRat_starGenType_SetInt_params) string {
	return fmt.Sprintf("SetInt(%#v)", params.X)
}

func (m *MoqRat_starGenType) ParamsKey_SetInt(params MoqRat_starGenType_SetInt_params, anyParams uint64) MoqRat_starGenType_SetInt_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetInt.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqRat_starGenType_SetInt_paramsKey{
		Params: struct{ X *big.Int }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) SetInt64(x int64) *MoqRat_starGenType_SetInt64_fnRecorder {
	return &MoqRat_starGenType_SetInt64_fnRecorder{
		Params: MoqRat_starGenType_SetInt64_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_SetInt64_fnRecorder) Any() *MoqRat_starGenType_SetInt64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt64(r.Params))
		return nil
	}
	return &MoqRat_starGenType_SetInt64_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_SetInt64_anyParams) X() *MoqRat_starGenType_SetInt64_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_SetInt64_fnRecorder) Seq() *MoqRat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_SetInt64_fnRecorder) NoSeq() *MoqRat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_SetInt64_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetInt64_doFn
		DoReturnFn MoqRat_starGenType_SetInt64_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_SetInt64_fnRecorder) AndDo(fn MoqRat_starGenType_SetInt64_doFn) *MoqRat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_SetInt64_fnRecorder) DoReturnResults(fn MoqRat_starGenType_SetInt64_doReturnFn) *MoqRat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetInt64_doFn
		DoReturnFn MoqRat_starGenType_SetInt64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_SetInt64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_SetInt64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetInt64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_SetInt64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_SetInt64_paramsKey]*MoqRat_starGenType_SetInt64_results{},
		}
		r.Moq.ResultsByParams_SetInt64 = append(r.Moq.ResultsByParams_SetInt64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetInt64) {
			copy(r.Moq.ResultsByParams_SetInt64[insertAt+1:], r.Moq.ResultsByParams_SetInt64[insertAt:0])
			r.Moq.ResultsByParams_SetInt64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetInt64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_SetInt64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_SetInt64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_SetInt64_doFn
				DoReturnFn MoqRat_starGenType_SetInt64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_SetInt64(params MoqRat_starGenType_SetInt64_params) string {
	return fmt.Sprintf("SetInt64(%#v)", params.X)
}

func (m *MoqRat_starGenType) ParamsKey_SetInt64(params MoqRat_starGenType_SetInt64_params, anyParams uint64) MoqRat_starGenType_SetInt64_paramsKey {
	m.Scene.T.Helper()
	var xUsed int64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetInt64.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqRat_starGenType_SetInt64_paramsKey{
		Params: struct{ X int64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) SetUint64(x uint64) *MoqRat_starGenType_SetUint64_fnRecorder {
	return &MoqRat_starGenType_SetUint64_fnRecorder{
		Params: MoqRat_starGenType_SetUint64_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_SetUint64_fnRecorder) Any() *MoqRat_starGenType_SetUint64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint64(r.Params))
		return nil
	}
	return &MoqRat_starGenType_SetUint64_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_SetUint64_anyParams) X() *MoqRat_starGenType_SetUint64_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_SetUint64_fnRecorder) Seq() *MoqRat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_SetUint64_fnRecorder) NoSeq() *MoqRat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_SetUint64_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetUint64_doFn
		DoReturnFn MoqRat_starGenType_SetUint64_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_SetUint64_fnRecorder) AndDo(fn MoqRat_starGenType_SetUint64_doFn) *MoqRat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_SetUint64_fnRecorder) DoReturnResults(fn MoqRat_starGenType_SetUint64_doReturnFn) *MoqRat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetUint64_doFn
		DoReturnFn MoqRat_starGenType_SetUint64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_SetUint64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_SetUint64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetUint64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_SetUint64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_SetUint64_paramsKey]*MoqRat_starGenType_SetUint64_results{},
		}
		r.Moq.ResultsByParams_SetUint64 = append(r.Moq.ResultsByParams_SetUint64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetUint64) {
			copy(r.Moq.ResultsByParams_SetUint64[insertAt+1:], r.Moq.ResultsByParams_SetUint64[insertAt:0])
			r.Moq.ResultsByParams_SetUint64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetUint64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_SetUint64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_SetUint64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_SetUint64_doFn
				DoReturnFn MoqRat_starGenType_SetUint64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_SetUint64(params MoqRat_starGenType_SetUint64_params) string {
	return fmt.Sprintf("SetUint64(%#v)", params.X)
}

func (m *MoqRat_starGenType) ParamsKey_SetUint64(params MoqRat_starGenType_SetUint64_params, anyParams uint64) MoqRat_starGenType_SetUint64_paramsKey {
	m.Scene.T.Helper()
	var xUsed uint64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetUint64.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqRat_starGenType_SetUint64_paramsKey{
		Params: struct{ X uint64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) Set(x *big.Rat) *MoqRat_starGenType_Set_fnRecorder {
	return &MoqRat_starGenType_Set_fnRecorder{
		Params: MoqRat_starGenType_Set_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Set_fnRecorder) Any() *MoqRat_starGenType_Set_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Set_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_Set_anyParams) X() *MoqRat_starGenType_Set_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_Set_fnRecorder) Seq() *MoqRat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Set_fnRecorder) NoSeq() *MoqRat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Set_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Set_doFn
		DoReturnFn MoqRat_starGenType_Set_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Set_fnRecorder) AndDo(fn MoqRat_starGenType_Set_doFn) *MoqRat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Set_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Set_doReturnFn) *MoqRat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Set_doFn
		DoReturnFn MoqRat_starGenType_Set_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Set_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Set_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Set {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Set_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Set_paramsKey]*MoqRat_starGenType_Set_results{},
		}
		r.Moq.ResultsByParams_Set = append(r.Moq.ResultsByParams_Set, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Set) {
			copy(r.Moq.ResultsByParams_Set[insertAt+1:], r.Moq.ResultsByParams_Set[insertAt:0])
			r.Moq.ResultsByParams_Set[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Set(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Set_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Set_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Set_doFn
				DoReturnFn MoqRat_starGenType_Set_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Set(params MoqRat_starGenType_Set_params) string {
	return fmt.Sprintf("Set(%#v)", params.X)
}

func (m *MoqRat_starGenType) ParamsKey_Set(params MoqRat_starGenType_Set_params, anyParams uint64) MoqRat_starGenType_Set_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Rat
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Set.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqRat_starGenType_Set_paramsKey{
		Params: struct{ X *big.Rat }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) Abs(x *big.Rat) *MoqRat_starGenType_Abs_fnRecorder {
	return &MoqRat_starGenType_Abs_fnRecorder{
		Params: MoqRat_starGenType_Abs_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Abs_fnRecorder) Any() *MoqRat_starGenType_Abs_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Abs(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Abs_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_Abs_anyParams) X() *MoqRat_starGenType_Abs_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_Abs_fnRecorder) Seq() *MoqRat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Abs(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Abs_fnRecorder) NoSeq() *MoqRat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Abs(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Abs_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Abs_doFn
		DoReturnFn MoqRat_starGenType_Abs_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Abs_fnRecorder) AndDo(fn MoqRat_starGenType_Abs_doFn) *MoqRat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Abs_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Abs_doReturnFn) *MoqRat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Abs_doFn
		DoReturnFn MoqRat_starGenType_Abs_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Abs_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Abs_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Abs {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Abs_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Abs_paramsKey]*MoqRat_starGenType_Abs_results{},
		}
		r.Moq.ResultsByParams_Abs = append(r.Moq.ResultsByParams_Abs, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Abs) {
			copy(r.Moq.ResultsByParams_Abs[insertAt+1:], r.Moq.ResultsByParams_Abs[insertAt:0])
			r.Moq.ResultsByParams_Abs[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Abs(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Abs_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Abs_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Abs_doFn
				DoReturnFn MoqRat_starGenType_Abs_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Abs(params MoqRat_starGenType_Abs_params) string {
	return fmt.Sprintf("Abs(%#v)", params.X)
}

func (m *MoqRat_starGenType) ParamsKey_Abs(params MoqRat_starGenType_Abs_params, anyParams uint64) MoqRat_starGenType_Abs_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Rat
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Abs.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqRat_starGenType_Abs_paramsKey{
		Params: struct{ X *big.Rat }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) Neg(x *big.Rat) *MoqRat_starGenType_Neg_fnRecorder {
	return &MoqRat_starGenType_Neg_fnRecorder{
		Params: MoqRat_starGenType_Neg_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Neg_fnRecorder) Any() *MoqRat_starGenType_Neg_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Neg(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Neg_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_Neg_anyParams) X() *MoqRat_starGenType_Neg_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_Neg_fnRecorder) Seq() *MoqRat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Neg(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Neg_fnRecorder) NoSeq() *MoqRat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Neg(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Neg_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Neg_doFn
		DoReturnFn MoqRat_starGenType_Neg_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Neg_fnRecorder) AndDo(fn MoqRat_starGenType_Neg_doFn) *MoqRat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Neg_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Neg_doReturnFn) *MoqRat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Neg_doFn
		DoReturnFn MoqRat_starGenType_Neg_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Neg_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Neg_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Neg {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Neg_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Neg_paramsKey]*MoqRat_starGenType_Neg_results{},
		}
		r.Moq.ResultsByParams_Neg = append(r.Moq.ResultsByParams_Neg, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Neg) {
			copy(r.Moq.ResultsByParams_Neg[insertAt+1:], r.Moq.ResultsByParams_Neg[insertAt:0])
			r.Moq.ResultsByParams_Neg[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Neg(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Neg_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Neg_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Neg_doFn
				DoReturnFn MoqRat_starGenType_Neg_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Neg(params MoqRat_starGenType_Neg_params) string {
	return fmt.Sprintf("Neg(%#v)", params.X)
}

func (m *MoqRat_starGenType) ParamsKey_Neg(params MoqRat_starGenType_Neg_params, anyParams uint64) MoqRat_starGenType_Neg_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Rat
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Neg.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqRat_starGenType_Neg_paramsKey{
		Params: struct{ X *big.Rat }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) Inv(x *big.Rat) *MoqRat_starGenType_Inv_fnRecorder {
	return &MoqRat_starGenType_Inv_fnRecorder{
		Params: MoqRat_starGenType_Inv_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Inv_fnRecorder) Any() *MoqRat_starGenType_Inv_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Inv(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Inv_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_Inv_anyParams) X() *MoqRat_starGenType_Inv_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_Inv_fnRecorder) Seq() *MoqRat_starGenType_Inv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Inv(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Inv_fnRecorder) NoSeq() *MoqRat_starGenType_Inv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Inv(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Inv_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_Inv_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Inv_doFn
		DoReturnFn MoqRat_starGenType_Inv_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Inv_fnRecorder) AndDo(fn MoqRat_starGenType_Inv_doFn) *MoqRat_starGenType_Inv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Inv_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Inv_doReturnFn) *MoqRat_starGenType_Inv_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Inv_doFn
		DoReturnFn MoqRat_starGenType_Inv_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Inv_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Inv_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Inv {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Inv_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Inv_paramsKey]*MoqRat_starGenType_Inv_results{},
		}
		r.Moq.ResultsByParams_Inv = append(r.Moq.ResultsByParams_Inv, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Inv) {
			copy(r.Moq.ResultsByParams_Inv[insertAt+1:], r.Moq.ResultsByParams_Inv[insertAt:0])
			r.Moq.ResultsByParams_Inv[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Inv(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Inv_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Inv_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Inv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Inv_doFn
				DoReturnFn MoqRat_starGenType_Inv_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Inv(params MoqRat_starGenType_Inv_params) string {
	return fmt.Sprintf("Inv(%#v)", params.X)
}

func (m *MoqRat_starGenType) ParamsKey_Inv(params MoqRat_starGenType_Inv_params, anyParams uint64) MoqRat_starGenType_Inv_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Rat
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Inv.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqRat_starGenType_Inv_paramsKey{
		Params: struct{ X *big.Rat }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) Sign() *MoqRat_starGenType_Sign_fnRecorder {
	return &MoqRat_starGenType_Sign_fnRecorder{
		Params:   MoqRat_starGenType_Sign_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Sign_fnRecorder) Any() *MoqRat_starGenType_Sign_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sign(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Sign_anyParams{Recorder: r}
}

func (r *MoqRat_starGenType_Sign_fnRecorder) Seq() *MoqRat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sign(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Sign_fnRecorder) NoSeq() *MoqRat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sign(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Sign_fnRecorder) ReturnResults(result1 int) *MoqRat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Sign_doFn
		DoReturnFn MoqRat_starGenType_Sign_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Sign_fnRecorder) AndDo(fn MoqRat_starGenType_Sign_doFn) *MoqRat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Sign_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Sign_doReturnFn) *MoqRat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Sign_doFn
		DoReturnFn MoqRat_starGenType_Sign_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Sign_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Sign_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Sign {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Sign_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Sign_paramsKey]*MoqRat_starGenType_Sign_results{},
		}
		r.Moq.ResultsByParams_Sign = append(r.Moq.ResultsByParams_Sign, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Sign) {
			copy(r.Moq.ResultsByParams_Sign[insertAt+1:], r.Moq.ResultsByParams_Sign[insertAt:0])
			r.Moq.ResultsByParams_Sign[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Sign(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Sign_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Sign_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Sign_doFn
				DoReturnFn MoqRat_starGenType_Sign_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Sign(params MoqRat_starGenType_Sign_params) string {
	return fmt.Sprintf("Sign()")
}

func (m *MoqRat_starGenType) ParamsKey_Sign(params MoqRat_starGenType_Sign_params, anyParams uint64) MoqRat_starGenType_Sign_paramsKey {
	m.Scene.T.Helper()
	return MoqRat_starGenType_Sign_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRat_starGenType_recorder) IsInt() *MoqRat_starGenType_IsInt_fnRecorder {
	return &MoqRat_starGenType_IsInt_fnRecorder{
		Params:   MoqRat_starGenType_IsInt_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_IsInt_fnRecorder) Any() *MoqRat_starGenType_IsInt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInt(r.Params))
		return nil
	}
	return &MoqRat_starGenType_IsInt_anyParams{Recorder: r}
}

func (r *MoqRat_starGenType_IsInt_fnRecorder) Seq() *MoqRat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_IsInt_fnRecorder) NoSeq() *MoqRat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_IsInt_fnRecorder) ReturnResults(result1 bool) *MoqRat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_IsInt_doFn
		DoReturnFn MoqRat_starGenType_IsInt_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_IsInt_fnRecorder) AndDo(fn MoqRat_starGenType_IsInt_doFn) *MoqRat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_IsInt_fnRecorder) DoReturnResults(fn MoqRat_starGenType_IsInt_doReturnFn) *MoqRat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_IsInt_doFn
		DoReturnFn MoqRat_starGenType_IsInt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_IsInt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_IsInt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsInt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_IsInt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_IsInt_paramsKey]*MoqRat_starGenType_IsInt_results{},
		}
		r.Moq.ResultsByParams_IsInt = append(r.Moq.ResultsByParams_IsInt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsInt) {
			copy(r.Moq.ResultsByParams_IsInt[insertAt+1:], r.Moq.ResultsByParams_IsInt[insertAt:0])
			r.Moq.ResultsByParams_IsInt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsInt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_IsInt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_IsInt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_IsInt_doFn
				DoReturnFn MoqRat_starGenType_IsInt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_IsInt(params MoqRat_starGenType_IsInt_params) string {
	return fmt.Sprintf("IsInt()")
}

func (m *MoqRat_starGenType) ParamsKey_IsInt(params MoqRat_starGenType_IsInt_params, anyParams uint64) MoqRat_starGenType_IsInt_paramsKey {
	m.Scene.T.Helper()
	return MoqRat_starGenType_IsInt_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRat_starGenType_recorder) Num() *MoqRat_starGenType_Num_fnRecorder {
	return &MoqRat_starGenType_Num_fnRecorder{
		Params:   MoqRat_starGenType_Num_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Num_fnRecorder) Any() *MoqRat_starGenType_Num_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Num(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Num_anyParams{Recorder: r}
}

func (r *MoqRat_starGenType_Num_fnRecorder) Seq() *MoqRat_starGenType_Num_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Num(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Num_fnRecorder) NoSeq() *MoqRat_starGenType_Num_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Num(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Num_fnRecorder) ReturnResults(result1 *big.Int) *MoqRat_starGenType_Num_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Num_doFn
		DoReturnFn MoqRat_starGenType_Num_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Num_fnRecorder) AndDo(fn MoqRat_starGenType_Num_doFn) *MoqRat_starGenType_Num_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Num_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Num_doReturnFn) *MoqRat_starGenType_Num_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Num_doFn
		DoReturnFn MoqRat_starGenType_Num_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Num_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Num_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Num {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Num_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Num_paramsKey]*MoqRat_starGenType_Num_results{},
		}
		r.Moq.ResultsByParams_Num = append(r.Moq.ResultsByParams_Num, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Num) {
			copy(r.Moq.ResultsByParams_Num[insertAt+1:], r.Moq.ResultsByParams_Num[insertAt:0])
			r.Moq.ResultsByParams_Num[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Num(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Num_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Num_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Num_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Num_doFn
				DoReturnFn MoqRat_starGenType_Num_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Num(params MoqRat_starGenType_Num_params) string {
	return fmt.Sprintf("Num()")
}

func (m *MoqRat_starGenType) ParamsKey_Num(params MoqRat_starGenType_Num_params, anyParams uint64) MoqRat_starGenType_Num_paramsKey {
	m.Scene.T.Helper()
	return MoqRat_starGenType_Num_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRat_starGenType_recorder) Denom() *MoqRat_starGenType_Denom_fnRecorder {
	return &MoqRat_starGenType_Denom_fnRecorder{
		Params:   MoqRat_starGenType_Denom_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Denom_fnRecorder) Any() *MoqRat_starGenType_Denom_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Denom(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Denom_anyParams{Recorder: r}
}

func (r *MoqRat_starGenType_Denom_fnRecorder) Seq() *MoqRat_starGenType_Denom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Denom(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Denom_fnRecorder) NoSeq() *MoqRat_starGenType_Denom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Denom(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Denom_fnRecorder) ReturnResults(result1 *big.Int) *MoqRat_starGenType_Denom_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Denom_doFn
		DoReturnFn MoqRat_starGenType_Denom_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Denom_fnRecorder) AndDo(fn MoqRat_starGenType_Denom_doFn) *MoqRat_starGenType_Denom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Denom_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Denom_doReturnFn) *MoqRat_starGenType_Denom_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Denom_doFn
		DoReturnFn MoqRat_starGenType_Denom_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Denom_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Denom_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Denom {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Denom_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Denom_paramsKey]*MoqRat_starGenType_Denom_results{},
		}
		r.Moq.ResultsByParams_Denom = append(r.Moq.ResultsByParams_Denom, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Denom) {
			copy(r.Moq.ResultsByParams_Denom[insertAt+1:], r.Moq.ResultsByParams_Denom[insertAt:0])
			r.Moq.ResultsByParams_Denom[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Denom(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Denom_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Denom_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Denom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Denom_doFn
				DoReturnFn MoqRat_starGenType_Denom_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Denom(params MoqRat_starGenType_Denom_params) string {
	return fmt.Sprintf("Denom()")
}

func (m *MoqRat_starGenType) ParamsKey_Denom(params MoqRat_starGenType_Denom_params, anyParams uint64) MoqRat_starGenType_Denom_paramsKey {
	m.Scene.T.Helper()
	return MoqRat_starGenType_Denom_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRat_starGenType_recorder) Cmp(y *big.Rat) *MoqRat_starGenType_Cmp_fnRecorder {
	return &MoqRat_starGenType_Cmp_fnRecorder{
		Params: MoqRat_starGenType_Cmp_params{
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Cmp_fnRecorder) Any() *MoqRat_starGenType_Cmp_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cmp(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Cmp_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_Cmp_anyParams) Y() *MoqRat_starGenType_Cmp_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_Cmp_fnRecorder) Seq() *MoqRat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cmp(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Cmp_fnRecorder) NoSeq() *MoqRat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cmp(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Cmp_fnRecorder) ReturnResults(result1 int) *MoqRat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Cmp_doFn
		DoReturnFn MoqRat_starGenType_Cmp_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Cmp_fnRecorder) AndDo(fn MoqRat_starGenType_Cmp_doFn) *MoqRat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Cmp_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Cmp_doReturnFn) *MoqRat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Cmp_doFn
		DoReturnFn MoqRat_starGenType_Cmp_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Cmp_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Cmp_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Cmp {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Cmp_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Cmp_paramsKey]*MoqRat_starGenType_Cmp_results{},
		}
		r.Moq.ResultsByParams_Cmp = append(r.Moq.ResultsByParams_Cmp, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Cmp) {
			copy(r.Moq.ResultsByParams_Cmp[insertAt+1:], r.Moq.ResultsByParams_Cmp[insertAt:0])
			r.Moq.ResultsByParams_Cmp[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Cmp(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Cmp_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Cmp_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Cmp_doFn
				DoReturnFn MoqRat_starGenType_Cmp_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Cmp(params MoqRat_starGenType_Cmp_params) string {
	return fmt.Sprintf("Cmp(%#v)", params.Y)
}

func (m *MoqRat_starGenType) ParamsKey_Cmp(params MoqRat_starGenType_Cmp_params, anyParams uint64) MoqRat_starGenType_Cmp_paramsKey {
	m.Scene.T.Helper()
	var yUsed *big.Rat
	var yUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Cmp.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqRat_starGenType_Cmp_paramsKey{
		Params: struct{ Y *big.Rat }{
			Y: yUsed,
		},
		Hashes: struct{ Y hash.Hash }{
			Y: yUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) Add(x, y *big.Rat) *MoqRat_starGenType_Add_fnRecorder {
	return &MoqRat_starGenType_Add_fnRecorder{
		Params: MoqRat_starGenType_Add_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Add_fnRecorder) Any() *MoqRat_starGenType_Add_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Add_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_Add_anyParams) X() *MoqRat_starGenType_Add_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRat_starGenType_Add_anyParams) Y() *MoqRat_starGenType_Add_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRat_starGenType_Add_fnRecorder) Seq() *MoqRat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Add_fnRecorder) NoSeq() *MoqRat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Add_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Add_doFn
		DoReturnFn MoqRat_starGenType_Add_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Add_fnRecorder) AndDo(fn MoqRat_starGenType_Add_doFn) *MoqRat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Add_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Add_doReturnFn) *MoqRat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Add_doFn
		DoReturnFn MoqRat_starGenType_Add_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Add_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Add_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Add {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Add_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Add_paramsKey]*MoqRat_starGenType_Add_results{},
		}
		r.Moq.ResultsByParams_Add = append(r.Moq.ResultsByParams_Add, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Add) {
			copy(r.Moq.ResultsByParams_Add[insertAt+1:], r.Moq.ResultsByParams_Add[insertAt:0])
			r.Moq.ResultsByParams_Add[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Add(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Add_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Add_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Add_doFn
				DoReturnFn MoqRat_starGenType_Add_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Add(params MoqRat_starGenType_Add_params) string {
	return fmt.Sprintf("Add(%#v, %#v)", params.X, params.Y)
}

func (m *MoqRat_starGenType) ParamsKey_Add(params MoqRat_starGenType_Add_params, anyParams uint64) MoqRat_starGenType_Add_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Rat
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Add.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Rat
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Add.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqRat_starGenType_Add_paramsKey{
		Params: struct{ X, Y *big.Rat }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) Sub(x, y *big.Rat) *MoqRat_starGenType_Sub_fnRecorder {
	return &MoqRat_starGenType_Sub_fnRecorder{
		Params: MoqRat_starGenType_Sub_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Sub_fnRecorder) Any() *MoqRat_starGenType_Sub_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Sub_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_Sub_anyParams) X() *MoqRat_starGenType_Sub_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRat_starGenType_Sub_anyParams) Y() *MoqRat_starGenType_Sub_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRat_starGenType_Sub_fnRecorder) Seq() *MoqRat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Sub_fnRecorder) NoSeq() *MoqRat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Sub_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Sub_doFn
		DoReturnFn MoqRat_starGenType_Sub_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Sub_fnRecorder) AndDo(fn MoqRat_starGenType_Sub_doFn) *MoqRat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Sub_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Sub_doReturnFn) *MoqRat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Sub_doFn
		DoReturnFn MoqRat_starGenType_Sub_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Sub_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Sub_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Sub {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Sub_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Sub_paramsKey]*MoqRat_starGenType_Sub_results{},
		}
		r.Moq.ResultsByParams_Sub = append(r.Moq.ResultsByParams_Sub, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Sub) {
			copy(r.Moq.ResultsByParams_Sub[insertAt+1:], r.Moq.ResultsByParams_Sub[insertAt:0])
			r.Moq.ResultsByParams_Sub[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Sub(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Sub_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Sub_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Sub_doFn
				DoReturnFn MoqRat_starGenType_Sub_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Sub(params MoqRat_starGenType_Sub_params) string {
	return fmt.Sprintf("Sub(%#v, %#v)", params.X, params.Y)
}

func (m *MoqRat_starGenType) ParamsKey_Sub(params MoqRat_starGenType_Sub_params, anyParams uint64) MoqRat_starGenType_Sub_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Rat
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Sub.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Rat
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Sub.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqRat_starGenType_Sub_paramsKey{
		Params: struct{ X, Y *big.Rat }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) Mul(x, y *big.Rat) *MoqRat_starGenType_Mul_fnRecorder {
	return &MoqRat_starGenType_Mul_fnRecorder{
		Params: MoqRat_starGenType_Mul_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Mul_fnRecorder) Any() *MoqRat_starGenType_Mul_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mul(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Mul_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_Mul_anyParams) X() *MoqRat_starGenType_Mul_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRat_starGenType_Mul_anyParams) Y() *MoqRat_starGenType_Mul_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRat_starGenType_Mul_fnRecorder) Seq() *MoqRat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mul(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Mul_fnRecorder) NoSeq() *MoqRat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mul(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Mul_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Mul_doFn
		DoReturnFn MoqRat_starGenType_Mul_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Mul_fnRecorder) AndDo(fn MoqRat_starGenType_Mul_doFn) *MoqRat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Mul_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Mul_doReturnFn) *MoqRat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Mul_doFn
		DoReturnFn MoqRat_starGenType_Mul_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Mul_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Mul_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Mul {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Mul_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Mul_paramsKey]*MoqRat_starGenType_Mul_results{},
		}
		r.Moq.ResultsByParams_Mul = append(r.Moq.ResultsByParams_Mul, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Mul) {
			copy(r.Moq.ResultsByParams_Mul[insertAt+1:], r.Moq.ResultsByParams_Mul[insertAt:0])
			r.Moq.ResultsByParams_Mul[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Mul(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Mul_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Mul_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Mul_doFn
				DoReturnFn MoqRat_starGenType_Mul_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Mul(params MoqRat_starGenType_Mul_params) string {
	return fmt.Sprintf("Mul(%#v, %#v)", params.X, params.Y)
}

func (m *MoqRat_starGenType) ParamsKey_Mul(params MoqRat_starGenType_Mul_params, anyParams uint64) MoqRat_starGenType_Mul_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Rat
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Mul.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Rat
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Mul.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqRat_starGenType_Mul_paramsKey{
		Params: struct{ X, Y *big.Rat }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) Quo(x, y *big.Rat) *MoqRat_starGenType_Quo_fnRecorder {
	return &MoqRat_starGenType_Quo_fnRecorder{
		Params: MoqRat_starGenType_Quo_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Quo_fnRecorder) Any() *MoqRat_starGenType_Quo_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quo(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Quo_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_Quo_anyParams) X() *MoqRat_starGenType_Quo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRat_starGenType_Quo_anyParams) Y() *MoqRat_starGenType_Quo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRat_starGenType_Quo_fnRecorder) Seq() *MoqRat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quo(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Quo_fnRecorder) NoSeq() *MoqRat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quo(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Quo_fnRecorder) ReturnResults(result1 *big.Rat) *MoqRat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Quo_doFn
		DoReturnFn MoqRat_starGenType_Quo_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Quo_fnRecorder) AndDo(fn MoqRat_starGenType_Quo_doFn) *MoqRat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Quo_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Quo_doReturnFn) *MoqRat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Quo_doFn
		DoReturnFn MoqRat_starGenType_Quo_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Quo_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Quo_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Quo {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Quo_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Quo_paramsKey]*MoqRat_starGenType_Quo_results{},
		}
		r.Moq.ResultsByParams_Quo = append(r.Moq.ResultsByParams_Quo, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Quo) {
			copy(r.Moq.ResultsByParams_Quo[insertAt+1:], r.Moq.ResultsByParams_Quo[insertAt:0])
			r.Moq.ResultsByParams_Quo[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Quo(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Quo_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Quo_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Quo_doFn
				DoReturnFn MoqRat_starGenType_Quo_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Quo(params MoqRat_starGenType_Quo_params) string {
	return fmt.Sprintf("Quo(%#v, %#v)", params.X, params.Y)
}

func (m *MoqRat_starGenType) ParamsKey_Quo(params MoqRat_starGenType_Quo_params, anyParams uint64) MoqRat_starGenType_Quo_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Rat
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Quo.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Rat
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Quo.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqRat_starGenType_Quo_paramsKey{
		Params: struct{ X, Y *big.Rat }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) Scan(s fmt.ScanState, ch rune) *MoqRat_starGenType_Scan_fnRecorder {
	return &MoqRat_starGenType_Scan_fnRecorder{
		Params: MoqRat_starGenType_Scan_params{
			S:  s,
			Ch: ch,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_Scan_fnRecorder) Any() *MoqRat_starGenType_Scan_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Scan(r.Params))
		return nil
	}
	return &MoqRat_starGenType_Scan_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_Scan_anyParams) S() *MoqRat_starGenType_Scan_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRat_starGenType_Scan_anyParams) Ch() *MoqRat_starGenType_Scan_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRat_starGenType_Scan_fnRecorder) Seq() *MoqRat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Scan(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_Scan_fnRecorder) NoSeq() *MoqRat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Scan(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_Scan_fnRecorder) ReturnResults(result1 error) *MoqRat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Scan_doFn
		DoReturnFn MoqRat_starGenType_Scan_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_Scan_fnRecorder) AndDo(fn MoqRat_starGenType_Scan_doFn) *MoqRat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_Scan_fnRecorder) DoReturnResults(fn MoqRat_starGenType_Scan_doReturnFn) *MoqRat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_Scan_doFn
		DoReturnFn MoqRat_starGenType_Scan_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_Scan_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_Scan_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Scan {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_Scan_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_Scan_paramsKey]*MoqRat_starGenType_Scan_results{},
		}
		r.Moq.ResultsByParams_Scan = append(r.Moq.ResultsByParams_Scan, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Scan) {
			copy(r.Moq.ResultsByParams_Scan[insertAt+1:], r.Moq.ResultsByParams_Scan[insertAt:0])
			r.Moq.ResultsByParams_Scan[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Scan(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_Scan_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_Scan_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_Scan_doFn
				DoReturnFn MoqRat_starGenType_Scan_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_Scan(params MoqRat_starGenType_Scan_params) string {
	return fmt.Sprintf("Scan(%#v, %#v)", params.S, params.Ch)
}

func (m *MoqRat_starGenType) ParamsKey_Scan(params MoqRat_starGenType_Scan_params, anyParams uint64) MoqRat_starGenType_Scan_paramsKey {
	m.Scene.T.Helper()
	var sUsed fmt.ScanState
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Scan.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var chUsed rune
	var chUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Scan.Ch == moq.ParamIndexByValue {
			chUsed = params.Ch
		} else {
			chUsedHash = hash.DeepHash(params.Ch)
		}
	}
	return MoqRat_starGenType_Scan_paramsKey{
		Params: struct {
			S  fmt.ScanState
			Ch rune
		}{
			S:  sUsed,
			Ch: chUsed,
		},
		Hashes: struct {
			S  hash.Hash
			Ch hash.Hash
		}{
			S:  sUsedHash,
			Ch: chUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) SetString(s string) *MoqRat_starGenType_SetString_fnRecorder {
	return &MoqRat_starGenType_SetString_fnRecorder{
		Params: MoqRat_starGenType_SetString_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_SetString_fnRecorder) Any() *MoqRat_starGenType_SetString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	return &MoqRat_starGenType_SetString_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_SetString_anyParams) S() *MoqRat_starGenType_SetString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_SetString_fnRecorder) Seq() *MoqRat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_SetString_fnRecorder) NoSeq() *MoqRat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_SetString_fnRecorder) ReturnResults(result1 *big.Rat, result2 bool) *MoqRat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetString_doFn
		DoReturnFn MoqRat_starGenType_SetString_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
			Result2 bool
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_SetString_fnRecorder) AndDo(fn MoqRat_starGenType_SetString_doFn) *MoqRat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_SetString_fnRecorder) DoReturnResults(fn MoqRat_starGenType_SetString_doReturnFn) *MoqRat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_SetString_doFn
		DoReturnFn MoqRat_starGenType_SetString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_SetString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_SetString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_SetString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_SetString_paramsKey]*MoqRat_starGenType_SetString_results{},
		}
		r.Moq.ResultsByParams_SetString = append(r.Moq.ResultsByParams_SetString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetString) {
			copy(r.Moq.ResultsByParams_SetString[insertAt+1:], r.Moq.ResultsByParams_SetString[insertAt:0])
			r.Moq.ResultsByParams_SetString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_SetString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_SetString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
					Result2 bool
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_SetString_doFn
				DoReturnFn MoqRat_starGenType_SetString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_SetString(params MoqRat_starGenType_SetString_params) string {
	return fmt.Sprintf("SetString(%#v)", params.S)
}

func (m *MoqRat_starGenType) ParamsKey_SetString(params MoqRat_starGenType_SetString_params, anyParams uint64) MoqRat_starGenType_SetString_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetString.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqRat_starGenType_SetString_paramsKey{
		Params: struct{ S string }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) String() *MoqRat_starGenType_String_fnRecorder {
	return &MoqRat_starGenType_String_fnRecorder{
		Params:   MoqRat_starGenType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_String_fnRecorder) Any() *MoqRat_starGenType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqRat_starGenType_String_anyParams{Recorder: r}
}

func (r *MoqRat_starGenType_String_fnRecorder) Seq() *MoqRat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_String_fnRecorder) NoSeq() *MoqRat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_String_fnRecorder) ReturnResults(result1 string) *MoqRat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_String_doFn
		DoReturnFn MoqRat_starGenType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_String_fnRecorder) AndDo(fn MoqRat_starGenType_String_doFn) *MoqRat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_String_fnRecorder) DoReturnResults(fn MoqRat_starGenType_String_doReturnFn) *MoqRat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_String_doFn
		DoReturnFn MoqRat_starGenType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_String_paramsKey]*MoqRat_starGenType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_String_doFn
				DoReturnFn MoqRat_starGenType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_String(params MoqRat_starGenType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqRat_starGenType) ParamsKey_String(params MoqRat_starGenType_String_params, anyParams uint64) MoqRat_starGenType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqRat_starGenType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRat_starGenType_recorder) RatString() *MoqRat_starGenType_RatString_fnRecorder {
	return &MoqRat_starGenType_RatString_fnRecorder{
		Params:   MoqRat_starGenType_RatString_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_RatString_fnRecorder) Any() *MoqRat_starGenType_RatString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RatString(r.Params))
		return nil
	}
	return &MoqRat_starGenType_RatString_anyParams{Recorder: r}
}

func (r *MoqRat_starGenType_RatString_fnRecorder) Seq() *MoqRat_starGenType_RatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RatString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_RatString_fnRecorder) NoSeq() *MoqRat_starGenType_RatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RatString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_RatString_fnRecorder) ReturnResults(result1 string) *MoqRat_starGenType_RatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_RatString_doFn
		DoReturnFn MoqRat_starGenType_RatString_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_RatString_fnRecorder) AndDo(fn MoqRat_starGenType_RatString_doFn) *MoqRat_starGenType_RatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_RatString_fnRecorder) DoReturnResults(fn MoqRat_starGenType_RatString_doReturnFn) *MoqRat_starGenType_RatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_RatString_doFn
		DoReturnFn MoqRat_starGenType_RatString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_RatString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_RatString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_RatString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_RatString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_RatString_paramsKey]*MoqRat_starGenType_RatString_results{},
		}
		r.Moq.ResultsByParams_RatString = append(r.Moq.ResultsByParams_RatString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_RatString) {
			copy(r.Moq.ResultsByParams_RatString[insertAt+1:], r.Moq.ResultsByParams_RatString[insertAt:0])
			r.Moq.ResultsByParams_RatString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_RatString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_RatString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_RatString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_RatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_RatString_doFn
				DoReturnFn MoqRat_starGenType_RatString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_RatString(params MoqRat_starGenType_RatString_params) string {
	return fmt.Sprintf("RatString()")
}

func (m *MoqRat_starGenType) ParamsKey_RatString(params MoqRat_starGenType_RatString_params, anyParams uint64) MoqRat_starGenType_RatString_paramsKey {
	m.Scene.T.Helper()
	return MoqRat_starGenType_RatString_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRat_starGenType_recorder) FloatString(prec int) *MoqRat_starGenType_FloatString_fnRecorder {
	return &MoqRat_starGenType_FloatString_fnRecorder{
		Params: MoqRat_starGenType_FloatString_params{
			Prec: prec,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_FloatString_fnRecorder) Any() *MoqRat_starGenType_FloatString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FloatString(r.Params))
		return nil
	}
	return &MoqRat_starGenType_FloatString_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_FloatString_anyParams) Prec() *MoqRat_starGenType_FloatString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_FloatString_fnRecorder) Seq() *MoqRat_starGenType_FloatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FloatString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_FloatString_fnRecorder) NoSeq() *MoqRat_starGenType_FloatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FloatString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_FloatString_fnRecorder) ReturnResults(result1 string) *MoqRat_starGenType_FloatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_FloatString_doFn
		DoReturnFn MoqRat_starGenType_FloatString_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_FloatString_fnRecorder) AndDo(fn MoqRat_starGenType_FloatString_doFn) *MoqRat_starGenType_FloatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_FloatString_fnRecorder) DoReturnResults(fn MoqRat_starGenType_FloatString_doReturnFn) *MoqRat_starGenType_FloatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_FloatString_doFn
		DoReturnFn MoqRat_starGenType_FloatString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_FloatString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_FloatString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FloatString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_FloatString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_FloatString_paramsKey]*MoqRat_starGenType_FloatString_results{},
		}
		r.Moq.ResultsByParams_FloatString = append(r.Moq.ResultsByParams_FloatString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FloatString) {
			copy(r.Moq.ResultsByParams_FloatString[insertAt+1:], r.Moq.ResultsByParams_FloatString[insertAt:0])
			r.Moq.ResultsByParams_FloatString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FloatString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_FloatString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_FloatString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_FloatString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_FloatString_doFn
				DoReturnFn MoqRat_starGenType_FloatString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_FloatString(params MoqRat_starGenType_FloatString_params) string {
	return fmt.Sprintf("FloatString(%#v)", params.Prec)
}

func (m *MoqRat_starGenType) ParamsKey_FloatString(params MoqRat_starGenType_FloatString_params, anyParams uint64) MoqRat_starGenType_FloatString_paramsKey {
	m.Scene.T.Helper()
	var precUsed int
	var precUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FloatString.Prec == moq.ParamIndexByValue {
			precUsed = params.Prec
		} else {
			precUsedHash = hash.DeepHash(params.Prec)
		}
	}
	return MoqRat_starGenType_FloatString_paramsKey{
		Params: struct{ Prec int }{
			Prec: precUsed,
		},
		Hashes: struct{ Prec hash.Hash }{
			Prec: precUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) GobEncode() *MoqRat_starGenType_GobEncode_fnRecorder {
	return &MoqRat_starGenType_GobEncode_fnRecorder{
		Params:   MoqRat_starGenType_GobEncode_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_GobEncode_fnRecorder) Any() *MoqRat_starGenType_GobEncode_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	return &MoqRat_starGenType_GobEncode_anyParams{Recorder: r}
}

func (r *MoqRat_starGenType_GobEncode_fnRecorder) Seq() *MoqRat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_GobEncode_fnRecorder) NoSeq() *MoqRat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_GobEncode_fnRecorder) ReturnResults(result1 []byte, result2 error) *MoqRat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_GobEncode_doFn
		DoReturnFn MoqRat_starGenType_GobEncode_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_GobEncode_fnRecorder) AndDo(fn MoqRat_starGenType_GobEncode_doFn) *MoqRat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_GobEncode_fnRecorder) DoReturnResults(fn MoqRat_starGenType_GobEncode_doReturnFn) *MoqRat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_GobEncode_doFn
		DoReturnFn MoqRat_starGenType_GobEncode_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_GobEncode_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_GobEncode_resultsByParams
	for n, res := range r.Moq.ResultsByParams_GobEncode {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_GobEncode_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_GobEncode_paramsKey]*MoqRat_starGenType_GobEncode_results{},
		}
		r.Moq.ResultsByParams_GobEncode = append(r.Moq.ResultsByParams_GobEncode, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_GobEncode) {
			copy(r.Moq.ResultsByParams_GobEncode[insertAt+1:], r.Moq.ResultsByParams_GobEncode[insertAt:0])
			r.Moq.ResultsByParams_GobEncode[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_GobEncode(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_GobEncode_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_GobEncode_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_GobEncode_doFn
				DoReturnFn MoqRat_starGenType_GobEncode_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_GobEncode(params MoqRat_starGenType_GobEncode_params) string {
	return fmt.Sprintf("GobEncode()")
}

func (m *MoqRat_starGenType) ParamsKey_GobEncode(params MoqRat_starGenType_GobEncode_params, anyParams uint64) MoqRat_starGenType_GobEncode_paramsKey {
	m.Scene.T.Helper()
	return MoqRat_starGenType_GobEncode_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRat_starGenType_recorder) GobDecode(buf []byte) *MoqRat_starGenType_GobDecode_fnRecorder {
	return &MoqRat_starGenType_GobDecode_fnRecorder{
		Params: MoqRat_starGenType_GobDecode_params{
			Buf: buf,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_GobDecode_fnRecorder) Any() *MoqRat_starGenType_GobDecode_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobDecode(r.Params))
		return nil
	}
	return &MoqRat_starGenType_GobDecode_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_GobDecode_anyParams) Buf() *MoqRat_starGenType_GobDecode_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_GobDecode_fnRecorder) Seq() *MoqRat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobDecode(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_GobDecode_fnRecorder) NoSeq() *MoqRat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobDecode(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_GobDecode_fnRecorder) ReturnResults(result1 error) *MoqRat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_GobDecode_doFn
		DoReturnFn MoqRat_starGenType_GobDecode_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_GobDecode_fnRecorder) AndDo(fn MoqRat_starGenType_GobDecode_doFn) *MoqRat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_GobDecode_fnRecorder) DoReturnResults(fn MoqRat_starGenType_GobDecode_doReturnFn) *MoqRat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_GobDecode_doFn
		DoReturnFn MoqRat_starGenType_GobDecode_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_GobDecode_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_GobDecode_resultsByParams
	for n, res := range r.Moq.ResultsByParams_GobDecode {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_GobDecode_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_GobDecode_paramsKey]*MoqRat_starGenType_GobDecode_results{},
		}
		r.Moq.ResultsByParams_GobDecode = append(r.Moq.ResultsByParams_GobDecode, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_GobDecode) {
			copy(r.Moq.ResultsByParams_GobDecode[insertAt+1:], r.Moq.ResultsByParams_GobDecode[insertAt:0])
			r.Moq.ResultsByParams_GobDecode[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_GobDecode(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_GobDecode_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_GobDecode_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_GobDecode_doFn
				DoReturnFn MoqRat_starGenType_GobDecode_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_GobDecode(params MoqRat_starGenType_GobDecode_params) string {
	return fmt.Sprintf("GobDecode(%#v)", params.Buf)
}

func (m *MoqRat_starGenType) ParamsKey_GobDecode(params MoqRat_starGenType_GobDecode_params, anyParams uint64) MoqRat_starGenType_GobDecode_paramsKey {
	m.Scene.T.Helper()
	var bufUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.GobDecode.Buf == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The buf parameter of the GobDecode function can't be indexed by value")
		}
		bufUsedHash = hash.DeepHash(params.Buf)
	}
	return MoqRat_starGenType_GobDecode_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Buf hash.Hash }{
			Buf: bufUsedHash,
		},
	}
}

func (m *MoqRat_starGenType_recorder) MarshalText() *MoqRat_starGenType_MarshalText_fnRecorder {
	return &MoqRat_starGenType_MarshalText_fnRecorder{
		Params:   MoqRat_starGenType_MarshalText_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_MarshalText_fnRecorder) Any() *MoqRat_starGenType_MarshalText_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	return &MoqRat_starGenType_MarshalText_anyParams{Recorder: r}
}

func (r *MoqRat_starGenType_MarshalText_fnRecorder) Seq() *MoqRat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_MarshalText_fnRecorder) NoSeq() *MoqRat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_MarshalText_fnRecorder) ReturnResults(text []byte, err error) *MoqRat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_MarshalText_doFn
		DoReturnFn MoqRat_starGenType_MarshalText_doReturnFn
	}{
		Values: &struct {
			Text []byte
			Err  error
		}{
			Text: text,
			Err:  err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_MarshalText_fnRecorder) AndDo(fn MoqRat_starGenType_MarshalText_doFn) *MoqRat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_MarshalText_fnRecorder) DoReturnResults(fn MoqRat_starGenType_MarshalText_doReturnFn) *MoqRat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_MarshalText_doFn
		DoReturnFn MoqRat_starGenType_MarshalText_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_MarshalText_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_MarshalText_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MarshalText {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_MarshalText_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_MarshalText_paramsKey]*MoqRat_starGenType_MarshalText_results{},
		}
		r.Moq.ResultsByParams_MarshalText = append(r.Moq.ResultsByParams_MarshalText, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MarshalText) {
			copy(r.Moq.ResultsByParams_MarshalText[insertAt+1:], r.Moq.ResultsByParams_MarshalText[insertAt:0])
			r.Moq.ResultsByParams_MarshalText[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MarshalText(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_MarshalText_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_MarshalText_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Text []byte
					Err  error
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_MarshalText_doFn
				DoReturnFn MoqRat_starGenType_MarshalText_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_MarshalText(params MoqRat_starGenType_MarshalText_params) string {
	return fmt.Sprintf("MarshalText()")
}

func (m *MoqRat_starGenType) ParamsKey_MarshalText(params MoqRat_starGenType_MarshalText_params, anyParams uint64) MoqRat_starGenType_MarshalText_paramsKey {
	m.Scene.T.Helper()
	return MoqRat_starGenType_MarshalText_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRat_starGenType_recorder) UnmarshalText(text []byte) *MoqRat_starGenType_UnmarshalText_fnRecorder {
	return &MoqRat_starGenType_UnmarshalText_fnRecorder{
		Params: MoqRat_starGenType_UnmarshalText_params{
			Text: text,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRat_starGenType_UnmarshalText_fnRecorder) Any() *MoqRat_starGenType_UnmarshalText_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalText(r.Params))
		return nil
	}
	return &MoqRat_starGenType_UnmarshalText_anyParams{Recorder: r}
}

func (a *MoqRat_starGenType_UnmarshalText_anyParams) Text() *MoqRat_starGenType_UnmarshalText_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRat_starGenType_UnmarshalText_fnRecorder) Seq() *MoqRat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalText(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRat_starGenType_UnmarshalText_fnRecorder) NoSeq() *MoqRat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalText(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRat_starGenType_UnmarshalText_fnRecorder) ReturnResults(result1 error) *MoqRat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_UnmarshalText_doFn
		DoReturnFn MoqRat_starGenType_UnmarshalText_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRat_starGenType_UnmarshalText_fnRecorder) AndDo(fn MoqRat_starGenType_UnmarshalText_doFn) *MoqRat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRat_starGenType_UnmarshalText_fnRecorder) DoReturnResults(fn MoqRat_starGenType_UnmarshalText_doReturnFn) *MoqRat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqRat_starGenType_UnmarshalText_doFn
		DoReturnFn MoqRat_starGenType_UnmarshalText_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRat_starGenType_UnmarshalText_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRat_starGenType_UnmarshalText_resultsByParams
	for n, res := range r.Moq.ResultsByParams_UnmarshalText {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRat_starGenType_UnmarshalText_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRat_starGenType_UnmarshalText_paramsKey]*MoqRat_starGenType_UnmarshalText_results{},
		}
		r.Moq.ResultsByParams_UnmarshalText = append(r.Moq.ResultsByParams_UnmarshalText, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_UnmarshalText) {
			copy(r.Moq.ResultsByParams_UnmarshalText[insertAt+1:], r.Moq.ResultsByParams_UnmarshalText[insertAt:0])
			r.Moq.ResultsByParams_UnmarshalText[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_UnmarshalText(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRat_starGenType_UnmarshalText_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRat_starGenType_UnmarshalText_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqRat_starGenType_UnmarshalText_doFn
				DoReturnFn MoqRat_starGenType_UnmarshalText_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRat_starGenType) PrettyParams_UnmarshalText(params MoqRat_starGenType_UnmarshalText_params) string {
	return fmt.Sprintf("UnmarshalText(%#v)", params.Text)
}

func (m *MoqRat_starGenType) ParamsKey_UnmarshalText(params MoqRat_starGenType_UnmarshalText_params, anyParams uint64) MoqRat_starGenType_UnmarshalText_paramsKey {
	m.Scene.T.Helper()
	var textUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.UnmarshalText.Text == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The text parameter of the UnmarshalText function can't be indexed by value")
		}
		textUsedHash = hash.DeepHash(params.Text)
	}
	return MoqRat_starGenType_UnmarshalText_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Text hash.Hash }{
			Text: textUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqRat_starGenType) Reset() {
	m.ResultsByParams_SetFloat64 = nil
	m.ResultsByParams_Float32 = nil
	m.ResultsByParams_Float64 = nil
	m.ResultsByParams_SetFrac = nil
	m.ResultsByParams_SetFrac64 = nil
	m.ResultsByParams_SetInt = nil
	m.ResultsByParams_SetInt64 = nil
	m.ResultsByParams_SetUint64 = nil
	m.ResultsByParams_Set = nil
	m.ResultsByParams_Abs = nil
	m.ResultsByParams_Neg = nil
	m.ResultsByParams_Inv = nil
	m.ResultsByParams_Sign = nil
	m.ResultsByParams_IsInt = nil
	m.ResultsByParams_Num = nil
	m.ResultsByParams_Denom = nil
	m.ResultsByParams_Cmp = nil
	m.ResultsByParams_Add = nil
	m.ResultsByParams_Sub = nil
	m.ResultsByParams_Mul = nil
	m.ResultsByParams_Quo = nil
	m.ResultsByParams_Scan = nil
	m.ResultsByParams_SetString = nil
	m.ResultsByParams_String = nil
	m.ResultsByParams_RatString = nil
	m.ResultsByParams_FloatString = nil
	m.ResultsByParams_GobEncode = nil
	m.ResultsByParams_GobDecode = nil
	m.ResultsByParams_MarshalText = nil
	m.ResultsByParams_UnmarshalText = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqRat_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_SetFloat64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetFloat64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Float32 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Float32(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Float64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Float64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetFrac {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetFrac(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetFrac64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetFrac64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetInt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetInt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetInt64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetInt64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetUint64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetUint64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Set {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Set(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Abs {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Abs(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Neg {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Neg(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Inv {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Inv(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Sign {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Sign(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsInt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsInt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Num {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Num(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Denom {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Denom(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Cmp {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Cmp(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Add {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Add(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Sub {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Sub(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Mul {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Mul(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Quo {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Quo(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Scan {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Scan(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_RatString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_RatString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FloatString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FloatString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_GobEncode {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_GobEncode(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_GobDecode {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_GobDecode(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MarshalText {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MarshalText(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_UnmarshalText {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_UnmarshalText(results.Params))
			}
		}
	}
}
