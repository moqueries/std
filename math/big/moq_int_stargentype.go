// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package big

import (
	"fmt"
	"math/big"
	"math/bits"
	"math/rand"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that big.Int_starGenType is mocked
// completely
var _ Int_starGenType = (*MoqInt_starGenType_mock)(nil)

// Int_starGenType is the fabricated implementation type of this mock (emitted
// when mocking a collections of methods directly and not from an interface
// type)
type Int_starGenType interface {
	Sign() int
	SetInt64(x int64) *big.Int
	SetUint64(x uint64) *big.Int
	Set(x *big.Int) *big.Int
	Bits() []big.Word
	SetBits(abs []big.Word) *big.Int
	Abs(x *big.Int) *big.Int
	Neg(x *big.Int) *big.Int
	Add(x, y *big.Int) *big.Int
	Sub(x, y *big.Int) *big.Int
	Mul(x, y *big.Int) *big.Int
	MulRange(a, b int64) *big.Int
	Binomial(n, k int64) *big.Int
	Quo(x, y *big.Int) *big.Int
	Rem(x, y *big.Int) *big.Int
	QuoRem(x, y, r *big.Int) (*big.Int, *big.Int)
	Div(x, y *big.Int) *big.Int
	Mod(x, y *big.Int) *big.Int
	DivMod(x, y, m *big.Int) (*big.Int, *big.Int)
	Cmp(y *big.Int) (r int)
	CmpAbs(y *big.Int) int
	Int64() int64
	Uint64() uint64
	IsInt64() bool
	IsUint64() bool
	SetString(s string, base int) (*big.Int, bool)
	SetBytes(buf []byte) *big.Int
	Bytes() []byte
	BitLen() int
	TrailingZeroBits() uint
	Exp(x, y, m *big.Int) *big.Int
	GCD(x, y, a, b *big.Int) *big.Int
	Rand(rnd *rand.Rand, n *big.Int) *big.Int
	ModInverse(g, n *big.Int) *big.Int
	ModSqrt(x, p *big.Int) *big.Int
	Lsh(x *big.Int, n uint) *big.Int
	Rsh(x *big.Int, n uint) *big.Int
	Bit(i int) uint
	SetBit(x *big.Int, i int, b uint) *big.Int
	And(x, y *big.Int) *big.Int
	AndNot(x, y *big.Int) *big.Int
	Or(x, y *big.Int) *big.Int
	Xor(x, y *big.Int) *big.Int
	Not(x *big.Int) *big.Int
	Sqrt(x *big.Int) *big.Int
	Text(base int) string
	Append(buf []byte, base int) []byte
	String() string
	Format(s fmt.State, ch rune)
	Scan(s fmt.ScanState, ch rune) error
	GobEncode() ([]byte, error)
	GobDecode(buf []byte) error
	MarshalText() (text []byte, err error)
	UnmarshalText(text []byte) error
	MarshalJSON() ([]byte, error)
	UnmarshalJSON(text []byte) error
	ProbablyPrime(n int) bool
}

// MoqInt_starGenType holds the state of a moq of the Int_starGenType type
type MoqInt_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqInt_starGenType_mock

	ResultsByParams_Sign             []MoqInt_starGenType_Sign_resultsByParams
	ResultsByParams_SetInt64         []MoqInt_starGenType_SetInt64_resultsByParams
	ResultsByParams_SetUint64        []MoqInt_starGenType_SetUint64_resultsByParams
	ResultsByParams_Set              []MoqInt_starGenType_Set_resultsByParams
	ResultsByParams_Bits             []MoqInt_starGenType_Bits_resultsByParams
	ResultsByParams_SetBits          []MoqInt_starGenType_SetBits_resultsByParams
	ResultsByParams_Abs              []MoqInt_starGenType_Abs_resultsByParams
	ResultsByParams_Neg              []MoqInt_starGenType_Neg_resultsByParams
	ResultsByParams_Add              []MoqInt_starGenType_Add_resultsByParams
	ResultsByParams_Sub              []MoqInt_starGenType_Sub_resultsByParams
	ResultsByParams_Mul              []MoqInt_starGenType_Mul_resultsByParams
	ResultsByParams_MulRange         []MoqInt_starGenType_MulRange_resultsByParams
	ResultsByParams_Binomial         []MoqInt_starGenType_Binomial_resultsByParams
	ResultsByParams_Quo              []MoqInt_starGenType_Quo_resultsByParams
	ResultsByParams_Rem              []MoqInt_starGenType_Rem_resultsByParams
	ResultsByParams_QuoRem           []MoqInt_starGenType_QuoRem_resultsByParams
	ResultsByParams_Div              []MoqInt_starGenType_Div_resultsByParams
	ResultsByParams_Mod              []MoqInt_starGenType_Mod_resultsByParams
	ResultsByParams_DivMod           []MoqInt_starGenType_DivMod_resultsByParams
	ResultsByParams_Cmp              []MoqInt_starGenType_Cmp_resultsByParams
	ResultsByParams_CmpAbs           []MoqInt_starGenType_CmpAbs_resultsByParams
	ResultsByParams_Int64            []MoqInt_starGenType_Int64_resultsByParams
	ResultsByParams_Uint64           []MoqInt_starGenType_Uint64_resultsByParams
	ResultsByParams_IsInt64          []MoqInt_starGenType_IsInt64_resultsByParams
	ResultsByParams_IsUint64         []MoqInt_starGenType_IsUint64_resultsByParams
	ResultsByParams_SetString        []MoqInt_starGenType_SetString_resultsByParams
	ResultsByParams_SetBytes         []MoqInt_starGenType_SetBytes_resultsByParams
	ResultsByParams_Bytes            []MoqInt_starGenType_Bytes_resultsByParams
	ResultsByParams_BitLen           []MoqInt_starGenType_BitLen_resultsByParams
	ResultsByParams_TrailingZeroBits []MoqInt_starGenType_TrailingZeroBits_resultsByParams
	ResultsByParams_Exp              []MoqInt_starGenType_Exp_resultsByParams
	ResultsByParams_GCD              []MoqInt_starGenType_GCD_resultsByParams
	ResultsByParams_Rand             []MoqInt_starGenType_Rand_resultsByParams
	ResultsByParams_ModInverse       []MoqInt_starGenType_ModInverse_resultsByParams
	ResultsByParams_ModSqrt          []MoqInt_starGenType_ModSqrt_resultsByParams
	ResultsByParams_Lsh              []MoqInt_starGenType_Lsh_resultsByParams
	ResultsByParams_Rsh              []MoqInt_starGenType_Rsh_resultsByParams
	ResultsByParams_Bit              []MoqInt_starGenType_Bit_resultsByParams
	ResultsByParams_SetBit           []MoqInt_starGenType_SetBit_resultsByParams
	ResultsByParams_And              []MoqInt_starGenType_And_resultsByParams
	ResultsByParams_AndNot           []MoqInt_starGenType_AndNot_resultsByParams
	ResultsByParams_Or               []MoqInt_starGenType_Or_resultsByParams
	ResultsByParams_Xor              []MoqInt_starGenType_Xor_resultsByParams
	ResultsByParams_Not              []MoqInt_starGenType_Not_resultsByParams
	ResultsByParams_Sqrt             []MoqInt_starGenType_Sqrt_resultsByParams
	ResultsByParams_Text             []MoqInt_starGenType_Text_resultsByParams
	ResultsByParams_Append           []MoqInt_starGenType_Append_resultsByParams
	ResultsByParams_String           []MoqInt_starGenType_String_resultsByParams
	ResultsByParams_Format           []MoqInt_starGenType_Format_resultsByParams
	ResultsByParams_Scan             []MoqInt_starGenType_Scan_resultsByParams
	ResultsByParams_GobEncode        []MoqInt_starGenType_GobEncode_resultsByParams
	ResultsByParams_GobDecode        []MoqInt_starGenType_GobDecode_resultsByParams
	ResultsByParams_MarshalText      []MoqInt_starGenType_MarshalText_resultsByParams
	ResultsByParams_UnmarshalText    []MoqInt_starGenType_UnmarshalText_resultsByParams
	ResultsByParams_MarshalJSON      []MoqInt_starGenType_MarshalJSON_resultsByParams
	ResultsByParams_UnmarshalJSON    []MoqInt_starGenType_UnmarshalJSON_resultsByParams
	ResultsByParams_ProbablyPrime    []MoqInt_starGenType_ProbablyPrime_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Sign     struct{}
			SetInt64 struct {
				X moq.ParamIndexing
			}
			SetUint64 struct {
				X moq.ParamIndexing
			}
			Set struct {
				X moq.ParamIndexing
			}
			Bits    struct{}
			SetBits struct {
				Abs moq.ParamIndexing
			}
			Abs struct {
				X moq.ParamIndexing
			}
			Neg struct {
				X moq.ParamIndexing
			}
			Add struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Sub struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Mul struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			MulRange struct {
				A moq.ParamIndexing
				B moq.ParamIndexing
			}
			Binomial struct {
				N moq.ParamIndexing
				K moq.ParamIndexing
			}
			Quo struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Rem struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			QuoRem struct {
				X      moq.ParamIndexing
				Y      moq.ParamIndexing
				Param3 moq.ParamIndexing
			}
			Div struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Mod struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			DivMod struct {
				X      moq.ParamIndexing
				Y      moq.ParamIndexing
				Param3 moq.ParamIndexing
			}
			Cmp struct {
				Y moq.ParamIndexing
			}
			CmpAbs struct {
				Y moq.ParamIndexing
			}
			Int64     struct{}
			Uint64    struct{}
			IsInt64   struct{}
			IsUint64  struct{}
			SetString struct {
				S    moq.ParamIndexing
				Base moq.ParamIndexing
			}
			SetBytes struct {
				Buf moq.ParamIndexing
			}
			Bytes            struct{}
			BitLen           struct{}
			TrailingZeroBits struct{}
			Exp              struct {
				X      moq.ParamIndexing
				Y      moq.ParamIndexing
				Param3 moq.ParamIndexing
			}
			GCD struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
				A moq.ParamIndexing
				B moq.ParamIndexing
			}
			Rand struct {
				Rnd moq.ParamIndexing
				N   moq.ParamIndexing
			}
			ModInverse struct {
				G moq.ParamIndexing
				N moq.ParamIndexing
			}
			ModSqrt struct {
				X moq.ParamIndexing
				P moq.ParamIndexing
			}
			Lsh struct {
				X moq.ParamIndexing
				N moq.ParamIndexing
			}
			Rsh struct {
				X moq.ParamIndexing
				N moq.ParamIndexing
			}
			Bit struct {
				Param1 moq.ParamIndexing
			}
			SetBit struct {
				X      moq.ParamIndexing
				Param2 moq.ParamIndexing
				B      moq.ParamIndexing
			}
			And struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			AndNot struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Or struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Xor struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Not struct {
				X moq.ParamIndexing
			}
			Sqrt struct {
				X moq.ParamIndexing
			}
			Text struct {
				Base moq.ParamIndexing
			}
			Append struct {
				Buf  moq.ParamIndexing
				Base moq.ParamIndexing
			}
			String struct{}
			Format struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}
			Scan struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}
			GobEncode struct{}
			GobDecode struct {
				Buf moq.ParamIndexing
			}
			MarshalText   struct{}
			UnmarshalText struct {
				Text moq.ParamIndexing
			}
			MarshalJSON   struct{}
			UnmarshalJSON struct {
				Text moq.ParamIndexing
			}
			ProbablyPrime struct {
				N moq.ParamIndexing
			}
		}
	}
	// MoqInt_starGenType_mock isolates the mock interface of the Int_starGenType
}

// type
type MoqInt_starGenType_mock struct {
	Moq *MoqInt_starGenType
}

// MoqInt_starGenType_recorder isolates the recorder interface of the
// Int_starGenType type
type MoqInt_starGenType_recorder struct {
	Moq *MoqInt_starGenType
}

// MoqInt_starGenType_Sign_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Sign_params struct{}

// MoqInt_starGenType_Sign_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Sign_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_Sign_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Sign_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Sign_paramsKey]*MoqInt_starGenType_Sign_results
}

// MoqInt_starGenType_Sign_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Sign_doFn func()

// MoqInt_starGenType_Sign_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Sign_doReturnFn func() int

// MoqInt_starGenType_Sign_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Sign_results struct {
	Params  MoqInt_starGenType_Sign_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Sign_doFn
		DoReturnFn MoqInt_starGenType_Sign_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Sign_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Sign_fnRecorder struct {
	Params    MoqInt_starGenType_Sign_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Sign_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Sign_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Sign_anyParams struct {
	Recorder *MoqInt_starGenType_Sign_fnRecorder
}

// MoqInt_starGenType_SetInt64_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_SetInt64_params struct{ X int64 }

// MoqInt_starGenType_SetInt64_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_SetInt64_paramsKey struct {
	Params struct{ X int64 }
	Hashes struct{ X hash.Hash }
}

// MoqInt_starGenType_SetInt64_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_SetInt64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_SetInt64_paramsKey]*MoqInt_starGenType_SetInt64_results
}

// MoqInt_starGenType_SetInt64_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_SetInt64_doFn func(x int64)

// MoqInt_starGenType_SetInt64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_SetInt64_doReturnFn func(x int64) *big.Int

// MoqInt_starGenType_SetInt64_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_SetInt64_results struct {
	Params  MoqInt_starGenType_SetInt64_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetInt64_doFn
		DoReturnFn MoqInt_starGenType_SetInt64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_SetInt64_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_SetInt64_fnRecorder struct {
	Params    MoqInt_starGenType_SetInt64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_SetInt64_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_SetInt64_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_SetInt64_anyParams struct {
	Recorder *MoqInt_starGenType_SetInt64_fnRecorder
}

// MoqInt_starGenType_SetUint64_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_SetUint64_params struct{ X uint64 }

// MoqInt_starGenType_SetUint64_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_SetUint64_paramsKey struct {
	Params struct{ X uint64 }
	Hashes struct{ X hash.Hash }
}

// MoqInt_starGenType_SetUint64_resultsByParams contains the results for a
// given set of parameters for the Int_starGenType type
type MoqInt_starGenType_SetUint64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_SetUint64_paramsKey]*MoqInt_starGenType_SetUint64_results
}

// MoqInt_starGenType_SetUint64_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_SetUint64_doFn func(x uint64)

// MoqInt_starGenType_SetUint64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_SetUint64_doReturnFn func(x uint64) *big.Int

// MoqInt_starGenType_SetUint64_results holds the results of the
// Int_starGenType type
type MoqInt_starGenType_SetUint64_results struct {
	Params  MoqInt_starGenType_SetUint64_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetUint64_doFn
		DoReturnFn MoqInt_starGenType_SetUint64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_SetUint64_fnRecorder routes recorded function calls to
// the MoqInt_starGenType moq
type MoqInt_starGenType_SetUint64_fnRecorder struct {
	Params    MoqInt_starGenType_SetUint64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_SetUint64_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_SetUint64_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_SetUint64_anyParams struct {
	Recorder *MoqInt_starGenType_SetUint64_fnRecorder
}

// MoqInt_starGenType_Set_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Set_params struct{ X *big.Int }

// MoqInt_starGenType_Set_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Set_paramsKey struct {
	Params struct{ X *big.Int }
	Hashes struct{ X hash.Hash }
}

// MoqInt_starGenType_Set_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Set_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Set_paramsKey]*MoqInt_starGenType_Set_results
}

// MoqInt_starGenType_Set_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Set_doFn func(x *big.Int)

// MoqInt_starGenType_Set_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Set_doReturnFn func(x *big.Int) *big.Int

// MoqInt_starGenType_Set_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Set_results struct {
	Params  MoqInt_starGenType_Set_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Set_doFn
		DoReturnFn MoqInt_starGenType_Set_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Set_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Set_fnRecorder struct {
	Params    MoqInt_starGenType_Set_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Set_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Set_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Set_anyParams struct {
	Recorder *MoqInt_starGenType_Set_fnRecorder
}

// MoqInt_starGenType_Bits_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Bits_params struct{}

// MoqInt_starGenType_Bits_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Bits_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_Bits_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Bits_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Bits_paramsKey]*MoqInt_starGenType_Bits_results
}

// MoqInt_starGenType_Bits_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Bits_doFn func()

// MoqInt_starGenType_Bits_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Bits_doReturnFn func() []big.Word

// MoqInt_starGenType_Bits_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Bits_results struct {
	Params  MoqInt_starGenType_Bits_params
	Results []struct {
		Values *struct {
			Result1 []big.Word
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Bits_doFn
		DoReturnFn MoqInt_starGenType_Bits_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Bits_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Bits_fnRecorder struct {
	Params    MoqInt_starGenType_Bits_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Bits_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Bits_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Bits_anyParams struct {
	Recorder *MoqInt_starGenType_Bits_fnRecorder
}

// MoqInt_starGenType_SetBits_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_SetBits_params struct{ Abs []big.Word }

// MoqInt_starGenType_SetBits_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_SetBits_paramsKey struct {
	Params struct{}
	Hashes struct{ Abs hash.Hash }
}

// MoqInt_starGenType_SetBits_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_SetBits_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_SetBits_paramsKey]*MoqInt_starGenType_SetBits_results
}

// MoqInt_starGenType_SetBits_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_SetBits_doFn func(abs []big.Word)

// MoqInt_starGenType_SetBits_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_SetBits_doReturnFn func(abs []big.Word) *big.Int

// MoqInt_starGenType_SetBits_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_SetBits_results struct {
	Params  MoqInt_starGenType_SetBits_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetBits_doFn
		DoReturnFn MoqInt_starGenType_SetBits_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_SetBits_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_SetBits_fnRecorder struct {
	Params    MoqInt_starGenType_SetBits_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_SetBits_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_SetBits_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_SetBits_anyParams struct {
	Recorder *MoqInt_starGenType_SetBits_fnRecorder
}

// MoqInt_starGenType_Abs_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Abs_params struct{ X *big.Int }

// MoqInt_starGenType_Abs_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Abs_paramsKey struct {
	Params struct{ X *big.Int }
	Hashes struct{ X hash.Hash }
}

// MoqInt_starGenType_Abs_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Abs_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Abs_paramsKey]*MoqInt_starGenType_Abs_results
}

// MoqInt_starGenType_Abs_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Abs_doFn func(x *big.Int)

// MoqInt_starGenType_Abs_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Abs_doReturnFn func(x *big.Int) *big.Int

// MoqInt_starGenType_Abs_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Abs_results struct {
	Params  MoqInt_starGenType_Abs_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Abs_doFn
		DoReturnFn MoqInt_starGenType_Abs_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Abs_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Abs_fnRecorder struct {
	Params    MoqInt_starGenType_Abs_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Abs_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Abs_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Abs_anyParams struct {
	Recorder *MoqInt_starGenType_Abs_fnRecorder
}

// MoqInt_starGenType_Neg_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Neg_params struct{ X *big.Int }

// MoqInt_starGenType_Neg_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Neg_paramsKey struct {
	Params struct{ X *big.Int }
	Hashes struct{ X hash.Hash }
}

// MoqInt_starGenType_Neg_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Neg_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Neg_paramsKey]*MoqInt_starGenType_Neg_results
}

// MoqInt_starGenType_Neg_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Neg_doFn func(x *big.Int)

// MoqInt_starGenType_Neg_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Neg_doReturnFn func(x *big.Int) *big.Int

// MoqInt_starGenType_Neg_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Neg_results struct {
	Params  MoqInt_starGenType_Neg_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Neg_doFn
		DoReturnFn MoqInt_starGenType_Neg_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Neg_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Neg_fnRecorder struct {
	Params    MoqInt_starGenType_Neg_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Neg_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Neg_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Neg_anyParams struct {
	Recorder *MoqInt_starGenType_Neg_fnRecorder
}

// MoqInt_starGenType_Add_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Add_params struct{ X, Y *big.Int }

// MoqInt_starGenType_Add_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Add_paramsKey struct {
	Params struct{ X, Y *big.Int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqInt_starGenType_Add_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Add_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Add_paramsKey]*MoqInt_starGenType_Add_results
}

// MoqInt_starGenType_Add_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Add_doFn func(x, y *big.Int)

// MoqInt_starGenType_Add_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Add_doReturnFn func(x, y *big.Int) *big.Int

// MoqInt_starGenType_Add_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Add_results struct {
	Params  MoqInt_starGenType_Add_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Add_doFn
		DoReturnFn MoqInt_starGenType_Add_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Add_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Add_fnRecorder struct {
	Params    MoqInt_starGenType_Add_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Add_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Add_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Add_anyParams struct {
	Recorder *MoqInt_starGenType_Add_fnRecorder
}

// MoqInt_starGenType_Sub_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Sub_params struct{ X, Y *big.Int }

// MoqInt_starGenType_Sub_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Sub_paramsKey struct {
	Params struct{ X, Y *big.Int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqInt_starGenType_Sub_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Sub_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Sub_paramsKey]*MoqInt_starGenType_Sub_results
}

// MoqInt_starGenType_Sub_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Sub_doFn func(x, y *big.Int)

// MoqInt_starGenType_Sub_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Sub_doReturnFn func(x, y *big.Int) *big.Int

// MoqInt_starGenType_Sub_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Sub_results struct {
	Params  MoqInt_starGenType_Sub_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Sub_doFn
		DoReturnFn MoqInt_starGenType_Sub_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Sub_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Sub_fnRecorder struct {
	Params    MoqInt_starGenType_Sub_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Sub_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Sub_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Sub_anyParams struct {
	Recorder *MoqInt_starGenType_Sub_fnRecorder
}

// MoqInt_starGenType_Mul_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Mul_params struct{ X, Y *big.Int }

// MoqInt_starGenType_Mul_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Mul_paramsKey struct {
	Params struct{ X, Y *big.Int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqInt_starGenType_Mul_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Mul_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Mul_paramsKey]*MoqInt_starGenType_Mul_results
}

// MoqInt_starGenType_Mul_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Mul_doFn func(x, y *big.Int)

// MoqInt_starGenType_Mul_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Mul_doReturnFn func(x, y *big.Int) *big.Int

// MoqInt_starGenType_Mul_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Mul_results struct {
	Params  MoqInt_starGenType_Mul_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Mul_doFn
		DoReturnFn MoqInt_starGenType_Mul_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Mul_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Mul_fnRecorder struct {
	Params    MoqInt_starGenType_Mul_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Mul_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Mul_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Mul_anyParams struct {
	Recorder *MoqInt_starGenType_Mul_fnRecorder
}

// MoqInt_starGenType_MulRange_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_MulRange_params struct{ A, B int64 }

// MoqInt_starGenType_MulRange_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_MulRange_paramsKey struct {
	Params struct{ A, B int64 }
	Hashes struct{ A, B hash.Hash }
}

// MoqInt_starGenType_MulRange_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_MulRange_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_MulRange_paramsKey]*MoqInt_starGenType_MulRange_results
}

// MoqInt_starGenType_MulRange_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_MulRange_doFn func(a, b int64)

// MoqInt_starGenType_MulRange_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_MulRange_doReturnFn func(a, b int64) *big.Int

// MoqInt_starGenType_MulRange_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_MulRange_results struct {
	Params  MoqInt_starGenType_MulRange_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_MulRange_doFn
		DoReturnFn MoqInt_starGenType_MulRange_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_MulRange_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_MulRange_fnRecorder struct {
	Params    MoqInt_starGenType_MulRange_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_MulRange_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_MulRange_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_MulRange_anyParams struct {
	Recorder *MoqInt_starGenType_MulRange_fnRecorder
}

// MoqInt_starGenType_Binomial_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_Binomial_params struct{ N, K int64 }

// MoqInt_starGenType_Binomial_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Binomial_paramsKey struct {
	Params struct{ N, K int64 }
	Hashes struct{ N, K hash.Hash }
}

// MoqInt_starGenType_Binomial_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_Binomial_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Binomial_paramsKey]*MoqInt_starGenType_Binomial_results
}

// MoqInt_starGenType_Binomial_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Binomial_doFn func(n, k int64)

// MoqInt_starGenType_Binomial_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Binomial_doReturnFn func(n, k int64) *big.Int

// MoqInt_starGenType_Binomial_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Binomial_results struct {
	Params  MoqInt_starGenType_Binomial_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Binomial_doFn
		DoReturnFn MoqInt_starGenType_Binomial_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Binomial_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Binomial_fnRecorder struct {
	Params    MoqInt_starGenType_Binomial_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Binomial_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Binomial_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_Binomial_anyParams struct {
	Recorder *MoqInt_starGenType_Binomial_fnRecorder
}

// MoqInt_starGenType_Quo_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Quo_params struct{ X, Y *big.Int }

// MoqInt_starGenType_Quo_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Quo_paramsKey struct {
	Params struct{ X, Y *big.Int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqInt_starGenType_Quo_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Quo_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Quo_paramsKey]*MoqInt_starGenType_Quo_results
}

// MoqInt_starGenType_Quo_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Quo_doFn func(x, y *big.Int)

// MoqInt_starGenType_Quo_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Quo_doReturnFn func(x, y *big.Int) *big.Int

// MoqInt_starGenType_Quo_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Quo_results struct {
	Params  MoqInt_starGenType_Quo_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Quo_doFn
		DoReturnFn MoqInt_starGenType_Quo_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Quo_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Quo_fnRecorder struct {
	Params    MoqInt_starGenType_Quo_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Quo_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Quo_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Quo_anyParams struct {
	Recorder *MoqInt_starGenType_Quo_fnRecorder
}

// MoqInt_starGenType_Rem_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Rem_params struct{ X, Y *big.Int }

// MoqInt_starGenType_Rem_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Rem_paramsKey struct {
	Params struct{ X, Y *big.Int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqInt_starGenType_Rem_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Rem_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Rem_paramsKey]*MoqInt_starGenType_Rem_results
}

// MoqInt_starGenType_Rem_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Rem_doFn func(x, y *big.Int)

// MoqInt_starGenType_Rem_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Rem_doReturnFn func(x, y *big.Int) *big.Int

// MoqInt_starGenType_Rem_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Rem_results struct {
	Params  MoqInt_starGenType_Rem_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Rem_doFn
		DoReturnFn MoqInt_starGenType_Rem_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Rem_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Rem_fnRecorder struct {
	Params    MoqInt_starGenType_Rem_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Rem_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Rem_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Rem_anyParams struct {
	Recorder *MoqInt_starGenType_Rem_fnRecorder
}

// MoqInt_starGenType_QuoRem_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_QuoRem_params struct{ X, Y, Param3 *big.Int }

// MoqInt_starGenType_QuoRem_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_QuoRem_paramsKey struct {
	Params struct{ X, Y, Param3 *big.Int }
	Hashes struct{ X, Y, Param3 hash.Hash }
}

// MoqInt_starGenType_QuoRem_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_QuoRem_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_QuoRem_paramsKey]*MoqInt_starGenType_QuoRem_results
}

// MoqInt_starGenType_QuoRem_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_QuoRem_doFn func(x, y, r *big.Int)

// MoqInt_starGenType_QuoRem_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_QuoRem_doReturnFn func(x, y, r *big.Int) (*big.Int, *big.Int)

// MoqInt_starGenType_QuoRem_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_QuoRem_results struct {
	Params  MoqInt_starGenType_QuoRem_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
			Result2 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_QuoRem_doFn
		DoReturnFn MoqInt_starGenType_QuoRem_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_QuoRem_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_QuoRem_fnRecorder struct {
	Params    MoqInt_starGenType_QuoRem_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_QuoRem_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_QuoRem_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_QuoRem_anyParams struct {
	Recorder *MoqInt_starGenType_QuoRem_fnRecorder
}

// MoqInt_starGenType_Div_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Div_params struct{ X, Y *big.Int }

// MoqInt_starGenType_Div_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Div_paramsKey struct {
	Params struct{ X, Y *big.Int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqInt_starGenType_Div_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Div_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Div_paramsKey]*MoqInt_starGenType_Div_results
}

// MoqInt_starGenType_Div_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Div_doFn func(x, y *big.Int)

// MoqInt_starGenType_Div_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Div_doReturnFn func(x, y *big.Int) *big.Int

// MoqInt_starGenType_Div_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Div_results struct {
	Params  MoqInt_starGenType_Div_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Div_doFn
		DoReturnFn MoqInt_starGenType_Div_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Div_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Div_fnRecorder struct {
	Params    MoqInt_starGenType_Div_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Div_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Div_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Div_anyParams struct {
	Recorder *MoqInt_starGenType_Div_fnRecorder
}

// MoqInt_starGenType_Mod_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Mod_params struct{ X, Y *big.Int }

// MoqInt_starGenType_Mod_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Mod_paramsKey struct {
	Params struct{ X, Y *big.Int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqInt_starGenType_Mod_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Mod_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Mod_paramsKey]*MoqInt_starGenType_Mod_results
}

// MoqInt_starGenType_Mod_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Mod_doFn func(x, y *big.Int)

// MoqInt_starGenType_Mod_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Mod_doReturnFn func(x, y *big.Int) *big.Int

// MoqInt_starGenType_Mod_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Mod_results struct {
	Params  MoqInt_starGenType_Mod_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Mod_doFn
		DoReturnFn MoqInt_starGenType_Mod_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Mod_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Mod_fnRecorder struct {
	Params    MoqInt_starGenType_Mod_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Mod_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Mod_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Mod_anyParams struct {
	Recorder *MoqInt_starGenType_Mod_fnRecorder
}

// MoqInt_starGenType_DivMod_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_DivMod_params struct{ X, Y, Param3 *big.Int }

// MoqInt_starGenType_DivMod_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_DivMod_paramsKey struct {
	Params struct{ X, Y, Param3 *big.Int }
	Hashes struct{ X, Y, Param3 hash.Hash }
}

// MoqInt_starGenType_DivMod_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_DivMod_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_DivMod_paramsKey]*MoqInt_starGenType_DivMod_results
}

// MoqInt_starGenType_DivMod_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_DivMod_doFn func(x, y, m *big.Int)

// MoqInt_starGenType_DivMod_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_DivMod_doReturnFn func(x, y, m *big.Int) (*big.Int, *big.Int)

// MoqInt_starGenType_DivMod_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_DivMod_results struct {
	Params  MoqInt_starGenType_DivMod_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
			Result2 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_DivMod_doFn
		DoReturnFn MoqInt_starGenType_DivMod_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_DivMod_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_DivMod_fnRecorder struct {
	Params    MoqInt_starGenType_DivMod_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_DivMod_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_DivMod_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_DivMod_anyParams struct {
	Recorder *MoqInt_starGenType_DivMod_fnRecorder
}

// MoqInt_starGenType_Cmp_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Cmp_params struct{ Y *big.Int }

// MoqInt_starGenType_Cmp_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Cmp_paramsKey struct {
	Params struct{ Y *big.Int }
	Hashes struct{ Y hash.Hash }
}

// MoqInt_starGenType_Cmp_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Cmp_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Cmp_paramsKey]*MoqInt_starGenType_Cmp_results
}

// MoqInt_starGenType_Cmp_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Cmp_doFn func(y *big.Int)

// MoqInt_starGenType_Cmp_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Cmp_doReturnFn func(y *big.Int) (r int)

// MoqInt_starGenType_Cmp_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Cmp_results struct {
	Params  MoqInt_starGenType_Cmp_params
	Results []struct {
		Values     *struct{ Result1 int }
		Sequence   uint32
		DoFn       MoqInt_starGenType_Cmp_doFn
		DoReturnFn MoqInt_starGenType_Cmp_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Cmp_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Cmp_fnRecorder struct {
	Params    MoqInt_starGenType_Cmp_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Cmp_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Cmp_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Cmp_anyParams struct {
	Recorder *MoqInt_starGenType_Cmp_fnRecorder
}

// MoqInt_starGenType_CmpAbs_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_CmpAbs_params struct{ Y *big.Int }

// MoqInt_starGenType_CmpAbs_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_CmpAbs_paramsKey struct {
	Params struct{ Y *big.Int }
	Hashes struct{ Y hash.Hash }
}

// MoqInt_starGenType_CmpAbs_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_CmpAbs_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_CmpAbs_paramsKey]*MoqInt_starGenType_CmpAbs_results
}

// MoqInt_starGenType_CmpAbs_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_CmpAbs_doFn func(y *big.Int)

// MoqInt_starGenType_CmpAbs_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_CmpAbs_doReturnFn func(y *big.Int) int

// MoqInt_starGenType_CmpAbs_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_CmpAbs_results struct {
	Params  MoqInt_starGenType_CmpAbs_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_CmpAbs_doFn
		DoReturnFn MoqInt_starGenType_CmpAbs_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_CmpAbs_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_CmpAbs_fnRecorder struct {
	Params    MoqInt_starGenType_CmpAbs_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_CmpAbs_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_CmpAbs_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_CmpAbs_anyParams struct {
	Recorder *MoqInt_starGenType_CmpAbs_fnRecorder
}

// MoqInt_starGenType_Int64_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Int64_params struct{}

// MoqInt_starGenType_Int64_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Int64_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_Int64_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_Int64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Int64_paramsKey]*MoqInt_starGenType_Int64_results
}

// MoqInt_starGenType_Int64_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Int64_doFn func()

// MoqInt_starGenType_Int64_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Int64_doReturnFn func() int64

// MoqInt_starGenType_Int64_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Int64_results struct {
	Params  MoqInt_starGenType_Int64_params
	Results []struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Int64_doFn
		DoReturnFn MoqInt_starGenType_Int64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Int64_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Int64_fnRecorder struct {
	Params    MoqInt_starGenType_Int64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Int64_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Int64_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Int64_anyParams struct {
	Recorder *MoqInt_starGenType_Int64_fnRecorder
}

// MoqInt_starGenType_Uint64_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_Uint64_params struct{}

// MoqInt_starGenType_Uint64_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Uint64_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_Uint64_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_Uint64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Uint64_paramsKey]*MoqInt_starGenType_Uint64_results
}

// MoqInt_starGenType_Uint64_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Uint64_doFn func()

// MoqInt_starGenType_Uint64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Uint64_doReturnFn func() uint64

// MoqInt_starGenType_Uint64_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Uint64_results struct {
	Params  MoqInt_starGenType_Uint64_params
	Results []struct {
		Values *struct {
			Result1 uint64
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Uint64_doFn
		DoReturnFn MoqInt_starGenType_Uint64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Uint64_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Uint64_fnRecorder struct {
	Params    MoqInt_starGenType_Uint64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Uint64_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Uint64_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Uint64_anyParams struct {
	Recorder *MoqInt_starGenType_Uint64_fnRecorder
}

// MoqInt_starGenType_IsInt64_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_IsInt64_params struct{}

// MoqInt_starGenType_IsInt64_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_IsInt64_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_IsInt64_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_IsInt64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_IsInt64_paramsKey]*MoqInt_starGenType_IsInt64_results
}

// MoqInt_starGenType_IsInt64_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_IsInt64_doFn func()

// MoqInt_starGenType_IsInt64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_IsInt64_doReturnFn func() bool

// MoqInt_starGenType_IsInt64_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_IsInt64_results struct {
	Params  MoqInt_starGenType_IsInt64_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_IsInt64_doFn
		DoReturnFn MoqInt_starGenType_IsInt64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_IsInt64_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_IsInt64_fnRecorder struct {
	Params    MoqInt_starGenType_IsInt64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_IsInt64_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_IsInt64_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_IsInt64_anyParams struct {
	Recorder *MoqInt_starGenType_IsInt64_fnRecorder
}

// MoqInt_starGenType_IsUint64_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_IsUint64_params struct{}

// MoqInt_starGenType_IsUint64_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_IsUint64_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_IsUint64_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_IsUint64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_IsUint64_paramsKey]*MoqInt_starGenType_IsUint64_results
}

// MoqInt_starGenType_IsUint64_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_IsUint64_doFn func()

// MoqInt_starGenType_IsUint64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_IsUint64_doReturnFn func() bool

// MoqInt_starGenType_IsUint64_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_IsUint64_results struct {
	Params  MoqInt_starGenType_IsUint64_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_IsUint64_doFn
		DoReturnFn MoqInt_starGenType_IsUint64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_IsUint64_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_IsUint64_fnRecorder struct {
	Params    MoqInt_starGenType_IsUint64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_IsUint64_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_IsUint64_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_IsUint64_anyParams struct {
	Recorder *MoqInt_starGenType_IsUint64_fnRecorder
}

// MoqInt_starGenType_SetString_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_SetString_params struct {
	S    string
	Base int
}

// MoqInt_starGenType_SetString_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_SetString_paramsKey struct {
	Params struct {
		S    string
		Base int
	}
	Hashes struct {
		S    hash.Hash
		Base hash.Hash
	}
}

// MoqInt_starGenType_SetString_resultsByParams contains the results for a
// given set of parameters for the Int_starGenType type
type MoqInt_starGenType_SetString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_SetString_paramsKey]*MoqInt_starGenType_SetString_results
}

// MoqInt_starGenType_SetString_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_SetString_doFn func(s string, base int)

// MoqInt_starGenType_SetString_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_SetString_doReturnFn func(s string, base int) (*big.Int, bool)

// MoqInt_starGenType_SetString_results holds the results of the
// Int_starGenType type
type MoqInt_starGenType_SetString_results struct {
	Params  MoqInt_starGenType_SetString_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetString_doFn
		DoReturnFn MoqInt_starGenType_SetString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_SetString_fnRecorder routes recorded function calls to
// the MoqInt_starGenType moq
type MoqInt_starGenType_SetString_fnRecorder struct {
	Params    MoqInt_starGenType_SetString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_SetString_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_SetString_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_SetString_anyParams struct {
	Recorder *MoqInt_starGenType_SetString_fnRecorder
}

// MoqInt_starGenType_SetBytes_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_SetBytes_params struct{ Buf []byte }

// MoqInt_starGenType_SetBytes_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_SetBytes_paramsKey struct {
	Params struct{}
	Hashes struct{ Buf hash.Hash }
}

// MoqInt_starGenType_SetBytes_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_SetBytes_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_SetBytes_paramsKey]*MoqInt_starGenType_SetBytes_results
}

// MoqInt_starGenType_SetBytes_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_SetBytes_doFn func(buf []byte)

// MoqInt_starGenType_SetBytes_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_SetBytes_doReturnFn func(buf []byte) *big.Int

// MoqInt_starGenType_SetBytes_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_SetBytes_results struct {
	Params  MoqInt_starGenType_SetBytes_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetBytes_doFn
		DoReturnFn MoqInt_starGenType_SetBytes_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_SetBytes_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_SetBytes_fnRecorder struct {
	Params    MoqInt_starGenType_SetBytes_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_SetBytes_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_SetBytes_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_SetBytes_anyParams struct {
	Recorder *MoqInt_starGenType_SetBytes_fnRecorder
}

// MoqInt_starGenType_Bytes_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Bytes_params struct{}

// MoqInt_starGenType_Bytes_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Bytes_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_Bytes_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_Bytes_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Bytes_paramsKey]*MoqInt_starGenType_Bytes_results
}

// MoqInt_starGenType_Bytes_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Bytes_doFn func()

// MoqInt_starGenType_Bytes_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Bytes_doReturnFn func() []byte

// MoqInt_starGenType_Bytes_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Bytes_results struct {
	Params  MoqInt_starGenType_Bytes_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Bytes_doFn
		DoReturnFn MoqInt_starGenType_Bytes_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Bytes_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Bytes_fnRecorder struct {
	Params    MoqInt_starGenType_Bytes_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Bytes_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Bytes_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Bytes_anyParams struct {
	Recorder *MoqInt_starGenType_Bytes_fnRecorder
}

// MoqInt_starGenType_BitLen_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_BitLen_params struct{}

// MoqInt_starGenType_BitLen_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_BitLen_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_BitLen_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_BitLen_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_BitLen_paramsKey]*MoqInt_starGenType_BitLen_results
}

// MoqInt_starGenType_BitLen_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_BitLen_doFn func()

// MoqInt_starGenType_BitLen_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_BitLen_doReturnFn func() int

// MoqInt_starGenType_BitLen_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_BitLen_results struct {
	Params  MoqInt_starGenType_BitLen_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_BitLen_doFn
		DoReturnFn MoqInt_starGenType_BitLen_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_BitLen_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_BitLen_fnRecorder struct {
	Params    MoqInt_starGenType_BitLen_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_BitLen_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_BitLen_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_BitLen_anyParams struct {
	Recorder *MoqInt_starGenType_BitLen_fnRecorder
}

// MoqInt_starGenType_TrailingZeroBits_params holds the params of the
// Int_starGenType type
type MoqInt_starGenType_TrailingZeroBits_params struct{}

// MoqInt_starGenType_TrailingZeroBits_paramsKey holds the map key params of
// the Int_starGenType type
type MoqInt_starGenType_TrailingZeroBits_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_TrailingZeroBits_resultsByParams contains the results for
// a given set of parameters for the Int_starGenType type
type MoqInt_starGenType_TrailingZeroBits_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_TrailingZeroBits_paramsKey]*MoqInt_starGenType_TrailingZeroBits_results
}

// MoqInt_starGenType_TrailingZeroBits_doFn defines the type of function needed
// when calling AndDo for the Int_starGenType type
type MoqInt_starGenType_TrailingZeroBits_doFn func()

// MoqInt_starGenType_TrailingZeroBits_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_TrailingZeroBits_doReturnFn func() uint

// MoqInt_starGenType_TrailingZeroBits_results holds the results of the
// Int_starGenType type
type MoqInt_starGenType_TrailingZeroBits_results struct {
	Params  MoqInt_starGenType_TrailingZeroBits_params
	Results []struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_TrailingZeroBits_doFn
		DoReturnFn MoqInt_starGenType_TrailingZeroBits_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_TrailingZeroBits_fnRecorder routes recorded function
// calls to the MoqInt_starGenType moq
type MoqInt_starGenType_TrailingZeroBits_fnRecorder struct {
	Params    MoqInt_starGenType_TrailingZeroBits_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_TrailingZeroBits_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_TrailingZeroBits_anyParams isolates the any params
// functions of the Int_starGenType type
type MoqInt_starGenType_TrailingZeroBits_anyParams struct {
	Recorder *MoqInt_starGenType_TrailingZeroBits_fnRecorder
}

// MoqInt_starGenType_Exp_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Exp_params struct{ X, Y, Param3 *big.Int }

// MoqInt_starGenType_Exp_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Exp_paramsKey struct {
	Params struct{ X, Y, Param3 *big.Int }
	Hashes struct{ X, Y, Param3 hash.Hash }
}

// MoqInt_starGenType_Exp_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Exp_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Exp_paramsKey]*MoqInt_starGenType_Exp_results
}

// MoqInt_starGenType_Exp_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Exp_doFn func(x, y, m *big.Int)

// MoqInt_starGenType_Exp_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Exp_doReturnFn func(x, y, m *big.Int) *big.Int

// MoqInt_starGenType_Exp_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Exp_results struct {
	Params  MoqInt_starGenType_Exp_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Exp_doFn
		DoReturnFn MoqInt_starGenType_Exp_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Exp_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Exp_fnRecorder struct {
	Params    MoqInt_starGenType_Exp_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Exp_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Exp_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Exp_anyParams struct {
	Recorder *MoqInt_starGenType_Exp_fnRecorder
}

// MoqInt_starGenType_GCD_params holds the params of the Int_starGenType type
type MoqInt_starGenType_GCD_params struct{ X, Y, A, B *big.Int }

// MoqInt_starGenType_GCD_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_GCD_paramsKey struct {
	Params struct{ X, Y, A, B *big.Int }
	Hashes struct{ X, Y, A, B hash.Hash }
}

// MoqInt_starGenType_GCD_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_GCD_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_GCD_paramsKey]*MoqInt_starGenType_GCD_results
}

// MoqInt_starGenType_GCD_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_GCD_doFn func(x, y, a, b *big.Int)

// MoqInt_starGenType_GCD_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_GCD_doReturnFn func(x, y, a, b *big.Int) *big.Int

// MoqInt_starGenType_GCD_results holds the results of the Int_starGenType type
type MoqInt_starGenType_GCD_results struct {
	Params  MoqInt_starGenType_GCD_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_GCD_doFn
		DoReturnFn MoqInt_starGenType_GCD_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_GCD_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_GCD_fnRecorder struct {
	Params    MoqInt_starGenType_GCD_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_GCD_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_GCD_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_GCD_anyParams struct {
	Recorder *MoqInt_starGenType_GCD_fnRecorder
}

// MoqInt_starGenType_Rand_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Rand_params struct {
	Rnd *rand.Rand
	N   *big.Int
}

// MoqInt_starGenType_Rand_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Rand_paramsKey struct {
	Params struct {
		Rnd *rand.Rand
		N   *big.Int
	}
	Hashes struct {
		Rnd hash.Hash
		N   hash.Hash
	}
}

// MoqInt_starGenType_Rand_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Rand_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Rand_paramsKey]*MoqInt_starGenType_Rand_results
}

// MoqInt_starGenType_Rand_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Rand_doFn func(rnd *rand.Rand, n *big.Int)

// MoqInt_starGenType_Rand_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Rand_doReturnFn func(rnd *rand.Rand, n *big.Int) *big.Int

// MoqInt_starGenType_Rand_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Rand_results struct {
	Params  MoqInt_starGenType_Rand_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Rand_doFn
		DoReturnFn MoqInt_starGenType_Rand_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Rand_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Rand_fnRecorder struct {
	Params    MoqInt_starGenType_Rand_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Rand_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Rand_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Rand_anyParams struct {
	Recorder *MoqInt_starGenType_Rand_fnRecorder
}

// MoqInt_starGenType_ModInverse_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_ModInverse_params struct{ G, N *big.Int }

// MoqInt_starGenType_ModInverse_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_ModInverse_paramsKey struct {
	Params struct{ G, N *big.Int }
	Hashes struct{ G, N hash.Hash }
}

// MoqInt_starGenType_ModInverse_resultsByParams contains the results for a
// given set of parameters for the Int_starGenType type
type MoqInt_starGenType_ModInverse_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_ModInverse_paramsKey]*MoqInt_starGenType_ModInverse_results
}

// MoqInt_starGenType_ModInverse_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_ModInverse_doFn func(g, n *big.Int)

// MoqInt_starGenType_ModInverse_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_ModInverse_doReturnFn func(g, n *big.Int) *big.Int

// MoqInt_starGenType_ModInverse_results holds the results of the
// Int_starGenType type
type MoqInt_starGenType_ModInverse_results struct {
	Params  MoqInt_starGenType_ModInverse_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_ModInverse_doFn
		DoReturnFn MoqInt_starGenType_ModInverse_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_ModInverse_fnRecorder routes recorded function calls to
// the MoqInt_starGenType moq
type MoqInt_starGenType_ModInverse_fnRecorder struct {
	Params    MoqInt_starGenType_ModInverse_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_ModInverse_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_ModInverse_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_ModInverse_anyParams struct {
	Recorder *MoqInt_starGenType_ModInverse_fnRecorder
}

// MoqInt_starGenType_ModSqrt_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_ModSqrt_params struct{ X, P *big.Int }

// MoqInt_starGenType_ModSqrt_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_ModSqrt_paramsKey struct {
	Params struct{ X, P *big.Int }
	Hashes struct{ X, P hash.Hash }
}

// MoqInt_starGenType_ModSqrt_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_ModSqrt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_ModSqrt_paramsKey]*MoqInt_starGenType_ModSqrt_results
}

// MoqInt_starGenType_ModSqrt_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_ModSqrt_doFn func(x, p *big.Int)

// MoqInt_starGenType_ModSqrt_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_ModSqrt_doReturnFn func(x, p *big.Int) *big.Int

// MoqInt_starGenType_ModSqrt_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_ModSqrt_results struct {
	Params  MoqInt_starGenType_ModSqrt_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_ModSqrt_doFn
		DoReturnFn MoqInt_starGenType_ModSqrt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_ModSqrt_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_ModSqrt_fnRecorder struct {
	Params    MoqInt_starGenType_ModSqrt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_ModSqrt_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_ModSqrt_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_ModSqrt_anyParams struct {
	Recorder *MoqInt_starGenType_ModSqrt_fnRecorder
}

// MoqInt_starGenType_Lsh_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Lsh_params struct {
	X *big.Int
	N uint
}

// MoqInt_starGenType_Lsh_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Lsh_paramsKey struct {
	Params struct {
		X *big.Int
		N uint
	}
	Hashes struct {
		X hash.Hash
		N hash.Hash
	}
}

// MoqInt_starGenType_Lsh_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Lsh_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Lsh_paramsKey]*MoqInt_starGenType_Lsh_results
}

// MoqInt_starGenType_Lsh_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Lsh_doFn func(x *big.Int, n uint)

// MoqInt_starGenType_Lsh_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Lsh_doReturnFn func(x *big.Int, n uint) *big.Int

// MoqInt_starGenType_Lsh_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Lsh_results struct {
	Params  MoqInt_starGenType_Lsh_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Lsh_doFn
		DoReturnFn MoqInt_starGenType_Lsh_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Lsh_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Lsh_fnRecorder struct {
	Params    MoqInt_starGenType_Lsh_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Lsh_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Lsh_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Lsh_anyParams struct {
	Recorder *MoqInt_starGenType_Lsh_fnRecorder
}

// MoqInt_starGenType_Rsh_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Rsh_params struct {
	X *big.Int
	N uint
}

// MoqInt_starGenType_Rsh_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Rsh_paramsKey struct {
	Params struct {
		X *big.Int
		N uint
	}
	Hashes struct {
		X hash.Hash
		N hash.Hash
	}
}

// MoqInt_starGenType_Rsh_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Rsh_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Rsh_paramsKey]*MoqInt_starGenType_Rsh_results
}

// MoqInt_starGenType_Rsh_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Rsh_doFn func(x *big.Int, n uint)

// MoqInt_starGenType_Rsh_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Rsh_doReturnFn func(x *big.Int, n uint) *big.Int

// MoqInt_starGenType_Rsh_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Rsh_results struct {
	Params  MoqInt_starGenType_Rsh_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Rsh_doFn
		DoReturnFn MoqInt_starGenType_Rsh_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Rsh_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Rsh_fnRecorder struct {
	Params    MoqInt_starGenType_Rsh_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Rsh_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Rsh_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Rsh_anyParams struct {
	Recorder *MoqInt_starGenType_Rsh_fnRecorder
}

// MoqInt_starGenType_Bit_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Bit_params struct{ Param1 int }

// MoqInt_starGenType_Bit_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Bit_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqInt_starGenType_Bit_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Bit_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Bit_paramsKey]*MoqInt_starGenType_Bit_results
}

// MoqInt_starGenType_Bit_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Bit_doFn func(i int)

// MoqInt_starGenType_Bit_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Bit_doReturnFn func(i int) uint

// MoqInt_starGenType_Bit_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Bit_results struct {
	Params  MoqInt_starGenType_Bit_params
	Results []struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Bit_doFn
		DoReturnFn MoqInt_starGenType_Bit_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Bit_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Bit_fnRecorder struct {
	Params    MoqInt_starGenType_Bit_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Bit_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Bit_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Bit_anyParams struct {
	Recorder *MoqInt_starGenType_Bit_fnRecorder
}

// MoqInt_starGenType_SetBit_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_SetBit_params struct {
	X      *big.Int
	Param2 int
	B      uint
}

// MoqInt_starGenType_SetBit_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_SetBit_paramsKey struct {
	Params struct {
		X      *big.Int
		Param2 int
		B      uint
	}
	Hashes struct {
		X      hash.Hash
		Param2 hash.Hash
		B      hash.Hash
	}
}

// MoqInt_starGenType_SetBit_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_SetBit_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_SetBit_paramsKey]*MoqInt_starGenType_SetBit_results
}

// MoqInt_starGenType_SetBit_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_SetBit_doFn func(x *big.Int, i int, b uint)

// MoqInt_starGenType_SetBit_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_SetBit_doReturnFn func(x *big.Int, i int, b uint) *big.Int

// MoqInt_starGenType_SetBit_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_SetBit_results struct {
	Params  MoqInt_starGenType_SetBit_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetBit_doFn
		DoReturnFn MoqInt_starGenType_SetBit_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_SetBit_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_SetBit_fnRecorder struct {
	Params    MoqInt_starGenType_SetBit_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_SetBit_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_SetBit_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_SetBit_anyParams struct {
	Recorder *MoqInt_starGenType_SetBit_fnRecorder
}

// MoqInt_starGenType_And_params holds the params of the Int_starGenType type
type MoqInt_starGenType_And_params struct{ X, Y *big.Int }

// MoqInt_starGenType_And_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_And_paramsKey struct {
	Params struct{ X, Y *big.Int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqInt_starGenType_And_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_And_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_And_paramsKey]*MoqInt_starGenType_And_results
}

// MoqInt_starGenType_And_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_And_doFn func(x, y *big.Int)

// MoqInt_starGenType_And_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_And_doReturnFn func(x, y *big.Int) *big.Int

// MoqInt_starGenType_And_results holds the results of the Int_starGenType type
type MoqInt_starGenType_And_results struct {
	Params  MoqInt_starGenType_And_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_And_doFn
		DoReturnFn MoqInt_starGenType_And_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_And_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_And_fnRecorder struct {
	Params    MoqInt_starGenType_And_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_And_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_And_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_And_anyParams struct {
	Recorder *MoqInt_starGenType_And_fnRecorder
}

// MoqInt_starGenType_AndNot_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_AndNot_params struct{ X, Y *big.Int }

// MoqInt_starGenType_AndNot_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_AndNot_paramsKey struct {
	Params struct{ X, Y *big.Int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqInt_starGenType_AndNot_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_AndNot_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_AndNot_paramsKey]*MoqInt_starGenType_AndNot_results
}

// MoqInt_starGenType_AndNot_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_AndNot_doFn func(x, y *big.Int)

// MoqInt_starGenType_AndNot_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_AndNot_doReturnFn func(x, y *big.Int) *big.Int

// MoqInt_starGenType_AndNot_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_AndNot_results struct {
	Params  MoqInt_starGenType_AndNot_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_AndNot_doFn
		DoReturnFn MoqInt_starGenType_AndNot_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_AndNot_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_AndNot_fnRecorder struct {
	Params    MoqInt_starGenType_AndNot_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_AndNot_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_AndNot_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_AndNot_anyParams struct {
	Recorder *MoqInt_starGenType_AndNot_fnRecorder
}

// MoqInt_starGenType_Or_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Or_params struct{ X, Y *big.Int }

// MoqInt_starGenType_Or_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Or_paramsKey struct {
	Params struct{ X, Y *big.Int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqInt_starGenType_Or_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Or_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Or_paramsKey]*MoqInt_starGenType_Or_results
}

// MoqInt_starGenType_Or_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Or_doFn func(x, y *big.Int)

// MoqInt_starGenType_Or_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Or_doReturnFn func(x, y *big.Int) *big.Int

// MoqInt_starGenType_Or_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Or_results struct {
	Params  MoqInt_starGenType_Or_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Or_doFn
		DoReturnFn MoqInt_starGenType_Or_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Or_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Or_fnRecorder struct {
	Params    MoqInt_starGenType_Or_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Or_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Or_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Or_anyParams struct {
	Recorder *MoqInt_starGenType_Or_fnRecorder
}

// MoqInt_starGenType_Xor_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Xor_params struct{ X, Y *big.Int }

// MoqInt_starGenType_Xor_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Xor_paramsKey struct {
	Params struct{ X, Y *big.Int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqInt_starGenType_Xor_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Xor_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Xor_paramsKey]*MoqInt_starGenType_Xor_results
}

// MoqInt_starGenType_Xor_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Xor_doFn func(x, y *big.Int)

// MoqInt_starGenType_Xor_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Xor_doReturnFn func(x, y *big.Int) *big.Int

// MoqInt_starGenType_Xor_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Xor_results struct {
	Params  MoqInt_starGenType_Xor_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Xor_doFn
		DoReturnFn MoqInt_starGenType_Xor_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Xor_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Xor_fnRecorder struct {
	Params    MoqInt_starGenType_Xor_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Xor_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Xor_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Xor_anyParams struct {
	Recorder *MoqInt_starGenType_Xor_fnRecorder
}

// MoqInt_starGenType_Not_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Not_params struct{ X *big.Int }

// MoqInt_starGenType_Not_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Not_paramsKey struct {
	Params struct{ X *big.Int }
	Hashes struct{ X hash.Hash }
}

// MoqInt_starGenType_Not_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Not_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Not_paramsKey]*MoqInt_starGenType_Not_results
}

// MoqInt_starGenType_Not_doFn defines the type of function needed when calling
// AndDo for the Int_starGenType type
type MoqInt_starGenType_Not_doFn func(x *big.Int)

// MoqInt_starGenType_Not_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Not_doReturnFn func(x *big.Int) *big.Int

// MoqInt_starGenType_Not_results holds the results of the Int_starGenType type
type MoqInt_starGenType_Not_results struct {
	Params  MoqInt_starGenType_Not_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Not_doFn
		DoReturnFn MoqInt_starGenType_Not_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Not_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Not_fnRecorder struct {
	Params    MoqInt_starGenType_Not_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Not_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Not_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Not_anyParams struct {
	Recorder *MoqInt_starGenType_Not_fnRecorder
}

// MoqInt_starGenType_Sqrt_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Sqrt_params struct{ X *big.Int }

// MoqInt_starGenType_Sqrt_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Sqrt_paramsKey struct {
	Params struct{ X *big.Int }
	Hashes struct{ X hash.Hash }
}

// MoqInt_starGenType_Sqrt_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Sqrt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Sqrt_paramsKey]*MoqInt_starGenType_Sqrt_results
}

// MoqInt_starGenType_Sqrt_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Sqrt_doFn func(x *big.Int)

// MoqInt_starGenType_Sqrt_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Sqrt_doReturnFn func(x *big.Int) *big.Int

// MoqInt_starGenType_Sqrt_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Sqrt_results struct {
	Params  MoqInt_starGenType_Sqrt_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Sqrt_doFn
		DoReturnFn MoqInt_starGenType_Sqrt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Sqrt_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Sqrt_fnRecorder struct {
	Params    MoqInt_starGenType_Sqrt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Sqrt_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Sqrt_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Sqrt_anyParams struct {
	Recorder *MoqInt_starGenType_Sqrt_fnRecorder
}

// MoqInt_starGenType_Text_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Text_params struct{ Base int }

// MoqInt_starGenType_Text_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Text_paramsKey struct {
	Params struct{ Base int }
	Hashes struct{ Base hash.Hash }
}

// MoqInt_starGenType_Text_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Text_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Text_paramsKey]*MoqInt_starGenType_Text_results
}

// MoqInt_starGenType_Text_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Text_doFn func(base int)

// MoqInt_starGenType_Text_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Text_doReturnFn func(base int) string

// MoqInt_starGenType_Text_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Text_results struct {
	Params  MoqInt_starGenType_Text_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Text_doFn
		DoReturnFn MoqInt_starGenType_Text_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Text_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Text_fnRecorder struct {
	Params    MoqInt_starGenType_Text_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Text_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Text_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Text_anyParams struct {
	Recorder *MoqInt_starGenType_Text_fnRecorder
}

// MoqInt_starGenType_Append_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_Append_params struct {
	Buf  []byte
	Base int
}

// MoqInt_starGenType_Append_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Append_paramsKey struct {
	Params struct{ Base int }
	Hashes struct {
		Buf  hash.Hash
		Base hash.Hash
	}
}

// MoqInt_starGenType_Append_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_Append_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Append_paramsKey]*MoqInt_starGenType_Append_results
}

// MoqInt_starGenType_Append_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Append_doFn func(buf []byte, base int)

// MoqInt_starGenType_Append_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Append_doReturnFn func(buf []byte, base int) []byte

// MoqInt_starGenType_Append_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Append_results struct {
	Params  MoqInt_starGenType_Append_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Append_doFn
		DoReturnFn MoqInt_starGenType_Append_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Append_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Append_fnRecorder struct {
	Params    MoqInt_starGenType_Append_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Append_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Append_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Append_anyParams struct {
	Recorder *MoqInt_starGenType_Append_fnRecorder
}

// MoqInt_starGenType_String_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_String_params struct{}

// MoqInt_starGenType_String_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_String_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_String_paramsKey]*MoqInt_starGenType_String_results
}

// MoqInt_starGenType_String_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_String_doFn func()

// MoqInt_starGenType_String_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_String_doReturnFn func() string

// MoqInt_starGenType_String_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_String_results struct {
	Params  MoqInt_starGenType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_String_doFn
		DoReturnFn MoqInt_starGenType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_String_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_String_fnRecorder struct {
	Params    MoqInt_starGenType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_String_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_String_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_String_anyParams struct {
	Recorder *MoqInt_starGenType_String_fnRecorder
}

// MoqInt_starGenType_Format_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_Format_params struct {
	S  fmt.State
	Ch rune
}

// MoqInt_starGenType_Format_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Format_paramsKey struct {
	Params struct {
		S  fmt.State
		Ch rune
	}
	Hashes struct {
		S  hash.Hash
		Ch hash.Hash
	}
}

// MoqInt_starGenType_Format_resultsByParams contains the results for a given
// set of parameters for the Int_starGenType type
type MoqInt_starGenType_Format_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Format_paramsKey]*MoqInt_starGenType_Format_results
}

// MoqInt_starGenType_Format_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Format_doFn func(s fmt.State, ch rune)

// MoqInt_starGenType_Format_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Format_doReturnFn func(s fmt.State, ch rune)

// MoqInt_starGenType_Format_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Format_results struct {
	Params  MoqInt_starGenType_Format_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Format_doFn
		DoReturnFn MoqInt_starGenType_Format_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Format_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Format_fnRecorder struct {
	Params    MoqInt_starGenType_Format_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Format_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Format_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Format_anyParams struct {
	Recorder *MoqInt_starGenType_Format_fnRecorder
}

// MoqInt_starGenType_Scan_params holds the params of the Int_starGenType type
type MoqInt_starGenType_Scan_params struct {
	S  fmt.ScanState
	Ch rune
}

// MoqInt_starGenType_Scan_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_Scan_paramsKey struct {
	Params struct {
		S  fmt.ScanState
		Ch rune
	}
	Hashes struct {
		S  hash.Hash
		Ch hash.Hash
	}
}

// MoqInt_starGenType_Scan_resultsByParams contains the results for a given set
// of parameters for the Int_starGenType type
type MoqInt_starGenType_Scan_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_Scan_paramsKey]*MoqInt_starGenType_Scan_results
}

// MoqInt_starGenType_Scan_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_Scan_doFn func(s fmt.ScanState, ch rune)

// MoqInt_starGenType_Scan_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_Scan_doReturnFn func(s fmt.ScanState, ch rune) error

// MoqInt_starGenType_Scan_results holds the results of the Int_starGenType
// type
type MoqInt_starGenType_Scan_results struct {
	Params  MoqInt_starGenType_Scan_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Scan_doFn
		DoReturnFn MoqInt_starGenType_Scan_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_Scan_fnRecorder routes recorded function calls to the
// MoqInt_starGenType moq
type MoqInt_starGenType_Scan_fnRecorder struct {
	Params    MoqInt_starGenType_Scan_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_Scan_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_Scan_anyParams isolates the any params functions of the
// Int_starGenType type
type MoqInt_starGenType_Scan_anyParams struct {
	Recorder *MoqInt_starGenType_Scan_fnRecorder
}

// MoqInt_starGenType_GobEncode_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_GobEncode_params struct{}

// MoqInt_starGenType_GobEncode_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_GobEncode_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_GobEncode_resultsByParams contains the results for a
// given set of parameters for the Int_starGenType type
type MoqInt_starGenType_GobEncode_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_GobEncode_paramsKey]*MoqInt_starGenType_GobEncode_results
}

// MoqInt_starGenType_GobEncode_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_GobEncode_doFn func()

// MoqInt_starGenType_GobEncode_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_GobEncode_doReturnFn func() ([]byte, error)

// MoqInt_starGenType_GobEncode_results holds the results of the
// Int_starGenType type
type MoqInt_starGenType_GobEncode_results struct {
	Params  MoqInt_starGenType_GobEncode_params
	Results []struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_GobEncode_doFn
		DoReturnFn MoqInt_starGenType_GobEncode_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_GobEncode_fnRecorder routes recorded function calls to
// the MoqInt_starGenType moq
type MoqInt_starGenType_GobEncode_fnRecorder struct {
	Params    MoqInt_starGenType_GobEncode_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_GobEncode_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_GobEncode_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_GobEncode_anyParams struct {
	Recorder *MoqInt_starGenType_GobEncode_fnRecorder
}

// MoqInt_starGenType_GobDecode_params holds the params of the Int_starGenType
// type
type MoqInt_starGenType_GobDecode_params struct{ Buf []byte }

// MoqInt_starGenType_GobDecode_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_GobDecode_paramsKey struct {
	Params struct{}
	Hashes struct{ Buf hash.Hash }
}

// MoqInt_starGenType_GobDecode_resultsByParams contains the results for a
// given set of parameters for the Int_starGenType type
type MoqInt_starGenType_GobDecode_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_GobDecode_paramsKey]*MoqInt_starGenType_GobDecode_results
}

// MoqInt_starGenType_GobDecode_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_GobDecode_doFn func(buf []byte)

// MoqInt_starGenType_GobDecode_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_GobDecode_doReturnFn func(buf []byte) error

// MoqInt_starGenType_GobDecode_results holds the results of the
// Int_starGenType type
type MoqInt_starGenType_GobDecode_results struct {
	Params  MoqInt_starGenType_GobDecode_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_GobDecode_doFn
		DoReturnFn MoqInt_starGenType_GobDecode_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_GobDecode_fnRecorder routes recorded function calls to
// the MoqInt_starGenType moq
type MoqInt_starGenType_GobDecode_fnRecorder struct {
	Params    MoqInt_starGenType_GobDecode_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_GobDecode_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_GobDecode_anyParams isolates the any params functions of
// the Int_starGenType type
type MoqInt_starGenType_GobDecode_anyParams struct {
	Recorder *MoqInt_starGenType_GobDecode_fnRecorder
}

// MoqInt_starGenType_MarshalText_params holds the params of the
// Int_starGenType type
type MoqInt_starGenType_MarshalText_params struct{}

// MoqInt_starGenType_MarshalText_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_MarshalText_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_MarshalText_resultsByParams contains the results for a
// given set of parameters for the Int_starGenType type
type MoqInt_starGenType_MarshalText_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_MarshalText_paramsKey]*MoqInt_starGenType_MarshalText_results
}

// MoqInt_starGenType_MarshalText_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_MarshalText_doFn func()

// MoqInt_starGenType_MarshalText_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_MarshalText_doReturnFn func() (text []byte, err error)

// MoqInt_starGenType_MarshalText_results holds the results of the
// Int_starGenType type
type MoqInt_starGenType_MarshalText_results struct {
	Params  MoqInt_starGenType_MarshalText_params
	Results []struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_MarshalText_doFn
		DoReturnFn MoqInt_starGenType_MarshalText_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_MarshalText_fnRecorder routes recorded function calls to
// the MoqInt_starGenType moq
type MoqInt_starGenType_MarshalText_fnRecorder struct {
	Params    MoqInt_starGenType_MarshalText_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_MarshalText_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_MarshalText_anyParams isolates the any params functions
// of the Int_starGenType type
type MoqInt_starGenType_MarshalText_anyParams struct {
	Recorder *MoqInt_starGenType_MarshalText_fnRecorder
}

// MoqInt_starGenType_UnmarshalText_params holds the params of the
// Int_starGenType type
type MoqInt_starGenType_UnmarshalText_params struct{ Text []byte }

// MoqInt_starGenType_UnmarshalText_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_UnmarshalText_paramsKey struct {
	Params struct{}
	Hashes struct{ Text hash.Hash }
}

// MoqInt_starGenType_UnmarshalText_resultsByParams contains the results for a
// given set of parameters for the Int_starGenType type
type MoqInt_starGenType_UnmarshalText_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_UnmarshalText_paramsKey]*MoqInt_starGenType_UnmarshalText_results
}

// MoqInt_starGenType_UnmarshalText_doFn defines the type of function needed
// when calling AndDo for the Int_starGenType type
type MoqInt_starGenType_UnmarshalText_doFn func(text []byte)

// MoqInt_starGenType_UnmarshalText_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_UnmarshalText_doReturnFn func(text []byte) error

// MoqInt_starGenType_UnmarshalText_results holds the results of the
// Int_starGenType type
type MoqInt_starGenType_UnmarshalText_results struct {
	Params  MoqInt_starGenType_UnmarshalText_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_UnmarshalText_doFn
		DoReturnFn MoqInt_starGenType_UnmarshalText_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_UnmarshalText_fnRecorder routes recorded function calls
// to the MoqInt_starGenType moq
type MoqInt_starGenType_UnmarshalText_fnRecorder struct {
	Params    MoqInt_starGenType_UnmarshalText_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_UnmarshalText_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_UnmarshalText_anyParams isolates the any params functions
// of the Int_starGenType type
type MoqInt_starGenType_UnmarshalText_anyParams struct {
	Recorder *MoqInt_starGenType_UnmarshalText_fnRecorder
}

// MoqInt_starGenType_MarshalJSON_params holds the params of the
// Int_starGenType type
type MoqInt_starGenType_MarshalJSON_params struct{}

// MoqInt_starGenType_MarshalJSON_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_MarshalJSON_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInt_starGenType_MarshalJSON_resultsByParams contains the results for a
// given set of parameters for the Int_starGenType type
type MoqInt_starGenType_MarshalJSON_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_MarshalJSON_paramsKey]*MoqInt_starGenType_MarshalJSON_results
}

// MoqInt_starGenType_MarshalJSON_doFn defines the type of function needed when
// calling AndDo for the Int_starGenType type
type MoqInt_starGenType_MarshalJSON_doFn func()

// MoqInt_starGenType_MarshalJSON_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_MarshalJSON_doReturnFn func() ([]byte, error)

// MoqInt_starGenType_MarshalJSON_results holds the results of the
// Int_starGenType type
type MoqInt_starGenType_MarshalJSON_results struct {
	Params  MoqInt_starGenType_MarshalJSON_params
	Results []struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_MarshalJSON_doFn
		DoReturnFn MoqInt_starGenType_MarshalJSON_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_MarshalJSON_fnRecorder routes recorded function calls to
// the MoqInt_starGenType moq
type MoqInt_starGenType_MarshalJSON_fnRecorder struct {
	Params    MoqInt_starGenType_MarshalJSON_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_MarshalJSON_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_MarshalJSON_anyParams isolates the any params functions
// of the Int_starGenType type
type MoqInt_starGenType_MarshalJSON_anyParams struct {
	Recorder *MoqInt_starGenType_MarshalJSON_fnRecorder
}

// MoqInt_starGenType_UnmarshalJSON_params holds the params of the
// Int_starGenType type
type MoqInt_starGenType_UnmarshalJSON_params struct{ Text []byte }

// MoqInt_starGenType_UnmarshalJSON_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_UnmarshalJSON_paramsKey struct {
	Params struct{}
	Hashes struct{ Text hash.Hash }
}

// MoqInt_starGenType_UnmarshalJSON_resultsByParams contains the results for a
// given set of parameters for the Int_starGenType type
type MoqInt_starGenType_UnmarshalJSON_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_UnmarshalJSON_paramsKey]*MoqInt_starGenType_UnmarshalJSON_results
}

// MoqInt_starGenType_UnmarshalJSON_doFn defines the type of function needed
// when calling AndDo for the Int_starGenType type
type MoqInt_starGenType_UnmarshalJSON_doFn func(text []byte)

// MoqInt_starGenType_UnmarshalJSON_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_UnmarshalJSON_doReturnFn func(text []byte) error

// MoqInt_starGenType_UnmarshalJSON_results holds the results of the
// Int_starGenType type
type MoqInt_starGenType_UnmarshalJSON_results struct {
	Params  MoqInt_starGenType_UnmarshalJSON_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_UnmarshalJSON_doFn
		DoReturnFn MoqInt_starGenType_UnmarshalJSON_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_UnmarshalJSON_fnRecorder routes recorded function calls
// to the MoqInt_starGenType moq
type MoqInt_starGenType_UnmarshalJSON_fnRecorder struct {
	Params    MoqInt_starGenType_UnmarshalJSON_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_UnmarshalJSON_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_UnmarshalJSON_anyParams isolates the any params functions
// of the Int_starGenType type
type MoqInt_starGenType_UnmarshalJSON_anyParams struct {
	Recorder *MoqInt_starGenType_UnmarshalJSON_fnRecorder
}

// MoqInt_starGenType_ProbablyPrime_params holds the params of the
// Int_starGenType type
type MoqInt_starGenType_ProbablyPrime_params struct{ N int }

// MoqInt_starGenType_ProbablyPrime_paramsKey holds the map key params of the
// Int_starGenType type
type MoqInt_starGenType_ProbablyPrime_paramsKey struct {
	Params struct{ N int }
	Hashes struct{ N hash.Hash }
}

// MoqInt_starGenType_ProbablyPrime_resultsByParams contains the results for a
// given set of parameters for the Int_starGenType type
type MoqInt_starGenType_ProbablyPrime_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInt_starGenType_ProbablyPrime_paramsKey]*MoqInt_starGenType_ProbablyPrime_results
}

// MoqInt_starGenType_ProbablyPrime_doFn defines the type of function needed
// when calling AndDo for the Int_starGenType type
type MoqInt_starGenType_ProbablyPrime_doFn func(n int)

// MoqInt_starGenType_ProbablyPrime_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Int_starGenType type
type MoqInt_starGenType_ProbablyPrime_doReturnFn func(n int) bool

// MoqInt_starGenType_ProbablyPrime_results holds the results of the
// Int_starGenType type
type MoqInt_starGenType_ProbablyPrime_results struct {
	Params  MoqInt_starGenType_ProbablyPrime_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_ProbablyPrime_doFn
		DoReturnFn MoqInt_starGenType_ProbablyPrime_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInt_starGenType_ProbablyPrime_fnRecorder routes recorded function calls
// to the MoqInt_starGenType moq
type MoqInt_starGenType_ProbablyPrime_fnRecorder struct {
	Params    MoqInt_starGenType_ProbablyPrime_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInt_starGenType_ProbablyPrime_results
	Moq       *MoqInt_starGenType
}

// MoqInt_starGenType_ProbablyPrime_anyParams isolates the any params functions
// of the Int_starGenType type
type MoqInt_starGenType_ProbablyPrime_anyParams struct {
	Recorder *MoqInt_starGenType_ProbablyPrime_fnRecorder
}

// NewMoqInt_starGenType creates a new moq of the Int_starGenType type
func NewMoqInt_starGenType(scene *moq.Scene, config *moq.Config) *MoqInt_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqInt_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqInt_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Sign     struct{}
				SetInt64 struct {
					X moq.ParamIndexing
				}
				SetUint64 struct {
					X moq.ParamIndexing
				}
				Set struct {
					X moq.ParamIndexing
				}
				Bits    struct{}
				SetBits struct {
					Abs moq.ParamIndexing
				}
				Abs struct {
					X moq.ParamIndexing
				}
				Neg struct {
					X moq.ParamIndexing
				}
				Add struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Sub struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Mul struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				MulRange struct {
					A moq.ParamIndexing
					B moq.ParamIndexing
				}
				Binomial struct {
					N moq.ParamIndexing
					K moq.ParamIndexing
				}
				Quo struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Rem struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				QuoRem struct {
					X      moq.ParamIndexing
					Y      moq.ParamIndexing
					Param3 moq.ParamIndexing
				}
				Div struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Mod struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				DivMod struct {
					X      moq.ParamIndexing
					Y      moq.ParamIndexing
					Param3 moq.ParamIndexing
				}
				Cmp struct {
					Y moq.ParamIndexing
				}
				CmpAbs struct {
					Y moq.ParamIndexing
				}
				Int64     struct{}
				Uint64    struct{}
				IsInt64   struct{}
				IsUint64  struct{}
				SetString struct {
					S    moq.ParamIndexing
					Base moq.ParamIndexing
				}
				SetBytes struct {
					Buf moq.ParamIndexing
				}
				Bytes            struct{}
				BitLen           struct{}
				TrailingZeroBits struct{}
				Exp              struct {
					X      moq.ParamIndexing
					Y      moq.ParamIndexing
					Param3 moq.ParamIndexing
				}
				GCD struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
					A moq.ParamIndexing
					B moq.ParamIndexing
				}
				Rand struct {
					Rnd moq.ParamIndexing
					N   moq.ParamIndexing
				}
				ModInverse struct {
					G moq.ParamIndexing
					N moq.ParamIndexing
				}
				ModSqrt struct {
					X moq.ParamIndexing
					P moq.ParamIndexing
				}
				Lsh struct {
					X moq.ParamIndexing
					N moq.ParamIndexing
				}
				Rsh struct {
					X moq.ParamIndexing
					N moq.ParamIndexing
				}
				Bit struct {
					Param1 moq.ParamIndexing
				}
				SetBit struct {
					X      moq.ParamIndexing
					Param2 moq.ParamIndexing
					B      moq.ParamIndexing
				}
				And struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				AndNot struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Or struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Xor struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Not struct {
					X moq.ParamIndexing
				}
				Sqrt struct {
					X moq.ParamIndexing
				}
				Text struct {
					Base moq.ParamIndexing
				}
				Append struct {
					Buf  moq.ParamIndexing
					Base moq.ParamIndexing
				}
				String struct{}
				Format struct {
					S  moq.ParamIndexing
					Ch moq.ParamIndexing
				}
				Scan struct {
					S  moq.ParamIndexing
					Ch moq.ParamIndexing
				}
				GobEncode struct{}
				GobDecode struct {
					Buf moq.ParamIndexing
				}
				MarshalText   struct{}
				UnmarshalText struct {
					Text moq.ParamIndexing
				}
				MarshalJSON   struct{}
				UnmarshalJSON struct {
					Text moq.ParamIndexing
				}
				ProbablyPrime struct {
					N moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			Sign     struct{}
			SetInt64 struct {
				X moq.ParamIndexing
			}
			SetUint64 struct {
				X moq.ParamIndexing
			}
			Set struct {
				X moq.ParamIndexing
			}
			Bits    struct{}
			SetBits struct {
				Abs moq.ParamIndexing
			}
			Abs struct {
				X moq.ParamIndexing
			}
			Neg struct {
				X moq.ParamIndexing
			}
			Add struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Sub struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Mul struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			MulRange struct {
				A moq.ParamIndexing
				B moq.ParamIndexing
			}
			Binomial struct {
				N moq.ParamIndexing
				K moq.ParamIndexing
			}
			Quo struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Rem struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			QuoRem struct {
				X      moq.ParamIndexing
				Y      moq.ParamIndexing
				Param3 moq.ParamIndexing
			}
			Div struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Mod struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			DivMod struct {
				X      moq.ParamIndexing
				Y      moq.ParamIndexing
				Param3 moq.ParamIndexing
			}
			Cmp struct {
				Y moq.ParamIndexing
			}
			CmpAbs struct {
				Y moq.ParamIndexing
			}
			Int64     struct{}
			Uint64    struct{}
			IsInt64   struct{}
			IsUint64  struct{}
			SetString struct {
				S    moq.ParamIndexing
				Base moq.ParamIndexing
			}
			SetBytes struct {
				Buf moq.ParamIndexing
			}
			Bytes            struct{}
			BitLen           struct{}
			TrailingZeroBits struct{}
			Exp              struct {
				X      moq.ParamIndexing
				Y      moq.ParamIndexing
				Param3 moq.ParamIndexing
			}
			GCD struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
				A moq.ParamIndexing
				B moq.ParamIndexing
			}
			Rand struct {
				Rnd moq.ParamIndexing
				N   moq.ParamIndexing
			}
			ModInverse struct {
				G moq.ParamIndexing
				N moq.ParamIndexing
			}
			ModSqrt struct {
				X moq.ParamIndexing
				P moq.ParamIndexing
			}
			Lsh struct {
				X moq.ParamIndexing
				N moq.ParamIndexing
			}
			Rsh struct {
				X moq.ParamIndexing
				N moq.ParamIndexing
			}
			Bit struct {
				Param1 moq.ParamIndexing
			}
			SetBit struct {
				X      moq.ParamIndexing
				Param2 moq.ParamIndexing
				B      moq.ParamIndexing
			}
			And struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			AndNot struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Or struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Xor struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Not struct {
				X moq.ParamIndexing
			}
			Sqrt struct {
				X moq.ParamIndexing
			}
			Text struct {
				Base moq.ParamIndexing
			}
			Append struct {
				Buf  moq.ParamIndexing
				Base moq.ParamIndexing
			}
			String struct{}
			Format struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}
			Scan struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}
			GobEncode struct{}
			GobDecode struct {
				Buf moq.ParamIndexing
			}
			MarshalText   struct{}
			UnmarshalText struct {
				Text moq.ParamIndexing
			}
			MarshalJSON   struct{}
			UnmarshalJSON struct {
				Text moq.ParamIndexing
			}
			ProbablyPrime struct {
				N moq.ParamIndexing
			}
		}{
			Sign: struct{}{},
			SetInt64: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			SetUint64: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			Set: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Bits: struct{}{},
			SetBits: struct {
				Abs moq.ParamIndexing
			}{
				Abs: moq.ParamIndexByHash,
			},
			Abs: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Neg: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Add: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Sub: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Mul: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			MulRange: struct {
				A moq.ParamIndexing
				B moq.ParamIndexing
			}{
				A: moq.ParamIndexByValue,
				B: moq.ParamIndexByValue,
			},
			Binomial: struct {
				N moq.ParamIndexing
				K moq.ParamIndexing
			}{
				N: moq.ParamIndexByValue,
				K: moq.ParamIndexByValue,
			},
			Quo: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Rem: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			QuoRem: struct {
				X      moq.ParamIndexing
				Y      moq.ParamIndexing
				Param3 moq.ParamIndexing
			}{
				X:      moq.ParamIndexByHash,
				Y:      moq.ParamIndexByHash,
				Param3: moq.ParamIndexByHash,
			},
			Div: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Mod: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			DivMod: struct {
				X      moq.ParamIndexing
				Y      moq.ParamIndexing
				Param3 moq.ParamIndexing
			}{
				X:      moq.ParamIndexByHash,
				Y:      moq.ParamIndexByHash,
				Param3: moq.ParamIndexByHash,
			},
			Cmp: struct {
				Y moq.ParamIndexing
			}{
				Y: moq.ParamIndexByHash,
			},
			CmpAbs: struct {
				Y moq.ParamIndexing
			}{
				Y: moq.ParamIndexByHash,
			},
			Int64:    struct{}{},
			Uint64:   struct{}{},
			IsInt64:  struct{}{},
			IsUint64: struct{}{},
			SetString: struct {
				S    moq.ParamIndexing
				Base moq.ParamIndexing
			}{
				S:    moq.ParamIndexByValue,
				Base: moq.ParamIndexByValue,
			},
			SetBytes: struct {
				Buf moq.ParamIndexing
			}{
				Buf: moq.ParamIndexByHash,
			},
			Bytes:            struct{}{},
			BitLen:           struct{}{},
			TrailingZeroBits: struct{}{},
			Exp: struct {
				X      moq.ParamIndexing
				Y      moq.ParamIndexing
				Param3 moq.ParamIndexing
			}{
				X:      moq.ParamIndexByHash,
				Y:      moq.ParamIndexByHash,
				Param3: moq.ParamIndexByHash,
			},
			GCD: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
				A moq.ParamIndexing
				B moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
				A: moq.ParamIndexByHash,
				B: moq.ParamIndexByHash,
			},
			Rand: struct {
				Rnd moq.ParamIndexing
				N   moq.ParamIndexing
			}{
				Rnd: moq.ParamIndexByHash,
				N:   moq.ParamIndexByHash,
			},
			ModInverse: struct {
				G moq.ParamIndexing
				N moq.ParamIndexing
			}{
				G: moq.ParamIndexByHash,
				N: moq.ParamIndexByHash,
			},
			ModSqrt: struct {
				X moq.ParamIndexing
				P moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				P: moq.ParamIndexByHash,
			},
			Lsh: struct {
				X moq.ParamIndexing
				N moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				N: moq.ParamIndexByValue,
			},
			Rsh: struct {
				X moq.ParamIndexing
				N moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				N: moq.ParamIndexByValue,
			},
			Bit: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			SetBit: struct {
				X      moq.ParamIndexing
				Param2 moq.ParamIndexing
				B      moq.ParamIndexing
			}{
				X:      moq.ParamIndexByHash,
				Param2: moq.ParamIndexByValue,
				B:      moq.ParamIndexByValue,
			},
			And: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			AndNot: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Or: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Xor: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Not: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Sqrt: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Text: struct {
				Base moq.ParamIndexing
			}{
				Base: moq.ParamIndexByValue,
			},
			Append: struct {
				Buf  moq.ParamIndexing
				Base moq.ParamIndexing
			}{
				Buf:  moq.ParamIndexByHash,
				Base: moq.ParamIndexByValue,
			},
			String: struct{}{},
			Format: struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}{
				S:  moq.ParamIndexByHash,
				Ch: moq.ParamIndexByValue,
			},
			Scan: struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}{
				S:  moq.ParamIndexByHash,
				Ch: moq.ParamIndexByValue,
			},
			GobEncode: struct{}{},
			GobDecode: struct {
				Buf moq.ParamIndexing
			}{
				Buf: moq.ParamIndexByHash,
			},
			MarshalText: struct{}{},
			UnmarshalText: struct {
				Text moq.ParamIndexing
			}{
				Text: moq.ParamIndexByHash,
			},
			MarshalJSON: struct{}{},
			UnmarshalJSON: struct {
				Text moq.ParamIndexing
			}{
				Text: moq.ParamIndexByHash,
			},
			ProbablyPrime: struct {
				N moq.ParamIndexing
			}{
				N: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Int_starGenType type
func (m *MoqInt_starGenType) Mock() *MoqInt_starGenType_mock { return m.Moq }

func (m *MoqInt_starGenType_mock) Sign() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Sign_params{}
	var results *MoqInt_starGenType_Sign_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Sign {
		paramsKey := m.Moq.ParamsKey_Sign(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Sign(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Sign(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Sign(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) SetInt64(x int64) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_SetInt64_params{
		X: x,
	}
	var results *MoqInt_starGenType_SetInt64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetInt64 {
		paramsKey := m.Moq.ParamsKey_SetInt64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetInt64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetInt64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetInt64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqInt_starGenType_mock) SetUint64(x uint64) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_SetUint64_params{
		X: x,
	}
	var results *MoqInt_starGenType_SetUint64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetUint64 {
		paramsKey := m.Moq.ParamsKey_SetUint64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetUint64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetUint64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetUint64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqInt_starGenType_mock) Set(x *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Set_params{
		X: x,
	}
	var results *MoqInt_starGenType_Set_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Set {
		paramsKey := m.Moq.ParamsKey_Set(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Set(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Set(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Set(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqInt_starGenType_mock) Bits() (result1 []big.Word) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Bits_params{}
	var results *MoqInt_starGenType_Bits_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Bits {
		paramsKey := m.Moq.ParamsKey_Bits(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Bits(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Bits(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Bits(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) SetBits(abs []big.Word) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_SetBits_params{
		Abs: abs,
	}
	var results *MoqInt_starGenType_SetBits_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetBits {
		paramsKey := m.Moq.ParamsKey_SetBits(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetBits(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetBits(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetBits(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(abs)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(abs)
	}
	return
}

func (m *MoqInt_starGenType_mock) Abs(x *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Abs_params{
		X: x,
	}
	var results *MoqInt_starGenType_Abs_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Abs {
		paramsKey := m.Moq.ParamsKey_Abs(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Abs(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Abs(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Abs(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqInt_starGenType_mock) Neg(x *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Neg_params{
		X: x,
	}
	var results *MoqInt_starGenType_Neg_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Neg {
		paramsKey := m.Moq.ParamsKey_Neg(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Neg(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Neg(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Neg(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqInt_starGenType_mock) Add(x, y *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Add_params{
		X: x,
		Y: y,
	}
	var results *MoqInt_starGenType_Add_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Add {
		paramsKey := m.Moq.ParamsKey_Add(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Add(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Add(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Add(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqInt_starGenType_mock) Sub(x, y *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Sub_params{
		X: x,
		Y: y,
	}
	var results *MoqInt_starGenType_Sub_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Sub {
		paramsKey := m.Moq.ParamsKey_Sub(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Sub(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Sub(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Sub(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqInt_starGenType_mock) Mul(x, y *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Mul_params{
		X: x,
		Y: y,
	}
	var results *MoqInt_starGenType_Mul_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Mul {
		paramsKey := m.Moq.ParamsKey_Mul(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Mul(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Mul(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Mul(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqInt_starGenType_mock) MulRange(a, b int64) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_MulRange_params{
		A: a,
		B: b,
	}
	var results *MoqInt_starGenType_MulRange_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MulRange {
		paramsKey := m.Moq.ParamsKey_MulRange(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MulRange(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MulRange(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MulRange(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(a, b)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(a, b)
	}
	return
}

func (m *MoqInt_starGenType_mock) Binomial(n, k int64) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Binomial_params{
		N: n,
		K: k,
	}
	var results *MoqInt_starGenType_Binomial_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Binomial {
		paramsKey := m.Moq.ParamsKey_Binomial(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Binomial(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Binomial(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Binomial(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(n, k)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(n, k)
	}
	return
}

func (m *MoqInt_starGenType_mock) Quo(x, y *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Quo_params{
		X: x,
		Y: y,
	}
	var results *MoqInt_starGenType_Quo_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Quo {
		paramsKey := m.Moq.ParamsKey_Quo(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Quo(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Quo(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Quo(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqInt_starGenType_mock) Rem(x, y *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Rem_params{
		X: x,
		Y: y,
	}
	var results *MoqInt_starGenType_Rem_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Rem {
		paramsKey := m.Moq.ParamsKey_Rem(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Rem(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Rem(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Rem(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqInt_starGenType_mock) QuoRem(x, y, param3 *big.Int) (result1 *big.Int, result2 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_QuoRem_params{
		X:      x,
		Y:      y,
		Param3: param3,
	}
	var results *MoqInt_starGenType_QuoRem_results
	for _, resultsByParams := range m.Moq.ResultsByParams_QuoRem {
		paramsKey := m.Moq.ParamsKey_QuoRem(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_QuoRem(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_QuoRem(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_QuoRem(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y, param3)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(x, y, param3)
	}
	return
}

func (m *MoqInt_starGenType_mock) Div(x, y *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Div_params{
		X: x,
		Y: y,
	}
	var results *MoqInt_starGenType_Div_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Div {
		paramsKey := m.Moq.ParamsKey_Div(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Div(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Div(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Div(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqInt_starGenType_mock) Mod(x, y *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Mod_params{
		X: x,
		Y: y,
	}
	var results *MoqInt_starGenType_Mod_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Mod {
		paramsKey := m.Moq.ParamsKey_Mod(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Mod(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Mod(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Mod(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqInt_starGenType_mock) DivMod(x, y, param3 *big.Int) (result1 *big.Int, result2 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_DivMod_params{
		X:      x,
		Y:      y,
		Param3: param3,
	}
	var results *MoqInt_starGenType_DivMod_results
	for _, resultsByParams := range m.Moq.ResultsByParams_DivMod {
		paramsKey := m.Moq.ParamsKey_DivMod(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_DivMod(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_DivMod(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_DivMod(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y, param3)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(x, y, param3)
	}
	return
}

func (m *MoqInt_starGenType_mock) Cmp(y *big.Int) (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Cmp_params{
		Y: y,
	}
	var results *MoqInt_starGenType_Cmp_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Cmp {
		paramsKey := m.Moq.ParamsKey_Cmp(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Cmp(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Cmp(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Cmp(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(y)
	}
	return
}

func (m *MoqInt_starGenType_mock) CmpAbs(y *big.Int) (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_CmpAbs_params{
		Y: y,
	}
	var results *MoqInt_starGenType_CmpAbs_results
	for _, resultsByParams := range m.Moq.ResultsByParams_CmpAbs {
		paramsKey := m.Moq.ParamsKey_CmpAbs(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_CmpAbs(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_CmpAbs(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_CmpAbs(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(y)
	}
	return
}

func (m *MoqInt_starGenType_mock) Int64() (result1 int64) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Int64_params{}
	var results *MoqInt_starGenType_Int64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Int64 {
		paramsKey := m.Moq.ParamsKey_Int64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Int64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Int64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Int64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) Uint64() (result1 uint64) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Uint64_params{}
	var results *MoqInt_starGenType_Uint64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Uint64 {
		paramsKey := m.Moq.ParamsKey_Uint64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Uint64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Uint64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Uint64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) IsInt64() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_IsInt64_params{}
	var results *MoqInt_starGenType_IsInt64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsInt64 {
		paramsKey := m.Moq.ParamsKey_IsInt64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsInt64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsInt64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsInt64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) IsUint64() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_IsUint64_params{}
	var results *MoqInt_starGenType_IsUint64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsUint64 {
		paramsKey := m.Moq.ParamsKey_IsUint64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsUint64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsUint64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsUint64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) SetString(s string, base int) (result1 *big.Int, result2 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_SetString_params{
		S:    s,
		Base: base,
	}
	var results *MoqInt_starGenType_SetString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetString {
		paramsKey := m.Moq.ParamsKey_SetString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, base)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(s, base)
	}
	return
}

func (m *MoqInt_starGenType_mock) SetBytes(buf []byte) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_SetBytes_params{
		Buf: buf,
	}
	var results *MoqInt_starGenType_SetBytes_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetBytes {
		paramsKey := m.Moq.ParamsKey_SetBytes(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetBytes(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetBytes(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetBytes(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(buf)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(buf)
	}
	return
}

func (m *MoqInt_starGenType_mock) Bytes() (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Bytes_params{}
	var results *MoqInt_starGenType_Bytes_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Bytes {
		paramsKey := m.Moq.ParamsKey_Bytes(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Bytes(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Bytes(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Bytes(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) BitLen() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_BitLen_params{}
	var results *MoqInt_starGenType_BitLen_results
	for _, resultsByParams := range m.Moq.ResultsByParams_BitLen {
		paramsKey := m.Moq.ParamsKey_BitLen(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_BitLen(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_BitLen(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_BitLen(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) TrailingZeroBits() (result1 uint) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_TrailingZeroBits_params{}
	var results *MoqInt_starGenType_TrailingZeroBits_results
	for _, resultsByParams := range m.Moq.ResultsByParams_TrailingZeroBits {
		paramsKey := m.Moq.ParamsKey_TrailingZeroBits(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_TrailingZeroBits(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_TrailingZeroBits(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_TrailingZeroBits(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) Exp(x, y, param3 *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Exp_params{
		X:      x,
		Y:      y,
		Param3: param3,
	}
	var results *MoqInt_starGenType_Exp_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Exp {
		paramsKey := m.Moq.ParamsKey_Exp(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Exp(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Exp(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Exp(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y, param3)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y, param3)
	}
	return
}

func (m *MoqInt_starGenType_mock) GCD(x, y, a, b *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_GCD_params{
		X: x,
		Y: y,
		A: a,
		B: b,
	}
	var results *MoqInt_starGenType_GCD_results
	for _, resultsByParams := range m.Moq.ResultsByParams_GCD {
		paramsKey := m.Moq.ParamsKey_GCD(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_GCD(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_GCD(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_GCD(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y, a, b)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y, a, b)
	}
	return
}

func (m *MoqInt_starGenType_mock) Rand(rnd *rand.Rand, n *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Rand_params{
		Rnd: rnd,
		N:   n,
	}
	var results *MoqInt_starGenType_Rand_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Rand {
		paramsKey := m.Moq.ParamsKey_Rand(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Rand(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Rand(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Rand(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(rnd, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(rnd, n)
	}
	return
}

func (m *MoqInt_starGenType_mock) ModInverse(g, n *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_ModInverse_params{
		G: g,
		N: n,
	}
	var results *MoqInt_starGenType_ModInverse_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ModInverse {
		paramsKey := m.Moq.ParamsKey_ModInverse(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ModInverse(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ModInverse(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ModInverse(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(g, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(g, n)
	}
	return
}

func (m *MoqInt_starGenType_mock) ModSqrt(x, p *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_ModSqrt_params{
		X: x,
		P: p,
	}
	var results *MoqInt_starGenType_ModSqrt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ModSqrt {
		paramsKey := m.Moq.ParamsKey_ModSqrt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ModSqrt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ModSqrt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ModSqrt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, p)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, p)
	}
	return
}

func (m *MoqInt_starGenType_mock) Lsh(x *big.Int, n uint) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Lsh_params{
		X: x,
		N: n,
	}
	var results *MoqInt_starGenType_Lsh_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Lsh {
		paramsKey := m.Moq.ParamsKey_Lsh(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Lsh(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Lsh(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Lsh(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, n)
	}
	return
}

func (m *MoqInt_starGenType_mock) Rsh(x *big.Int, n uint) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Rsh_params{
		X: x,
		N: n,
	}
	var results *MoqInt_starGenType_Rsh_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Rsh {
		paramsKey := m.Moq.ParamsKey_Rsh(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Rsh(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Rsh(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Rsh(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, n)
	}
	return
}

func (m *MoqInt_starGenType_mock) Bit(param1 int) (result1 uint) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Bit_params{
		Param1: param1,
	}
	var results *MoqInt_starGenType_Bit_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Bit {
		paramsKey := m.Moq.ParamsKey_Bit(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Bit(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Bit(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Bit(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqInt_starGenType_mock) SetBit(x *big.Int, param2 int, b uint) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_SetBit_params{
		X:      x,
		Param2: param2,
		B:      b,
	}
	var results *MoqInt_starGenType_SetBit_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetBit {
		paramsKey := m.Moq.ParamsKey_SetBit(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetBit(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetBit(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetBit(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, param2, b)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, param2, b)
	}
	return
}

func (m *MoqInt_starGenType_mock) And(x, y *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_And_params{
		X: x,
		Y: y,
	}
	var results *MoqInt_starGenType_And_results
	for _, resultsByParams := range m.Moq.ResultsByParams_And {
		paramsKey := m.Moq.ParamsKey_And(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_And(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_And(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_And(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqInt_starGenType_mock) AndNot(x, y *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_AndNot_params{
		X: x,
		Y: y,
	}
	var results *MoqInt_starGenType_AndNot_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AndNot {
		paramsKey := m.Moq.ParamsKey_AndNot(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AndNot(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AndNot(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AndNot(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqInt_starGenType_mock) Or(x, y *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Or_params{
		X: x,
		Y: y,
	}
	var results *MoqInt_starGenType_Or_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Or {
		paramsKey := m.Moq.ParamsKey_Or(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Or(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Or(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Or(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqInt_starGenType_mock) Xor(x, y *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Xor_params{
		X: x,
		Y: y,
	}
	var results *MoqInt_starGenType_Xor_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Xor {
		paramsKey := m.Moq.ParamsKey_Xor(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Xor(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Xor(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Xor(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqInt_starGenType_mock) Not(x *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Not_params{
		X: x,
	}
	var results *MoqInt_starGenType_Not_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Not {
		paramsKey := m.Moq.ParamsKey_Not(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Not(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Not(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Not(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqInt_starGenType_mock) Sqrt(x *big.Int) (result1 *big.Int) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Sqrt_params{
		X: x,
	}
	var results *MoqInt_starGenType_Sqrt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Sqrt {
		paramsKey := m.Moq.ParamsKey_Sqrt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Sqrt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Sqrt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Sqrt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqInt_starGenType_mock) Text(base int) (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Text_params{
		Base: base,
	}
	var results *MoqInt_starGenType_Text_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Text {
		paramsKey := m.Moq.ParamsKey_Text(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Text(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Text(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Text(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(base)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(base)
	}
	return
}

func (m *MoqInt_starGenType_mock) Append(buf []byte, base int) (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Append_params{
		Buf:  buf,
		Base: base,
	}
	var results *MoqInt_starGenType_Append_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Append {
		paramsKey := m.Moq.ParamsKey_Append(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Append(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Append(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Append(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(buf, base)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(buf, base)
	}
	return
}

func (m *MoqInt_starGenType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_String_params{}
	var results *MoqInt_starGenType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) Format(s fmt.State, ch rune) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Format_params{
		S:  s,
		Ch: ch,
	}
	var results *MoqInt_starGenType_Format_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Format {
		paramsKey := m.Moq.ParamsKey_Format(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Format(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Format(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Format(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, ch)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(s, ch)
	}
	return
}

func (m *MoqInt_starGenType_mock) Scan(s fmt.ScanState, ch rune) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_Scan_params{
		S:  s,
		Ch: ch,
	}
	var results *MoqInt_starGenType_Scan_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Scan {
		paramsKey := m.Moq.ParamsKey_Scan(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Scan(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Scan(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Scan(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, ch)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s, ch)
	}
	return
}

func (m *MoqInt_starGenType_mock) GobEncode() (result1 []byte, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_GobEncode_params{}
	var results *MoqInt_starGenType_GobEncode_results
	for _, resultsByParams := range m.Moq.ResultsByParams_GobEncode {
		paramsKey := m.Moq.ParamsKey_GobEncode(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_GobEncode(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_GobEncode(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_GobEncode(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) GobDecode(buf []byte) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_GobDecode_params{
		Buf: buf,
	}
	var results *MoqInt_starGenType_GobDecode_results
	for _, resultsByParams := range m.Moq.ResultsByParams_GobDecode {
		paramsKey := m.Moq.ParamsKey_GobDecode(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_GobDecode(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_GobDecode(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_GobDecode(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(buf)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(buf)
	}
	return
}

func (m *MoqInt_starGenType_mock) MarshalText() (text []byte, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_MarshalText_params{}
	var results *MoqInt_starGenType_MarshalText_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MarshalText {
		paramsKey := m.Moq.ParamsKey_MarshalText(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MarshalText(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MarshalText(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MarshalText(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		text = result.Values.Text
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		text, err = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) UnmarshalText(text []byte) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_UnmarshalText_params{
		Text: text,
	}
	var results *MoqInt_starGenType_UnmarshalText_results
	for _, resultsByParams := range m.Moq.ResultsByParams_UnmarshalText {
		paramsKey := m.Moq.ParamsKey_UnmarshalText(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_UnmarshalText(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_UnmarshalText(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_UnmarshalText(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(text)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(text)
	}
	return
}

func (m *MoqInt_starGenType_mock) MarshalJSON() (result1 []byte, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_MarshalJSON_params{}
	var results *MoqInt_starGenType_MarshalJSON_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MarshalJSON {
		paramsKey := m.Moq.ParamsKey_MarshalJSON(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MarshalJSON(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MarshalJSON(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MarshalJSON(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqInt_starGenType_mock) UnmarshalJSON(text []byte) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_UnmarshalJSON_params{
		Text: text,
	}
	var results *MoqInt_starGenType_UnmarshalJSON_results
	for _, resultsByParams := range m.Moq.ResultsByParams_UnmarshalJSON {
		paramsKey := m.Moq.ParamsKey_UnmarshalJSON(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_UnmarshalJSON(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_UnmarshalJSON(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_UnmarshalJSON(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(text)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(text)
	}
	return
}

func (m *MoqInt_starGenType_mock) ProbablyPrime(n int) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqInt_starGenType_ProbablyPrime_params{
		N: n,
	}
	var results *MoqInt_starGenType_ProbablyPrime_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ProbablyPrime {
		paramsKey := m.Moq.ParamsKey_ProbablyPrime(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ProbablyPrime(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ProbablyPrime(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ProbablyPrime(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(n)
	}
	return
}

// OnCall returns the recorder implementation of the Int_starGenType type
func (m *MoqInt_starGenType) OnCall() *MoqInt_starGenType_recorder {
	return &MoqInt_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqInt_starGenType_recorder) Sign() *MoqInt_starGenType_Sign_fnRecorder {
	return &MoqInt_starGenType_Sign_fnRecorder{
		Params:   MoqInt_starGenType_Sign_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Sign_fnRecorder) Any() *MoqInt_starGenType_Sign_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sign(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Sign_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_Sign_fnRecorder) Seq() *MoqInt_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sign(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Sign_fnRecorder) NoSeq() *MoqInt_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sign(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Sign_fnRecorder) ReturnResults(result1 int) *MoqInt_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Sign_doFn
		DoReturnFn MoqInt_starGenType_Sign_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Sign_fnRecorder) AndDo(fn MoqInt_starGenType_Sign_doFn) *MoqInt_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Sign_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Sign_doReturnFn) *MoqInt_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Sign_doFn
		DoReturnFn MoqInt_starGenType_Sign_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Sign_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Sign_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Sign {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Sign_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Sign_paramsKey]*MoqInt_starGenType_Sign_results{},
		}
		r.Moq.ResultsByParams_Sign = append(r.Moq.ResultsByParams_Sign, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Sign) {
			copy(r.Moq.ResultsByParams_Sign[insertAt+1:], r.Moq.ResultsByParams_Sign[insertAt:0])
			r.Moq.ResultsByParams_Sign[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Sign(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Sign_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Sign_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Sign_doFn
				DoReturnFn MoqInt_starGenType_Sign_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Sign(params MoqInt_starGenType_Sign_params) string {
	return fmt.Sprintf("Sign()")
}

func (m *MoqInt_starGenType) ParamsKey_Sign(params MoqInt_starGenType_Sign_params, anyParams uint64) MoqInt_starGenType_Sign_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_Sign_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) SetInt64(x int64) *MoqInt_starGenType_SetInt64_fnRecorder {
	return &MoqInt_starGenType_SetInt64_fnRecorder{
		Params: MoqInt_starGenType_SetInt64_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_SetInt64_fnRecorder) Any() *MoqInt_starGenType_SetInt64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt64(r.Params))
		return nil
	}
	return &MoqInt_starGenType_SetInt64_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_SetInt64_anyParams) X() *MoqInt_starGenType_SetInt64_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_SetInt64_fnRecorder) Seq() *MoqInt_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_SetInt64_fnRecorder) NoSeq() *MoqInt_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_SetInt64_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetInt64_doFn
		DoReturnFn MoqInt_starGenType_SetInt64_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_SetInt64_fnRecorder) AndDo(fn MoqInt_starGenType_SetInt64_doFn) *MoqInt_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_SetInt64_fnRecorder) DoReturnResults(fn MoqInt_starGenType_SetInt64_doReturnFn) *MoqInt_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetInt64_doFn
		DoReturnFn MoqInt_starGenType_SetInt64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_SetInt64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_SetInt64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetInt64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_SetInt64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_SetInt64_paramsKey]*MoqInt_starGenType_SetInt64_results{},
		}
		r.Moq.ResultsByParams_SetInt64 = append(r.Moq.ResultsByParams_SetInt64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetInt64) {
			copy(r.Moq.ResultsByParams_SetInt64[insertAt+1:], r.Moq.ResultsByParams_SetInt64[insertAt:0])
			r.Moq.ResultsByParams_SetInt64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetInt64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_SetInt64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_SetInt64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_SetInt64_doFn
				DoReturnFn MoqInt_starGenType_SetInt64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_SetInt64(params MoqInt_starGenType_SetInt64_params) string {
	return fmt.Sprintf("SetInt64(%#v)", params.X)
}

func (m *MoqInt_starGenType) ParamsKey_SetInt64(params MoqInt_starGenType_SetInt64_params, anyParams uint64) MoqInt_starGenType_SetInt64_paramsKey {
	m.Scene.T.Helper()
	var xUsed int64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetInt64.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqInt_starGenType_SetInt64_paramsKey{
		Params: struct{ X int64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) SetUint64(x uint64) *MoqInt_starGenType_SetUint64_fnRecorder {
	return &MoqInt_starGenType_SetUint64_fnRecorder{
		Params: MoqInt_starGenType_SetUint64_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_SetUint64_fnRecorder) Any() *MoqInt_starGenType_SetUint64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint64(r.Params))
		return nil
	}
	return &MoqInt_starGenType_SetUint64_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_SetUint64_anyParams) X() *MoqInt_starGenType_SetUint64_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_SetUint64_fnRecorder) Seq() *MoqInt_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_SetUint64_fnRecorder) NoSeq() *MoqInt_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_SetUint64_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetUint64_doFn
		DoReturnFn MoqInt_starGenType_SetUint64_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_SetUint64_fnRecorder) AndDo(fn MoqInt_starGenType_SetUint64_doFn) *MoqInt_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_SetUint64_fnRecorder) DoReturnResults(fn MoqInt_starGenType_SetUint64_doReturnFn) *MoqInt_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetUint64_doFn
		DoReturnFn MoqInt_starGenType_SetUint64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_SetUint64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_SetUint64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetUint64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_SetUint64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_SetUint64_paramsKey]*MoqInt_starGenType_SetUint64_results{},
		}
		r.Moq.ResultsByParams_SetUint64 = append(r.Moq.ResultsByParams_SetUint64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetUint64) {
			copy(r.Moq.ResultsByParams_SetUint64[insertAt+1:], r.Moq.ResultsByParams_SetUint64[insertAt:0])
			r.Moq.ResultsByParams_SetUint64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetUint64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_SetUint64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_SetUint64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_SetUint64_doFn
				DoReturnFn MoqInt_starGenType_SetUint64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_SetUint64(params MoqInt_starGenType_SetUint64_params) string {
	return fmt.Sprintf("SetUint64(%#v)", params.X)
}

func (m *MoqInt_starGenType) ParamsKey_SetUint64(params MoqInt_starGenType_SetUint64_params, anyParams uint64) MoqInt_starGenType_SetUint64_paramsKey {
	m.Scene.T.Helper()
	var xUsed uint64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetUint64.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqInt_starGenType_SetUint64_paramsKey{
		Params: struct{ X uint64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Set(x *big.Int) *MoqInt_starGenType_Set_fnRecorder {
	return &MoqInt_starGenType_Set_fnRecorder{
		Params: MoqInt_starGenType_Set_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Set_fnRecorder) Any() *MoqInt_starGenType_Set_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Set_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Set_anyParams) X() *MoqInt_starGenType_Set_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_Set_fnRecorder) Seq() *MoqInt_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Set_fnRecorder) NoSeq() *MoqInt_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Set_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Set_doFn
		DoReturnFn MoqInt_starGenType_Set_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Set_fnRecorder) AndDo(fn MoqInt_starGenType_Set_doFn) *MoqInt_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Set_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Set_doReturnFn) *MoqInt_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Set_doFn
		DoReturnFn MoqInt_starGenType_Set_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Set_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Set_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Set {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Set_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Set_paramsKey]*MoqInt_starGenType_Set_results{},
		}
		r.Moq.ResultsByParams_Set = append(r.Moq.ResultsByParams_Set, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Set) {
			copy(r.Moq.ResultsByParams_Set[insertAt+1:], r.Moq.ResultsByParams_Set[insertAt:0])
			r.Moq.ResultsByParams_Set[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Set(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Set_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Set_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Set_doFn
				DoReturnFn MoqInt_starGenType_Set_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Set(params MoqInt_starGenType_Set_params) string {
	return fmt.Sprintf("Set(%#v)", params.X)
}

func (m *MoqInt_starGenType) ParamsKey_Set(params MoqInt_starGenType_Set_params, anyParams uint64) MoqInt_starGenType_Set_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Set.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqInt_starGenType_Set_paramsKey{
		Params: struct{ X *big.Int }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Bits() *MoqInt_starGenType_Bits_fnRecorder {
	return &MoqInt_starGenType_Bits_fnRecorder{
		Params:   MoqInt_starGenType_Bits_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Bits_fnRecorder) Any() *MoqInt_starGenType_Bits_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bits(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Bits_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_Bits_fnRecorder) Seq() *MoqInt_starGenType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bits(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Bits_fnRecorder) NoSeq() *MoqInt_starGenType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bits(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Bits_fnRecorder) ReturnResults(result1 []big.Word) *MoqInt_starGenType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []big.Word
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Bits_doFn
		DoReturnFn MoqInt_starGenType_Bits_doReturnFn
	}{
		Values: &struct {
			Result1 []big.Word
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Bits_fnRecorder) AndDo(fn MoqInt_starGenType_Bits_doFn) *MoqInt_starGenType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Bits_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Bits_doReturnFn) *MoqInt_starGenType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []big.Word
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Bits_doFn
		DoReturnFn MoqInt_starGenType_Bits_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Bits_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Bits_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Bits {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Bits_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Bits_paramsKey]*MoqInt_starGenType_Bits_results{},
		}
		r.Moq.ResultsByParams_Bits = append(r.Moq.ResultsByParams_Bits, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Bits) {
			copy(r.Moq.ResultsByParams_Bits[insertAt+1:], r.Moq.ResultsByParams_Bits[insertAt:0])
			r.Moq.ResultsByParams_Bits[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Bits(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Bits_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Bits_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []big.Word
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Bits_doFn
				DoReturnFn MoqInt_starGenType_Bits_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Bits(params MoqInt_starGenType_Bits_params) string {
	return fmt.Sprintf("Bits()")
}

func (m *MoqInt_starGenType) ParamsKey_Bits(params MoqInt_starGenType_Bits_params, anyParams uint64) MoqInt_starGenType_Bits_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_Bits_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) SetBits(abs []big.Word) *MoqInt_starGenType_SetBits_fnRecorder {
	return &MoqInt_starGenType_SetBits_fnRecorder{
		Params: MoqInt_starGenType_SetBits_params{
			Abs: abs,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_SetBits_fnRecorder) Any() *MoqInt_starGenType_SetBits_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBits(r.Params))
		return nil
	}
	return &MoqInt_starGenType_SetBits_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_SetBits_anyParams) Abs() *MoqInt_starGenType_SetBits_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_SetBits_fnRecorder) Seq() *MoqInt_starGenType_SetBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBits(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_SetBits_fnRecorder) NoSeq() *MoqInt_starGenType_SetBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBits(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_SetBits_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_SetBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetBits_doFn
		DoReturnFn MoqInt_starGenType_SetBits_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_SetBits_fnRecorder) AndDo(fn MoqInt_starGenType_SetBits_doFn) *MoqInt_starGenType_SetBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_SetBits_fnRecorder) DoReturnResults(fn MoqInt_starGenType_SetBits_doReturnFn) *MoqInt_starGenType_SetBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetBits_doFn
		DoReturnFn MoqInt_starGenType_SetBits_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_SetBits_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_SetBits_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetBits {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_SetBits_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_SetBits_paramsKey]*MoqInt_starGenType_SetBits_results{},
		}
		r.Moq.ResultsByParams_SetBits = append(r.Moq.ResultsByParams_SetBits, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetBits) {
			copy(r.Moq.ResultsByParams_SetBits[insertAt+1:], r.Moq.ResultsByParams_SetBits[insertAt:0])
			r.Moq.ResultsByParams_SetBits[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetBits(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_SetBits_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_SetBits_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_SetBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_SetBits_doFn
				DoReturnFn MoqInt_starGenType_SetBits_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_SetBits(params MoqInt_starGenType_SetBits_params) string {
	return fmt.Sprintf("SetBits(%#v)", params.Abs)
}

func (m *MoqInt_starGenType) ParamsKey_SetBits(params MoqInt_starGenType_SetBits_params, anyParams uint64) MoqInt_starGenType_SetBits_paramsKey {
	m.Scene.T.Helper()
	var absUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetBits.Abs == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The abs parameter of the SetBits function can't be indexed by value")
		}
		absUsedHash = hash.DeepHash(params.Abs)
	}
	return MoqInt_starGenType_SetBits_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Abs hash.Hash }{
			Abs: absUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Abs(x *big.Int) *MoqInt_starGenType_Abs_fnRecorder {
	return &MoqInt_starGenType_Abs_fnRecorder{
		Params: MoqInt_starGenType_Abs_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Abs_fnRecorder) Any() *MoqInt_starGenType_Abs_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Abs(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Abs_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Abs_anyParams) X() *MoqInt_starGenType_Abs_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_Abs_fnRecorder) Seq() *MoqInt_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Abs(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Abs_fnRecorder) NoSeq() *MoqInt_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Abs(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Abs_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Abs_doFn
		DoReturnFn MoqInt_starGenType_Abs_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Abs_fnRecorder) AndDo(fn MoqInt_starGenType_Abs_doFn) *MoqInt_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Abs_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Abs_doReturnFn) *MoqInt_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Abs_doFn
		DoReturnFn MoqInt_starGenType_Abs_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Abs_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Abs_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Abs {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Abs_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Abs_paramsKey]*MoqInt_starGenType_Abs_results{},
		}
		r.Moq.ResultsByParams_Abs = append(r.Moq.ResultsByParams_Abs, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Abs) {
			copy(r.Moq.ResultsByParams_Abs[insertAt+1:], r.Moq.ResultsByParams_Abs[insertAt:0])
			r.Moq.ResultsByParams_Abs[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Abs(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Abs_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Abs_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Abs_doFn
				DoReturnFn MoqInt_starGenType_Abs_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Abs(params MoqInt_starGenType_Abs_params) string {
	return fmt.Sprintf("Abs(%#v)", params.X)
}

func (m *MoqInt_starGenType) ParamsKey_Abs(params MoqInt_starGenType_Abs_params, anyParams uint64) MoqInt_starGenType_Abs_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Abs.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqInt_starGenType_Abs_paramsKey{
		Params: struct{ X *big.Int }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Neg(x *big.Int) *MoqInt_starGenType_Neg_fnRecorder {
	return &MoqInt_starGenType_Neg_fnRecorder{
		Params: MoqInt_starGenType_Neg_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Neg_fnRecorder) Any() *MoqInt_starGenType_Neg_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Neg(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Neg_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Neg_anyParams) X() *MoqInt_starGenType_Neg_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_Neg_fnRecorder) Seq() *MoqInt_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Neg(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Neg_fnRecorder) NoSeq() *MoqInt_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Neg(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Neg_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Neg_doFn
		DoReturnFn MoqInt_starGenType_Neg_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Neg_fnRecorder) AndDo(fn MoqInt_starGenType_Neg_doFn) *MoqInt_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Neg_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Neg_doReturnFn) *MoqInt_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Neg_doFn
		DoReturnFn MoqInt_starGenType_Neg_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Neg_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Neg_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Neg {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Neg_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Neg_paramsKey]*MoqInt_starGenType_Neg_results{},
		}
		r.Moq.ResultsByParams_Neg = append(r.Moq.ResultsByParams_Neg, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Neg) {
			copy(r.Moq.ResultsByParams_Neg[insertAt+1:], r.Moq.ResultsByParams_Neg[insertAt:0])
			r.Moq.ResultsByParams_Neg[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Neg(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Neg_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Neg_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Neg_doFn
				DoReturnFn MoqInt_starGenType_Neg_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Neg(params MoqInt_starGenType_Neg_params) string {
	return fmt.Sprintf("Neg(%#v)", params.X)
}

func (m *MoqInt_starGenType) ParamsKey_Neg(params MoqInt_starGenType_Neg_params, anyParams uint64) MoqInt_starGenType_Neg_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Neg.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqInt_starGenType_Neg_paramsKey{
		Params: struct{ X *big.Int }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Add(x, y *big.Int) *MoqInt_starGenType_Add_fnRecorder {
	return &MoqInt_starGenType_Add_fnRecorder{
		Params: MoqInt_starGenType_Add_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Add_fnRecorder) Any() *MoqInt_starGenType_Add_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Add_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Add_anyParams) X() *MoqInt_starGenType_Add_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Add_anyParams) Y() *MoqInt_starGenType_Add_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Add_fnRecorder) Seq() *MoqInt_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Add_fnRecorder) NoSeq() *MoqInt_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Add_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Add_doFn
		DoReturnFn MoqInt_starGenType_Add_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Add_fnRecorder) AndDo(fn MoqInt_starGenType_Add_doFn) *MoqInt_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Add_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Add_doReturnFn) *MoqInt_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Add_doFn
		DoReturnFn MoqInt_starGenType_Add_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Add_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Add_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Add {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Add_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Add_paramsKey]*MoqInt_starGenType_Add_results{},
		}
		r.Moq.ResultsByParams_Add = append(r.Moq.ResultsByParams_Add, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Add) {
			copy(r.Moq.ResultsByParams_Add[insertAt+1:], r.Moq.ResultsByParams_Add[insertAt:0])
			r.Moq.ResultsByParams_Add[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Add(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Add_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Add_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Add_doFn
				DoReturnFn MoqInt_starGenType_Add_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Add(params MoqInt_starGenType_Add_params) string {
	return fmt.Sprintf("Add(%#v, %#v)", params.X, params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_Add(params MoqInt_starGenType_Add_params, anyParams uint64) MoqInt_starGenType_Add_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Add.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Add.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_Add_paramsKey{
		Params: struct{ X, Y *big.Int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Sub(x, y *big.Int) *MoqInt_starGenType_Sub_fnRecorder {
	return &MoqInt_starGenType_Sub_fnRecorder{
		Params: MoqInt_starGenType_Sub_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Sub_fnRecorder) Any() *MoqInt_starGenType_Sub_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Sub_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Sub_anyParams) X() *MoqInt_starGenType_Sub_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Sub_anyParams) Y() *MoqInt_starGenType_Sub_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Sub_fnRecorder) Seq() *MoqInt_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Sub_fnRecorder) NoSeq() *MoqInt_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Sub_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Sub_doFn
		DoReturnFn MoqInt_starGenType_Sub_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Sub_fnRecorder) AndDo(fn MoqInt_starGenType_Sub_doFn) *MoqInt_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Sub_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Sub_doReturnFn) *MoqInt_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Sub_doFn
		DoReturnFn MoqInt_starGenType_Sub_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Sub_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Sub_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Sub {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Sub_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Sub_paramsKey]*MoqInt_starGenType_Sub_results{},
		}
		r.Moq.ResultsByParams_Sub = append(r.Moq.ResultsByParams_Sub, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Sub) {
			copy(r.Moq.ResultsByParams_Sub[insertAt+1:], r.Moq.ResultsByParams_Sub[insertAt:0])
			r.Moq.ResultsByParams_Sub[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Sub(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Sub_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Sub_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Sub_doFn
				DoReturnFn MoqInt_starGenType_Sub_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Sub(params MoqInt_starGenType_Sub_params) string {
	return fmt.Sprintf("Sub(%#v, %#v)", params.X, params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_Sub(params MoqInt_starGenType_Sub_params, anyParams uint64) MoqInt_starGenType_Sub_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Sub.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Sub.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_Sub_paramsKey{
		Params: struct{ X, Y *big.Int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Mul(x, y *big.Int) *MoqInt_starGenType_Mul_fnRecorder {
	return &MoqInt_starGenType_Mul_fnRecorder{
		Params: MoqInt_starGenType_Mul_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Mul_fnRecorder) Any() *MoqInt_starGenType_Mul_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mul(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Mul_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Mul_anyParams) X() *MoqInt_starGenType_Mul_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Mul_anyParams) Y() *MoqInt_starGenType_Mul_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Mul_fnRecorder) Seq() *MoqInt_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mul(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Mul_fnRecorder) NoSeq() *MoqInt_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mul(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Mul_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Mul_doFn
		DoReturnFn MoqInt_starGenType_Mul_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Mul_fnRecorder) AndDo(fn MoqInt_starGenType_Mul_doFn) *MoqInt_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Mul_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Mul_doReturnFn) *MoqInt_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Mul_doFn
		DoReturnFn MoqInt_starGenType_Mul_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Mul_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Mul_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Mul {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Mul_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Mul_paramsKey]*MoqInt_starGenType_Mul_results{},
		}
		r.Moq.ResultsByParams_Mul = append(r.Moq.ResultsByParams_Mul, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Mul) {
			copy(r.Moq.ResultsByParams_Mul[insertAt+1:], r.Moq.ResultsByParams_Mul[insertAt:0])
			r.Moq.ResultsByParams_Mul[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Mul(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Mul_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Mul_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Mul_doFn
				DoReturnFn MoqInt_starGenType_Mul_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Mul(params MoqInt_starGenType_Mul_params) string {
	return fmt.Sprintf("Mul(%#v, %#v)", params.X, params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_Mul(params MoqInt_starGenType_Mul_params, anyParams uint64) MoqInt_starGenType_Mul_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Mul.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Mul.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_Mul_paramsKey{
		Params: struct{ X, Y *big.Int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) MulRange(a, b int64) *MoqInt_starGenType_MulRange_fnRecorder {
	return &MoqInt_starGenType_MulRange_fnRecorder{
		Params: MoqInt_starGenType_MulRange_params{
			A: a,
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_MulRange_fnRecorder) Any() *MoqInt_starGenType_MulRange_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MulRange(r.Params))
		return nil
	}
	return &MoqInt_starGenType_MulRange_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_MulRange_anyParams) A() *MoqInt_starGenType_MulRange_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_MulRange_anyParams) B() *MoqInt_starGenType_MulRange_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_MulRange_fnRecorder) Seq() *MoqInt_starGenType_MulRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MulRange(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_MulRange_fnRecorder) NoSeq() *MoqInt_starGenType_MulRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MulRange(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_MulRange_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_MulRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_MulRange_doFn
		DoReturnFn MoqInt_starGenType_MulRange_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_MulRange_fnRecorder) AndDo(fn MoqInt_starGenType_MulRange_doFn) *MoqInt_starGenType_MulRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_MulRange_fnRecorder) DoReturnResults(fn MoqInt_starGenType_MulRange_doReturnFn) *MoqInt_starGenType_MulRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_MulRange_doFn
		DoReturnFn MoqInt_starGenType_MulRange_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_MulRange_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_MulRange_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MulRange {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_MulRange_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_MulRange_paramsKey]*MoqInt_starGenType_MulRange_results{},
		}
		r.Moq.ResultsByParams_MulRange = append(r.Moq.ResultsByParams_MulRange, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MulRange) {
			copy(r.Moq.ResultsByParams_MulRange[insertAt+1:], r.Moq.ResultsByParams_MulRange[insertAt:0])
			r.Moq.ResultsByParams_MulRange[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MulRange(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_MulRange_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_MulRange_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_MulRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_MulRange_doFn
				DoReturnFn MoqInt_starGenType_MulRange_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_MulRange(params MoqInt_starGenType_MulRange_params) string {
	return fmt.Sprintf("MulRange(%#v, %#v)", params.A, params.B)
}

func (m *MoqInt_starGenType) ParamsKey_MulRange(params MoqInt_starGenType_MulRange_params, anyParams uint64) MoqInt_starGenType_MulRange_paramsKey {
	m.Scene.T.Helper()
	var aUsed int64
	var aUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MulRange.A == moq.ParamIndexByValue {
			aUsed = params.A
		} else {
			aUsedHash = hash.DeepHash(params.A)
		}
	}
	var bUsed int64
	var bUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.MulRange.B == moq.ParamIndexByValue {
			bUsed = params.B
		} else {
			bUsedHash = hash.DeepHash(params.B)
		}
	}
	return MoqInt_starGenType_MulRange_paramsKey{
		Params: struct{ A, B int64 }{
			A: aUsed,
			B: bUsed,
		},
		Hashes: struct{ A, B hash.Hash }{
			A: aUsedHash,
			B: bUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Binomial(n, k int64) *MoqInt_starGenType_Binomial_fnRecorder {
	return &MoqInt_starGenType_Binomial_fnRecorder{
		Params: MoqInt_starGenType_Binomial_params{
			N: n,
			K: k,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Binomial_fnRecorder) Any() *MoqInt_starGenType_Binomial_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Binomial(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Binomial_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Binomial_anyParams) N() *MoqInt_starGenType_Binomial_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Binomial_anyParams) K() *MoqInt_starGenType_Binomial_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Binomial_fnRecorder) Seq() *MoqInt_starGenType_Binomial_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Binomial(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Binomial_fnRecorder) NoSeq() *MoqInt_starGenType_Binomial_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Binomial(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Binomial_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Binomial_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Binomial_doFn
		DoReturnFn MoqInt_starGenType_Binomial_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Binomial_fnRecorder) AndDo(fn MoqInt_starGenType_Binomial_doFn) *MoqInt_starGenType_Binomial_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Binomial_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Binomial_doReturnFn) *MoqInt_starGenType_Binomial_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Binomial_doFn
		DoReturnFn MoqInt_starGenType_Binomial_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Binomial_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Binomial_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Binomial {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Binomial_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Binomial_paramsKey]*MoqInt_starGenType_Binomial_results{},
		}
		r.Moq.ResultsByParams_Binomial = append(r.Moq.ResultsByParams_Binomial, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Binomial) {
			copy(r.Moq.ResultsByParams_Binomial[insertAt+1:], r.Moq.ResultsByParams_Binomial[insertAt:0])
			r.Moq.ResultsByParams_Binomial[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Binomial(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Binomial_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Binomial_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Binomial_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Binomial_doFn
				DoReturnFn MoqInt_starGenType_Binomial_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Binomial(params MoqInt_starGenType_Binomial_params) string {
	return fmt.Sprintf("Binomial(%#v, %#v)", params.N, params.K)
}

func (m *MoqInt_starGenType) ParamsKey_Binomial(params MoqInt_starGenType_Binomial_params, anyParams uint64) MoqInt_starGenType_Binomial_paramsKey {
	m.Scene.T.Helper()
	var nUsed int64
	var nUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Binomial.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	var kUsed int64
	var kUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Binomial.K == moq.ParamIndexByValue {
			kUsed = params.K
		} else {
			kUsedHash = hash.DeepHash(params.K)
		}
	}
	return MoqInt_starGenType_Binomial_paramsKey{
		Params: struct{ N, K int64 }{
			N: nUsed,
			K: kUsed,
		},
		Hashes: struct{ N, K hash.Hash }{
			N: nUsedHash,
			K: kUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Quo(x, y *big.Int) *MoqInt_starGenType_Quo_fnRecorder {
	return &MoqInt_starGenType_Quo_fnRecorder{
		Params: MoqInt_starGenType_Quo_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Quo_fnRecorder) Any() *MoqInt_starGenType_Quo_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quo(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Quo_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Quo_anyParams) X() *MoqInt_starGenType_Quo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Quo_anyParams) Y() *MoqInt_starGenType_Quo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Quo_fnRecorder) Seq() *MoqInt_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quo(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Quo_fnRecorder) NoSeq() *MoqInt_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quo(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Quo_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Quo_doFn
		DoReturnFn MoqInt_starGenType_Quo_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Quo_fnRecorder) AndDo(fn MoqInt_starGenType_Quo_doFn) *MoqInt_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Quo_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Quo_doReturnFn) *MoqInt_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Quo_doFn
		DoReturnFn MoqInt_starGenType_Quo_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Quo_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Quo_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Quo {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Quo_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Quo_paramsKey]*MoqInt_starGenType_Quo_results{},
		}
		r.Moq.ResultsByParams_Quo = append(r.Moq.ResultsByParams_Quo, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Quo) {
			copy(r.Moq.ResultsByParams_Quo[insertAt+1:], r.Moq.ResultsByParams_Quo[insertAt:0])
			r.Moq.ResultsByParams_Quo[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Quo(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Quo_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Quo_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Quo_doFn
				DoReturnFn MoqInt_starGenType_Quo_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Quo(params MoqInt_starGenType_Quo_params) string {
	return fmt.Sprintf("Quo(%#v, %#v)", params.X, params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_Quo(params MoqInt_starGenType_Quo_params, anyParams uint64) MoqInt_starGenType_Quo_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Quo.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Quo.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_Quo_paramsKey{
		Params: struct{ X, Y *big.Int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Rem(x, y *big.Int) *MoqInt_starGenType_Rem_fnRecorder {
	return &MoqInt_starGenType_Rem_fnRecorder{
		Params: MoqInt_starGenType_Rem_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Rem_fnRecorder) Any() *MoqInt_starGenType_Rem_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rem(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Rem_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Rem_anyParams) X() *MoqInt_starGenType_Rem_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Rem_anyParams) Y() *MoqInt_starGenType_Rem_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Rem_fnRecorder) Seq() *MoqInt_starGenType_Rem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rem(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Rem_fnRecorder) NoSeq() *MoqInt_starGenType_Rem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rem(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Rem_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Rem_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Rem_doFn
		DoReturnFn MoqInt_starGenType_Rem_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Rem_fnRecorder) AndDo(fn MoqInt_starGenType_Rem_doFn) *MoqInt_starGenType_Rem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Rem_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Rem_doReturnFn) *MoqInt_starGenType_Rem_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Rem_doFn
		DoReturnFn MoqInt_starGenType_Rem_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Rem_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Rem_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Rem {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Rem_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Rem_paramsKey]*MoqInt_starGenType_Rem_results{},
		}
		r.Moq.ResultsByParams_Rem = append(r.Moq.ResultsByParams_Rem, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Rem) {
			copy(r.Moq.ResultsByParams_Rem[insertAt+1:], r.Moq.ResultsByParams_Rem[insertAt:0])
			r.Moq.ResultsByParams_Rem[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Rem(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Rem_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Rem_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Rem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Rem_doFn
				DoReturnFn MoqInt_starGenType_Rem_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Rem(params MoqInt_starGenType_Rem_params) string {
	return fmt.Sprintf("Rem(%#v, %#v)", params.X, params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_Rem(params MoqInt_starGenType_Rem_params, anyParams uint64) MoqInt_starGenType_Rem_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Rem.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Rem.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_Rem_paramsKey{
		Params: struct{ X, Y *big.Int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) QuoRem(x, y, param3 *big.Int) *MoqInt_starGenType_QuoRem_fnRecorder {
	return &MoqInt_starGenType_QuoRem_fnRecorder{
		Params: MoqInt_starGenType_QuoRem_params{
			X:      x,
			Y:      y,
			Param3: param3,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_QuoRem_fnRecorder) Any() *MoqInt_starGenType_QuoRem_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_QuoRem(r.Params))
		return nil
	}
	return &MoqInt_starGenType_QuoRem_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_QuoRem_anyParams) X() *MoqInt_starGenType_QuoRem_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_QuoRem_anyParams) Y() *MoqInt_starGenType_QuoRem_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqInt_starGenType_QuoRem_anyParams) Param3() *MoqInt_starGenType_QuoRem_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqInt_starGenType_QuoRem_fnRecorder) Seq() *MoqInt_starGenType_QuoRem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_QuoRem(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_QuoRem_fnRecorder) NoSeq() *MoqInt_starGenType_QuoRem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_QuoRem(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_QuoRem_fnRecorder) ReturnResults(result1 *big.Int, result2 *big.Int) *MoqInt_starGenType_QuoRem_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
			Result2 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_QuoRem_doFn
		DoReturnFn MoqInt_starGenType_QuoRem_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
			Result2 *big.Int
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_QuoRem_fnRecorder) AndDo(fn MoqInt_starGenType_QuoRem_doFn) *MoqInt_starGenType_QuoRem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_QuoRem_fnRecorder) DoReturnResults(fn MoqInt_starGenType_QuoRem_doReturnFn) *MoqInt_starGenType_QuoRem_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
			Result2 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_QuoRem_doFn
		DoReturnFn MoqInt_starGenType_QuoRem_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_QuoRem_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_QuoRem_resultsByParams
	for n, res := range r.Moq.ResultsByParams_QuoRem {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_QuoRem_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_QuoRem_paramsKey]*MoqInt_starGenType_QuoRem_results{},
		}
		r.Moq.ResultsByParams_QuoRem = append(r.Moq.ResultsByParams_QuoRem, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_QuoRem) {
			copy(r.Moq.ResultsByParams_QuoRem[insertAt+1:], r.Moq.ResultsByParams_QuoRem[insertAt:0])
			r.Moq.ResultsByParams_QuoRem[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_QuoRem(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_QuoRem_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_QuoRem_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_QuoRem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
					Result2 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_QuoRem_doFn
				DoReturnFn MoqInt_starGenType_QuoRem_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_QuoRem(params MoqInt_starGenType_QuoRem_params) string {
	return fmt.Sprintf("QuoRem(%#v, %#v, %#v)", params.X, params.Y, params.Param3)
}

func (m *MoqInt_starGenType) ParamsKey_QuoRem(params MoqInt_starGenType_QuoRem_params, anyParams uint64) MoqInt_starGenType_QuoRem_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.QuoRem.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.QuoRem.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	var param3Used *big.Int
	var param3UsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.QuoRem.Param3 == moq.ParamIndexByValue {
			param3Used = params.Param3
		} else {
			param3UsedHash = hash.DeepHash(params.Param3)
		}
	}
	return MoqInt_starGenType_QuoRem_paramsKey{
		Params: struct{ X, Y, Param3 *big.Int }{
			X:      xUsed,
			Y:      yUsed,
			Param3: param3Used,
		},
		Hashes: struct{ X, Y, Param3 hash.Hash }{
			X:      xUsedHash,
			Y:      yUsedHash,
			Param3: param3UsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Div(x, y *big.Int) *MoqInt_starGenType_Div_fnRecorder {
	return &MoqInt_starGenType_Div_fnRecorder{
		Params: MoqInt_starGenType_Div_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Div_fnRecorder) Any() *MoqInt_starGenType_Div_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Div(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Div_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Div_anyParams) X() *MoqInt_starGenType_Div_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Div_anyParams) Y() *MoqInt_starGenType_Div_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Div_fnRecorder) Seq() *MoqInt_starGenType_Div_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Div(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Div_fnRecorder) NoSeq() *MoqInt_starGenType_Div_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Div(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Div_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Div_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Div_doFn
		DoReturnFn MoqInt_starGenType_Div_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Div_fnRecorder) AndDo(fn MoqInt_starGenType_Div_doFn) *MoqInt_starGenType_Div_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Div_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Div_doReturnFn) *MoqInt_starGenType_Div_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Div_doFn
		DoReturnFn MoqInt_starGenType_Div_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Div_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Div_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Div {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Div_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Div_paramsKey]*MoqInt_starGenType_Div_results{},
		}
		r.Moq.ResultsByParams_Div = append(r.Moq.ResultsByParams_Div, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Div) {
			copy(r.Moq.ResultsByParams_Div[insertAt+1:], r.Moq.ResultsByParams_Div[insertAt:0])
			r.Moq.ResultsByParams_Div[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Div(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Div_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Div_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Div_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Div_doFn
				DoReturnFn MoqInt_starGenType_Div_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Div(params MoqInt_starGenType_Div_params) string {
	return fmt.Sprintf("Div(%#v, %#v)", params.X, params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_Div(params MoqInt_starGenType_Div_params, anyParams uint64) MoqInt_starGenType_Div_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Div.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Div.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_Div_paramsKey{
		Params: struct{ X, Y *big.Int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Mod(x, y *big.Int) *MoqInt_starGenType_Mod_fnRecorder {
	return &MoqInt_starGenType_Mod_fnRecorder{
		Params: MoqInt_starGenType_Mod_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Mod_fnRecorder) Any() *MoqInt_starGenType_Mod_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mod(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Mod_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Mod_anyParams) X() *MoqInt_starGenType_Mod_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Mod_anyParams) Y() *MoqInt_starGenType_Mod_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Mod_fnRecorder) Seq() *MoqInt_starGenType_Mod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mod(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Mod_fnRecorder) NoSeq() *MoqInt_starGenType_Mod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mod(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Mod_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Mod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Mod_doFn
		DoReturnFn MoqInt_starGenType_Mod_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Mod_fnRecorder) AndDo(fn MoqInt_starGenType_Mod_doFn) *MoqInt_starGenType_Mod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Mod_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Mod_doReturnFn) *MoqInt_starGenType_Mod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Mod_doFn
		DoReturnFn MoqInt_starGenType_Mod_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Mod_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Mod_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Mod {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Mod_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Mod_paramsKey]*MoqInt_starGenType_Mod_results{},
		}
		r.Moq.ResultsByParams_Mod = append(r.Moq.ResultsByParams_Mod, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Mod) {
			copy(r.Moq.ResultsByParams_Mod[insertAt+1:], r.Moq.ResultsByParams_Mod[insertAt:0])
			r.Moq.ResultsByParams_Mod[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Mod(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Mod_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Mod_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Mod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Mod_doFn
				DoReturnFn MoqInt_starGenType_Mod_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Mod(params MoqInt_starGenType_Mod_params) string {
	return fmt.Sprintf("Mod(%#v, %#v)", params.X, params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_Mod(params MoqInt_starGenType_Mod_params, anyParams uint64) MoqInt_starGenType_Mod_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Mod.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Mod.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_Mod_paramsKey{
		Params: struct{ X, Y *big.Int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) DivMod(x, y, param3 *big.Int) *MoqInt_starGenType_DivMod_fnRecorder {
	return &MoqInt_starGenType_DivMod_fnRecorder{
		Params: MoqInt_starGenType_DivMod_params{
			X:      x,
			Y:      y,
			Param3: param3,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_DivMod_fnRecorder) Any() *MoqInt_starGenType_DivMod_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_DivMod(r.Params))
		return nil
	}
	return &MoqInt_starGenType_DivMod_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_DivMod_anyParams) X() *MoqInt_starGenType_DivMod_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_DivMod_anyParams) Y() *MoqInt_starGenType_DivMod_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqInt_starGenType_DivMod_anyParams) Param3() *MoqInt_starGenType_DivMod_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqInt_starGenType_DivMod_fnRecorder) Seq() *MoqInt_starGenType_DivMod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_DivMod(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_DivMod_fnRecorder) NoSeq() *MoqInt_starGenType_DivMod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_DivMod(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_DivMod_fnRecorder) ReturnResults(result1 *big.Int, result2 *big.Int) *MoqInt_starGenType_DivMod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
			Result2 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_DivMod_doFn
		DoReturnFn MoqInt_starGenType_DivMod_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
			Result2 *big.Int
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_DivMod_fnRecorder) AndDo(fn MoqInt_starGenType_DivMod_doFn) *MoqInt_starGenType_DivMod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_DivMod_fnRecorder) DoReturnResults(fn MoqInt_starGenType_DivMod_doReturnFn) *MoqInt_starGenType_DivMod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
			Result2 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_DivMod_doFn
		DoReturnFn MoqInt_starGenType_DivMod_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_DivMod_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_DivMod_resultsByParams
	for n, res := range r.Moq.ResultsByParams_DivMod {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_DivMod_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_DivMod_paramsKey]*MoqInt_starGenType_DivMod_results{},
		}
		r.Moq.ResultsByParams_DivMod = append(r.Moq.ResultsByParams_DivMod, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_DivMod) {
			copy(r.Moq.ResultsByParams_DivMod[insertAt+1:], r.Moq.ResultsByParams_DivMod[insertAt:0])
			r.Moq.ResultsByParams_DivMod[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_DivMod(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_DivMod_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_DivMod_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_DivMod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
					Result2 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_DivMod_doFn
				DoReturnFn MoqInt_starGenType_DivMod_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_DivMod(params MoqInt_starGenType_DivMod_params) string {
	return fmt.Sprintf("DivMod(%#v, %#v, %#v)", params.X, params.Y, params.Param3)
}

func (m *MoqInt_starGenType) ParamsKey_DivMod(params MoqInt_starGenType_DivMod_params, anyParams uint64) MoqInt_starGenType_DivMod_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.DivMod.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.DivMod.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	var param3Used *big.Int
	var param3UsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.DivMod.Param3 == moq.ParamIndexByValue {
			param3Used = params.Param3
		} else {
			param3UsedHash = hash.DeepHash(params.Param3)
		}
	}
	return MoqInt_starGenType_DivMod_paramsKey{
		Params: struct{ X, Y, Param3 *big.Int }{
			X:      xUsed,
			Y:      yUsed,
			Param3: param3Used,
		},
		Hashes: struct{ X, Y, Param3 hash.Hash }{
			X:      xUsedHash,
			Y:      yUsedHash,
			Param3: param3UsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Cmp(y *big.Int) *MoqInt_starGenType_Cmp_fnRecorder {
	return &MoqInt_starGenType_Cmp_fnRecorder{
		Params: MoqInt_starGenType_Cmp_params{
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Cmp_fnRecorder) Any() *MoqInt_starGenType_Cmp_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cmp(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Cmp_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Cmp_anyParams) Y() *MoqInt_starGenType_Cmp_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_Cmp_fnRecorder) Seq() *MoqInt_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cmp(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Cmp_fnRecorder) NoSeq() *MoqInt_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cmp(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Cmp_fnRecorder) ReturnResults(result1 int) *MoqInt_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Result1 int }
		Sequence   uint32
		DoFn       MoqInt_starGenType_Cmp_doFn
		DoReturnFn MoqInt_starGenType_Cmp_doReturnFn
	}{
		Values: &struct{ Result1 int }{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Cmp_fnRecorder) AndDo(fn MoqInt_starGenType_Cmp_doFn) *MoqInt_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Cmp_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Cmp_doReturnFn) *MoqInt_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Result1 int }
		Sequence   uint32
		DoFn       MoqInt_starGenType_Cmp_doFn
		DoReturnFn MoqInt_starGenType_Cmp_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Cmp_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Cmp_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Cmp {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Cmp_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Cmp_paramsKey]*MoqInt_starGenType_Cmp_results{},
		}
		r.Moq.ResultsByParams_Cmp = append(r.Moq.ResultsByParams_Cmp, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Cmp) {
			copy(r.Moq.ResultsByParams_Cmp[insertAt+1:], r.Moq.ResultsByParams_Cmp[insertAt:0])
			r.Moq.ResultsByParams_Cmp[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Cmp(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Cmp_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Cmp_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Result1 int }
				Sequence   uint32
				DoFn       MoqInt_starGenType_Cmp_doFn
				DoReturnFn MoqInt_starGenType_Cmp_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Cmp(params MoqInt_starGenType_Cmp_params) string {
	return fmt.Sprintf("Cmp(%#v)", params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_Cmp(params MoqInt_starGenType_Cmp_params, anyParams uint64) MoqInt_starGenType_Cmp_paramsKey {
	m.Scene.T.Helper()
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Cmp.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_Cmp_paramsKey{
		Params: struct{ Y *big.Int }{
			Y: yUsed,
		},
		Hashes: struct{ Y hash.Hash }{
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) CmpAbs(y *big.Int) *MoqInt_starGenType_CmpAbs_fnRecorder {
	return &MoqInt_starGenType_CmpAbs_fnRecorder{
		Params: MoqInt_starGenType_CmpAbs_params{
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_CmpAbs_fnRecorder) Any() *MoqInt_starGenType_CmpAbs_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CmpAbs(r.Params))
		return nil
	}
	return &MoqInt_starGenType_CmpAbs_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_CmpAbs_anyParams) Y() *MoqInt_starGenType_CmpAbs_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_CmpAbs_fnRecorder) Seq() *MoqInt_starGenType_CmpAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CmpAbs(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_CmpAbs_fnRecorder) NoSeq() *MoqInt_starGenType_CmpAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CmpAbs(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_CmpAbs_fnRecorder) ReturnResults(result1 int) *MoqInt_starGenType_CmpAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_CmpAbs_doFn
		DoReturnFn MoqInt_starGenType_CmpAbs_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_CmpAbs_fnRecorder) AndDo(fn MoqInt_starGenType_CmpAbs_doFn) *MoqInt_starGenType_CmpAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_CmpAbs_fnRecorder) DoReturnResults(fn MoqInt_starGenType_CmpAbs_doReturnFn) *MoqInt_starGenType_CmpAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_CmpAbs_doFn
		DoReturnFn MoqInt_starGenType_CmpAbs_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_CmpAbs_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_CmpAbs_resultsByParams
	for n, res := range r.Moq.ResultsByParams_CmpAbs {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_CmpAbs_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_CmpAbs_paramsKey]*MoqInt_starGenType_CmpAbs_results{},
		}
		r.Moq.ResultsByParams_CmpAbs = append(r.Moq.ResultsByParams_CmpAbs, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_CmpAbs) {
			copy(r.Moq.ResultsByParams_CmpAbs[insertAt+1:], r.Moq.ResultsByParams_CmpAbs[insertAt:0])
			r.Moq.ResultsByParams_CmpAbs[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_CmpAbs(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_CmpAbs_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_CmpAbs_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_CmpAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_CmpAbs_doFn
				DoReturnFn MoqInt_starGenType_CmpAbs_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_CmpAbs(params MoqInt_starGenType_CmpAbs_params) string {
	return fmt.Sprintf("CmpAbs(%#v)", params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_CmpAbs(params MoqInt_starGenType_CmpAbs_params, anyParams uint64) MoqInt_starGenType_CmpAbs_paramsKey {
	m.Scene.T.Helper()
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.CmpAbs.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_CmpAbs_paramsKey{
		Params: struct{ Y *big.Int }{
			Y: yUsed,
		},
		Hashes: struct{ Y hash.Hash }{
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Int64() *MoqInt_starGenType_Int64_fnRecorder {
	return &MoqInt_starGenType_Int64_fnRecorder{
		Params:   MoqInt_starGenType_Int64_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Int64_fnRecorder) Any() *MoqInt_starGenType_Int64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int64(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Int64_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_Int64_fnRecorder) Seq() *MoqInt_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Int64_fnRecorder) NoSeq() *MoqInt_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Int64_fnRecorder) ReturnResults(result1 int64) *MoqInt_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Int64_doFn
		DoReturnFn MoqInt_starGenType_Int64_doReturnFn
	}{
		Values: &struct {
			Result1 int64
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Int64_fnRecorder) AndDo(fn MoqInt_starGenType_Int64_doFn) *MoqInt_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Int64_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Int64_doReturnFn) *MoqInt_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Int64_doFn
		DoReturnFn MoqInt_starGenType_Int64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Int64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Int64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Int64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Int64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Int64_paramsKey]*MoqInt_starGenType_Int64_results{},
		}
		r.Moq.ResultsByParams_Int64 = append(r.Moq.ResultsByParams_Int64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Int64) {
			copy(r.Moq.ResultsByParams_Int64[insertAt+1:], r.Moq.ResultsByParams_Int64[insertAt:0])
			r.Moq.ResultsByParams_Int64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Int64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Int64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Int64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int64
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Int64_doFn
				DoReturnFn MoqInt_starGenType_Int64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Int64(params MoqInt_starGenType_Int64_params) string {
	return fmt.Sprintf("Int64()")
}

func (m *MoqInt_starGenType) ParamsKey_Int64(params MoqInt_starGenType_Int64_params, anyParams uint64) MoqInt_starGenType_Int64_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_Int64_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) Uint64() *MoqInt_starGenType_Uint64_fnRecorder {
	return &MoqInt_starGenType_Uint64_fnRecorder{
		Params:   MoqInt_starGenType_Uint64_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Uint64_fnRecorder) Any() *MoqInt_starGenType_Uint64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Uint64(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Uint64_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_Uint64_fnRecorder) Seq() *MoqInt_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Uint64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Uint64_fnRecorder) NoSeq() *MoqInt_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Uint64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Uint64_fnRecorder) ReturnResults(result1 uint64) *MoqInt_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint64
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Uint64_doFn
		DoReturnFn MoqInt_starGenType_Uint64_doReturnFn
	}{
		Values: &struct {
			Result1 uint64
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Uint64_fnRecorder) AndDo(fn MoqInt_starGenType_Uint64_doFn) *MoqInt_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Uint64_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Uint64_doReturnFn) *MoqInt_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint64
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Uint64_doFn
		DoReturnFn MoqInt_starGenType_Uint64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Uint64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Uint64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Uint64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Uint64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Uint64_paramsKey]*MoqInt_starGenType_Uint64_results{},
		}
		r.Moq.ResultsByParams_Uint64 = append(r.Moq.ResultsByParams_Uint64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Uint64) {
			copy(r.Moq.ResultsByParams_Uint64[insertAt+1:], r.Moq.ResultsByParams_Uint64[insertAt:0])
			r.Moq.ResultsByParams_Uint64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Uint64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Uint64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Uint64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 uint64
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Uint64_doFn
				DoReturnFn MoqInt_starGenType_Uint64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Uint64(params MoqInt_starGenType_Uint64_params) string {
	return fmt.Sprintf("Uint64()")
}

func (m *MoqInt_starGenType) ParamsKey_Uint64(params MoqInt_starGenType_Uint64_params, anyParams uint64) MoqInt_starGenType_Uint64_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_Uint64_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) IsInt64() *MoqInt_starGenType_IsInt64_fnRecorder {
	return &MoqInt_starGenType_IsInt64_fnRecorder{
		Params:   MoqInt_starGenType_IsInt64_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_IsInt64_fnRecorder) Any() *MoqInt_starGenType_IsInt64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInt64(r.Params))
		return nil
	}
	return &MoqInt_starGenType_IsInt64_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_IsInt64_fnRecorder) Seq() *MoqInt_starGenType_IsInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInt64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_IsInt64_fnRecorder) NoSeq() *MoqInt_starGenType_IsInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInt64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_IsInt64_fnRecorder) ReturnResults(result1 bool) *MoqInt_starGenType_IsInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_IsInt64_doFn
		DoReturnFn MoqInt_starGenType_IsInt64_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_IsInt64_fnRecorder) AndDo(fn MoqInt_starGenType_IsInt64_doFn) *MoqInt_starGenType_IsInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_IsInt64_fnRecorder) DoReturnResults(fn MoqInt_starGenType_IsInt64_doReturnFn) *MoqInt_starGenType_IsInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_IsInt64_doFn
		DoReturnFn MoqInt_starGenType_IsInt64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_IsInt64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_IsInt64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsInt64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_IsInt64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_IsInt64_paramsKey]*MoqInt_starGenType_IsInt64_results{},
		}
		r.Moq.ResultsByParams_IsInt64 = append(r.Moq.ResultsByParams_IsInt64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsInt64) {
			copy(r.Moq.ResultsByParams_IsInt64[insertAt+1:], r.Moq.ResultsByParams_IsInt64[insertAt:0])
			r.Moq.ResultsByParams_IsInt64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsInt64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_IsInt64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_IsInt64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_IsInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_IsInt64_doFn
				DoReturnFn MoqInt_starGenType_IsInt64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_IsInt64(params MoqInt_starGenType_IsInt64_params) string {
	return fmt.Sprintf("IsInt64()")
}

func (m *MoqInt_starGenType) ParamsKey_IsInt64(params MoqInt_starGenType_IsInt64_params, anyParams uint64) MoqInt_starGenType_IsInt64_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_IsInt64_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) IsUint64() *MoqInt_starGenType_IsUint64_fnRecorder {
	return &MoqInt_starGenType_IsUint64_fnRecorder{
		Params:   MoqInt_starGenType_IsUint64_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_IsUint64_fnRecorder) Any() *MoqInt_starGenType_IsUint64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsUint64(r.Params))
		return nil
	}
	return &MoqInt_starGenType_IsUint64_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_IsUint64_fnRecorder) Seq() *MoqInt_starGenType_IsUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsUint64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_IsUint64_fnRecorder) NoSeq() *MoqInt_starGenType_IsUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsUint64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_IsUint64_fnRecorder) ReturnResults(result1 bool) *MoqInt_starGenType_IsUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_IsUint64_doFn
		DoReturnFn MoqInt_starGenType_IsUint64_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_IsUint64_fnRecorder) AndDo(fn MoqInt_starGenType_IsUint64_doFn) *MoqInt_starGenType_IsUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_IsUint64_fnRecorder) DoReturnResults(fn MoqInt_starGenType_IsUint64_doReturnFn) *MoqInt_starGenType_IsUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_IsUint64_doFn
		DoReturnFn MoqInt_starGenType_IsUint64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_IsUint64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_IsUint64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsUint64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_IsUint64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_IsUint64_paramsKey]*MoqInt_starGenType_IsUint64_results{},
		}
		r.Moq.ResultsByParams_IsUint64 = append(r.Moq.ResultsByParams_IsUint64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsUint64) {
			copy(r.Moq.ResultsByParams_IsUint64[insertAt+1:], r.Moq.ResultsByParams_IsUint64[insertAt:0])
			r.Moq.ResultsByParams_IsUint64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsUint64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_IsUint64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_IsUint64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_IsUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_IsUint64_doFn
				DoReturnFn MoqInt_starGenType_IsUint64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_IsUint64(params MoqInt_starGenType_IsUint64_params) string {
	return fmt.Sprintf("IsUint64()")
}

func (m *MoqInt_starGenType) ParamsKey_IsUint64(params MoqInt_starGenType_IsUint64_params, anyParams uint64) MoqInt_starGenType_IsUint64_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_IsUint64_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) SetString(s string, base int) *MoqInt_starGenType_SetString_fnRecorder {
	return &MoqInt_starGenType_SetString_fnRecorder{
		Params: MoqInt_starGenType_SetString_params{
			S:    s,
			Base: base,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_SetString_fnRecorder) Any() *MoqInt_starGenType_SetString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	return &MoqInt_starGenType_SetString_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_SetString_anyParams) S() *MoqInt_starGenType_SetString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_SetString_anyParams) Base() *MoqInt_starGenType_SetString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_SetString_fnRecorder) Seq() *MoqInt_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_SetString_fnRecorder) NoSeq() *MoqInt_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_SetString_fnRecorder) ReturnResults(result1 *big.Int, result2 bool) *MoqInt_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetString_doFn
		DoReturnFn MoqInt_starGenType_SetString_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
			Result2 bool
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_SetString_fnRecorder) AndDo(fn MoqInt_starGenType_SetString_doFn) *MoqInt_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_SetString_fnRecorder) DoReturnResults(fn MoqInt_starGenType_SetString_doReturnFn) *MoqInt_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetString_doFn
		DoReturnFn MoqInt_starGenType_SetString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_SetString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_SetString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_SetString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_SetString_paramsKey]*MoqInt_starGenType_SetString_results{},
		}
		r.Moq.ResultsByParams_SetString = append(r.Moq.ResultsByParams_SetString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetString) {
			copy(r.Moq.ResultsByParams_SetString[insertAt+1:], r.Moq.ResultsByParams_SetString[insertAt:0])
			r.Moq.ResultsByParams_SetString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_SetString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_SetString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
					Result2 bool
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_SetString_doFn
				DoReturnFn MoqInt_starGenType_SetString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_SetString(params MoqInt_starGenType_SetString_params) string {
	return fmt.Sprintf("SetString(%#v, %#v)", params.S, params.Base)
}

func (m *MoqInt_starGenType) ParamsKey_SetString(params MoqInt_starGenType_SetString_params, anyParams uint64) MoqInt_starGenType_SetString_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetString.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var baseUsed int
	var baseUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.SetString.Base == moq.ParamIndexByValue {
			baseUsed = params.Base
		} else {
			baseUsedHash = hash.DeepHash(params.Base)
		}
	}
	return MoqInt_starGenType_SetString_paramsKey{
		Params: struct {
			S    string
			Base int
		}{
			S:    sUsed,
			Base: baseUsed,
		},
		Hashes: struct {
			S    hash.Hash
			Base hash.Hash
		}{
			S:    sUsedHash,
			Base: baseUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) SetBytes(buf []byte) *MoqInt_starGenType_SetBytes_fnRecorder {
	return &MoqInt_starGenType_SetBytes_fnRecorder{
		Params: MoqInt_starGenType_SetBytes_params{
			Buf: buf,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_SetBytes_fnRecorder) Any() *MoqInt_starGenType_SetBytes_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBytes(r.Params))
		return nil
	}
	return &MoqInt_starGenType_SetBytes_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_SetBytes_anyParams) Buf() *MoqInt_starGenType_SetBytes_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_SetBytes_fnRecorder) Seq() *MoqInt_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBytes(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_SetBytes_fnRecorder) NoSeq() *MoqInt_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBytes(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_SetBytes_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetBytes_doFn
		DoReturnFn MoqInt_starGenType_SetBytes_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_SetBytes_fnRecorder) AndDo(fn MoqInt_starGenType_SetBytes_doFn) *MoqInt_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_SetBytes_fnRecorder) DoReturnResults(fn MoqInt_starGenType_SetBytes_doReturnFn) *MoqInt_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetBytes_doFn
		DoReturnFn MoqInt_starGenType_SetBytes_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_SetBytes_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_SetBytes_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetBytes {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_SetBytes_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_SetBytes_paramsKey]*MoqInt_starGenType_SetBytes_results{},
		}
		r.Moq.ResultsByParams_SetBytes = append(r.Moq.ResultsByParams_SetBytes, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetBytes) {
			copy(r.Moq.ResultsByParams_SetBytes[insertAt+1:], r.Moq.ResultsByParams_SetBytes[insertAt:0])
			r.Moq.ResultsByParams_SetBytes[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetBytes(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_SetBytes_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_SetBytes_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_SetBytes_doFn
				DoReturnFn MoqInt_starGenType_SetBytes_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_SetBytes(params MoqInt_starGenType_SetBytes_params) string {
	return fmt.Sprintf("SetBytes(%#v)", params.Buf)
}

func (m *MoqInt_starGenType) ParamsKey_SetBytes(params MoqInt_starGenType_SetBytes_params, anyParams uint64) MoqInt_starGenType_SetBytes_paramsKey {
	m.Scene.T.Helper()
	var bufUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetBytes.Buf == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The buf parameter of the SetBytes function can't be indexed by value")
		}
		bufUsedHash = hash.DeepHash(params.Buf)
	}
	return MoqInt_starGenType_SetBytes_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Buf hash.Hash }{
			Buf: bufUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Bytes() *MoqInt_starGenType_Bytes_fnRecorder {
	return &MoqInt_starGenType_Bytes_fnRecorder{
		Params:   MoqInt_starGenType_Bytes_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Bytes_fnRecorder) Any() *MoqInt_starGenType_Bytes_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bytes(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Bytes_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_Bytes_fnRecorder) Seq() *MoqInt_starGenType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bytes(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Bytes_fnRecorder) NoSeq() *MoqInt_starGenType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bytes(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Bytes_fnRecorder) ReturnResults(result1 []byte) *MoqInt_starGenType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Bytes_doFn
		DoReturnFn MoqInt_starGenType_Bytes_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Bytes_fnRecorder) AndDo(fn MoqInt_starGenType_Bytes_doFn) *MoqInt_starGenType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Bytes_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Bytes_doReturnFn) *MoqInt_starGenType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Bytes_doFn
		DoReturnFn MoqInt_starGenType_Bytes_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Bytes_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Bytes_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Bytes {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Bytes_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Bytes_paramsKey]*MoqInt_starGenType_Bytes_results{},
		}
		r.Moq.ResultsByParams_Bytes = append(r.Moq.ResultsByParams_Bytes, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Bytes) {
			copy(r.Moq.ResultsByParams_Bytes[insertAt+1:], r.Moq.ResultsByParams_Bytes[insertAt:0])
			r.Moq.ResultsByParams_Bytes[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Bytes(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Bytes_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Bytes_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Bytes_doFn
				DoReturnFn MoqInt_starGenType_Bytes_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Bytes(params MoqInt_starGenType_Bytes_params) string {
	return fmt.Sprintf("Bytes()")
}

func (m *MoqInt_starGenType) ParamsKey_Bytes(params MoqInt_starGenType_Bytes_params, anyParams uint64) MoqInt_starGenType_Bytes_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_Bytes_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) BitLen() *MoqInt_starGenType_BitLen_fnRecorder {
	return &MoqInt_starGenType_BitLen_fnRecorder{
		Params:   MoqInt_starGenType_BitLen_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_BitLen_fnRecorder) Any() *MoqInt_starGenType_BitLen_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_BitLen(r.Params))
		return nil
	}
	return &MoqInt_starGenType_BitLen_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_BitLen_fnRecorder) Seq() *MoqInt_starGenType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_BitLen(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_BitLen_fnRecorder) NoSeq() *MoqInt_starGenType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_BitLen(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_BitLen_fnRecorder) ReturnResults(result1 int) *MoqInt_starGenType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_BitLen_doFn
		DoReturnFn MoqInt_starGenType_BitLen_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_BitLen_fnRecorder) AndDo(fn MoqInt_starGenType_BitLen_doFn) *MoqInt_starGenType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_BitLen_fnRecorder) DoReturnResults(fn MoqInt_starGenType_BitLen_doReturnFn) *MoqInt_starGenType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_BitLen_doFn
		DoReturnFn MoqInt_starGenType_BitLen_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_BitLen_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_BitLen_resultsByParams
	for n, res := range r.Moq.ResultsByParams_BitLen {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_BitLen_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_BitLen_paramsKey]*MoqInt_starGenType_BitLen_results{},
		}
		r.Moq.ResultsByParams_BitLen = append(r.Moq.ResultsByParams_BitLen, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_BitLen) {
			copy(r.Moq.ResultsByParams_BitLen[insertAt+1:], r.Moq.ResultsByParams_BitLen[insertAt:0])
			r.Moq.ResultsByParams_BitLen[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_BitLen(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_BitLen_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_BitLen_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_BitLen_doFn
				DoReturnFn MoqInt_starGenType_BitLen_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_BitLen(params MoqInt_starGenType_BitLen_params) string {
	return fmt.Sprintf("BitLen()")
}

func (m *MoqInt_starGenType) ParamsKey_BitLen(params MoqInt_starGenType_BitLen_params, anyParams uint64) MoqInt_starGenType_BitLen_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_BitLen_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) TrailingZeroBits() *MoqInt_starGenType_TrailingZeroBits_fnRecorder {
	return &MoqInt_starGenType_TrailingZeroBits_fnRecorder{
		Params:   MoqInt_starGenType_TrailingZeroBits_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_TrailingZeroBits_fnRecorder) Any() *MoqInt_starGenType_TrailingZeroBits_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TrailingZeroBits(r.Params))
		return nil
	}
	return &MoqInt_starGenType_TrailingZeroBits_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_TrailingZeroBits_fnRecorder) Seq() *MoqInt_starGenType_TrailingZeroBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TrailingZeroBits(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_TrailingZeroBits_fnRecorder) NoSeq() *MoqInt_starGenType_TrailingZeroBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TrailingZeroBits(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_TrailingZeroBits_fnRecorder) ReturnResults(result1 uint) *MoqInt_starGenType_TrailingZeroBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_TrailingZeroBits_doFn
		DoReturnFn MoqInt_starGenType_TrailingZeroBits_doReturnFn
	}{
		Values: &struct {
			Result1 uint
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_TrailingZeroBits_fnRecorder) AndDo(fn MoqInt_starGenType_TrailingZeroBits_doFn) *MoqInt_starGenType_TrailingZeroBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_TrailingZeroBits_fnRecorder) DoReturnResults(fn MoqInt_starGenType_TrailingZeroBits_doReturnFn) *MoqInt_starGenType_TrailingZeroBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_TrailingZeroBits_doFn
		DoReturnFn MoqInt_starGenType_TrailingZeroBits_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_TrailingZeroBits_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_TrailingZeroBits_resultsByParams
	for n, res := range r.Moq.ResultsByParams_TrailingZeroBits {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_TrailingZeroBits_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_TrailingZeroBits_paramsKey]*MoqInt_starGenType_TrailingZeroBits_results{},
		}
		r.Moq.ResultsByParams_TrailingZeroBits = append(r.Moq.ResultsByParams_TrailingZeroBits, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_TrailingZeroBits) {
			copy(r.Moq.ResultsByParams_TrailingZeroBits[insertAt+1:], r.Moq.ResultsByParams_TrailingZeroBits[insertAt:0])
			r.Moq.ResultsByParams_TrailingZeroBits[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_TrailingZeroBits(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_TrailingZeroBits_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_TrailingZeroBits_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_TrailingZeroBits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 uint
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_TrailingZeroBits_doFn
				DoReturnFn MoqInt_starGenType_TrailingZeroBits_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_TrailingZeroBits(params MoqInt_starGenType_TrailingZeroBits_params) string {
	return fmt.Sprintf("TrailingZeroBits()")
}

func (m *MoqInt_starGenType) ParamsKey_TrailingZeroBits(params MoqInt_starGenType_TrailingZeroBits_params, anyParams uint64) MoqInt_starGenType_TrailingZeroBits_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_TrailingZeroBits_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) Exp(x, y, param3 *big.Int) *MoqInt_starGenType_Exp_fnRecorder {
	return &MoqInt_starGenType_Exp_fnRecorder{
		Params: MoqInt_starGenType_Exp_params{
			X:      x,
			Y:      y,
			Param3: param3,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Exp_fnRecorder) Any() *MoqInt_starGenType_Exp_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Exp(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Exp_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Exp_anyParams) X() *MoqInt_starGenType_Exp_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Exp_anyParams) Y() *MoqInt_starGenType_Exp_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqInt_starGenType_Exp_anyParams) Param3() *MoqInt_starGenType_Exp_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqInt_starGenType_Exp_fnRecorder) Seq() *MoqInt_starGenType_Exp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Exp(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Exp_fnRecorder) NoSeq() *MoqInt_starGenType_Exp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Exp(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Exp_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Exp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Exp_doFn
		DoReturnFn MoqInt_starGenType_Exp_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Exp_fnRecorder) AndDo(fn MoqInt_starGenType_Exp_doFn) *MoqInt_starGenType_Exp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Exp_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Exp_doReturnFn) *MoqInt_starGenType_Exp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Exp_doFn
		DoReturnFn MoqInt_starGenType_Exp_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Exp_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Exp_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Exp {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Exp_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Exp_paramsKey]*MoqInt_starGenType_Exp_results{},
		}
		r.Moq.ResultsByParams_Exp = append(r.Moq.ResultsByParams_Exp, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Exp) {
			copy(r.Moq.ResultsByParams_Exp[insertAt+1:], r.Moq.ResultsByParams_Exp[insertAt:0])
			r.Moq.ResultsByParams_Exp[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Exp(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Exp_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Exp_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Exp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Exp_doFn
				DoReturnFn MoqInt_starGenType_Exp_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Exp(params MoqInt_starGenType_Exp_params) string {
	return fmt.Sprintf("Exp(%#v, %#v, %#v)", params.X, params.Y, params.Param3)
}

func (m *MoqInt_starGenType) ParamsKey_Exp(params MoqInt_starGenType_Exp_params, anyParams uint64) MoqInt_starGenType_Exp_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Exp.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Exp.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	var param3Used *big.Int
	var param3UsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.Exp.Param3 == moq.ParamIndexByValue {
			param3Used = params.Param3
		} else {
			param3UsedHash = hash.DeepHash(params.Param3)
		}
	}
	return MoqInt_starGenType_Exp_paramsKey{
		Params: struct{ X, Y, Param3 *big.Int }{
			X:      xUsed,
			Y:      yUsed,
			Param3: param3Used,
		},
		Hashes: struct{ X, Y, Param3 hash.Hash }{
			X:      xUsedHash,
			Y:      yUsedHash,
			Param3: param3UsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) GCD(x, y, a, b *big.Int) *MoqInt_starGenType_GCD_fnRecorder {
	return &MoqInt_starGenType_GCD_fnRecorder{
		Params: MoqInt_starGenType_GCD_params{
			X: x,
			Y: y,
			A: a,
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_GCD_fnRecorder) Any() *MoqInt_starGenType_GCD_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GCD(r.Params))
		return nil
	}
	return &MoqInt_starGenType_GCD_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_GCD_anyParams) X() *MoqInt_starGenType_GCD_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_GCD_anyParams) Y() *MoqInt_starGenType_GCD_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqInt_starGenType_GCD_anyParams) A() *MoqInt_starGenType_GCD_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (a *MoqInt_starGenType_GCD_anyParams) B() *MoqInt_starGenType_GCD_fnRecorder {
	a.Recorder.AnyParams |= 1 << 3
	return a.Recorder
}

func (r *MoqInt_starGenType_GCD_fnRecorder) Seq() *MoqInt_starGenType_GCD_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GCD(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_GCD_fnRecorder) NoSeq() *MoqInt_starGenType_GCD_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GCD(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_GCD_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_GCD_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_GCD_doFn
		DoReturnFn MoqInt_starGenType_GCD_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_GCD_fnRecorder) AndDo(fn MoqInt_starGenType_GCD_doFn) *MoqInt_starGenType_GCD_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_GCD_fnRecorder) DoReturnResults(fn MoqInt_starGenType_GCD_doReturnFn) *MoqInt_starGenType_GCD_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_GCD_doFn
		DoReturnFn MoqInt_starGenType_GCD_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_GCD_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_GCD_resultsByParams
	for n, res := range r.Moq.ResultsByParams_GCD {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_GCD_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_GCD_paramsKey]*MoqInt_starGenType_GCD_results{},
		}
		r.Moq.ResultsByParams_GCD = append(r.Moq.ResultsByParams_GCD, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_GCD) {
			copy(r.Moq.ResultsByParams_GCD[insertAt+1:], r.Moq.ResultsByParams_GCD[insertAt:0])
			r.Moq.ResultsByParams_GCD[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_GCD(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_GCD_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_GCD_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_GCD_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_GCD_doFn
				DoReturnFn MoqInt_starGenType_GCD_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_GCD(params MoqInt_starGenType_GCD_params) string {
	return fmt.Sprintf("GCD(%#v, %#v, %#v, %#v)", params.X, params.Y, params.A, params.B)
}

func (m *MoqInt_starGenType) ParamsKey_GCD(params MoqInt_starGenType_GCD_params, anyParams uint64) MoqInt_starGenType_GCD_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.GCD.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.GCD.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	var aUsed *big.Int
	var aUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.GCD.A == moq.ParamIndexByValue {
			aUsed = params.A
		} else {
			aUsedHash = hash.DeepHash(params.A)
		}
	}
	var bUsed *big.Int
	var bUsedHash hash.Hash
	if anyParams&(1<<3) == 0 {
		if m.Runtime.ParameterIndexing.GCD.B == moq.ParamIndexByValue {
			bUsed = params.B
		} else {
			bUsedHash = hash.DeepHash(params.B)
		}
	}
	return MoqInt_starGenType_GCD_paramsKey{
		Params: struct{ X, Y, A, B *big.Int }{
			X: xUsed,
			Y: yUsed,
			A: aUsed,
			B: bUsed,
		},
		Hashes: struct{ X, Y, A, B hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
			A: aUsedHash,
			B: bUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Rand(rnd *rand.Rand, n *big.Int) *MoqInt_starGenType_Rand_fnRecorder {
	return &MoqInt_starGenType_Rand_fnRecorder{
		Params: MoqInt_starGenType_Rand_params{
			Rnd: rnd,
			N:   n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Rand_fnRecorder) Any() *MoqInt_starGenType_Rand_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rand(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Rand_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Rand_anyParams) Rnd() *MoqInt_starGenType_Rand_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Rand_anyParams) N() *MoqInt_starGenType_Rand_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Rand_fnRecorder) Seq() *MoqInt_starGenType_Rand_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rand(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Rand_fnRecorder) NoSeq() *MoqInt_starGenType_Rand_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rand(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Rand_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Rand_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Rand_doFn
		DoReturnFn MoqInt_starGenType_Rand_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Rand_fnRecorder) AndDo(fn MoqInt_starGenType_Rand_doFn) *MoqInt_starGenType_Rand_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Rand_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Rand_doReturnFn) *MoqInt_starGenType_Rand_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Rand_doFn
		DoReturnFn MoqInt_starGenType_Rand_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Rand_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Rand_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Rand {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Rand_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Rand_paramsKey]*MoqInt_starGenType_Rand_results{},
		}
		r.Moq.ResultsByParams_Rand = append(r.Moq.ResultsByParams_Rand, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Rand) {
			copy(r.Moq.ResultsByParams_Rand[insertAt+1:], r.Moq.ResultsByParams_Rand[insertAt:0])
			r.Moq.ResultsByParams_Rand[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Rand(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Rand_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Rand_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Rand_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Rand_doFn
				DoReturnFn MoqInt_starGenType_Rand_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Rand(params MoqInt_starGenType_Rand_params) string {
	return fmt.Sprintf("Rand(%#v, %#v)", params.Rnd, params.N)
}

func (m *MoqInt_starGenType) ParamsKey_Rand(params MoqInt_starGenType_Rand_params, anyParams uint64) MoqInt_starGenType_Rand_paramsKey {
	m.Scene.T.Helper()
	var rndUsed *rand.Rand
	var rndUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Rand.Rnd == moq.ParamIndexByValue {
			rndUsed = params.Rnd
		} else {
			rndUsedHash = hash.DeepHash(params.Rnd)
		}
	}
	var nUsed *big.Int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Rand.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqInt_starGenType_Rand_paramsKey{
		Params: struct {
			Rnd *rand.Rand
			N   *big.Int
		}{
			Rnd: rndUsed,
			N:   nUsed,
		},
		Hashes: struct {
			Rnd hash.Hash
			N   hash.Hash
		}{
			Rnd: rndUsedHash,
			N:   nUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) ModInverse(g, n *big.Int) *MoqInt_starGenType_ModInverse_fnRecorder {
	return &MoqInt_starGenType_ModInverse_fnRecorder{
		Params: MoqInt_starGenType_ModInverse_params{
			G: g,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_ModInverse_fnRecorder) Any() *MoqInt_starGenType_ModInverse_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ModInverse(r.Params))
		return nil
	}
	return &MoqInt_starGenType_ModInverse_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_ModInverse_anyParams) G() *MoqInt_starGenType_ModInverse_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_ModInverse_anyParams) N() *MoqInt_starGenType_ModInverse_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_ModInverse_fnRecorder) Seq() *MoqInt_starGenType_ModInverse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ModInverse(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_ModInverse_fnRecorder) NoSeq() *MoqInt_starGenType_ModInverse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ModInverse(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_ModInverse_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_ModInverse_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_ModInverse_doFn
		DoReturnFn MoqInt_starGenType_ModInverse_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_ModInverse_fnRecorder) AndDo(fn MoqInt_starGenType_ModInverse_doFn) *MoqInt_starGenType_ModInverse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_ModInverse_fnRecorder) DoReturnResults(fn MoqInt_starGenType_ModInverse_doReturnFn) *MoqInt_starGenType_ModInverse_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_ModInverse_doFn
		DoReturnFn MoqInt_starGenType_ModInverse_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_ModInverse_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_ModInverse_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ModInverse {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_ModInverse_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_ModInverse_paramsKey]*MoqInt_starGenType_ModInverse_results{},
		}
		r.Moq.ResultsByParams_ModInverse = append(r.Moq.ResultsByParams_ModInverse, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ModInverse) {
			copy(r.Moq.ResultsByParams_ModInverse[insertAt+1:], r.Moq.ResultsByParams_ModInverse[insertAt:0])
			r.Moq.ResultsByParams_ModInverse[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ModInverse(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_ModInverse_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_ModInverse_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_ModInverse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_ModInverse_doFn
				DoReturnFn MoqInt_starGenType_ModInverse_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_ModInverse(params MoqInt_starGenType_ModInverse_params) string {
	return fmt.Sprintf("ModInverse(%#v, %#v)", params.G, params.N)
}

func (m *MoqInt_starGenType) ParamsKey_ModInverse(params MoqInt_starGenType_ModInverse_params, anyParams uint64) MoqInt_starGenType_ModInverse_paramsKey {
	m.Scene.T.Helper()
	var gUsed *big.Int
	var gUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ModInverse.G == moq.ParamIndexByValue {
			gUsed = params.G
		} else {
			gUsedHash = hash.DeepHash(params.G)
		}
	}
	var nUsed *big.Int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ModInverse.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqInt_starGenType_ModInverse_paramsKey{
		Params: struct{ G, N *big.Int }{
			G: gUsed,
			N: nUsed,
		},
		Hashes: struct{ G, N hash.Hash }{
			G: gUsedHash,
			N: nUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) ModSqrt(x, p *big.Int) *MoqInt_starGenType_ModSqrt_fnRecorder {
	return &MoqInt_starGenType_ModSqrt_fnRecorder{
		Params: MoqInt_starGenType_ModSqrt_params{
			X: x,
			P: p,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_ModSqrt_fnRecorder) Any() *MoqInt_starGenType_ModSqrt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ModSqrt(r.Params))
		return nil
	}
	return &MoqInt_starGenType_ModSqrt_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_ModSqrt_anyParams) X() *MoqInt_starGenType_ModSqrt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_ModSqrt_anyParams) P() *MoqInt_starGenType_ModSqrt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_ModSqrt_fnRecorder) Seq() *MoqInt_starGenType_ModSqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ModSqrt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_ModSqrt_fnRecorder) NoSeq() *MoqInt_starGenType_ModSqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ModSqrt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_ModSqrt_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_ModSqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_ModSqrt_doFn
		DoReturnFn MoqInt_starGenType_ModSqrt_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_ModSqrt_fnRecorder) AndDo(fn MoqInt_starGenType_ModSqrt_doFn) *MoqInt_starGenType_ModSqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_ModSqrt_fnRecorder) DoReturnResults(fn MoqInt_starGenType_ModSqrt_doReturnFn) *MoqInt_starGenType_ModSqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_ModSqrt_doFn
		DoReturnFn MoqInt_starGenType_ModSqrt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_ModSqrt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_ModSqrt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ModSqrt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_ModSqrt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_ModSqrt_paramsKey]*MoqInt_starGenType_ModSqrt_results{},
		}
		r.Moq.ResultsByParams_ModSqrt = append(r.Moq.ResultsByParams_ModSqrt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ModSqrt) {
			copy(r.Moq.ResultsByParams_ModSqrt[insertAt+1:], r.Moq.ResultsByParams_ModSqrt[insertAt:0])
			r.Moq.ResultsByParams_ModSqrt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ModSqrt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_ModSqrt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_ModSqrt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_ModSqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_ModSqrt_doFn
				DoReturnFn MoqInt_starGenType_ModSqrt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_ModSqrt(params MoqInt_starGenType_ModSqrt_params) string {
	return fmt.Sprintf("ModSqrt(%#v, %#v)", params.X, params.P)
}

func (m *MoqInt_starGenType) ParamsKey_ModSqrt(params MoqInt_starGenType_ModSqrt_params, anyParams uint64) MoqInt_starGenType_ModSqrt_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ModSqrt.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var pUsed *big.Int
	var pUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ModSqrt.P == moq.ParamIndexByValue {
			pUsed = params.P
		} else {
			pUsedHash = hash.DeepHash(params.P)
		}
	}
	return MoqInt_starGenType_ModSqrt_paramsKey{
		Params: struct{ X, P *big.Int }{
			X: xUsed,
			P: pUsed,
		},
		Hashes: struct{ X, P hash.Hash }{
			X: xUsedHash,
			P: pUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Lsh(x *big.Int, n uint) *MoqInt_starGenType_Lsh_fnRecorder {
	return &MoqInt_starGenType_Lsh_fnRecorder{
		Params: MoqInt_starGenType_Lsh_params{
			X: x,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Lsh_fnRecorder) Any() *MoqInt_starGenType_Lsh_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Lsh(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Lsh_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Lsh_anyParams) X() *MoqInt_starGenType_Lsh_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Lsh_anyParams) N() *MoqInt_starGenType_Lsh_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Lsh_fnRecorder) Seq() *MoqInt_starGenType_Lsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Lsh(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Lsh_fnRecorder) NoSeq() *MoqInt_starGenType_Lsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Lsh(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Lsh_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Lsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Lsh_doFn
		DoReturnFn MoqInt_starGenType_Lsh_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Lsh_fnRecorder) AndDo(fn MoqInt_starGenType_Lsh_doFn) *MoqInt_starGenType_Lsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Lsh_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Lsh_doReturnFn) *MoqInt_starGenType_Lsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Lsh_doFn
		DoReturnFn MoqInt_starGenType_Lsh_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Lsh_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Lsh_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Lsh {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Lsh_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Lsh_paramsKey]*MoqInt_starGenType_Lsh_results{},
		}
		r.Moq.ResultsByParams_Lsh = append(r.Moq.ResultsByParams_Lsh, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Lsh) {
			copy(r.Moq.ResultsByParams_Lsh[insertAt+1:], r.Moq.ResultsByParams_Lsh[insertAt:0])
			r.Moq.ResultsByParams_Lsh[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Lsh(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Lsh_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Lsh_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Lsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Lsh_doFn
				DoReturnFn MoqInt_starGenType_Lsh_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Lsh(params MoqInt_starGenType_Lsh_params) string {
	return fmt.Sprintf("Lsh(%#v, %#v)", params.X, params.N)
}

func (m *MoqInt_starGenType) ParamsKey_Lsh(params MoqInt_starGenType_Lsh_params, anyParams uint64) MoqInt_starGenType_Lsh_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Lsh.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var nUsed uint
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Lsh.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqInt_starGenType_Lsh_paramsKey{
		Params: struct {
			X *big.Int
			N uint
		}{
			X: xUsed,
			N: nUsed,
		},
		Hashes: struct {
			X hash.Hash
			N hash.Hash
		}{
			X: xUsedHash,
			N: nUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Rsh(x *big.Int, n uint) *MoqInt_starGenType_Rsh_fnRecorder {
	return &MoqInt_starGenType_Rsh_fnRecorder{
		Params: MoqInt_starGenType_Rsh_params{
			X: x,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Rsh_fnRecorder) Any() *MoqInt_starGenType_Rsh_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rsh(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Rsh_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Rsh_anyParams) X() *MoqInt_starGenType_Rsh_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Rsh_anyParams) N() *MoqInt_starGenType_Rsh_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Rsh_fnRecorder) Seq() *MoqInt_starGenType_Rsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rsh(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Rsh_fnRecorder) NoSeq() *MoqInt_starGenType_Rsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rsh(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Rsh_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Rsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Rsh_doFn
		DoReturnFn MoqInt_starGenType_Rsh_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Rsh_fnRecorder) AndDo(fn MoqInt_starGenType_Rsh_doFn) *MoqInt_starGenType_Rsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Rsh_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Rsh_doReturnFn) *MoqInt_starGenType_Rsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Rsh_doFn
		DoReturnFn MoqInt_starGenType_Rsh_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Rsh_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Rsh_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Rsh {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Rsh_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Rsh_paramsKey]*MoqInt_starGenType_Rsh_results{},
		}
		r.Moq.ResultsByParams_Rsh = append(r.Moq.ResultsByParams_Rsh, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Rsh) {
			copy(r.Moq.ResultsByParams_Rsh[insertAt+1:], r.Moq.ResultsByParams_Rsh[insertAt:0])
			r.Moq.ResultsByParams_Rsh[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Rsh(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Rsh_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Rsh_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Rsh_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Rsh_doFn
				DoReturnFn MoqInt_starGenType_Rsh_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Rsh(params MoqInt_starGenType_Rsh_params) string {
	return fmt.Sprintf("Rsh(%#v, %#v)", params.X, params.N)
}

func (m *MoqInt_starGenType) ParamsKey_Rsh(params MoqInt_starGenType_Rsh_params, anyParams uint64) MoqInt_starGenType_Rsh_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Rsh.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var nUsed uint
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Rsh.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqInt_starGenType_Rsh_paramsKey{
		Params: struct {
			X *big.Int
			N uint
		}{
			X: xUsed,
			N: nUsed,
		},
		Hashes: struct {
			X hash.Hash
			N hash.Hash
		}{
			X: xUsedHash,
			N: nUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Bit(param1 int) *MoqInt_starGenType_Bit_fnRecorder {
	return &MoqInt_starGenType_Bit_fnRecorder{
		Params: MoqInt_starGenType_Bit_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Bit_fnRecorder) Any() *MoqInt_starGenType_Bit_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bit(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Bit_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Bit_anyParams) Param1() *MoqInt_starGenType_Bit_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_Bit_fnRecorder) Seq() *MoqInt_starGenType_Bit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bit(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Bit_fnRecorder) NoSeq() *MoqInt_starGenType_Bit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bit(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Bit_fnRecorder) ReturnResults(result1 uint) *MoqInt_starGenType_Bit_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Bit_doFn
		DoReturnFn MoqInt_starGenType_Bit_doReturnFn
	}{
		Values: &struct {
			Result1 uint
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Bit_fnRecorder) AndDo(fn MoqInt_starGenType_Bit_doFn) *MoqInt_starGenType_Bit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Bit_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Bit_doReturnFn) *MoqInt_starGenType_Bit_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Bit_doFn
		DoReturnFn MoqInt_starGenType_Bit_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Bit_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Bit_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Bit {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Bit_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Bit_paramsKey]*MoqInt_starGenType_Bit_results{},
		}
		r.Moq.ResultsByParams_Bit = append(r.Moq.ResultsByParams_Bit, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Bit) {
			copy(r.Moq.ResultsByParams_Bit[insertAt+1:], r.Moq.ResultsByParams_Bit[insertAt:0])
			r.Moq.ResultsByParams_Bit[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Bit(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Bit_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Bit_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Bit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 uint
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Bit_doFn
				DoReturnFn MoqInt_starGenType_Bit_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Bit(params MoqInt_starGenType_Bit_params) string {
	return fmt.Sprintf("Bit(%#v)", params.Param1)
}

func (m *MoqInt_starGenType) ParamsKey_Bit(params MoqInt_starGenType_Bit_params, anyParams uint64) MoqInt_starGenType_Bit_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Bit.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqInt_starGenType_Bit_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) SetBit(x *big.Int, param2 int, b uint) *MoqInt_starGenType_SetBit_fnRecorder {
	return &MoqInt_starGenType_SetBit_fnRecorder{
		Params: MoqInt_starGenType_SetBit_params{
			X:      x,
			Param2: param2,
			B:      b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_SetBit_fnRecorder) Any() *MoqInt_starGenType_SetBit_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBit(r.Params))
		return nil
	}
	return &MoqInt_starGenType_SetBit_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_SetBit_anyParams) X() *MoqInt_starGenType_SetBit_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_SetBit_anyParams) Param2() *MoqInt_starGenType_SetBit_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqInt_starGenType_SetBit_anyParams) B() *MoqInt_starGenType_SetBit_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqInt_starGenType_SetBit_fnRecorder) Seq() *MoqInt_starGenType_SetBit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBit(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_SetBit_fnRecorder) NoSeq() *MoqInt_starGenType_SetBit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBit(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_SetBit_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_SetBit_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetBit_doFn
		DoReturnFn MoqInt_starGenType_SetBit_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_SetBit_fnRecorder) AndDo(fn MoqInt_starGenType_SetBit_doFn) *MoqInt_starGenType_SetBit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_SetBit_fnRecorder) DoReturnResults(fn MoqInt_starGenType_SetBit_doReturnFn) *MoqInt_starGenType_SetBit_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_SetBit_doFn
		DoReturnFn MoqInt_starGenType_SetBit_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_SetBit_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_SetBit_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetBit {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_SetBit_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_SetBit_paramsKey]*MoqInt_starGenType_SetBit_results{},
		}
		r.Moq.ResultsByParams_SetBit = append(r.Moq.ResultsByParams_SetBit, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetBit) {
			copy(r.Moq.ResultsByParams_SetBit[insertAt+1:], r.Moq.ResultsByParams_SetBit[insertAt:0])
			r.Moq.ResultsByParams_SetBit[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetBit(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_SetBit_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_SetBit_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_SetBit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_SetBit_doFn
				DoReturnFn MoqInt_starGenType_SetBit_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_SetBit(params MoqInt_starGenType_SetBit_params) string {
	return fmt.Sprintf("SetBit(%#v, %#v, %#v)", params.X, params.Param2, params.B)
}

func (m *MoqInt_starGenType) ParamsKey_SetBit(params MoqInt_starGenType_SetBit_params, anyParams uint64) MoqInt_starGenType_SetBit_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetBit.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var param2Used int
	var param2UsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.SetBit.Param2 == moq.ParamIndexByValue {
			param2Used = params.Param2
		} else {
			param2UsedHash = hash.DeepHash(params.Param2)
		}
	}
	var bUsed uint
	var bUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.SetBit.B == moq.ParamIndexByValue {
			bUsed = params.B
		} else {
			bUsedHash = hash.DeepHash(params.B)
		}
	}
	return MoqInt_starGenType_SetBit_paramsKey{
		Params: struct {
			X      *big.Int
			Param2 int
			B      uint
		}{
			X:      xUsed,
			Param2: param2Used,
			B:      bUsed,
		},
		Hashes: struct {
			X      hash.Hash
			Param2 hash.Hash
			B      hash.Hash
		}{
			X:      xUsedHash,
			Param2: param2UsedHash,
			B:      bUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) And(x, y *big.Int) *MoqInt_starGenType_And_fnRecorder {
	return &MoqInt_starGenType_And_fnRecorder{
		Params: MoqInt_starGenType_And_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_And_fnRecorder) Any() *MoqInt_starGenType_And_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_And(r.Params))
		return nil
	}
	return &MoqInt_starGenType_And_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_And_anyParams) X() *MoqInt_starGenType_And_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_And_anyParams) Y() *MoqInt_starGenType_And_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_And_fnRecorder) Seq() *MoqInt_starGenType_And_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_And(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_And_fnRecorder) NoSeq() *MoqInt_starGenType_And_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_And(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_And_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_And_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_And_doFn
		DoReturnFn MoqInt_starGenType_And_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_And_fnRecorder) AndDo(fn MoqInt_starGenType_And_doFn) *MoqInt_starGenType_And_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_And_fnRecorder) DoReturnResults(fn MoqInt_starGenType_And_doReturnFn) *MoqInt_starGenType_And_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_And_doFn
		DoReturnFn MoqInt_starGenType_And_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_And_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_And_resultsByParams
	for n, res := range r.Moq.ResultsByParams_And {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_And_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_And_paramsKey]*MoqInt_starGenType_And_results{},
		}
		r.Moq.ResultsByParams_And = append(r.Moq.ResultsByParams_And, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_And) {
			copy(r.Moq.ResultsByParams_And[insertAt+1:], r.Moq.ResultsByParams_And[insertAt:0])
			r.Moq.ResultsByParams_And[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_And(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_And_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_And_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_And_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_And_doFn
				DoReturnFn MoqInt_starGenType_And_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_And(params MoqInt_starGenType_And_params) string {
	return fmt.Sprintf("And(%#v, %#v)", params.X, params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_And(params MoqInt_starGenType_And_params, anyParams uint64) MoqInt_starGenType_And_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.And.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.And.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_And_paramsKey{
		Params: struct{ X, Y *big.Int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) AndNot(x, y *big.Int) *MoqInt_starGenType_AndNot_fnRecorder {
	return &MoqInt_starGenType_AndNot_fnRecorder{
		Params: MoqInt_starGenType_AndNot_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_AndNot_fnRecorder) Any() *MoqInt_starGenType_AndNot_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AndNot(r.Params))
		return nil
	}
	return &MoqInt_starGenType_AndNot_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_AndNot_anyParams) X() *MoqInt_starGenType_AndNot_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_AndNot_anyParams) Y() *MoqInt_starGenType_AndNot_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_AndNot_fnRecorder) Seq() *MoqInt_starGenType_AndNot_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AndNot(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_AndNot_fnRecorder) NoSeq() *MoqInt_starGenType_AndNot_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AndNot(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_AndNot_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_AndNot_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_AndNot_doFn
		DoReturnFn MoqInt_starGenType_AndNot_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_AndNot_fnRecorder) AndDo(fn MoqInt_starGenType_AndNot_doFn) *MoqInt_starGenType_AndNot_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_AndNot_fnRecorder) DoReturnResults(fn MoqInt_starGenType_AndNot_doReturnFn) *MoqInt_starGenType_AndNot_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_AndNot_doFn
		DoReturnFn MoqInt_starGenType_AndNot_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_AndNot_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_AndNot_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AndNot {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_AndNot_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_AndNot_paramsKey]*MoqInt_starGenType_AndNot_results{},
		}
		r.Moq.ResultsByParams_AndNot = append(r.Moq.ResultsByParams_AndNot, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AndNot) {
			copy(r.Moq.ResultsByParams_AndNot[insertAt+1:], r.Moq.ResultsByParams_AndNot[insertAt:0])
			r.Moq.ResultsByParams_AndNot[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AndNot(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_AndNot_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_AndNot_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_AndNot_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_AndNot_doFn
				DoReturnFn MoqInt_starGenType_AndNot_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_AndNot(params MoqInt_starGenType_AndNot_params) string {
	return fmt.Sprintf("AndNot(%#v, %#v)", params.X, params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_AndNot(params MoqInt_starGenType_AndNot_params, anyParams uint64) MoqInt_starGenType_AndNot_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.AndNot.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.AndNot.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_AndNot_paramsKey{
		Params: struct{ X, Y *big.Int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Or(x, y *big.Int) *MoqInt_starGenType_Or_fnRecorder {
	return &MoqInt_starGenType_Or_fnRecorder{
		Params: MoqInt_starGenType_Or_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Or_fnRecorder) Any() *MoqInt_starGenType_Or_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Or(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Or_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Or_anyParams) X() *MoqInt_starGenType_Or_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Or_anyParams) Y() *MoqInt_starGenType_Or_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Or_fnRecorder) Seq() *MoqInt_starGenType_Or_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Or(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Or_fnRecorder) NoSeq() *MoqInt_starGenType_Or_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Or(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Or_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Or_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Or_doFn
		DoReturnFn MoqInt_starGenType_Or_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Or_fnRecorder) AndDo(fn MoqInt_starGenType_Or_doFn) *MoqInt_starGenType_Or_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Or_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Or_doReturnFn) *MoqInt_starGenType_Or_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Or_doFn
		DoReturnFn MoqInt_starGenType_Or_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Or_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Or_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Or {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Or_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Or_paramsKey]*MoqInt_starGenType_Or_results{},
		}
		r.Moq.ResultsByParams_Or = append(r.Moq.ResultsByParams_Or, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Or) {
			copy(r.Moq.ResultsByParams_Or[insertAt+1:], r.Moq.ResultsByParams_Or[insertAt:0])
			r.Moq.ResultsByParams_Or[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Or(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Or_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Or_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Or_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Or_doFn
				DoReturnFn MoqInt_starGenType_Or_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Or(params MoqInt_starGenType_Or_params) string {
	return fmt.Sprintf("Or(%#v, %#v)", params.X, params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_Or(params MoqInt_starGenType_Or_params, anyParams uint64) MoqInt_starGenType_Or_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Or.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Or.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_Or_paramsKey{
		Params: struct{ X, Y *big.Int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Xor(x, y *big.Int) *MoqInt_starGenType_Xor_fnRecorder {
	return &MoqInt_starGenType_Xor_fnRecorder{
		Params: MoqInt_starGenType_Xor_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Xor_fnRecorder) Any() *MoqInt_starGenType_Xor_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Xor(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Xor_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Xor_anyParams) X() *MoqInt_starGenType_Xor_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Xor_anyParams) Y() *MoqInt_starGenType_Xor_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Xor_fnRecorder) Seq() *MoqInt_starGenType_Xor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Xor(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Xor_fnRecorder) NoSeq() *MoqInt_starGenType_Xor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Xor(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Xor_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Xor_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Xor_doFn
		DoReturnFn MoqInt_starGenType_Xor_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Xor_fnRecorder) AndDo(fn MoqInt_starGenType_Xor_doFn) *MoqInt_starGenType_Xor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Xor_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Xor_doReturnFn) *MoqInt_starGenType_Xor_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Xor_doFn
		DoReturnFn MoqInt_starGenType_Xor_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Xor_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Xor_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Xor {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Xor_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Xor_paramsKey]*MoqInt_starGenType_Xor_results{},
		}
		r.Moq.ResultsByParams_Xor = append(r.Moq.ResultsByParams_Xor, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Xor) {
			copy(r.Moq.ResultsByParams_Xor[insertAt+1:], r.Moq.ResultsByParams_Xor[insertAt:0])
			r.Moq.ResultsByParams_Xor[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Xor(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Xor_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Xor_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Xor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Xor_doFn
				DoReturnFn MoqInt_starGenType_Xor_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Xor(params MoqInt_starGenType_Xor_params) string {
	return fmt.Sprintf("Xor(%#v, %#v)", params.X, params.Y)
}

func (m *MoqInt_starGenType) ParamsKey_Xor(params MoqInt_starGenType_Xor_params, anyParams uint64) MoqInt_starGenType_Xor_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Xor.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Xor.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqInt_starGenType_Xor_paramsKey{
		Params: struct{ X, Y *big.Int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Not(x *big.Int) *MoqInt_starGenType_Not_fnRecorder {
	return &MoqInt_starGenType_Not_fnRecorder{
		Params: MoqInt_starGenType_Not_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Not_fnRecorder) Any() *MoqInt_starGenType_Not_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Not(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Not_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Not_anyParams) X() *MoqInt_starGenType_Not_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_Not_fnRecorder) Seq() *MoqInt_starGenType_Not_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Not(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Not_fnRecorder) NoSeq() *MoqInt_starGenType_Not_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Not(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Not_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Not_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Not_doFn
		DoReturnFn MoqInt_starGenType_Not_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Not_fnRecorder) AndDo(fn MoqInt_starGenType_Not_doFn) *MoqInt_starGenType_Not_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Not_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Not_doReturnFn) *MoqInt_starGenType_Not_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Not_doFn
		DoReturnFn MoqInt_starGenType_Not_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Not_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Not_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Not {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Not_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Not_paramsKey]*MoqInt_starGenType_Not_results{},
		}
		r.Moq.ResultsByParams_Not = append(r.Moq.ResultsByParams_Not, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Not) {
			copy(r.Moq.ResultsByParams_Not[insertAt+1:], r.Moq.ResultsByParams_Not[insertAt:0])
			r.Moq.ResultsByParams_Not[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Not(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Not_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Not_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Not_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Not_doFn
				DoReturnFn MoqInt_starGenType_Not_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Not(params MoqInt_starGenType_Not_params) string {
	return fmt.Sprintf("Not(%#v)", params.X)
}

func (m *MoqInt_starGenType) ParamsKey_Not(params MoqInt_starGenType_Not_params, anyParams uint64) MoqInt_starGenType_Not_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Not.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqInt_starGenType_Not_paramsKey{
		Params: struct{ X *big.Int }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Sqrt(x *big.Int) *MoqInt_starGenType_Sqrt_fnRecorder {
	return &MoqInt_starGenType_Sqrt_fnRecorder{
		Params: MoqInt_starGenType_Sqrt_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Sqrt_fnRecorder) Any() *MoqInt_starGenType_Sqrt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sqrt(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Sqrt_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Sqrt_anyParams) X() *MoqInt_starGenType_Sqrt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_Sqrt_fnRecorder) Seq() *MoqInt_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sqrt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Sqrt_fnRecorder) NoSeq() *MoqInt_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sqrt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Sqrt_fnRecorder) ReturnResults(result1 *big.Int) *MoqInt_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Sqrt_doFn
		DoReturnFn MoqInt_starGenType_Sqrt_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Sqrt_fnRecorder) AndDo(fn MoqInt_starGenType_Sqrt_doFn) *MoqInt_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Sqrt_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Sqrt_doReturnFn) *MoqInt_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Sqrt_doFn
		DoReturnFn MoqInt_starGenType_Sqrt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Sqrt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Sqrt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Sqrt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Sqrt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Sqrt_paramsKey]*MoqInt_starGenType_Sqrt_results{},
		}
		r.Moq.ResultsByParams_Sqrt = append(r.Moq.ResultsByParams_Sqrt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Sqrt) {
			copy(r.Moq.ResultsByParams_Sqrt[insertAt+1:], r.Moq.ResultsByParams_Sqrt[insertAt:0])
			r.Moq.ResultsByParams_Sqrt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Sqrt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Sqrt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Sqrt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Sqrt_doFn
				DoReturnFn MoqInt_starGenType_Sqrt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Sqrt(params MoqInt_starGenType_Sqrt_params) string {
	return fmt.Sprintf("Sqrt(%#v)", params.X)
}

func (m *MoqInt_starGenType) ParamsKey_Sqrt(params MoqInt_starGenType_Sqrt_params, anyParams uint64) MoqInt_starGenType_Sqrt_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Sqrt.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqInt_starGenType_Sqrt_paramsKey{
		Params: struct{ X *big.Int }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Text(base int) *MoqInt_starGenType_Text_fnRecorder {
	return &MoqInt_starGenType_Text_fnRecorder{
		Params: MoqInt_starGenType_Text_params{
			Base: base,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Text_fnRecorder) Any() *MoqInt_starGenType_Text_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Text(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Text_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Text_anyParams) Base() *MoqInt_starGenType_Text_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_Text_fnRecorder) Seq() *MoqInt_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Text(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Text_fnRecorder) NoSeq() *MoqInt_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Text(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Text_fnRecorder) ReturnResults(result1 string) *MoqInt_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Text_doFn
		DoReturnFn MoqInt_starGenType_Text_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Text_fnRecorder) AndDo(fn MoqInt_starGenType_Text_doFn) *MoqInt_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Text_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Text_doReturnFn) *MoqInt_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Text_doFn
		DoReturnFn MoqInt_starGenType_Text_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Text_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Text_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Text {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Text_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Text_paramsKey]*MoqInt_starGenType_Text_results{},
		}
		r.Moq.ResultsByParams_Text = append(r.Moq.ResultsByParams_Text, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Text) {
			copy(r.Moq.ResultsByParams_Text[insertAt+1:], r.Moq.ResultsByParams_Text[insertAt:0])
			r.Moq.ResultsByParams_Text[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Text(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Text_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Text_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Text_doFn
				DoReturnFn MoqInt_starGenType_Text_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Text(params MoqInt_starGenType_Text_params) string {
	return fmt.Sprintf("Text(%#v)", params.Base)
}

func (m *MoqInt_starGenType) ParamsKey_Text(params MoqInt_starGenType_Text_params, anyParams uint64) MoqInt_starGenType_Text_paramsKey {
	m.Scene.T.Helper()
	var baseUsed int
	var baseUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Text.Base == moq.ParamIndexByValue {
			baseUsed = params.Base
		} else {
			baseUsedHash = hash.DeepHash(params.Base)
		}
	}
	return MoqInt_starGenType_Text_paramsKey{
		Params: struct{ Base int }{
			Base: baseUsed,
		},
		Hashes: struct{ Base hash.Hash }{
			Base: baseUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Append(buf []byte, base int) *MoqInt_starGenType_Append_fnRecorder {
	return &MoqInt_starGenType_Append_fnRecorder{
		Params: MoqInt_starGenType_Append_params{
			Buf:  buf,
			Base: base,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Append_fnRecorder) Any() *MoqInt_starGenType_Append_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Append(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Append_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Append_anyParams) Buf() *MoqInt_starGenType_Append_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Append_anyParams) Base() *MoqInt_starGenType_Append_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Append_fnRecorder) Seq() *MoqInt_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Append(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Append_fnRecorder) NoSeq() *MoqInt_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Append(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Append_fnRecorder) ReturnResults(result1 []byte) *MoqInt_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Append_doFn
		DoReturnFn MoqInt_starGenType_Append_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Append_fnRecorder) AndDo(fn MoqInt_starGenType_Append_doFn) *MoqInt_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Append_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Append_doReturnFn) *MoqInt_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Append_doFn
		DoReturnFn MoqInt_starGenType_Append_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Append_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Append_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Append {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Append_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Append_paramsKey]*MoqInt_starGenType_Append_results{},
		}
		r.Moq.ResultsByParams_Append = append(r.Moq.ResultsByParams_Append, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Append) {
			copy(r.Moq.ResultsByParams_Append[insertAt+1:], r.Moq.ResultsByParams_Append[insertAt:0])
			r.Moq.ResultsByParams_Append[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Append(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Append_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Append_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Append_doFn
				DoReturnFn MoqInt_starGenType_Append_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Append(params MoqInt_starGenType_Append_params) string {
	return fmt.Sprintf("Append(%#v, %#v)", params.Buf, params.Base)
}

func (m *MoqInt_starGenType) ParamsKey_Append(params MoqInt_starGenType_Append_params, anyParams uint64) MoqInt_starGenType_Append_paramsKey {
	m.Scene.T.Helper()
	var bufUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Append.Buf == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The buf parameter of the Append function can't be indexed by value")
		}
		bufUsedHash = hash.DeepHash(params.Buf)
	}
	var baseUsed int
	var baseUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Append.Base == moq.ParamIndexByValue {
			baseUsed = params.Base
		} else {
			baseUsedHash = hash.DeepHash(params.Base)
		}
	}
	return MoqInt_starGenType_Append_paramsKey{
		Params: struct{ Base int }{
			Base: baseUsed,
		},
		Hashes: struct {
			Buf  hash.Hash
			Base hash.Hash
		}{
			Buf:  bufUsedHash,
			Base: baseUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) String() *MoqInt_starGenType_String_fnRecorder {
	return &MoqInt_starGenType_String_fnRecorder{
		Params:   MoqInt_starGenType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_String_fnRecorder) Any() *MoqInt_starGenType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqInt_starGenType_String_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_String_fnRecorder) Seq() *MoqInt_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_String_fnRecorder) NoSeq() *MoqInt_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_String_fnRecorder) ReturnResults(result1 string) *MoqInt_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_String_doFn
		DoReturnFn MoqInt_starGenType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_String_fnRecorder) AndDo(fn MoqInt_starGenType_String_doFn) *MoqInt_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_String_fnRecorder) DoReturnResults(fn MoqInt_starGenType_String_doReturnFn) *MoqInt_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_String_doFn
		DoReturnFn MoqInt_starGenType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_String_paramsKey]*MoqInt_starGenType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_String_doFn
				DoReturnFn MoqInt_starGenType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_String(params MoqInt_starGenType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqInt_starGenType) ParamsKey_String(params MoqInt_starGenType_String_params, anyParams uint64) MoqInt_starGenType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) Format(s fmt.State, ch rune) *MoqInt_starGenType_Format_fnRecorder {
	return &MoqInt_starGenType_Format_fnRecorder{
		Params: MoqInt_starGenType_Format_params{
			S:  s,
			Ch: ch,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Format_fnRecorder) Any() *MoqInt_starGenType_Format_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Format(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Format_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Format_anyParams) S() *MoqInt_starGenType_Format_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Format_anyParams) Ch() *MoqInt_starGenType_Format_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Format_fnRecorder) Seq() *MoqInt_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Format(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Format_fnRecorder) NoSeq() *MoqInt_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Format(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Format_fnRecorder) ReturnResults() *MoqInt_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Format_doFn
		DoReturnFn MoqInt_starGenType_Format_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Format_fnRecorder) AndDo(fn MoqInt_starGenType_Format_doFn) *MoqInt_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Format_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Format_doReturnFn) *MoqInt_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Format_doFn
		DoReturnFn MoqInt_starGenType_Format_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Format_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Format_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Format {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Format_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Format_paramsKey]*MoqInt_starGenType_Format_results{},
		}
		r.Moq.ResultsByParams_Format = append(r.Moq.ResultsByParams_Format, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Format) {
			copy(r.Moq.ResultsByParams_Format[insertAt+1:], r.Moq.ResultsByParams_Format[insertAt:0])
			r.Moq.ResultsByParams_Format[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Format(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Format_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Format_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Format_doFn
				DoReturnFn MoqInt_starGenType_Format_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Format(params MoqInt_starGenType_Format_params) string {
	return fmt.Sprintf("Format(%#v, %#v)", params.S, params.Ch)
}

func (m *MoqInt_starGenType) ParamsKey_Format(params MoqInt_starGenType_Format_params, anyParams uint64) MoqInt_starGenType_Format_paramsKey {
	m.Scene.T.Helper()
	var sUsed fmt.State
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Format.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var chUsed rune
	var chUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Format.Ch == moq.ParamIndexByValue {
			chUsed = params.Ch
		} else {
			chUsedHash = hash.DeepHash(params.Ch)
		}
	}
	return MoqInt_starGenType_Format_paramsKey{
		Params: struct {
			S  fmt.State
			Ch rune
		}{
			S:  sUsed,
			Ch: chUsed,
		},
		Hashes: struct {
			S  hash.Hash
			Ch hash.Hash
		}{
			S:  sUsedHash,
			Ch: chUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) Scan(s fmt.ScanState, ch rune) *MoqInt_starGenType_Scan_fnRecorder {
	return &MoqInt_starGenType_Scan_fnRecorder{
		Params: MoqInt_starGenType_Scan_params{
			S:  s,
			Ch: ch,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_Scan_fnRecorder) Any() *MoqInt_starGenType_Scan_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Scan(r.Params))
		return nil
	}
	return &MoqInt_starGenType_Scan_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_Scan_anyParams) S() *MoqInt_starGenType_Scan_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqInt_starGenType_Scan_anyParams) Ch() *MoqInt_starGenType_Scan_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqInt_starGenType_Scan_fnRecorder) Seq() *MoqInt_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Scan(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_Scan_fnRecorder) NoSeq() *MoqInt_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Scan(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_Scan_fnRecorder) ReturnResults(result1 error) *MoqInt_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Scan_doFn
		DoReturnFn MoqInt_starGenType_Scan_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_Scan_fnRecorder) AndDo(fn MoqInt_starGenType_Scan_doFn) *MoqInt_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_Scan_fnRecorder) DoReturnResults(fn MoqInt_starGenType_Scan_doReturnFn) *MoqInt_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_Scan_doFn
		DoReturnFn MoqInt_starGenType_Scan_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_Scan_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_Scan_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Scan {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_Scan_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_Scan_paramsKey]*MoqInt_starGenType_Scan_results{},
		}
		r.Moq.ResultsByParams_Scan = append(r.Moq.ResultsByParams_Scan, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Scan) {
			copy(r.Moq.ResultsByParams_Scan[insertAt+1:], r.Moq.ResultsByParams_Scan[insertAt:0])
			r.Moq.ResultsByParams_Scan[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Scan(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_Scan_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_Scan_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_Scan_doFn
				DoReturnFn MoqInt_starGenType_Scan_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_Scan(params MoqInt_starGenType_Scan_params) string {
	return fmt.Sprintf("Scan(%#v, %#v)", params.S, params.Ch)
}

func (m *MoqInt_starGenType) ParamsKey_Scan(params MoqInt_starGenType_Scan_params, anyParams uint64) MoqInt_starGenType_Scan_paramsKey {
	m.Scene.T.Helper()
	var sUsed fmt.ScanState
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Scan.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var chUsed rune
	var chUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Scan.Ch == moq.ParamIndexByValue {
			chUsed = params.Ch
		} else {
			chUsedHash = hash.DeepHash(params.Ch)
		}
	}
	return MoqInt_starGenType_Scan_paramsKey{
		Params: struct {
			S  fmt.ScanState
			Ch rune
		}{
			S:  sUsed,
			Ch: chUsed,
		},
		Hashes: struct {
			S  hash.Hash
			Ch hash.Hash
		}{
			S:  sUsedHash,
			Ch: chUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) GobEncode() *MoqInt_starGenType_GobEncode_fnRecorder {
	return &MoqInt_starGenType_GobEncode_fnRecorder{
		Params:   MoqInt_starGenType_GobEncode_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_GobEncode_fnRecorder) Any() *MoqInt_starGenType_GobEncode_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	return &MoqInt_starGenType_GobEncode_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_GobEncode_fnRecorder) Seq() *MoqInt_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_GobEncode_fnRecorder) NoSeq() *MoqInt_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_GobEncode_fnRecorder) ReturnResults(result1 []byte, result2 error) *MoqInt_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_GobEncode_doFn
		DoReturnFn MoqInt_starGenType_GobEncode_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_GobEncode_fnRecorder) AndDo(fn MoqInt_starGenType_GobEncode_doFn) *MoqInt_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_GobEncode_fnRecorder) DoReturnResults(fn MoqInt_starGenType_GobEncode_doReturnFn) *MoqInt_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_GobEncode_doFn
		DoReturnFn MoqInt_starGenType_GobEncode_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_GobEncode_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_GobEncode_resultsByParams
	for n, res := range r.Moq.ResultsByParams_GobEncode {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_GobEncode_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_GobEncode_paramsKey]*MoqInt_starGenType_GobEncode_results{},
		}
		r.Moq.ResultsByParams_GobEncode = append(r.Moq.ResultsByParams_GobEncode, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_GobEncode) {
			copy(r.Moq.ResultsByParams_GobEncode[insertAt+1:], r.Moq.ResultsByParams_GobEncode[insertAt:0])
			r.Moq.ResultsByParams_GobEncode[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_GobEncode(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_GobEncode_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_GobEncode_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_GobEncode_doFn
				DoReturnFn MoqInt_starGenType_GobEncode_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_GobEncode(params MoqInt_starGenType_GobEncode_params) string {
	return fmt.Sprintf("GobEncode()")
}

func (m *MoqInt_starGenType) ParamsKey_GobEncode(params MoqInt_starGenType_GobEncode_params, anyParams uint64) MoqInt_starGenType_GobEncode_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_GobEncode_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) GobDecode(buf []byte) *MoqInt_starGenType_GobDecode_fnRecorder {
	return &MoqInt_starGenType_GobDecode_fnRecorder{
		Params: MoqInt_starGenType_GobDecode_params{
			Buf: buf,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_GobDecode_fnRecorder) Any() *MoqInt_starGenType_GobDecode_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobDecode(r.Params))
		return nil
	}
	return &MoqInt_starGenType_GobDecode_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_GobDecode_anyParams) Buf() *MoqInt_starGenType_GobDecode_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_GobDecode_fnRecorder) Seq() *MoqInt_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobDecode(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_GobDecode_fnRecorder) NoSeq() *MoqInt_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobDecode(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_GobDecode_fnRecorder) ReturnResults(result1 error) *MoqInt_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_GobDecode_doFn
		DoReturnFn MoqInt_starGenType_GobDecode_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_GobDecode_fnRecorder) AndDo(fn MoqInt_starGenType_GobDecode_doFn) *MoqInt_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_GobDecode_fnRecorder) DoReturnResults(fn MoqInt_starGenType_GobDecode_doReturnFn) *MoqInt_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_GobDecode_doFn
		DoReturnFn MoqInt_starGenType_GobDecode_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_GobDecode_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_GobDecode_resultsByParams
	for n, res := range r.Moq.ResultsByParams_GobDecode {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_GobDecode_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_GobDecode_paramsKey]*MoqInt_starGenType_GobDecode_results{},
		}
		r.Moq.ResultsByParams_GobDecode = append(r.Moq.ResultsByParams_GobDecode, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_GobDecode) {
			copy(r.Moq.ResultsByParams_GobDecode[insertAt+1:], r.Moq.ResultsByParams_GobDecode[insertAt:0])
			r.Moq.ResultsByParams_GobDecode[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_GobDecode(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_GobDecode_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_GobDecode_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_GobDecode_doFn
				DoReturnFn MoqInt_starGenType_GobDecode_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_GobDecode(params MoqInt_starGenType_GobDecode_params) string {
	return fmt.Sprintf("GobDecode(%#v)", params.Buf)
}

func (m *MoqInt_starGenType) ParamsKey_GobDecode(params MoqInt_starGenType_GobDecode_params, anyParams uint64) MoqInt_starGenType_GobDecode_paramsKey {
	m.Scene.T.Helper()
	var bufUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.GobDecode.Buf == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The buf parameter of the GobDecode function can't be indexed by value")
		}
		bufUsedHash = hash.DeepHash(params.Buf)
	}
	return MoqInt_starGenType_GobDecode_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Buf hash.Hash }{
			Buf: bufUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) MarshalText() *MoqInt_starGenType_MarshalText_fnRecorder {
	return &MoqInt_starGenType_MarshalText_fnRecorder{
		Params:   MoqInt_starGenType_MarshalText_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_MarshalText_fnRecorder) Any() *MoqInt_starGenType_MarshalText_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	return &MoqInt_starGenType_MarshalText_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_MarshalText_fnRecorder) Seq() *MoqInt_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_MarshalText_fnRecorder) NoSeq() *MoqInt_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_MarshalText_fnRecorder) ReturnResults(text []byte, err error) *MoqInt_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_MarshalText_doFn
		DoReturnFn MoqInt_starGenType_MarshalText_doReturnFn
	}{
		Values: &struct {
			Text []byte
			Err  error
		}{
			Text: text,
			Err:  err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_MarshalText_fnRecorder) AndDo(fn MoqInt_starGenType_MarshalText_doFn) *MoqInt_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_MarshalText_fnRecorder) DoReturnResults(fn MoqInt_starGenType_MarshalText_doReturnFn) *MoqInt_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_MarshalText_doFn
		DoReturnFn MoqInt_starGenType_MarshalText_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_MarshalText_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_MarshalText_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MarshalText {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_MarshalText_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_MarshalText_paramsKey]*MoqInt_starGenType_MarshalText_results{},
		}
		r.Moq.ResultsByParams_MarshalText = append(r.Moq.ResultsByParams_MarshalText, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MarshalText) {
			copy(r.Moq.ResultsByParams_MarshalText[insertAt+1:], r.Moq.ResultsByParams_MarshalText[insertAt:0])
			r.Moq.ResultsByParams_MarshalText[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MarshalText(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_MarshalText_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_MarshalText_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Text []byte
					Err  error
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_MarshalText_doFn
				DoReturnFn MoqInt_starGenType_MarshalText_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_MarshalText(params MoqInt_starGenType_MarshalText_params) string {
	return fmt.Sprintf("MarshalText()")
}

func (m *MoqInt_starGenType) ParamsKey_MarshalText(params MoqInt_starGenType_MarshalText_params, anyParams uint64) MoqInt_starGenType_MarshalText_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_MarshalText_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) UnmarshalText(text []byte) *MoqInt_starGenType_UnmarshalText_fnRecorder {
	return &MoqInt_starGenType_UnmarshalText_fnRecorder{
		Params: MoqInt_starGenType_UnmarshalText_params{
			Text: text,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_UnmarshalText_fnRecorder) Any() *MoqInt_starGenType_UnmarshalText_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalText(r.Params))
		return nil
	}
	return &MoqInt_starGenType_UnmarshalText_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_UnmarshalText_anyParams) Text() *MoqInt_starGenType_UnmarshalText_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_UnmarshalText_fnRecorder) Seq() *MoqInt_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalText(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_UnmarshalText_fnRecorder) NoSeq() *MoqInt_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalText(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_UnmarshalText_fnRecorder) ReturnResults(result1 error) *MoqInt_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_UnmarshalText_doFn
		DoReturnFn MoqInt_starGenType_UnmarshalText_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_UnmarshalText_fnRecorder) AndDo(fn MoqInt_starGenType_UnmarshalText_doFn) *MoqInt_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_UnmarshalText_fnRecorder) DoReturnResults(fn MoqInt_starGenType_UnmarshalText_doReturnFn) *MoqInt_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_UnmarshalText_doFn
		DoReturnFn MoqInt_starGenType_UnmarshalText_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_UnmarshalText_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_UnmarshalText_resultsByParams
	for n, res := range r.Moq.ResultsByParams_UnmarshalText {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_UnmarshalText_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_UnmarshalText_paramsKey]*MoqInt_starGenType_UnmarshalText_results{},
		}
		r.Moq.ResultsByParams_UnmarshalText = append(r.Moq.ResultsByParams_UnmarshalText, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_UnmarshalText) {
			copy(r.Moq.ResultsByParams_UnmarshalText[insertAt+1:], r.Moq.ResultsByParams_UnmarshalText[insertAt:0])
			r.Moq.ResultsByParams_UnmarshalText[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_UnmarshalText(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_UnmarshalText_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_UnmarshalText_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_UnmarshalText_doFn
				DoReturnFn MoqInt_starGenType_UnmarshalText_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_UnmarshalText(params MoqInt_starGenType_UnmarshalText_params) string {
	return fmt.Sprintf("UnmarshalText(%#v)", params.Text)
}

func (m *MoqInt_starGenType) ParamsKey_UnmarshalText(params MoqInt_starGenType_UnmarshalText_params, anyParams uint64) MoqInt_starGenType_UnmarshalText_paramsKey {
	m.Scene.T.Helper()
	var textUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.UnmarshalText.Text == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The text parameter of the UnmarshalText function can't be indexed by value")
		}
		textUsedHash = hash.DeepHash(params.Text)
	}
	return MoqInt_starGenType_UnmarshalText_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Text hash.Hash }{
			Text: textUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) MarshalJSON() *MoqInt_starGenType_MarshalJSON_fnRecorder {
	return &MoqInt_starGenType_MarshalJSON_fnRecorder{
		Params:   MoqInt_starGenType_MarshalJSON_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_MarshalJSON_fnRecorder) Any() *MoqInt_starGenType_MarshalJSON_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalJSON(r.Params))
		return nil
	}
	return &MoqInt_starGenType_MarshalJSON_anyParams{Recorder: r}
}

func (r *MoqInt_starGenType_MarshalJSON_fnRecorder) Seq() *MoqInt_starGenType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalJSON(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_MarshalJSON_fnRecorder) NoSeq() *MoqInt_starGenType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalJSON(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_MarshalJSON_fnRecorder) ReturnResults(result1 []byte, result2 error) *MoqInt_starGenType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_MarshalJSON_doFn
		DoReturnFn MoqInt_starGenType_MarshalJSON_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_MarshalJSON_fnRecorder) AndDo(fn MoqInt_starGenType_MarshalJSON_doFn) *MoqInt_starGenType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_MarshalJSON_fnRecorder) DoReturnResults(fn MoqInt_starGenType_MarshalJSON_doReturnFn) *MoqInt_starGenType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_MarshalJSON_doFn
		DoReturnFn MoqInt_starGenType_MarshalJSON_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_MarshalJSON_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_MarshalJSON_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MarshalJSON {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_MarshalJSON_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_MarshalJSON_paramsKey]*MoqInt_starGenType_MarshalJSON_results{},
		}
		r.Moq.ResultsByParams_MarshalJSON = append(r.Moq.ResultsByParams_MarshalJSON, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MarshalJSON) {
			copy(r.Moq.ResultsByParams_MarshalJSON[insertAt+1:], r.Moq.ResultsByParams_MarshalJSON[insertAt:0])
			r.Moq.ResultsByParams_MarshalJSON[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MarshalJSON(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_MarshalJSON_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_MarshalJSON_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_MarshalJSON_doFn
				DoReturnFn MoqInt_starGenType_MarshalJSON_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_MarshalJSON(params MoqInt_starGenType_MarshalJSON_params) string {
	return fmt.Sprintf("MarshalJSON()")
}

func (m *MoqInt_starGenType) ParamsKey_MarshalJSON(params MoqInt_starGenType_MarshalJSON_params, anyParams uint64) MoqInt_starGenType_MarshalJSON_paramsKey {
	m.Scene.T.Helper()
	return MoqInt_starGenType_MarshalJSON_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInt_starGenType_recorder) UnmarshalJSON(text []byte) *MoqInt_starGenType_UnmarshalJSON_fnRecorder {
	return &MoqInt_starGenType_UnmarshalJSON_fnRecorder{
		Params: MoqInt_starGenType_UnmarshalJSON_params{
			Text: text,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_UnmarshalJSON_fnRecorder) Any() *MoqInt_starGenType_UnmarshalJSON_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalJSON(r.Params))
		return nil
	}
	return &MoqInt_starGenType_UnmarshalJSON_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_UnmarshalJSON_anyParams) Text() *MoqInt_starGenType_UnmarshalJSON_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_UnmarshalJSON_fnRecorder) Seq() *MoqInt_starGenType_UnmarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalJSON(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_UnmarshalJSON_fnRecorder) NoSeq() *MoqInt_starGenType_UnmarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalJSON(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_UnmarshalJSON_fnRecorder) ReturnResults(result1 error) *MoqInt_starGenType_UnmarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_UnmarshalJSON_doFn
		DoReturnFn MoqInt_starGenType_UnmarshalJSON_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_UnmarshalJSON_fnRecorder) AndDo(fn MoqInt_starGenType_UnmarshalJSON_doFn) *MoqInt_starGenType_UnmarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_UnmarshalJSON_fnRecorder) DoReturnResults(fn MoqInt_starGenType_UnmarshalJSON_doReturnFn) *MoqInt_starGenType_UnmarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_UnmarshalJSON_doFn
		DoReturnFn MoqInt_starGenType_UnmarshalJSON_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_UnmarshalJSON_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_UnmarshalJSON_resultsByParams
	for n, res := range r.Moq.ResultsByParams_UnmarshalJSON {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_UnmarshalJSON_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_UnmarshalJSON_paramsKey]*MoqInt_starGenType_UnmarshalJSON_results{},
		}
		r.Moq.ResultsByParams_UnmarshalJSON = append(r.Moq.ResultsByParams_UnmarshalJSON, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_UnmarshalJSON) {
			copy(r.Moq.ResultsByParams_UnmarshalJSON[insertAt+1:], r.Moq.ResultsByParams_UnmarshalJSON[insertAt:0])
			r.Moq.ResultsByParams_UnmarshalJSON[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_UnmarshalJSON(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_UnmarshalJSON_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_UnmarshalJSON_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_UnmarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_UnmarshalJSON_doFn
				DoReturnFn MoqInt_starGenType_UnmarshalJSON_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_UnmarshalJSON(params MoqInt_starGenType_UnmarshalJSON_params) string {
	return fmt.Sprintf("UnmarshalJSON(%#v)", params.Text)
}

func (m *MoqInt_starGenType) ParamsKey_UnmarshalJSON(params MoqInt_starGenType_UnmarshalJSON_params, anyParams uint64) MoqInt_starGenType_UnmarshalJSON_paramsKey {
	m.Scene.T.Helper()
	var textUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.UnmarshalJSON.Text == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The text parameter of the UnmarshalJSON function can't be indexed by value")
		}
		textUsedHash = hash.DeepHash(params.Text)
	}
	return MoqInt_starGenType_UnmarshalJSON_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Text hash.Hash }{
			Text: textUsedHash,
		},
	}
}

func (m *MoqInt_starGenType_recorder) ProbablyPrime(n int) *MoqInt_starGenType_ProbablyPrime_fnRecorder {
	return &MoqInt_starGenType_ProbablyPrime_fnRecorder{
		Params: MoqInt_starGenType_ProbablyPrime_params{
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInt_starGenType_ProbablyPrime_fnRecorder) Any() *MoqInt_starGenType_ProbablyPrime_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ProbablyPrime(r.Params))
		return nil
	}
	return &MoqInt_starGenType_ProbablyPrime_anyParams{Recorder: r}
}

func (a *MoqInt_starGenType_ProbablyPrime_anyParams) N() *MoqInt_starGenType_ProbablyPrime_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInt_starGenType_ProbablyPrime_fnRecorder) Seq() *MoqInt_starGenType_ProbablyPrime_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ProbablyPrime(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInt_starGenType_ProbablyPrime_fnRecorder) NoSeq() *MoqInt_starGenType_ProbablyPrime_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ProbablyPrime(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInt_starGenType_ProbablyPrime_fnRecorder) ReturnResults(result1 bool) *MoqInt_starGenType_ProbablyPrime_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_ProbablyPrime_doFn
		DoReturnFn MoqInt_starGenType_ProbablyPrime_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInt_starGenType_ProbablyPrime_fnRecorder) AndDo(fn MoqInt_starGenType_ProbablyPrime_doFn) *MoqInt_starGenType_ProbablyPrime_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInt_starGenType_ProbablyPrime_fnRecorder) DoReturnResults(fn MoqInt_starGenType_ProbablyPrime_doReturnFn) *MoqInt_starGenType_ProbablyPrime_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInt_starGenType_ProbablyPrime_doFn
		DoReturnFn MoqInt_starGenType_ProbablyPrime_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInt_starGenType_ProbablyPrime_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInt_starGenType_ProbablyPrime_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ProbablyPrime {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInt_starGenType_ProbablyPrime_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInt_starGenType_ProbablyPrime_paramsKey]*MoqInt_starGenType_ProbablyPrime_results{},
		}
		r.Moq.ResultsByParams_ProbablyPrime = append(r.Moq.ResultsByParams_ProbablyPrime, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ProbablyPrime) {
			copy(r.Moq.ResultsByParams_ProbablyPrime[insertAt+1:], r.Moq.ResultsByParams_ProbablyPrime[insertAt:0])
			r.Moq.ResultsByParams_ProbablyPrime[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ProbablyPrime(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInt_starGenType_ProbablyPrime_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInt_starGenType_ProbablyPrime_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInt_starGenType_ProbablyPrime_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqInt_starGenType_ProbablyPrime_doFn
				DoReturnFn MoqInt_starGenType_ProbablyPrime_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInt_starGenType) PrettyParams_ProbablyPrime(params MoqInt_starGenType_ProbablyPrime_params) string {
	return fmt.Sprintf("ProbablyPrime(%#v)", params.N)
}

func (m *MoqInt_starGenType) ParamsKey_ProbablyPrime(params MoqInt_starGenType_ProbablyPrime_params, anyParams uint64) MoqInt_starGenType_ProbablyPrime_paramsKey {
	m.Scene.T.Helper()
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ProbablyPrime.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqInt_starGenType_ProbablyPrime_paramsKey{
		Params: struct{ N int }{
			N: nUsed,
		},
		Hashes: struct{ N hash.Hash }{
			N: nUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqInt_starGenType) Reset() {
	m.ResultsByParams_Sign = nil
	m.ResultsByParams_SetInt64 = nil
	m.ResultsByParams_SetUint64 = nil
	m.ResultsByParams_Set = nil
	m.ResultsByParams_Bits = nil
	m.ResultsByParams_SetBits = nil
	m.ResultsByParams_Abs = nil
	m.ResultsByParams_Neg = nil
	m.ResultsByParams_Add = nil
	m.ResultsByParams_Sub = nil
	m.ResultsByParams_Mul = nil
	m.ResultsByParams_MulRange = nil
	m.ResultsByParams_Binomial = nil
	m.ResultsByParams_Quo = nil
	m.ResultsByParams_Rem = nil
	m.ResultsByParams_QuoRem = nil
	m.ResultsByParams_Div = nil
	m.ResultsByParams_Mod = nil
	m.ResultsByParams_DivMod = nil
	m.ResultsByParams_Cmp = nil
	m.ResultsByParams_CmpAbs = nil
	m.ResultsByParams_Int64 = nil
	m.ResultsByParams_Uint64 = nil
	m.ResultsByParams_IsInt64 = nil
	m.ResultsByParams_IsUint64 = nil
	m.ResultsByParams_SetString = nil
	m.ResultsByParams_SetBytes = nil
	m.ResultsByParams_Bytes = nil
	m.ResultsByParams_BitLen = nil
	m.ResultsByParams_TrailingZeroBits = nil
	m.ResultsByParams_Exp = nil
	m.ResultsByParams_GCD = nil
	m.ResultsByParams_Rand = nil
	m.ResultsByParams_ModInverse = nil
	m.ResultsByParams_ModSqrt = nil
	m.ResultsByParams_Lsh = nil
	m.ResultsByParams_Rsh = nil
	m.ResultsByParams_Bit = nil
	m.ResultsByParams_SetBit = nil
	m.ResultsByParams_And = nil
	m.ResultsByParams_AndNot = nil
	m.ResultsByParams_Or = nil
	m.ResultsByParams_Xor = nil
	m.ResultsByParams_Not = nil
	m.ResultsByParams_Sqrt = nil
	m.ResultsByParams_Text = nil
	m.ResultsByParams_Append = nil
	m.ResultsByParams_String = nil
	m.ResultsByParams_Format = nil
	m.ResultsByParams_Scan = nil
	m.ResultsByParams_GobEncode = nil
	m.ResultsByParams_GobDecode = nil
	m.ResultsByParams_MarshalText = nil
	m.ResultsByParams_UnmarshalText = nil
	m.ResultsByParams_MarshalJSON = nil
	m.ResultsByParams_UnmarshalJSON = nil
	m.ResultsByParams_ProbablyPrime = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqInt_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Sign {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Sign(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetInt64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetInt64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetUint64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetUint64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Set {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Set(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Bits {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Bits(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetBits {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetBits(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Abs {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Abs(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Neg {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Neg(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Add {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Add(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Sub {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Sub(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Mul {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Mul(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MulRange {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MulRange(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Binomial {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Binomial(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Quo {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Quo(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Rem {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Rem(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_QuoRem {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_QuoRem(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Div {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Div(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Mod {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Mod(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_DivMod {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_DivMod(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Cmp {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Cmp(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_CmpAbs {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_CmpAbs(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Int64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Int64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Uint64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Uint64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsInt64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsInt64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsUint64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsUint64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetBytes {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetBytes(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Bytes {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Bytes(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_BitLen {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_BitLen(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_TrailingZeroBits {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_TrailingZeroBits(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Exp {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Exp(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_GCD {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_GCD(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Rand {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Rand(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ModInverse {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ModInverse(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ModSqrt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ModSqrt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Lsh {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Lsh(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Rsh {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Rsh(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Bit {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Bit(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetBit {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetBit(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_And {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_And(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AndNot {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AndNot(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Or {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Or(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Xor {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Xor(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Not {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Not(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Sqrt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Sqrt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Text {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Text(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Append {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Append(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Format {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Format(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Scan {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Scan(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_GobEncode {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_GobEncode(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_GobDecode {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_GobDecode(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MarshalText {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MarshalText(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_UnmarshalText {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_UnmarshalText(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MarshalJSON {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MarshalJSON(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_UnmarshalJSON {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_UnmarshalJSON(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ProbablyPrime {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ProbablyPrime(results.Params))
			}
		}
	}
}
