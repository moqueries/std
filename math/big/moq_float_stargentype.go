// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package big

import (
	"fmt"
	"math/big"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that big.Float_starGenType is mocked
// completely
var _ Float_starGenType = (*MoqFloat_starGenType_mock)(nil)

// Float_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Float_starGenType interface {
	SetPrec(prec uint) *big.Float
	SetMode(mode big.RoundingMode) *big.Float
	Prec() uint
	MinPrec() uint
	Mode() big.RoundingMode
	Acc() big.Accuracy
	Sign() int
	MantExp(mant *big.Float) (exp int)
	SetMantExp(mant *big.Float, exp int) *big.Float
	Signbit() bool
	IsInf() bool
	IsInt() bool
	SetUint64(x uint64) *big.Float
	SetInt64(x int64) *big.Float
	SetFloat64(x float64) *big.Float
	SetInt(x *big.Int) *big.Float
	SetRat(x *big.Rat) *big.Float
	SetInf(signbit bool) *big.Float
	Set(x *big.Float) *big.Float
	Copy(x *big.Float) *big.Float
	Uint64() (uint64, big.Accuracy)
	Int64() (int64, big.Accuracy)
	Float32() (float32, big.Accuracy)
	Float64() (float64, big.Accuracy)
	Int(z *big.Int) (*big.Int, big.Accuracy)
	Rat(z *big.Rat) (*big.Rat, big.Accuracy)
	Abs(x *big.Float) *big.Float
	Neg(x *big.Float) *big.Float
	Add(x, y *big.Float) *big.Float
	Sub(x, y *big.Float) *big.Float
	Mul(x, y *big.Float) *big.Float
	Quo(x, y *big.Float) *big.Float
	Cmp(y *big.Float) int
	SetString(s string) (*big.Float, bool)
	Parse(s string, base int) (f *big.Float, b int, err error)
	Scan(s fmt.ScanState, ch rune) error
	GobEncode() ([]byte, error)
	GobDecode(buf []byte) error
	MarshalText() (text []byte, err error)
	UnmarshalText(text []byte) error
	Text(format byte, prec int) string
	String() string
	Append(buf []byte, fmt byte, prec int) []byte
	Format(s fmt.State, format rune)
	Sqrt(x *big.Float) *big.Float
}

// MoqFloat_starGenType holds the state of a moq of the Float_starGenType type
type MoqFloat_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqFloat_starGenType_mock

	ResultsByParams_SetPrec       []MoqFloat_starGenType_SetPrec_resultsByParams
	ResultsByParams_SetMode       []MoqFloat_starGenType_SetMode_resultsByParams
	ResultsByParams_Prec          []MoqFloat_starGenType_Prec_resultsByParams
	ResultsByParams_MinPrec       []MoqFloat_starGenType_MinPrec_resultsByParams
	ResultsByParams_Mode          []MoqFloat_starGenType_Mode_resultsByParams
	ResultsByParams_Acc           []MoqFloat_starGenType_Acc_resultsByParams
	ResultsByParams_Sign          []MoqFloat_starGenType_Sign_resultsByParams
	ResultsByParams_MantExp       []MoqFloat_starGenType_MantExp_resultsByParams
	ResultsByParams_SetMantExp    []MoqFloat_starGenType_SetMantExp_resultsByParams
	ResultsByParams_Signbit       []MoqFloat_starGenType_Signbit_resultsByParams
	ResultsByParams_IsInf         []MoqFloat_starGenType_IsInf_resultsByParams
	ResultsByParams_IsInt         []MoqFloat_starGenType_IsInt_resultsByParams
	ResultsByParams_SetUint64     []MoqFloat_starGenType_SetUint64_resultsByParams
	ResultsByParams_SetInt64      []MoqFloat_starGenType_SetInt64_resultsByParams
	ResultsByParams_SetFloat64    []MoqFloat_starGenType_SetFloat64_resultsByParams
	ResultsByParams_SetInt        []MoqFloat_starGenType_SetInt_resultsByParams
	ResultsByParams_SetRat        []MoqFloat_starGenType_SetRat_resultsByParams
	ResultsByParams_SetInf        []MoqFloat_starGenType_SetInf_resultsByParams
	ResultsByParams_Set           []MoqFloat_starGenType_Set_resultsByParams
	ResultsByParams_Copy          []MoqFloat_starGenType_Copy_resultsByParams
	ResultsByParams_Uint64        []MoqFloat_starGenType_Uint64_resultsByParams
	ResultsByParams_Int64         []MoqFloat_starGenType_Int64_resultsByParams
	ResultsByParams_Float32       []MoqFloat_starGenType_Float32_resultsByParams
	ResultsByParams_Float64       []MoqFloat_starGenType_Float64_resultsByParams
	ResultsByParams_Int           []MoqFloat_starGenType_Int_resultsByParams
	ResultsByParams_Rat           []MoqFloat_starGenType_Rat_resultsByParams
	ResultsByParams_Abs           []MoqFloat_starGenType_Abs_resultsByParams
	ResultsByParams_Neg           []MoqFloat_starGenType_Neg_resultsByParams
	ResultsByParams_Add           []MoqFloat_starGenType_Add_resultsByParams
	ResultsByParams_Sub           []MoqFloat_starGenType_Sub_resultsByParams
	ResultsByParams_Mul           []MoqFloat_starGenType_Mul_resultsByParams
	ResultsByParams_Quo           []MoqFloat_starGenType_Quo_resultsByParams
	ResultsByParams_Cmp           []MoqFloat_starGenType_Cmp_resultsByParams
	ResultsByParams_SetString     []MoqFloat_starGenType_SetString_resultsByParams
	ResultsByParams_Parse         []MoqFloat_starGenType_Parse_resultsByParams
	ResultsByParams_Scan          []MoqFloat_starGenType_Scan_resultsByParams
	ResultsByParams_GobEncode     []MoqFloat_starGenType_GobEncode_resultsByParams
	ResultsByParams_GobDecode     []MoqFloat_starGenType_GobDecode_resultsByParams
	ResultsByParams_MarshalText   []MoqFloat_starGenType_MarshalText_resultsByParams
	ResultsByParams_UnmarshalText []MoqFloat_starGenType_UnmarshalText_resultsByParams
	ResultsByParams_Text          []MoqFloat_starGenType_Text_resultsByParams
	ResultsByParams_String        []MoqFloat_starGenType_String_resultsByParams
	ResultsByParams_Append        []MoqFloat_starGenType_Append_resultsByParams
	ResultsByParams_Format        []MoqFloat_starGenType_Format_resultsByParams
	ResultsByParams_Sqrt          []MoqFloat_starGenType_Sqrt_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			SetPrec struct {
				Prec moq.ParamIndexing
			}
			SetMode struct {
				Mode moq.ParamIndexing
			}
			Prec    struct{}
			MinPrec struct{}
			Mode    struct{}
			Acc     struct{}
			Sign    struct{}
			MantExp struct {
				Mant moq.ParamIndexing
			}
			SetMantExp struct {
				Mant moq.ParamIndexing
				Exp  moq.ParamIndexing
			}
			Signbit   struct{}
			IsInf     struct{}
			IsInt     struct{}
			SetUint64 struct {
				X moq.ParamIndexing
			}
			SetInt64 struct {
				X moq.ParamIndexing
			}
			SetFloat64 struct {
				X moq.ParamIndexing
			}
			SetInt struct {
				X moq.ParamIndexing
			}
			SetRat struct {
				X moq.ParamIndexing
			}
			SetInf struct {
				Signbit moq.ParamIndexing
			}
			Set struct {
				X moq.ParamIndexing
			}
			Copy struct {
				X moq.ParamIndexing
			}
			Uint64  struct{}
			Int64   struct{}
			Float32 struct{}
			Float64 struct{}
			Int     struct {
				Z moq.ParamIndexing
			}
			Rat struct {
				Z moq.ParamIndexing
			}
			Abs struct {
				X moq.ParamIndexing
			}
			Neg struct {
				X moq.ParamIndexing
			}
			Add struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Sub struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Mul struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Quo struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Cmp struct {
				Y moq.ParamIndexing
			}
			SetString struct {
				S moq.ParamIndexing
			}
			Parse struct {
				S    moq.ParamIndexing
				Base moq.ParamIndexing
			}
			Scan struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}
			GobEncode struct{}
			GobDecode struct {
				Buf moq.ParamIndexing
			}
			MarshalText   struct{}
			UnmarshalText struct {
				Text moq.ParamIndexing
			}
			Text struct {
				Format moq.ParamIndexing
				Prec   moq.ParamIndexing
			}
			String struct{}
			Append struct {
				Buf  moq.ParamIndexing
				Fmt  moq.ParamIndexing
				Prec moq.ParamIndexing
			}
			Format struct {
				S      moq.ParamIndexing
				Format moq.ParamIndexing
			}
			Sqrt struct {
				X moq.ParamIndexing
			}
		}
	}
	// MoqFloat_starGenType_mock isolates the mock interface of the
}

// Float_starGenType type
type MoqFloat_starGenType_mock struct {
	Moq *MoqFloat_starGenType
}

// MoqFloat_starGenType_recorder isolates the recorder interface of the
// Float_starGenType type
type MoqFloat_starGenType_recorder struct {
	Moq *MoqFloat_starGenType
}

// MoqFloat_starGenType_SetPrec_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_SetPrec_params struct{ Prec uint }

// MoqFloat_starGenType_SetPrec_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_SetPrec_paramsKey struct {
	Params struct{ Prec uint }
	Hashes struct{ Prec hash.Hash }
}

// MoqFloat_starGenType_SetPrec_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_SetPrec_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_SetPrec_paramsKey]*MoqFloat_starGenType_SetPrec_results
}

// MoqFloat_starGenType_SetPrec_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_SetPrec_doFn func(prec uint)

// MoqFloat_starGenType_SetPrec_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_SetPrec_doReturnFn func(prec uint) *big.Float

// MoqFloat_starGenType_SetPrec_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_SetPrec_results struct {
	Params  MoqFloat_starGenType_SetPrec_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetPrec_doFn
		DoReturnFn MoqFloat_starGenType_SetPrec_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_SetPrec_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_SetPrec_fnRecorder struct {
	Params    MoqFloat_starGenType_SetPrec_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_SetPrec_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_SetPrec_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_SetPrec_anyParams struct {
	Recorder *MoqFloat_starGenType_SetPrec_fnRecorder
}

// MoqFloat_starGenType_SetMode_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_SetMode_params struct{ Mode big.RoundingMode }

// MoqFloat_starGenType_SetMode_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_SetMode_paramsKey struct {
	Params struct{ Mode big.RoundingMode }
	Hashes struct{ Mode hash.Hash }
}

// MoqFloat_starGenType_SetMode_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_SetMode_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_SetMode_paramsKey]*MoqFloat_starGenType_SetMode_results
}

// MoqFloat_starGenType_SetMode_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_SetMode_doFn func(mode big.RoundingMode)

// MoqFloat_starGenType_SetMode_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_SetMode_doReturnFn func(mode big.RoundingMode) *big.Float

// MoqFloat_starGenType_SetMode_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_SetMode_results struct {
	Params  MoqFloat_starGenType_SetMode_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetMode_doFn
		DoReturnFn MoqFloat_starGenType_SetMode_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_SetMode_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_SetMode_fnRecorder struct {
	Params    MoqFloat_starGenType_SetMode_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_SetMode_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_SetMode_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_SetMode_anyParams struct {
	Recorder *MoqFloat_starGenType_SetMode_fnRecorder
}

// MoqFloat_starGenType_Prec_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Prec_params struct{}

// MoqFloat_starGenType_Prec_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Prec_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_Prec_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Prec_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Prec_paramsKey]*MoqFloat_starGenType_Prec_results
}

// MoqFloat_starGenType_Prec_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Prec_doFn func()

// MoqFloat_starGenType_Prec_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Prec_doReturnFn func() uint

// MoqFloat_starGenType_Prec_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Prec_results struct {
	Params  MoqFloat_starGenType_Prec_params
	Results []struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Prec_doFn
		DoReturnFn MoqFloat_starGenType_Prec_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Prec_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Prec_fnRecorder struct {
	Params    MoqFloat_starGenType_Prec_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Prec_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Prec_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Prec_anyParams struct {
	Recorder *MoqFloat_starGenType_Prec_fnRecorder
}

// MoqFloat_starGenType_MinPrec_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_MinPrec_params struct{}

// MoqFloat_starGenType_MinPrec_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_MinPrec_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_MinPrec_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_MinPrec_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_MinPrec_paramsKey]*MoqFloat_starGenType_MinPrec_results
}

// MoqFloat_starGenType_MinPrec_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_MinPrec_doFn func()

// MoqFloat_starGenType_MinPrec_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_MinPrec_doReturnFn func() uint

// MoqFloat_starGenType_MinPrec_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_MinPrec_results struct {
	Params  MoqFloat_starGenType_MinPrec_params
	Results []struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_MinPrec_doFn
		DoReturnFn MoqFloat_starGenType_MinPrec_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_MinPrec_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_MinPrec_fnRecorder struct {
	Params    MoqFloat_starGenType_MinPrec_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_MinPrec_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_MinPrec_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_MinPrec_anyParams struct {
	Recorder *MoqFloat_starGenType_MinPrec_fnRecorder
}

// MoqFloat_starGenType_Mode_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Mode_params struct{}

// MoqFloat_starGenType_Mode_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Mode_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_Mode_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Mode_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Mode_paramsKey]*MoqFloat_starGenType_Mode_results
}

// MoqFloat_starGenType_Mode_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Mode_doFn func()

// MoqFloat_starGenType_Mode_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Mode_doReturnFn func() big.RoundingMode

// MoqFloat_starGenType_Mode_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Mode_results struct {
	Params  MoqFloat_starGenType_Mode_params
	Results []struct {
		Values *struct {
			Result1 big.RoundingMode
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Mode_doFn
		DoReturnFn MoqFloat_starGenType_Mode_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Mode_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Mode_fnRecorder struct {
	Params    MoqFloat_starGenType_Mode_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Mode_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Mode_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Mode_anyParams struct {
	Recorder *MoqFloat_starGenType_Mode_fnRecorder
}

// MoqFloat_starGenType_Acc_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Acc_params struct{}

// MoqFloat_starGenType_Acc_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Acc_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_Acc_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Acc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Acc_paramsKey]*MoqFloat_starGenType_Acc_results
}

// MoqFloat_starGenType_Acc_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Acc_doFn func()

// MoqFloat_starGenType_Acc_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Acc_doReturnFn func() big.Accuracy

// MoqFloat_starGenType_Acc_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Acc_results struct {
	Params  MoqFloat_starGenType_Acc_params
	Results []struct {
		Values *struct {
			Result1 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Acc_doFn
		DoReturnFn MoqFloat_starGenType_Acc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Acc_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Acc_fnRecorder struct {
	Params    MoqFloat_starGenType_Acc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Acc_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Acc_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Acc_anyParams struct {
	Recorder *MoqFloat_starGenType_Acc_fnRecorder
}

// MoqFloat_starGenType_Sign_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Sign_params struct{}

// MoqFloat_starGenType_Sign_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Sign_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_Sign_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Sign_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Sign_paramsKey]*MoqFloat_starGenType_Sign_results
}

// MoqFloat_starGenType_Sign_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Sign_doFn func()

// MoqFloat_starGenType_Sign_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Sign_doReturnFn func() int

// MoqFloat_starGenType_Sign_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Sign_results struct {
	Params  MoqFloat_starGenType_Sign_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Sign_doFn
		DoReturnFn MoqFloat_starGenType_Sign_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Sign_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Sign_fnRecorder struct {
	Params    MoqFloat_starGenType_Sign_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Sign_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Sign_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Sign_anyParams struct {
	Recorder *MoqFloat_starGenType_Sign_fnRecorder
}

// MoqFloat_starGenType_MantExp_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_MantExp_params struct{ Mant *big.Float }

// MoqFloat_starGenType_MantExp_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_MantExp_paramsKey struct {
	Params struct{ Mant *big.Float }
	Hashes struct{ Mant hash.Hash }
}

// MoqFloat_starGenType_MantExp_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_MantExp_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_MantExp_paramsKey]*MoqFloat_starGenType_MantExp_results
}

// MoqFloat_starGenType_MantExp_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_MantExp_doFn func(mant *big.Float)

// MoqFloat_starGenType_MantExp_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_MantExp_doReturnFn func(mant *big.Float) (exp int)

// MoqFloat_starGenType_MantExp_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_MantExp_results struct {
	Params  MoqFloat_starGenType_MantExp_params
	Results []struct {
		Values     *struct{ Exp int }
		Sequence   uint32
		DoFn       MoqFloat_starGenType_MantExp_doFn
		DoReturnFn MoqFloat_starGenType_MantExp_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_MantExp_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_MantExp_fnRecorder struct {
	Params    MoqFloat_starGenType_MantExp_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_MantExp_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_MantExp_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_MantExp_anyParams struct {
	Recorder *MoqFloat_starGenType_MantExp_fnRecorder
}

// MoqFloat_starGenType_SetMantExp_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_SetMantExp_params struct {
	Mant *big.Float
	Exp  int
}

// MoqFloat_starGenType_SetMantExp_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_SetMantExp_paramsKey struct {
	Params struct {
		Mant *big.Float
		Exp  int
	}
	Hashes struct {
		Mant hash.Hash
		Exp  hash.Hash
	}
}

// MoqFloat_starGenType_SetMantExp_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_SetMantExp_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_SetMantExp_paramsKey]*MoqFloat_starGenType_SetMantExp_results
}

// MoqFloat_starGenType_SetMantExp_doFn defines the type of function needed
// when calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_SetMantExp_doFn func(mant *big.Float, exp int)

// MoqFloat_starGenType_SetMantExp_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_SetMantExp_doReturnFn func(mant *big.Float, exp int) *big.Float

// MoqFloat_starGenType_SetMantExp_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_SetMantExp_results struct {
	Params  MoqFloat_starGenType_SetMantExp_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetMantExp_doFn
		DoReturnFn MoqFloat_starGenType_SetMantExp_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_SetMantExp_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_SetMantExp_fnRecorder struct {
	Params    MoqFloat_starGenType_SetMantExp_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_SetMantExp_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_SetMantExp_anyParams isolates the any params functions
// of the Float_starGenType type
type MoqFloat_starGenType_SetMantExp_anyParams struct {
	Recorder *MoqFloat_starGenType_SetMantExp_fnRecorder
}

// MoqFloat_starGenType_Signbit_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_Signbit_params struct{}

// MoqFloat_starGenType_Signbit_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Signbit_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_Signbit_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Signbit_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Signbit_paramsKey]*MoqFloat_starGenType_Signbit_results
}

// MoqFloat_starGenType_Signbit_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Signbit_doFn func()

// MoqFloat_starGenType_Signbit_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Signbit_doReturnFn func() bool

// MoqFloat_starGenType_Signbit_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_Signbit_results struct {
	Params  MoqFloat_starGenType_Signbit_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Signbit_doFn
		DoReturnFn MoqFloat_starGenType_Signbit_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Signbit_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_Signbit_fnRecorder struct {
	Params    MoqFloat_starGenType_Signbit_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Signbit_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Signbit_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_Signbit_anyParams struct {
	Recorder *MoqFloat_starGenType_Signbit_fnRecorder
}

// MoqFloat_starGenType_IsInf_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_IsInf_params struct{}

// MoqFloat_starGenType_IsInf_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_IsInf_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_IsInf_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_IsInf_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_IsInf_paramsKey]*MoqFloat_starGenType_IsInf_results
}

// MoqFloat_starGenType_IsInf_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_IsInf_doFn func()

// MoqFloat_starGenType_IsInf_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_IsInf_doReturnFn func() bool

// MoqFloat_starGenType_IsInf_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_IsInf_results struct {
	Params  MoqFloat_starGenType_IsInf_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_IsInf_doFn
		DoReturnFn MoqFloat_starGenType_IsInf_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_IsInf_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_IsInf_fnRecorder struct {
	Params    MoqFloat_starGenType_IsInf_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_IsInf_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_IsInf_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_IsInf_anyParams struct {
	Recorder *MoqFloat_starGenType_IsInf_fnRecorder
}

// MoqFloat_starGenType_IsInt_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_IsInt_params struct{}

// MoqFloat_starGenType_IsInt_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_IsInt_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_IsInt_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_IsInt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_IsInt_paramsKey]*MoqFloat_starGenType_IsInt_results
}

// MoqFloat_starGenType_IsInt_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_IsInt_doFn func()

// MoqFloat_starGenType_IsInt_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_IsInt_doReturnFn func() bool

// MoqFloat_starGenType_IsInt_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_IsInt_results struct {
	Params  MoqFloat_starGenType_IsInt_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_IsInt_doFn
		DoReturnFn MoqFloat_starGenType_IsInt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_IsInt_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_IsInt_fnRecorder struct {
	Params    MoqFloat_starGenType_IsInt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_IsInt_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_IsInt_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_IsInt_anyParams struct {
	Recorder *MoqFloat_starGenType_IsInt_fnRecorder
}

// MoqFloat_starGenType_SetUint64_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_SetUint64_params struct{ X uint64 }

// MoqFloat_starGenType_SetUint64_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_SetUint64_paramsKey struct {
	Params struct{ X uint64 }
	Hashes struct{ X hash.Hash }
}

// MoqFloat_starGenType_SetUint64_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_SetUint64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_SetUint64_paramsKey]*MoqFloat_starGenType_SetUint64_results
}

// MoqFloat_starGenType_SetUint64_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_SetUint64_doFn func(x uint64)

// MoqFloat_starGenType_SetUint64_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_SetUint64_doReturnFn func(x uint64) *big.Float

// MoqFloat_starGenType_SetUint64_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_SetUint64_results struct {
	Params  MoqFloat_starGenType_SetUint64_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetUint64_doFn
		DoReturnFn MoqFloat_starGenType_SetUint64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_SetUint64_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_SetUint64_fnRecorder struct {
	Params    MoqFloat_starGenType_SetUint64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_SetUint64_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_SetUint64_anyParams isolates the any params functions
// of the Float_starGenType type
type MoqFloat_starGenType_SetUint64_anyParams struct {
	Recorder *MoqFloat_starGenType_SetUint64_fnRecorder
}

// MoqFloat_starGenType_SetInt64_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_SetInt64_params struct{ X int64 }

// MoqFloat_starGenType_SetInt64_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_SetInt64_paramsKey struct {
	Params struct{ X int64 }
	Hashes struct{ X hash.Hash }
}

// MoqFloat_starGenType_SetInt64_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_SetInt64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_SetInt64_paramsKey]*MoqFloat_starGenType_SetInt64_results
}

// MoqFloat_starGenType_SetInt64_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_SetInt64_doFn func(x int64)

// MoqFloat_starGenType_SetInt64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_SetInt64_doReturnFn func(x int64) *big.Float

// MoqFloat_starGenType_SetInt64_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_SetInt64_results struct {
	Params  MoqFloat_starGenType_SetInt64_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetInt64_doFn
		DoReturnFn MoqFloat_starGenType_SetInt64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_SetInt64_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_SetInt64_fnRecorder struct {
	Params    MoqFloat_starGenType_SetInt64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_SetInt64_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_SetInt64_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_SetInt64_anyParams struct {
	Recorder *MoqFloat_starGenType_SetInt64_fnRecorder
}

// MoqFloat_starGenType_SetFloat64_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_SetFloat64_params struct{ X float64 }

// MoqFloat_starGenType_SetFloat64_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_SetFloat64_paramsKey struct {
	Params struct{ X float64 }
	Hashes struct{ X hash.Hash }
}

// MoqFloat_starGenType_SetFloat64_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_SetFloat64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_SetFloat64_paramsKey]*MoqFloat_starGenType_SetFloat64_results
}

// MoqFloat_starGenType_SetFloat64_doFn defines the type of function needed
// when calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_SetFloat64_doFn func(x float64)

// MoqFloat_starGenType_SetFloat64_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_SetFloat64_doReturnFn func(x float64) *big.Float

// MoqFloat_starGenType_SetFloat64_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_SetFloat64_results struct {
	Params  MoqFloat_starGenType_SetFloat64_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetFloat64_doFn
		DoReturnFn MoqFloat_starGenType_SetFloat64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_SetFloat64_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_SetFloat64_fnRecorder struct {
	Params    MoqFloat_starGenType_SetFloat64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_SetFloat64_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_SetFloat64_anyParams isolates the any params functions
// of the Float_starGenType type
type MoqFloat_starGenType_SetFloat64_anyParams struct {
	Recorder *MoqFloat_starGenType_SetFloat64_fnRecorder
}

// MoqFloat_starGenType_SetInt_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_SetInt_params struct{ X *big.Int }

// MoqFloat_starGenType_SetInt_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_SetInt_paramsKey struct {
	Params struct{ X *big.Int }
	Hashes struct{ X hash.Hash }
}

// MoqFloat_starGenType_SetInt_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_SetInt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_SetInt_paramsKey]*MoqFloat_starGenType_SetInt_results
}

// MoqFloat_starGenType_SetInt_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_SetInt_doFn func(x *big.Int)

// MoqFloat_starGenType_SetInt_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_SetInt_doReturnFn func(x *big.Int) *big.Float

// MoqFloat_starGenType_SetInt_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_SetInt_results struct {
	Params  MoqFloat_starGenType_SetInt_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetInt_doFn
		DoReturnFn MoqFloat_starGenType_SetInt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_SetInt_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_SetInt_fnRecorder struct {
	Params    MoqFloat_starGenType_SetInt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_SetInt_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_SetInt_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_SetInt_anyParams struct {
	Recorder *MoqFloat_starGenType_SetInt_fnRecorder
}

// MoqFloat_starGenType_SetRat_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_SetRat_params struct{ X *big.Rat }

// MoqFloat_starGenType_SetRat_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_SetRat_paramsKey struct {
	Params struct{ X *big.Rat }
	Hashes struct{ X hash.Hash }
}

// MoqFloat_starGenType_SetRat_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_SetRat_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_SetRat_paramsKey]*MoqFloat_starGenType_SetRat_results
}

// MoqFloat_starGenType_SetRat_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_SetRat_doFn func(x *big.Rat)

// MoqFloat_starGenType_SetRat_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_SetRat_doReturnFn func(x *big.Rat) *big.Float

// MoqFloat_starGenType_SetRat_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_SetRat_results struct {
	Params  MoqFloat_starGenType_SetRat_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetRat_doFn
		DoReturnFn MoqFloat_starGenType_SetRat_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_SetRat_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_SetRat_fnRecorder struct {
	Params    MoqFloat_starGenType_SetRat_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_SetRat_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_SetRat_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_SetRat_anyParams struct {
	Recorder *MoqFloat_starGenType_SetRat_fnRecorder
}

// MoqFloat_starGenType_SetInf_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_SetInf_params struct{ Signbit bool }

// MoqFloat_starGenType_SetInf_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_SetInf_paramsKey struct {
	Params struct{ Signbit bool }
	Hashes struct{ Signbit hash.Hash }
}

// MoqFloat_starGenType_SetInf_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_SetInf_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_SetInf_paramsKey]*MoqFloat_starGenType_SetInf_results
}

// MoqFloat_starGenType_SetInf_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_SetInf_doFn func(signbit bool)

// MoqFloat_starGenType_SetInf_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_SetInf_doReturnFn func(signbit bool) *big.Float

// MoqFloat_starGenType_SetInf_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_SetInf_results struct {
	Params  MoqFloat_starGenType_SetInf_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetInf_doFn
		DoReturnFn MoqFloat_starGenType_SetInf_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_SetInf_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_SetInf_fnRecorder struct {
	Params    MoqFloat_starGenType_SetInf_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_SetInf_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_SetInf_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_SetInf_anyParams struct {
	Recorder *MoqFloat_starGenType_SetInf_fnRecorder
}

// MoqFloat_starGenType_Set_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Set_params struct{ X *big.Float }

// MoqFloat_starGenType_Set_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Set_paramsKey struct {
	Params struct{ X *big.Float }
	Hashes struct{ X hash.Hash }
}

// MoqFloat_starGenType_Set_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Set_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Set_paramsKey]*MoqFloat_starGenType_Set_results
}

// MoqFloat_starGenType_Set_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Set_doFn func(x *big.Float)

// MoqFloat_starGenType_Set_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Set_doReturnFn func(x *big.Float) *big.Float

// MoqFloat_starGenType_Set_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Set_results struct {
	Params  MoqFloat_starGenType_Set_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Set_doFn
		DoReturnFn MoqFloat_starGenType_Set_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Set_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Set_fnRecorder struct {
	Params    MoqFloat_starGenType_Set_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Set_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Set_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Set_anyParams struct {
	Recorder *MoqFloat_starGenType_Set_fnRecorder
}

// MoqFloat_starGenType_Copy_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Copy_params struct{ X *big.Float }

// MoqFloat_starGenType_Copy_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Copy_paramsKey struct {
	Params struct{ X *big.Float }
	Hashes struct{ X hash.Hash }
}

// MoqFloat_starGenType_Copy_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Copy_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Copy_paramsKey]*MoqFloat_starGenType_Copy_results
}

// MoqFloat_starGenType_Copy_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Copy_doFn func(x *big.Float)

// MoqFloat_starGenType_Copy_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Copy_doReturnFn func(x *big.Float) *big.Float

// MoqFloat_starGenType_Copy_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Copy_results struct {
	Params  MoqFloat_starGenType_Copy_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Copy_doFn
		DoReturnFn MoqFloat_starGenType_Copy_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Copy_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Copy_fnRecorder struct {
	Params    MoqFloat_starGenType_Copy_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Copy_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Copy_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Copy_anyParams struct {
	Recorder *MoqFloat_starGenType_Copy_fnRecorder
}

// MoqFloat_starGenType_Uint64_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Uint64_params struct{}

// MoqFloat_starGenType_Uint64_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Uint64_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_Uint64_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Uint64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Uint64_paramsKey]*MoqFloat_starGenType_Uint64_results
}

// MoqFloat_starGenType_Uint64_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Uint64_doFn func()

// MoqFloat_starGenType_Uint64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Uint64_doReturnFn func() (uint64, big.Accuracy)

// MoqFloat_starGenType_Uint64_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_Uint64_results struct {
	Params  MoqFloat_starGenType_Uint64_params
	Results []struct {
		Values *struct {
			Result1 uint64
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Uint64_doFn
		DoReturnFn MoqFloat_starGenType_Uint64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Uint64_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Uint64_fnRecorder struct {
	Params    MoqFloat_starGenType_Uint64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Uint64_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Uint64_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_Uint64_anyParams struct {
	Recorder *MoqFloat_starGenType_Uint64_fnRecorder
}

// MoqFloat_starGenType_Int64_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Int64_params struct{}

// MoqFloat_starGenType_Int64_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Int64_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_Int64_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Int64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Int64_paramsKey]*MoqFloat_starGenType_Int64_results
}

// MoqFloat_starGenType_Int64_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Int64_doFn func()

// MoqFloat_starGenType_Int64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Int64_doReturnFn func() (int64, big.Accuracy)

// MoqFloat_starGenType_Int64_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_Int64_results struct {
	Params  MoqFloat_starGenType_Int64_params
	Results []struct {
		Values *struct {
			Result1 int64
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Int64_doFn
		DoReturnFn MoqFloat_starGenType_Int64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Int64_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Int64_fnRecorder struct {
	Params    MoqFloat_starGenType_Int64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Int64_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Int64_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_Int64_anyParams struct {
	Recorder *MoqFloat_starGenType_Int64_fnRecorder
}

// MoqFloat_starGenType_Float32_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_Float32_params struct{}

// MoqFloat_starGenType_Float32_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Float32_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_Float32_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Float32_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Float32_paramsKey]*MoqFloat_starGenType_Float32_results
}

// MoqFloat_starGenType_Float32_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Float32_doFn func()

// MoqFloat_starGenType_Float32_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Float32_doReturnFn func() (float32, big.Accuracy)

// MoqFloat_starGenType_Float32_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_Float32_results struct {
	Params  MoqFloat_starGenType_Float32_params
	Results []struct {
		Values *struct {
			Result1 float32
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Float32_doFn
		DoReturnFn MoqFloat_starGenType_Float32_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Float32_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_Float32_fnRecorder struct {
	Params    MoqFloat_starGenType_Float32_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Float32_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Float32_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_Float32_anyParams struct {
	Recorder *MoqFloat_starGenType_Float32_fnRecorder
}

// MoqFloat_starGenType_Float64_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_Float64_params struct{}

// MoqFloat_starGenType_Float64_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Float64_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_Float64_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Float64_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Float64_paramsKey]*MoqFloat_starGenType_Float64_results
}

// MoqFloat_starGenType_Float64_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Float64_doFn func()

// MoqFloat_starGenType_Float64_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Float64_doReturnFn func() (float64, big.Accuracy)

// MoqFloat_starGenType_Float64_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_Float64_results struct {
	Params  MoqFloat_starGenType_Float64_params
	Results []struct {
		Values *struct {
			Result1 float64
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Float64_doFn
		DoReturnFn MoqFloat_starGenType_Float64_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Float64_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_Float64_fnRecorder struct {
	Params    MoqFloat_starGenType_Float64_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Float64_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Float64_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_Float64_anyParams struct {
	Recorder *MoqFloat_starGenType_Float64_fnRecorder
}

// MoqFloat_starGenType_Int_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Int_params struct{ Z *big.Int }

// MoqFloat_starGenType_Int_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Int_paramsKey struct {
	Params struct{ Z *big.Int }
	Hashes struct{ Z hash.Hash }
}

// MoqFloat_starGenType_Int_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Int_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Int_paramsKey]*MoqFloat_starGenType_Int_results
}

// MoqFloat_starGenType_Int_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Int_doFn func(z *big.Int)

// MoqFloat_starGenType_Int_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Int_doReturnFn func(z *big.Int) (*big.Int, big.Accuracy)

// MoqFloat_starGenType_Int_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Int_results struct {
	Params  MoqFloat_starGenType_Int_params
	Results []struct {
		Values *struct {
			Result1 *big.Int
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Int_doFn
		DoReturnFn MoqFloat_starGenType_Int_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Int_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Int_fnRecorder struct {
	Params    MoqFloat_starGenType_Int_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Int_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Int_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Int_anyParams struct {
	Recorder *MoqFloat_starGenType_Int_fnRecorder
}

// MoqFloat_starGenType_Rat_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Rat_params struct{ Z *big.Rat }

// MoqFloat_starGenType_Rat_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Rat_paramsKey struct {
	Params struct{ Z *big.Rat }
	Hashes struct{ Z hash.Hash }
}

// MoqFloat_starGenType_Rat_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Rat_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Rat_paramsKey]*MoqFloat_starGenType_Rat_results
}

// MoqFloat_starGenType_Rat_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Rat_doFn func(z *big.Rat)

// MoqFloat_starGenType_Rat_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Rat_doReturnFn func(z *big.Rat) (*big.Rat, big.Accuracy)

// MoqFloat_starGenType_Rat_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Rat_results struct {
	Params  MoqFloat_starGenType_Rat_params
	Results []struct {
		Values *struct {
			Result1 *big.Rat
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Rat_doFn
		DoReturnFn MoqFloat_starGenType_Rat_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Rat_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Rat_fnRecorder struct {
	Params    MoqFloat_starGenType_Rat_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Rat_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Rat_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Rat_anyParams struct {
	Recorder *MoqFloat_starGenType_Rat_fnRecorder
}

// MoqFloat_starGenType_Abs_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Abs_params struct{ X *big.Float }

// MoqFloat_starGenType_Abs_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Abs_paramsKey struct {
	Params struct{ X *big.Float }
	Hashes struct{ X hash.Hash }
}

// MoqFloat_starGenType_Abs_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Abs_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Abs_paramsKey]*MoqFloat_starGenType_Abs_results
}

// MoqFloat_starGenType_Abs_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Abs_doFn func(x *big.Float)

// MoqFloat_starGenType_Abs_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Abs_doReturnFn func(x *big.Float) *big.Float

// MoqFloat_starGenType_Abs_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Abs_results struct {
	Params  MoqFloat_starGenType_Abs_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Abs_doFn
		DoReturnFn MoqFloat_starGenType_Abs_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Abs_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Abs_fnRecorder struct {
	Params    MoqFloat_starGenType_Abs_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Abs_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Abs_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Abs_anyParams struct {
	Recorder *MoqFloat_starGenType_Abs_fnRecorder
}

// MoqFloat_starGenType_Neg_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Neg_params struct{ X *big.Float }

// MoqFloat_starGenType_Neg_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Neg_paramsKey struct {
	Params struct{ X *big.Float }
	Hashes struct{ X hash.Hash }
}

// MoqFloat_starGenType_Neg_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Neg_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Neg_paramsKey]*MoqFloat_starGenType_Neg_results
}

// MoqFloat_starGenType_Neg_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Neg_doFn func(x *big.Float)

// MoqFloat_starGenType_Neg_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Neg_doReturnFn func(x *big.Float) *big.Float

// MoqFloat_starGenType_Neg_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Neg_results struct {
	Params  MoqFloat_starGenType_Neg_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Neg_doFn
		DoReturnFn MoqFloat_starGenType_Neg_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Neg_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Neg_fnRecorder struct {
	Params    MoqFloat_starGenType_Neg_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Neg_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Neg_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Neg_anyParams struct {
	Recorder *MoqFloat_starGenType_Neg_fnRecorder
}

// MoqFloat_starGenType_Add_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Add_params struct{ X, Y *big.Float }

// MoqFloat_starGenType_Add_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Add_paramsKey struct {
	Params struct{ X, Y *big.Float }
	Hashes struct{ X, Y hash.Hash }
}

// MoqFloat_starGenType_Add_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Add_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Add_paramsKey]*MoqFloat_starGenType_Add_results
}

// MoqFloat_starGenType_Add_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Add_doFn func(x, y *big.Float)

// MoqFloat_starGenType_Add_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Add_doReturnFn func(x, y *big.Float) *big.Float

// MoqFloat_starGenType_Add_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Add_results struct {
	Params  MoqFloat_starGenType_Add_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Add_doFn
		DoReturnFn MoqFloat_starGenType_Add_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Add_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Add_fnRecorder struct {
	Params    MoqFloat_starGenType_Add_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Add_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Add_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Add_anyParams struct {
	Recorder *MoqFloat_starGenType_Add_fnRecorder
}

// MoqFloat_starGenType_Sub_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Sub_params struct{ X, Y *big.Float }

// MoqFloat_starGenType_Sub_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Sub_paramsKey struct {
	Params struct{ X, Y *big.Float }
	Hashes struct{ X, Y hash.Hash }
}

// MoqFloat_starGenType_Sub_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Sub_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Sub_paramsKey]*MoqFloat_starGenType_Sub_results
}

// MoqFloat_starGenType_Sub_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Sub_doFn func(x, y *big.Float)

// MoqFloat_starGenType_Sub_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Sub_doReturnFn func(x, y *big.Float) *big.Float

// MoqFloat_starGenType_Sub_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Sub_results struct {
	Params  MoqFloat_starGenType_Sub_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Sub_doFn
		DoReturnFn MoqFloat_starGenType_Sub_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Sub_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Sub_fnRecorder struct {
	Params    MoqFloat_starGenType_Sub_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Sub_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Sub_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Sub_anyParams struct {
	Recorder *MoqFloat_starGenType_Sub_fnRecorder
}

// MoqFloat_starGenType_Mul_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Mul_params struct{ X, Y *big.Float }

// MoqFloat_starGenType_Mul_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Mul_paramsKey struct {
	Params struct{ X, Y *big.Float }
	Hashes struct{ X, Y hash.Hash }
}

// MoqFloat_starGenType_Mul_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Mul_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Mul_paramsKey]*MoqFloat_starGenType_Mul_results
}

// MoqFloat_starGenType_Mul_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Mul_doFn func(x, y *big.Float)

// MoqFloat_starGenType_Mul_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Mul_doReturnFn func(x, y *big.Float) *big.Float

// MoqFloat_starGenType_Mul_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Mul_results struct {
	Params  MoqFloat_starGenType_Mul_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Mul_doFn
		DoReturnFn MoqFloat_starGenType_Mul_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Mul_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Mul_fnRecorder struct {
	Params    MoqFloat_starGenType_Mul_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Mul_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Mul_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Mul_anyParams struct {
	Recorder *MoqFloat_starGenType_Mul_fnRecorder
}

// MoqFloat_starGenType_Quo_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Quo_params struct{ X, Y *big.Float }

// MoqFloat_starGenType_Quo_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Quo_paramsKey struct {
	Params struct{ X, Y *big.Float }
	Hashes struct{ X, Y hash.Hash }
}

// MoqFloat_starGenType_Quo_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Quo_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Quo_paramsKey]*MoqFloat_starGenType_Quo_results
}

// MoqFloat_starGenType_Quo_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Quo_doFn func(x, y *big.Float)

// MoqFloat_starGenType_Quo_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Quo_doReturnFn func(x, y *big.Float) *big.Float

// MoqFloat_starGenType_Quo_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Quo_results struct {
	Params  MoqFloat_starGenType_Quo_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Quo_doFn
		DoReturnFn MoqFloat_starGenType_Quo_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Quo_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Quo_fnRecorder struct {
	Params    MoqFloat_starGenType_Quo_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Quo_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Quo_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Quo_anyParams struct {
	Recorder *MoqFloat_starGenType_Quo_fnRecorder
}

// MoqFloat_starGenType_Cmp_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Cmp_params struct{ Y *big.Float }

// MoqFloat_starGenType_Cmp_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Cmp_paramsKey struct {
	Params struct{ Y *big.Float }
	Hashes struct{ Y hash.Hash }
}

// MoqFloat_starGenType_Cmp_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Cmp_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Cmp_paramsKey]*MoqFloat_starGenType_Cmp_results
}

// MoqFloat_starGenType_Cmp_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Cmp_doFn func(y *big.Float)

// MoqFloat_starGenType_Cmp_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Cmp_doReturnFn func(y *big.Float) int

// MoqFloat_starGenType_Cmp_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Cmp_results struct {
	Params  MoqFloat_starGenType_Cmp_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Cmp_doFn
		DoReturnFn MoqFloat_starGenType_Cmp_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Cmp_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Cmp_fnRecorder struct {
	Params    MoqFloat_starGenType_Cmp_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Cmp_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Cmp_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Cmp_anyParams struct {
	Recorder *MoqFloat_starGenType_Cmp_fnRecorder
}

// MoqFloat_starGenType_SetString_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_SetString_params struct{ S string }

// MoqFloat_starGenType_SetString_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_SetString_paramsKey struct {
	Params struct{ S string }
	Hashes struct{ S hash.Hash }
}

// MoqFloat_starGenType_SetString_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_SetString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_SetString_paramsKey]*MoqFloat_starGenType_SetString_results
}

// MoqFloat_starGenType_SetString_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_SetString_doFn func(s string)

// MoqFloat_starGenType_SetString_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_SetString_doReturnFn func(s string) (*big.Float, bool)

// MoqFloat_starGenType_SetString_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_SetString_results struct {
	Params  MoqFloat_starGenType_SetString_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetString_doFn
		DoReturnFn MoqFloat_starGenType_SetString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_SetString_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_SetString_fnRecorder struct {
	Params    MoqFloat_starGenType_SetString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_SetString_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_SetString_anyParams isolates the any params functions
// of the Float_starGenType type
type MoqFloat_starGenType_SetString_anyParams struct {
	Recorder *MoqFloat_starGenType_SetString_fnRecorder
}

// MoqFloat_starGenType_Parse_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Parse_params struct {
	S    string
	Base int
}

// MoqFloat_starGenType_Parse_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Parse_paramsKey struct {
	Params struct {
		S    string
		Base int
	}
	Hashes struct {
		S    hash.Hash
		Base hash.Hash
	}
}

// MoqFloat_starGenType_Parse_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Parse_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Parse_paramsKey]*MoqFloat_starGenType_Parse_results
}

// MoqFloat_starGenType_Parse_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Parse_doFn func(s string, base int)

// MoqFloat_starGenType_Parse_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Parse_doReturnFn func(s string, base int) (f *big.Float, b int, err error)

// MoqFloat_starGenType_Parse_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_Parse_results struct {
	Params  MoqFloat_starGenType_Parse_params
	Results []struct {
		Values *struct {
			F   *big.Float
			B   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Parse_doFn
		DoReturnFn MoqFloat_starGenType_Parse_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Parse_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Parse_fnRecorder struct {
	Params    MoqFloat_starGenType_Parse_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Parse_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Parse_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_Parse_anyParams struct {
	Recorder *MoqFloat_starGenType_Parse_fnRecorder
}

// MoqFloat_starGenType_Scan_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Scan_params struct {
	S  fmt.ScanState
	Ch rune
}

// MoqFloat_starGenType_Scan_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Scan_paramsKey struct {
	Params struct {
		S  fmt.ScanState
		Ch rune
	}
	Hashes struct {
		S  hash.Hash
		Ch hash.Hash
	}
}

// MoqFloat_starGenType_Scan_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Scan_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Scan_paramsKey]*MoqFloat_starGenType_Scan_results
}

// MoqFloat_starGenType_Scan_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Scan_doFn func(s fmt.ScanState, ch rune)

// MoqFloat_starGenType_Scan_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Scan_doReturnFn func(s fmt.ScanState, ch rune) error

// MoqFloat_starGenType_Scan_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Scan_results struct {
	Params  MoqFloat_starGenType_Scan_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Scan_doFn
		DoReturnFn MoqFloat_starGenType_Scan_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Scan_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Scan_fnRecorder struct {
	Params    MoqFloat_starGenType_Scan_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Scan_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Scan_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Scan_anyParams struct {
	Recorder *MoqFloat_starGenType_Scan_fnRecorder
}

// MoqFloat_starGenType_GobEncode_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_GobEncode_params struct{}

// MoqFloat_starGenType_GobEncode_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_GobEncode_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_GobEncode_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_GobEncode_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_GobEncode_paramsKey]*MoqFloat_starGenType_GobEncode_results
}

// MoqFloat_starGenType_GobEncode_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_GobEncode_doFn func()

// MoqFloat_starGenType_GobEncode_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_GobEncode_doReturnFn func() ([]byte, error)

// MoqFloat_starGenType_GobEncode_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_GobEncode_results struct {
	Params  MoqFloat_starGenType_GobEncode_params
	Results []struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_GobEncode_doFn
		DoReturnFn MoqFloat_starGenType_GobEncode_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_GobEncode_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_GobEncode_fnRecorder struct {
	Params    MoqFloat_starGenType_GobEncode_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_GobEncode_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_GobEncode_anyParams isolates the any params functions
// of the Float_starGenType type
type MoqFloat_starGenType_GobEncode_anyParams struct {
	Recorder *MoqFloat_starGenType_GobEncode_fnRecorder
}

// MoqFloat_starGenType_GobDecode_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_GobDecode_params struct{ Buf []byte }

// MoqFloat_starGenType_GobDecode_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_GobDecode_paramsKey struct {
	Params struct{}
	Hashes struct{ Buf hash.Hash }
}

// MoqFloat_starGenType_GobDecode_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_GobDecode_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_GobDecode_paramsKey]*MoqFloat_starGenType_GobDecode_results
}

// MoqFloat_starGenType_GobDecode_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_GobDecode_doFn func(buf []byte)

// MoqFloat_starGenType_GobDecode_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_GobDecode_doReturnFn func(buf []byte) error

// MoqFloat_starGenType_GobDecode_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_GobDecode_results struct {
	Params  MoqFloat_starGenType_GobDecode_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_GobDecode_doFn
		DoReturnFn MoqFloat_starGenType_GobDecode_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_GobDecode_fnRecorder routes recorded function calls to
// the MoqFloat_starGenType moq
type MoqFloat_starGenType_GobDecode_fnRecorder struct {
	Params    MoqFloat_starGenType_GobDecode_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_GobDecode_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_GobDecode_anyParams isolates the any params functions
// of the Float_starGenType type
type MoqFloat_starGenType_GobDecode_anyParams struct {
	Recorder *MoqFloat_starGenType_GobDecode_fnRecorder
}

// MoqFloat_starGenType_MarshalText_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_MarshalText_params struct{}

// MoqFloat_starGenType_MarshalText_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_MarshalText_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_MarshalText_resultsByParams contains the results for a
// given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_MarshalText_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_MarshalText_paramsKey]*MoqFloat_starGenType_MarshalText_results
}

// MoqFloat_starGenType_MarshalText_doFn defines the type of function needed
// when calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_MarshalText_doFn func()

// MoqFloat_starGenType_MarshalText_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_MarshalText_doReturnFn func() (text []byte, err error)

// MoqFloat_starGenType_MarshalText_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_MarshalText_results struct {
	Params  MoqFloat_starGenType_MarshalText_params
	Results []struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_MarshalText_doFn
		DoReturnFn MoqFloat_starGenType_MarshalText_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_MarshalText_fnRecorder routes recorded function calls
// to the MoqFloat_starGenType moq
type MoqFloat_starGenType_MarshalText_fnRecorder struct {
	Params    MoqFloat_starGenType_MarshalText_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_MarshalText_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_MarshalText_anyParams isolates the any params functions
// of the Float_starGenType type
type MoqFloat_starGenType_MarshalText_anyParams struct {
	Recorder *MoqFloat_starGenType_MarshalText_fnRecorder
}

// MoqFloat_starGenType_UnmarshalText_params holds the params of the
// Float_starGenType type
type MoqFloat_starGenType_UnmarshalText_params struct{ Text []byte }

// MoqFloat_starGenType_UnmarshalText_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_UnmarshalText_paramsKey struct {
	Params struct{}
	Hashes struct{ Text hash.Hash }
}

// MoqFloat_starGenType_UnmarshalText_resultsByParams contains the results for
// a given set of parameters for the Float_starGenType type
type MoqFloat_starGenType_UnmarshalText_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_UnmarshalText_paramsKey]*MoqFloat_starGenType_UnmarshalText_results
}

// MoqFloat_starGenType_UnmarshalText_doFn defines the type of function needed
// when calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_UnmarshalText_doFn func(text []byte)

// MoqFloat_starGenType_UnmarshalText_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_UnmarshalText_doReturnFn func(text []byte) error

// MoqFloat_starGenType_UnmarshalText_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_UnmarshalText_results struct {
	Params  MoqFloat_starGenType_UnmarshalText_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_UnmarshalText_doFn
		DoReturnFn MoqFloat_starGenType_UnmarshalText_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_UnmarshalText_fnRecorder routes recorded function calls
// to the MoqFloat_starGenType moq
type MoqFloat_starGenType_UnmarshalText_fnRecorder struct {
	Params    MoqFloat_starGenType_UnmarshalText_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_UnmarshalText_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_UnmarshalText_anyParams isolates the any params
// functions of the Float_starGenType type
type MoqFloat_starGenType_UnmarshalText_anyParams struct {
	Recorder *MoqFloat_starGenType_UnmarshalText_fnRecorder
}

// MoqFloat_starGenType_Text_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Text_params struct {
	Format byte
	Prec   int
}

// MoqFloat_starGenType_Text_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Text_paramsKey struct {
	Params struct {
		Format byte
		Prec   int
	}
	Hashes struct {
		Format hash.Hash
		Prec   hash.Hash
	}
}

// MoqFloat_starGenType_Text_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Text_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Text_paramsKey]*MoqFloat_starGenType_Text_results
}

// MoqFloat_starGenType_Text_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Text_doFn func(format byte, prec int)

// MoqFloat_starGenType_Text_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Text_doReturnFn func(format byte, prec int) string

// MoqFloat_starGenType_Text_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Text_results struct {
	Params  MoqFloat_starGenType_Text_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Text_doFn
		DoReturnFn MoqFloat_starGenType_Text_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Text_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Text_fnRecorder struct {
	Params    MoqFloat_starGenType_Text_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Text_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Text_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Text_anyParams struct {
	Recorder *MoqFloat_starGenType_Text_fnRecorder
}

// MoqFloat_starGenType_String_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_String_params struct{}

// MoqFloat_starGenType_String_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFloat_starGenType_String_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_String_paramsKey]*MoqFloat_starGenType_String_results
}

// MoqFloat_starGenType_String_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_String_doFn func()

// MoqFloat_starGenType_String_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_String_doReturnFn func() string

// MoqFloat_starGenType_String_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_String_results struct {
	Params  MoqFloat_starGenType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_String_doFn
		DoReturnFn MoqFloat_starGenType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_String_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_String_fnRecorder struct {
	Params    MoqFloat_starGenType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_String_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_String_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_String_anyParams struct {
	Recorder *MoqFloat_starGenType_String_fnRecorder
}

// MoqFloat_starGenType_Append_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Append_params struct {
	Buf  []byte
	Fmt  byte
	Prec int
}

// MoqFloat_starGenType_Append_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Append_paramsKey struct {
	Params struct {
		Fmt  byte
		Prec int
	}
	Hashes struct {
		Buf  hash.Hash
		Fmt  hash.Hash
		Prec hash.Hash
	}
}

// MoqFloat_starGenType_Append_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Append_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Append_paramsKey]*MoqFloat_starGenType_Append_results
}

// MoqFloat_starGenType_Append_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Append_doFn func(buf []byte, fmt byte, prec int)

// MoqFloat_starGenType_Append_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Append_doReturnFn func(buf []byte, fmt byte, prec int) []byte

// MoqFloat_starGenType_Append_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_Append_results struct {
	Params  MoqFloat_starGenType_Append_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Append_doFn
		DoReturnFn MoqFloat_starGenType_Append_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Append_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Append_fnRecorder struct {
	Params    MoqFloat_starGenType_Append_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Append_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Append_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_Append_anyParams struct {
	Recorder *MoqFloat_starGenType_Append_fnRecorder
}

// MoqFloat_starGenType_Format_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Format_params struct {
	S      fmt.State
	Format rune
}

// MoqFloat_starGenType_Format_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Format_paramsKey struct {
	Params struct {
		S      fmt.State
		Format rune
	}
	Hashes struct {
		S      hash.Hash
		Format hash.Hash
	}
}

// MoqFloat_starGenType_Format_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Format_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Format_paramsKey]*MoqFloat_starGenType_Format_results
}

// MoqFloat_starGenType_Format_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Format_doFn func(s fmt.State, format rune)

// MoqFloat_starGenType_Format_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Format_doReturnFn func(s fmt.State, format rune)

// MoqFloat_starGenType_Format_results holds the results of the
// Float_starGenType type
type MoqFloat_starGenType_Format_results struct {
	Params  MoqFloat_starGenType_Format_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Format_doFn
		DoReturnFn MoqFloat_starGenType_Format_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Format_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Format_fnRecorder struct {
	Params    MoqFloat_starGenType_Format_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Format_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Format_anyParams isolates the any params functions of
// the Float_starGenType type
type MoqFloat_starGenType_Format_anyParams struct {
	Recorder *MoqFloat_starGenType_Format_fnRecorder
}

// MoqFloat_starGenType_Sqrt_params holds the params of the Float_starGenType
// type
type MoqFloat_starGenType_Sqrt_params struct{ X *big.Float }

// MoqFloat_starGenType_Sqrt_paramsKey holds the map key params of the
// Float_starGenType type
type MoqFloat_starGenType_Sqrt_paramsKey struct {
	Params struct{ X *big.Float }
	Hashes struct{ X hash.Hash }
}

// MoqFloat_starGenType_Sqrt_resultsByParams contains the results for a given
// set of parameters for the Float_starGenType type
type MoqFloat_starGenType_Sqrt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFloat_starGenType_Sqrt_paramsKey]*MoqFloat_starGenType_Sqrt_results
}

// MoqFloat_starGenType_Sqrt_doFn defines the type of function needed when
// calling AndDo for the Float_starGenType type
type MoqFloat_starGenType_Sqrt_doFn func(x *big.Float)

// MoqFloat_starGenType_Sqrt_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Float_starGenType type
type MoqFloat_starGenType_Sqrt_doReturnFn func(x *big.Float) *big.Float

// MoqFloat_starGenType_Sqrt_results holds the results of the Float_starGenType
// type
type MoqFloat_starGenType_Sqrt_results struct {
	Params  MoqFloat_starGenType_Sqrt_params
	Results []struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Sqrt_doFn
		DoReturnFn MoqFloat_starGenType_Sqrt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFloat_starGenType_Sqrt_fnRecorder routes recorded function calls to the
// MoqFloat_starGenType moq
type MoqFloat_starGenType_Sqrt_fnRecorder struct {
	Params    MoqFloat_starGenType_Sqrt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFloat_starGenType_Sqrt_results
	Moq       *MoqFloat_starGenType
}

// MoqFloat_starGenType_Sqrt_anyParams isolates the any params functions of the
// Float_starGenType type
type MoqFloat_starGenType_Sqrt_anyParams struct {
	Recorder *MoqFloat_starGenType_Sqrt_fnRecorder
}

// NewMoqFloat_starGenType creates a new moq of the Float_starGenType type
func NewMoqFloat_starGenType(scene *moq.Scene, config *moq.Config) *MoqFloat_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqFloat_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqFloat_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				SetPrec struct {
					Prec moq.ParamIndexing
				}
				SetMode struct {
					Mode moq.ParamIndexing
				}
				Prec    struct{}
				MinPrec struct{}
				Mode    struct{}
				Acc     struct{}
				Sign    struct{}
				MantExp struct {
					Mant moq.ParamIndexing
				}
				SetMantExp struct {
					Mant moq.ParamIndexing
					Exp  moq.ParamIndexing
				}
				Signbit   struct{}
				IsInf     struct{}
				IsInt     struct{}
				SetUint64 struct {
					X moq.ParamIndexing
				}
				SetInt64 struct {
					X moq.ParamIndexing
				}
				SetFloat64 struct {
					X moq.ParamIndexing
				}
				SetInt struct {
					X moq.ParamIndexing
				}
				SetRat struct {
					X moq.ParamIndexing
				}
				SetInf struct {
					Signbit moq.ParamIndexing
				}
				Set struct {
					X moq.ParamIndexing
				}
				Copy struct {
					X moq.ParamIndexing
				}
				Uint64  struct{}
				Int64   struct{}
				Float32 struct{}
				Float64 struct{}
				Int     struct {
					Z moq.ParamIndexing
				}
				Rat struct {
					Z moq.ParamIndexing
				}
				Abs struct {
					X moq.ParamIndexing
				}
				Neg struct {
					X moq.ParamIndexing
				}
				Add struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Sub struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Mul struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Quo struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Cmp struct {
					Y moq.ParamIndexing
				}
				SetString struct {
					S moq.ParamIndexing
				}
				Parse struct {
					S    moq.ParamIndexing
					Base moq.ParamIndexing
				}
				Scan struct {
					S  moq.ParamIndexing
					Ch moq.ParamIndexing
				}
				GobEncode struct{}
				GobDecode struct {
					Buf moq.ParamIndexing
				}
				MarshalText   struct{}
				UnmarshalText struct {
					Text moq.ParamIndexing
				}
				Text struct {
					Format moq.ParamIndexing
					Prec   moq.ParamIndexing
				}
				String struct{}
				Append struct {
					Buf  moq.ParamIndexing
					Fmt  moq.ParamIndexing
					Prec moq.ParamIndexing
				}
				Format struct {
					S      moq.ParamIndexing
					Format moq.ParamIndexing
				}
				Sqrt struct {
					X moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			SetPrec struct {
				Prec moq.ParamIndexing
			}
			SetMode struct {
				Mode moq.ParamIndexing
			}
			Prec    struct{}
			MinPrec struct{}
			Mode    struct{}
			Acc     struct{}
			Sign    struct{}
			MantExp struct {
				Mant moq.ParamIndexing
			}
			SetMantExp struct {
				Mant moq.ParamIndexing
				Exp  moq.ParamIndexing
			}
			Signbit   struct{}
			IsInf     struct{}
			IsInt     struct{}
			SetUint64 struct {
				X moq.ParamIndexing
			}
			SetInt64 struct {
				X moq.ParamIndexing
			}
			SetFloat64 struct {
				X moq.ParamIndexing
			}
			SetInt struct {
				X moq.ParamIndexing
			}
			SetRat struct {
				X moq.ParamIndexing
			}
			SetInf struct {
				Signbit moq.ParamIndexing
			}
			Set struct {
				X moq.ParamIndexing
			}
			Copy struct {
				X moq.ParamIndexing
			}
			Uint64  struct{}
			Int64   struct{}
			Float32 struct{}
			Float64 struct{}
			Int     struct {
				Z moq.ParamIndexing
			}
			Rat struct {
				Z moq.ParamIndexing
			}
			Abs struct {
				X moq.ParamIndexing
			}
			Neg struct {
				X moq.ParamIndexing
			}
			Add struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Sub struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Mul struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Quo struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Cmp struct {
				Y moq.ParamIndexing
			}
			SetString struct {
				S moq.ParamIndexing
			}
			Parse struct {
				S    moq.ParamIndexing
				Base moq.ParamIndexing
			}
			Scan struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}
			GobEncode struct{}
			GobDecode struct {
				Buf moq.ParamIndexing
			}
			MarshalText   struct{}
			UnmarshalText struct {
				Text moq.ParamIndexing
			}
			Text struct {
				Format moq.ParamIndexing
				Prec   moq.ParamIndexing
			}
			String struct{}
			Append struct {
				Buf  moq.ParamIndexing
				Fmt  moq.ParamIndexing
				Prec moq.ParamIndexing
			}
			Format struct {
				S      moq.ParamIndexing
				Format moq.ParamIndexing
			}
			Sqrt struct {
				X moq.ParamIndexing
			}
		}{
			SetPrec: struct {
				Prec moq.ParamIndexing
			}{
				Prec: moq.ParamIndexByValue,
			},
			SetMode: struct {
				Mode moq.ParamIndexing
			}{
				Mode: moq.ParamIndexByValue,
			},
			Prec:    struct{}{},
			MinPrec: struct{}{},
			Mode:    struct{}{},
			Acc:     struct{}{},
			Sign:    struct{}{},
			MantExp: struct {
				Mant moq.ParamIndexing
			}{
				Mant: moq.ParamIndexByHash,
			},
			SetMantExp: struct {
				Mant moq.ParamIndexing
				Exp  moq.ParamIndexing
			}{
				Mant: moq.ParamIndexByHash,
				Exp:  moq.ParamIndexByValue,
			},
			Signbit: struct{}{},
			IsInf:   struct{}{},
			IsInt:   struct{}{},
			SetUint64: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			SetInt64: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			SetFloat64: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			SetInt: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			SetRat: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			SetInf: struct {
				Signbit moq.ParamIndexing
			}{
				Signbit: moq.ParamIndexByValue,
			},
			Set: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Copy: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Uint64:  struct{}{},
			Int64:   struct{}{},
			Float32: struct{}{},
			Float64: struct{}{},
			Int: struct {
				Z moq.ParamIndexing
			}{
				Z: moq.ParamIndexByHash,
			},
			Rat: struct {
				Z moq.ParamIndexing
			}{
				Z: moq.ParamIndexByHash,
			},
			Abs: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Neg: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Add: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Sub: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Mul: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Quo: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
				Y: moq.ParamIndexByHash,
			},
			Cmp: struct {
				Y moq.ParamIndexing
			}{
				Y: moq.ParamIndexByHash,
			},
			SetString: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			Parse: struct {
				S    moq.ParamIndexing
				Base moq.ParamIndexing
			}{
				S:    moq.ParamIndexByValue,
				Base: moq.ParamIndexByValue,
			},
			Scan: struct {
				S  moq.ParamIndexing
				Ch moq.ParamIndexing
			}{
				S:  moq.ParamIndexByHash,
				Ch: moq.ParamIndexByValue,
			},
			GobEncode: struct{}{},
			GobDecode: struct {
				Buf moq.ParamIndexing
			}{
				Buf: moq.ParamIndexByHash,
			},
			MarshalText: struct{}{},
			UnmarshalText: struct {
				Text moq.ParamIndexing
			}{
				Text: moq.ParamIndexByHash,
			},
			Text: struct {
				Format moq.ParamIndexing
				Prec   moq.ParamIndexing
			}{
				Format: moq.ParamIndexByValue,
				Prec:   moq.ParamIndexByValue,
			},
			String: struct{}{},
			Append: struct {
				Buf  moq.ParamIndexing
				Fmt  moq.ParamIndexing
				Prec moq.ParamIndexing
			}{
				Buf:  moq.ParamIndexByHash,
				Fmt:  moq.ParamIndexByValue,
				Prec: moq.ParamIndexByValue,
			},
			Format: struct {
				S      moq.ParamIndexing
				Format moq.ParamIndexing
			}{
				S:      moq.ParamIndexByHash,
				Format: moq.ParamIndexByValue,
			},
			Sqrt: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Float_starGenType type
func (m *MoqFloat_starGenType) Mock() *MoqFloat_starGenType_mock { return m.Moq }

func (m *MoqFloat_starGenType_mock) SetPrec(prec uint) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_SetPrec_params{
		Prec: prec,
	}
	var results *MoqFloat_starGenType_SetPrec_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetPrec {
		paramsKey := m.Moq.ParamsKey_SetPrec(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetPrec(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetPrec(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetPrec(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(prec)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(prec)
	}
	return
}

func (m *MoqFloat_starGenType_mock) SetMode(mode big.RoundingMode) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_SetMode_params{
		Mode: mode,
	}
	var results *MoqFloat_starGenType_SetMode_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetMode {
		paramsKey := m.Moq.ParamsKey_SetMode(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetMode(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetMode(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetMode(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(mode)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(mode)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Prec() (result1 uint) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Prec_params{}
	var results *MoqFloat_starGenType_Prec_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Prec {
		paramsKey := m.Moq.ParamsKey_Prec(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Prec(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Prec(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Prec(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) MinPrec() (result1 uint) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_MinPrec_params{}
	var results *MoqFloat_starGenType_MinPrec_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MinPrec {
		paramsKey := m.Moq.ParamsKey_MinPrec(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MinPrec(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MinPrec(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MinPrec(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) Mode() (result1 big.RoundingMode) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Mode_params{}
	var results *MoqFloat_starGenType_Mode_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Mode {
		paramsKey := m.Moq.ParamsKey_Mode(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Mode(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Mode(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Mode(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) Acc() (result1 big.Accuracy) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Acc_params{}
	var results *MoqFloat_starGenType_Acc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Acc {
		paramsKey := m.Moq.ParamsKey_Acc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Acc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Acc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Acc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) Sign() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Sign_params{}
	var results *MoqFloat_starGenType_Sign_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Sign {
		paramsKey := m.Moq.ParamsKey_Sign(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Sign(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Sign(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Sign(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) MantExp(mant *big.Float) (exp int) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_MantExp_params{
		Mant: mant,
	}
	var results *MoqFloat_starGenType_MantExp_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MantExp {
		paramsKey := m.Moq.ParamsKey_MantExp(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MantExp(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MantExp(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MantExp(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(mant)
	}

	if result.Values != nil {
		exp = result.Values.Exp
	}
	if result.DoReturnFn != nil {
		exp = result.DoReturnFn(mant)
	}
	return
}

func (m *MoqFloat_starGenType_mock) SetMantExp(mant *big.Float, exp int) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_SetMantExp_params{
		Mant: mant,
		Exp:  exp,
	}
	var results *MoqFloat_starGenType_SetMantExp_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetMantExp {
		paramsKey := m.Moq.ParamsKey_SetMantExp(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetMantExp(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetMantExp(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetMantExp(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(mant, exp)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(mant, exp)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Signbit() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Signbit_params{}
	var results *MoqFloat_starGenType_Signbit_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Signbit {
		paramsKey := m.Moq.ParamsKey_Signbit(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Signbit(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Signbit(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Signbit(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) IsInf() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_IsInf_params{}
	var results *MoqFloat_starGenType_IsInf_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsInf {
		paramsKey := m.Moq.ParamsKey_IsInf(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsInf(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsInf(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsInf(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) IsInt() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_IsInt_params{}
	var results *MoqFloat_starGenType_IsInt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsInt {
		paramsKey := m.Moq.ParamsKey_IsInt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsInt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsInt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsInt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) SetUint64(x uint64) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_SetUint64_params{
		X: x,
	}
	var results *MoqFloat_starGenType_SetUint64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetUint64 {
		paramsKey := m.Moq.ParamsKey_SetUint64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetUint64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetUint64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetUint64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqFloat_starGenType_mock) SetInt64(x int64) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_SetInt64_params{
		X: x,
	}
	var results *MoqFloat_starGenType_SetInt64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetInt64 {
		paramsKey := m.Moq.ParamsKey_SetInt64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetInt64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetInt64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetInt64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqFloat_starGenType_mock) SetFloat64(x float64) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_SetFloat64_params{
		X: x,
	}
	var results *MoqFloat_starGenType_SetFloat64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetFloat64 {
		paramsKey := m.Moq.ParamsKey_SetFloat64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetFloat64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetFloat64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetFloat64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqFloat_starGenType_mock) SetInt(x *big.Int) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_SetInt_params{
		X: x,
	}
	var results *MoqFloat_starGenType_SetInt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetInt {
		paramsKey := m.Moq.ParamsKey_SetInt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetInt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetInt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetInt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqFloat_starGenType_mock) SetRat(x *big.Rat) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_SetRat_params{
		X: x,
	}
	var results *MoqFloat_starGenType_SetRat_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetRat {
		paramsKey := m.Moq.ParamsKey_SetRat(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetRat(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetRat(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetRat(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqFloat_starGenType_mock) SetInf(signbit bool) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_SetInf_params{
		Signbit: signbit,
	}
	var results *MoqFloat_starGenType_SetInf_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetInf {
		paramsKey := m.Moq.ParamsKey_SetInf(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetInf(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetInf(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetInf(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(signbit)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(signbit)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Set(x *big.Float) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Set_params{
		X: x,
	}
	var results *MoqFloat_starGenType_Set_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Set {
		paramsKey := m.Moq.ParamsKey_Set(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Set(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Set(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Set(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Copy(x *big.Float) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Copy_params{
		X: x,
	}
	var results *MoqFloat_starGenType_Copy_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Copy {
		paramsKey := m.Moq.ParamsKey_Copy(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Copy(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Copy(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Copy(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Uint64() (result1 uint64, result2 big.Accuracy) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Uint64_params{}
	var results *MoqFloat_starGenType_Uint64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Uint64 {
		paramsKey := m.Moq.ParamsKey_Uint64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Uint64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Uint64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Uint64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) Int64() (result1 int64, result2 big.Accuracy) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Int64_params{}
	var results *MoqFloat_starGenType_Int64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Int64 {
		paramsKey := m.Moq.ParamsKey_Int64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Int64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Int64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Int64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) Float32() (result1 float32, result2 big.Accuracy) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Float32_params{}
	var results *MoqFloat_starGenType_Float32_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Float32 {
		paramsKey := m.Moq.ParamsKey_Float32(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Float32(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Float32(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Float32(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) Float64() (result1 float64, result2 big.Accuracy) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Float64_params{}
	var results *MoqFloat_starGenType_Float64_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Float64 {
		paramsKey := m.Moq.ParamsKey_Float64(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Float64(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Float64(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Float64(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) Int(z *big.Int) (result1 *big.Int, result2 big.Accuracy) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Int_params{
		Z: z,
	}
	var results *MoqFloat_starGenType_Int_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Int {
		paramsKey := m.Moq.ParamsKey_Int(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Int(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Int(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Int(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(z)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(z)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Rat(z *big.Rat) (result1 *big.Rat, result2 big.Accuracy) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Rat_params{
		Z: z,
	}
	var results *MoqFloat_starGenType_Rat_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Rat {
		paramsKey := m.Moq.ParamsKey_Rat(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Rat(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Rat(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Rat(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(z)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(z)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Abs(x *big.Float) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Abs_params{
		X: x,
	}
	var results *MoqFloat_starGenType_Abs_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Abs {
		paramsKey := m.Moq.ParamsKey_Abs(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Abs(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Abs(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Abs(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Neg(x *big.Float) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Neg_params{
		X: x,
	}
	var results *MoqFloat_starGenType_Neg_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Neg {
		paramsKey := m.Moq.ParamsKey_Neg(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Neg(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Neg(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Neg(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Add(x, y *big.Float) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Add_params{
		X: x,
		Y: y,
	}
	var results *MoqFloat_starGenType_Add_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Add {
		paramsKey := m.Moq.ParamsKey_Add(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Add(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Add(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Add(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Sub(x, y *big.Float) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Sub_params{
		X: x,
		Y: y,
	}
	var results *MoqFloat_starGenType_Sub_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Sub {
		paramsKey := m.Moq.ParamsKey_Sub(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Sub(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Sub(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Sub(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Mul(x, y *big.Float) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Mul_params{
		X: x,
		Y: y,
	}
	var results *MoqFloat_starGenType_Mul_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Mul {
		paramsKey := m.Moq.ParamsKey_Mul(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Mul(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Mul(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Mul(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Quo(x, y *big.Float) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Quo_params{
		X: x,
		Y: y,
	}
	var results *MoqFloat_starGenType_Quo_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Quo {
		paramsKey := m.Moq.ParamsKey_Quo(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Quo(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Quo(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Quo(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Cmp(y *big.Float) (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Cmp_params{
		Y: y,
	}
	var results *MoqFloat_starGenType_Cmp_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Cmp {
		paramsKey := m.Moq.ParamsKey_Cmp(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Cmp(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Cmp(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Cmp(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(y)
	}
	return
}

func (m *MoqFloat_starGenType_mock) SetString(s string) (result1 *big.Float, result2 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_SetString_params{
		S: s,
	}
	var results *MoqFloat_starGenType_SetString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetString {
		paramsKey := m.Moq.ParamsKey_SetString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(s)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Parse(s string, base int) (f *big.Float, b int, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Parse_params{
		S:    s,
		Base: base,
	}
	var results *MoqFloat_starGenType_Parse_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Parse {
		paramsKey := m.Moq.ParamsKey_Parse(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Parse(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Parse(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Parse(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, base)
	}

	if result.Values != nil {
		f = result.Values.F
		b = result.Values.B
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		f, b, err = result.DoReturnFn(s, base)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Scan(s fmt.ScanState, ch rune) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Scan_params{
		S:  s,
		Ch: ch,
	}
	var results *MoqFloat_starGenType_Scan_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Scan {
		paramsKey := m.Moq.ParamsKey_Scan(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Scan(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Scan(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Scan(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, ch)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s, ch)
	}
	return
}

func (m *MoqFloat_starGenType_mock) GobEncode() (result1 []byte, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_GobEncode_params{}
	var results *MoqFloat_starGenType_GobEncode_results
	for _, resultsByParams := range m.Moq.ResultsByParams_GobEncode {
		paramsKey := m.Moq.ParamsKey_GobEncode(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_GobEncode(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_GobEncode(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_GobEncode(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) GobDecode(buf []byte) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_GobDecode_params{
		Buf: buf,
	}
	var results *MoqFloat_starGenType_GobDecode_results
	for _, resultsByParams := range m.Moq.ResultsByParams_GobDecode {
		paramsKey := m.Moq.ParamsKey_GobDecode(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_GobDecode(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_GobDecode(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_GobDecode(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(buf)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(buf)
	}
	return
}

func (m *MoqFloat_starGenType_mock) MarshalText() (text []byte, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_MarshalText_params{}
	var results *MoqFloat_starGenType_MarshalText_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MarshalText {
		paramsKey := m.Moq.ParamsKey_MarshalText(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MarshalText(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MarshalText(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MarshalText(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		text = result.Values.Text
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		text, err = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) UnmarshalText(text []byte) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_UnmarshalText_params{
		Text: text,
	}
	var results *MoqFloat_starGenType_UnmarshalText_results
	for _, resultsByParams := range m.Moq.ResultsByParams_UnmarshalText {
		paramsKey := m.Moq.ParamsKey_UnmarshalText(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_UnmarshalText(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_UnmarshalText(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_UnmarshalText(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(text)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(text)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Text(format byte, prec int) (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Text_params{
		Format: format,
		Prec:   prec,
	}
	var results *MoqFloat_starGenType_Text_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Text {
		paramsKey := m.Moq.ParamsKey_Text(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Text(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Text(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Text(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(format, prec)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(format, prec)
	}
	return
}

func (m *MoqFloat_starGenType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_String_params{}
	var results *MoqFloat_starGenType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFloat_starGenType_mock) Append(buf []byte, fmt byte, prec int) (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Append_params{
		Buf:  buf,
		Fmt:  fmt,
		Prec: prec,
	}
	var results *MoqFloat_starGenType_Append_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Append {
		paramsKey := m.Moq.ParamsKey_Append(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Append(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Append(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Append(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(buf, fmt, prec)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(buf, fmt, prec)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Format(s fmt.State, format rune) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Format_params{
		S:      s,
		Format: format,
	}
	var results *MoqFloat_starGenType_Format_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Format {
		paramsKey := m.Moq.ParamsKey_Format(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Format(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Format(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Format(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, format)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(s, format)
	}
	return
}

func (m *MoqFloat_starGenType_mock) Sqrt(x *big.Float) (result1 *big.Float) {
	m.Moq.Scene.T.Helper()
	params := MoqFloat_starGenType_Sqrt_params{
		X: x,
	}
	var results *MoqFloat_starGenType_Sqrt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Sqrt {
		paramsKey := m.Moq.ParamsKey_Sqrt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Sqrt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Sqrt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Sqrt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

// OnCall returns the recorder implementation of the Float_starGenType type
func (m *MoqFloat_starGenType) OnCall() *MoqFloat_starGenType_recorder {
	return &MoqFloat_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqFloat_starGenType_recorder) SetPrec(prec uint) *MoqFloat_starGenType_SetPrec_fnRecorder {
	return &MoqFloat_starGenType_SetPrec_fnRecorder{
		Params: MoqFloat_starGenType_SetPrec_params{
			Prec: prec,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_SetPrec_fnRecorder) Any() *MoqFloat_starGenType_SetPrec_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetPrec(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_SetPrec_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_SetPrec_anyParams) Prec() *MoqFloat_starGenType_SetPrec_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_SetPrec_fnRecorder) Seq() *MoqFloat_starGenType_SetPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetPrec(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_SetPrec_fnRecorder) NoSeq() *MoqFloat_starGenType_SetPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetPrec(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_SetPrec_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_SetPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetPrec_doFn
		DoReturnFn MoqFloat_starGenType_SetPrec_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_SetPrec_fnRecorder) AndDo(fn MoqFloat_starGenType_SetPrec_doFn) *MoqFloat_starGenType_SetPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_SetPrec_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_SetPrec_doReturnFn) *MoqFloat_starGenType_SetPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetPrec_doFn
		DoReturnFn MoqFloat_starGenType_SetPrec_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_SetPrec_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_SetPrec_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetPrec {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_SetPrec_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_SetPrec_paramsKey]*MoqFloat_starGenType_SetPrec_results{},
		}
		r.Moq.ResultsByParams_SetPrec = append(r.Moq.ResultsByParams_SetPrec, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetPrec) {
			copy(r.Moq.ResultsByParams_SetPrec[insertAt+1:], r.Moq.ResultsByParams_SetPrec[insertAt:0])
			r.Moq.ResultsByParams_SetPrec[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetPrec(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_SetPrec_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_SetPrec_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_SetPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_SetPrec_doFn
				DoReturnFn MoqFloat_starGenType_SetPrec_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_SetPrec(params MoqFloat_starGenType_SetPrec_params) string {
	return fmt.Sprintf("SetPrec(%#v)", params.Prec)
}

func (m *MoqFloat_starGenType) ParamsKey_SetPrec(params MoqFloat_starGenType_SetPrec_params, anyParams uint64) MoqFloat_starGenType_SetPrec_paramsKey {
	m.Scene.T.Helper()
	var precUsed uint
	var precUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetPrec.Prec == moq.ParamIndexByValue {
			precUsed = params.Prec
		} else {
			precUsedHash = hash.DeepHash(params.Prec)
		}
	}
	return MoqFloat_starGenType_SetPrec_paramsKey{
		Params: struct{ Prec uint }{
			Prec: precUsed,
		},
		Hashes: struct{ Prec hash.Hash }{
			Prec: precUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) SetMode(mode big.RoundingMode) *MoqFloat_starGenType_SetMode_fnRecorder {
	return &MoqFloat_starGenType_SetMode_fnRecorder{
		Params: MoqFloat_starGenType_SetMode_params{
			Mode: mode,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_SetMode_fnRecorder) Any() *MoqFloat_starGenType_SetMode_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetMode(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_SetMode_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_SetMode_anyParams) Mode() *MoqFloat_starGenType_SetMode_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_SetMode_fnRecorder) Seq() *MoqFloat_starGenType_SetMode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetMode(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_SetMode_fnRecorder) NoSeq() *MoqFloat_starGenType_SetMode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetMode(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_SetMode_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_SetMode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetMode_doFn
		DoReturnFn MoqFloat_starGenType_SetMode_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_SetMode_fnRecorder) AndDo(fn MoqFloat_starGenType_SetMode_doFn) *MoqFloat_starGenType_SetMode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_SetMode_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_SetMode_doReturnFn) *MoqFloat_starGenType_SetMode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetMode_doFn
		DoReturnFn MoqFloat_starGenType_SetMode_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_SetMode_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_SetMode_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetMode {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_SetMode_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_SetMode_paramsKey]*MoqFloat_starGenType_SetMode_results{},
		}
		r.Moq.ResultsByParams_SetMode = append(r.Moq.ResultsByParams_SetMode, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetMode) {
			copy(r.Moq.ResultsByParams_SetMode[insertAt+1:], r.Moq.ResultsByParams_SetMode[insertAt:0])
			r.Moq.ResultsByParams_SetMode[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetMode(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_SetMode_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_SetMode_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_SetMode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_SetMode_doFn
				DoReturnFn MoqFloat_starGenType_SetMode_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_SetMode(params MoqFloat_starGenType_SetMode_params) string {
	return fmt.Sprintf("SetMode(%#v)", params.Mode)
}

func (m *MoqFloat_starGenType) ParamsKey_SetMode(params MoqFloat_starGenType_SetMode_params, anyParams uint64) MoqFloat_starGenType_SetMode_paramsKey {
	m.Scene.T.Helper()
	var modeUsed big.RoundingMode
	var modeUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetMode.Mode == moq.ParamIndexByValue {
			modeUsed = params.Mode
		} else {
			modeUsedHash = hash.DeepHash(params.Mode)
		}
	}
	return MoqFloat_starGenType_SetMode_paramsKey{
		Params: struct{ Mode big.RoundingMode }{
			Mode: modeUsed,
		},
		Hashes: struct{ Mode hash.Hash }{
			Mode: modeUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Prec() *MoqFloat_starGenType_Prec_fnRecorder {
	return &MoqFloat_starGenType_Prec_fnRecorder{
		Params:   MoqFloat_starGenType_Prec_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Prec_fnRecorder) Any() *MoqFloat_starGenType_Prec_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prec(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Prec_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_Prec_fnRecorder) Seq() *MoqFloat_starGenType_Prec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prec(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Prec_fnRecorder) NoSeq() *MoqFloat_starGenType_Prec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prec(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Prec_fnRecorder) ReturnResults(result1 uint) *MoqFloat_starGenType_Prec_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Prec_doFn
		DoReturnFn MoqFloat_starGenType_Prec_doReturnFn
	}{
		Values: &struct {
			Result1 uint
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Prec_fnRecorder) AndDo(fn MoqFloat_starGenType_Prec_doFn) *MoqFloat_starGenType_Prec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Prec_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Prec_doReturnFn) *MoqFloat_starGenType_Prec_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Prec_doFn
		DoReturnFn MoqFloat_starGenType_Prec_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Prec_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Prec_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Prec {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Prec_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Prec_paramsKey]*MoqFloat_starGenType_Prec_results{},
		}
		r.Moq.ResultsByParams_Prec = append(r.Moq.ResultsByParams_Prec, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Prec) {
			copy(r.Moq.ResultsByParams_Prec[insertAt+1:], r.Moq.ResultsByParams_Prec[insertAt:0])
			r.Moq.ResultsByParams_Prec[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Prec(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Prec_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Prec_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Prec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 uint
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Prec_doFn
				DoReturnFn MoqFloat_starGenType_Prec_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Prec(params MoqFloat_starGenType_Prec_params) string {
	return fmt.Sprintf("Prec()")
}

func (m *MoqFloat_starGenType) ParamsKey_Prec(params MoqFloat_starGenType_Prec_params, anyParams uint64) MoqFloat_starGenType_Prec_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_Prec_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) MinPrec() *MoqFloat_starGenType_MinPrec_fnRecorder {
	return &MoqFloat_starGenType_MinPrec_fnRecorder{
		Params:   MoqFloat_starGenType_MinPrec_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_MinPrec_fnRecorder) Any() *MoqFloat_starGenType_MinPrec_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MinPrec(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_MinPrec_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_MinPrec_fnRecorder) Seq() *MoqFloat_starGenType_MinPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MinPrec(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_MinPrec_fnRecorder) NoSeq() *MoqFloat_starGenType_MinPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MinPrec(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_MinPrec_fnRecorder) ReturnResults(result1 uint) *MoqFloat_starGenType_MinPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_MinPrec_doFn
		DoReturnFn MoqFloat_starGenType_MinPrec_doReturnFn
	}{
		Values: &struct {
			Result1 uint
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_MinPrec_fnRecorder) AndDo(fn MoqFloat_starGenType_MinPrec_doFn) *MoqFloat_starGenType_MinPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_MinPrec_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_MinPrec_doReturnFn) *MoqFloat_starGenType_MinPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_MinPrec_doFn
		DoReturnFn MoqFloat_starGenType_MinPrec_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_MinPrec_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_MinPrec_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MinPrec {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_MinPrec_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_MinPrec_paramsKey]*MoqFloat_starGenType_MinPrec_results{},
		}
		r.Moq.ResultsByParams_MinPrec = append(r.Moq.ResultsByParams_MinPrec, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MinPrec) {
			copy(r.Moq.ResultsByParams_MinPrec[insertAt+1:], r.Moq.ResultsByParams_MinPrec[insertAt:0])
			r.Moq.ResultsByParams_MinPrec[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MinPrec(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_MinPrec_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_MinPrec_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_MinPrec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 uint
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_MinPrec_doFn
				DoReturnFn MoqFloat_starGenType_MinPrec_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_MinPrec(params MoqFloat_starGenType_MinPrec_params) string {
	return fmt.Sprintf("MinPrec()")
}

func (m *MoqFloat_starGenType) ParamsKey_MinPrec(params MoqFloat_starGenType_MinPrec_params, anyParams uint64) MoqFloat_starGenType_MinPrec_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_MinPrec_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) Mode() *MoqFloat_starGenType_Mode_fnRecorder {
	return &MoqFloat_starGenType_Mode_fnRecorder{
		Params:   MoqFloat_starGenType_Mode_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Mode_fnRecorder) Any() *MoqFloat_starGenType_Mode_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mode(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Mode_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_Mode_fnRecorder) Seq() *MoqFloat_starGenType_Mode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mode(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Mode_fnRecorder) NoSeq() *MoqFloat_starGenType_Mode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mode(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Mode_fnRecorder) ReturnResults(result1 big.RoundingMode) *MoqFloat_starGenType_Mode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 big.RoundingMode
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Mode_doFn
		DoReturnFn MoqFloat_starGenType_Mode_doReturnFn
	}{
		Values: &struct {
			Result1 big.RoundingMode
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Mode_fnRecorder) AndDo(fn MoqFloat_starGenType_Mode_doFn) *MoqFloat_starGenType_Mode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Mode_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Mode_doReturnFn) *MoqFloat_starGenType_Mode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 big.RoundingMode
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Mode_doFn
		DoReturnFn MoqFloat_starGenType_Mode_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Mode_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Mode_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Mode {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Mode_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Mode_paramsKey]*MoqFloat_starGenType_Mode_results{},
		}
		r.Moq.ResultsByParams_Mode = append(r.Moq.ResultsByParams_Mode, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Mode) {
			copy(r.Moq.ResultsByParams_Mode[insertAt+1:], r.Moq.ResultsByParams_Mode[insertAt:0])
			r.Moq.ResultsByParams_Mode[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Mode(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Mode_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Mode_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Mode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 big.RoundingMode
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Mode_doFn
				DoReturnFn MoqFloat_starGenType_Mode_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Mode(params MoqFloat_starGenType_Mode_params) string {
	return fmt.Sprintf("Mode()")
}

func (m *MoqFloat_starGenType) ParamsKey_Mode(params MoqFloat_starGenType_Mode_params, anyParams uint64) MoqFloat_starGenType_Mode_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_Mode_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) Acc() *MoqFloat_starGenType_Acc_fnRecorder {
	return &MoqFloat_starGenType_Acc_fnRecorder{
		Params:   MoqFloat_starGenType_Acc_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Acc_fnRecorder) Any() *MoqFloat_starGenType_Acc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Acc(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Acc_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_Acc_fnRecorder) Seq() *MoqFloat_starGenType_Acc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Acc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Acc_fnRecorder) NoSeq() *MoqFloat_starGenType_Acc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Acc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Acc_fnRecorder) ReturnResults(result1 big.Accuracy) *MoqFloat_starGenType_Acc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Acc_doFn
		DoReturnFn MoqFloat_starGenType_Acc_doReturnFn
	}{
		Values: &struct {
			Result1 big.Accuracy
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Acc_fnRecorder) AndDo(fn MoqFloat_starGenType_Acc_doFn) *MoqFloat_starGenType_Acc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Acc_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Acc_doReturnFn) *MoqFloat_starGenType_Acc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Acc_doFn
		DoReturnFn MoqFloat_starGenType_Acc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Acc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Acc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Acc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Acc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Acc_paramsKey]*MoqFloat_starGenType_Acc_results{},
		}
		r.Moq.ResultsByParams_Acc = append(r.Moq.ResultsByParams_Acc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Acc) {
			copy(r.Moq.ResultsByParams_Acc[insertAt+1:], r.Moq.ResultsByParams_Acc[insertAt:0])
			r.Moq.ResultsByParams_Acc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Acc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Acc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Acc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Acc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 big.Accuracy
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Acc_doFn
				DoReturnFn MoqFloat_starGenType_Acc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Acc(params MoqFloat_starGenType_Acc_params) string {
	return fmt.Sprintf("Acc()")
}

func (m *MoqFloat_starGenType) ParamsKey_Acc(params MoqFloat_starGenType_Acc_params, anyParams uint64) MoqFloat_starGenType_Acc_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_Acc_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) Sign() *MoqFloat_starGenType_Sign_fnRecorder {
	return &MoqFloat_starGenType_Sign_fnRecorder{
		Params:   MoqFloat_starGenType_Sign_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Sign_fnRecorder) Any() *MoqFloat_starGenType_Sign_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sign(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Sign_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_Sign_fnRecorder) Seq() *MoqFloat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sign(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Sign_fnRecorder) NoSeq() *MoqFloat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sign(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Sign_fnRecorder) ReturnResults(result1 int) *MoqFloat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Sign_doFn
		DoReturnFn MoqFloat_starGenType_Sign_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Sign_fnRecorder) AndDo(fn MoqFloat_starGenType_Sign_doFn) *MoqFloat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Sign_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Sign_doReturnFn) *MoqFloat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Sign_doFn
		DoReturnFn MoqFloat_starGenType_Sign_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Sign_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Sign_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Sign {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Sign_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Sign_paramsKey]*MoqFloat_starGenType_Sign_results{},
		}
		r.Moq.ResultsByParams_Sign = append(r.Moq.ResultsByParams_Sign, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Sign) {
			copy(r.Moq.ResultsByParams_Sign[insertAt+1:], r.Moq.ResultsByParams_Sign[insertAt:0])
			r.Moq.ResultsByParams_Sign[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Sign(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Sign_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Sign_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Sign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Sign_doFn
				DoReturnFn MoqFloat_starGenType_Sign_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Sign(params MoqFloat_starGenType_Sign_params) string {
	return fmt.Sprintf("Sign()")
}

func (m *MoqFloat_starGenType) ParamsKey_Sign(params MoqFloat_starGenType_Sign_params, anyParams uint64) MoqFloat_starGenType_Sign_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_Sign_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) MantExp(mant *big.Float) *MoqFloat_starGenType_MantExp_fnRecorder {
	return &MoqFloat_starGenType_MantExp_fnRecorder{
		Params: MoqFloat_starGenType_MantExp_params{
			Mant: mant,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_MantExp_fnRecorder) Any() *MoqFloat_starGenType_MantExp_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MantExp(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_MantExp_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_MantExp_anyParams) Mant() *MoqFloat_starGenType_MantExp_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_MantExp_fnRecorder) Seq() *MoqFloat_starGenType_MantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MantExp(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_MantExp_fnRecorder) NoSeq() *MoqFloat_starGenType_MantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MantExp(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_MantExp_fnRecorder) ReturnResults(exp int) *MoqFloat_starGenType_MantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Exp int }
		Sequence   uint32
		DoFn       MoqFloat_starGenType_MantExp_doFn
		DoReturnFn MoqFloat_starGenType_MantExp_doReturnFn
	}{
		Values: &struct{ Exp int }{
			Exp: exp,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_MantExp_fnRecorder) AndDo(fn MoqFloat_starGenType_MantExp_doFn) *MoqFloat_starGenType_MantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_MantExp_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_MantExp_doReturnFn) *MoqFloat_starGenType_MantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Exp int }
		Sequence   uint32
		DoFn       MoqFloat_starGenType_MantExp_doFn
		DoReturnFn MoqFloat_starGenType_MantExp_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_MantExp_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_MantExp_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MantExp {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_MantExp_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_MantExp_paramsKey]*MoqFloat_starGenType_MantExp_results{},
		}
		r.Moq.ResultsByParams_MantExp = append(r.Moq.ResultsByParams_MantExp, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MantExp) {
			copy(r.Moq.ResultsByParams_MantExp[insertAt+1:], r.Moq.ResultsByParams_MantExp[insertAt:0])
			r.Moq.ResultsByParams_MantExp[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MantExp(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_MantExp_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_MantExp_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_MantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Exp int }
				Sequence   uint32
				DoFn       MoqFloat_starGenType_MantExp_doFn
				DoReturnFn MoqFloat_starGenType_MantExp_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_MantExp(params MoqFloat_starGenType_MantExp_params) string {
	return fmt.Sprintf("MantExp(%#v)", params.Mant)
}

func (m *MoqFloat_starGenType) ParamsKey_MantExp(params MoqFloat_starGenType_MantExp_params, anyParams uint64) MoqFloat_starGenType_MantExp_paramsKey {
	m.Scene.T.Helper()
	var mantUsed *big.Float
	var mantUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MantExp.Mant == moq.ParamIndexByValue {
			mantUsed = params.Mant
		} else {
			mantUsedHash = hash.DeepHash(params.Mant)
		}
	}
	return MoqFloat_starGenType_MantExp_paramsKey{
		Params: struct{ Mant *big.Float }{
			Mant: mantUsed,
		},
		Hashes: struct{ Mant hash.Hash }{
			Mant: mantUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) SetMantExp(mant *big.Float, exp int) *MoqFloat_starGenType_SetMantExp_fnRecorder {
	return &MoqFloat_starGenType_SetMantExp_fnRecorder{
		Params: MoqFloat_starGenType_SetMantExp_params{
			Mant: mant,
			Exp:  exp,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_SetMantExp_fnRecorder) Any() *MoqFloat_starGenType_SetMantExp_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetMantExp(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_SetMantExp_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_SetMantExp_anyParams) Mant() *MoqFloat_starGenType_SetMantExp_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFloat_starGenType_SetMantExp_anyParams) Exp() *MoqFloat_starGenType_SetMantExp_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFloat_starGenType_SetMantExp_fnRecorder) Seq() *MoqFloat_starGenType_SetMantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetMantExp(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_SetMantExp_fnRecorder) NoSeq() *MoqFloat_starGenType_SetMantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetMantExp(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_SetMantExp_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_SetMantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetMantExp_doFn
		DoReturnFn MoqFloat_starGenType_SetMantExp_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_SetMantExp_fnRecorder) AndDo(fn MoqFloat_starGenType_SetMantExp_doFn) *MoqFloat_starGenType_SetMantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_SetMantExp_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_SetMantExp_doReturnFn) *MoqFloat_starGenType_SetMantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetMantExp_doFn
		DoReturnFn MoqFloat_starGenType_SetMantExp_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_SetMantExp_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_SetMantExp_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetMantExp {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_SetMantExp_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_SetMantExp_paramsKey]*MoqFloat_starGenType_SetMantExp_results{},
		}
		r.Moq.ResultsByParams_SetMantExp = append(r.Moq.ResultsByParams_SetMantExp, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetMantExp) {
			copy(r.Moq.ResultsByParams_SetMantExp[insertAt+1:], r.Moq.ResultsByParams_SetMantExp[insertAt:0])
			r.Moq.ResultsByParams_SetMantExp[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetMantExp(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_SetMantExp_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_SetMantExp_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_SetMantExp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_SetMantExp_doFn
				DoReturnFn MoqFloat_starGenType_SetMantExp_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_SetMantExp(params MoqFloat_starGenType_SetMantExp_params) string {
	return fmt.Sprintf("SetMantExp(%#v, %#v)", params.Mant, params.Exp)
}

func (m *MoqFloat_starGenType) ParamsKey_SetMantExp(params MoqFloat_starGenType_SetMantExp_params, anyParams uint64) MoqFloat_starGenType_SetMantExp_paramsKey {
	m.Scene.T.Helper()
	var mantUsed *big.Float
	var mantUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetMantExp.Mant == moq.ParamIndexByValue {
			mantUsed = params.Mant
		} else {
			mantUsedHash = hash.DeepHash(params.Mant)
		}
	}
	var expUsed int
	var expUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.SetMantExp.Exp == moq.ParamIndexByValue {
			expUsed = params.Exp
		} else {
			expUsedHash = hash.DeepHash(params.Exp)
		}
	}
	return MoqFloat_starGenType_SetMantExp_paramsKey{
		Params: struct {
			Mant *big.Float
			Exp  int
		}{
			Mant: mantUsed,
			Exp:  expUsed,
		},
		Hashes: struct {
			Mant hash.Hash
			Exp  hash.Hash
		}{
			Mant: mantUsedHash,
			Exp:  expUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Signbit() *MoqFloat_starGenType_Signbit_fnRecorder {
	return &MoqFloat_starGenType_Signbit_fnRecorder{
		Params:   MoqFloat_starGenType_Signbit_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Signbit_fnRecorder) Any() *MoqFloat_starGenType_Signbit_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Signbit(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Signbit_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_Signbit_fnRecorder) Seq() *MoqFloat_starGenType_Signbit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Signbit(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Signbit_fnRecorder) NoSeq() *MoqFloat_starGenType_Signbit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Signbit(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Signbit_fnRecorder) ReturnResults(result1 bool) *MoqFloat_starGenType_Signbit_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Signbit_doFn
		DoReturnFn MoqFloat_starGenType_Signbit_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Signbit_fnRecorder) AndDo(fn MoqFloat_starGenType_Signbit_doFn) *MoqFloat_starGenType_Signbit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Signbit_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Signbit_doReturnFn) *MoqFloat_starGenType_Signbit_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Signbit_doFn
		DoReturnFn MoqFloat_starGenType_Signbit_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Signbit_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Signbit_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Signbit {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Signbit_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Signbit_paramsKey]*MoqFloat_starGenType_Signbit_results{},
		}
		r.Moq.ResultsByParams_Signbit = append(r.Moq.ResultsByParams_Signbit, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Signbit) {
			copy(r.Moq.ResultsByParams_Signbit[insertAt+1:], r.Moq.ResultsByParams_Signbit[insertAt:0])
			r.Moq.ResultsByParams_Signbit[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Signbit(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Signbit_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Signbit_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Signbit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Signbit_doFn
				DoReturnFn MoqFloat_starGenType_Signbit_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Signbit(params MoqFloat_starGenType_Signbit_params) string {
	return fmt.Sprintf("Signbit()")
}

func (m *MoqFloat_starGenType) ParamsKey_Signbit(params MoqFloat_starGenType_Signbit_params, anyParams uint64) MoqFloat_starGenType_Signbit_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_Signbit_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) IsInf() *MoqFloat_starGenType_IsInf_fnRecorder {
	return &MoqFloat_starGenType_IsInf_fnRecorder{
		Params:   MoqFloat_starGenType_IsInf_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_IsInf_fnRecorder) Any() *MoqFloat_starGenType_IsInf_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInf(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_IsInf_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_IsInf_fnRecorder) Seq() *MoqFloat_starGenType_IsInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInf(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_IsInf_fnRecorder) NoSeq() *MoqFloat_starGenType_IsInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInf(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_IsInf_fnRecorder) ReturnResults(result1 bool) *MoqFloat_starGenType_IsInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_IsInf_doFn
		DoReturnFn MoqFloat_starGenType_IsInf_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_IsInf_fnRecorder) AndDo(fn MoqFloat_starGenType_IsInf_doFn) *MoqFloat_starGenType_IsInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_IsInf_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_IsInf_doReturnFn) *MoqFloat_starGenType_IsInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_IsInf_doFn
		DoReturnFn MoqFloat_starGenType_IsInf_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_IsInf_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_IsInf_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsInf {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_IsInf_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_IsInf_paramsKey]*MoqFloat_starGenType_IsInf_results{},
		}
		r.Moq.ResultsByParams_IsInf = append(r.Moq.ResultsByParams_IsInf, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsInf) {
			copy(r.Moq.ResultsByParams_IsInf[insertAt+1:], r.Moq.ResultsByParams_IsInf[insertAt:0])
			r.Moq.ResultsByParams_IsInf[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsInf(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_IsInf_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_IsInf_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_IsInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_IsInf_doFn
				DoReturnFn MoqFloat_starGenType_IsInf_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_IsInf(params MoqFloat_starGenType_IsInf_params) string {
	return fmt.Sprintf("IsInf()")
}

func (m *MoqFloat_starGenType) ParamsKey_IsInf(params MoqFloat_starGenType_IsInf_params, anyParams uint64) MoqFloat_starGenType_IsInf_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_IsInf_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) IsInt() *MoqFloat_starGenType_IsInt_fnRecorder {
	return &MoqFloat_starGenType_IsInt_fnRecorder{
		Params:   MoqFloat_starGenType_IsInt_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_IsInt_fnRecorder) Any() *MoqFloat_starGenType_IsInt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInt(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_IsInt_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_IsInt_fnRecorder) Seq() *MoqFloat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_IsInt_fnRecorder) NoSeq() *MoqFloat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_IsInt_fnRecorder) ReturnResults(result1 bool) *MoqFloat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_IsInt_doFn
		DoReturnFn MoqFloat_starGenType_IsInt_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_IsInt_fnRecorder) AndDo(fn MoqFloat_starGenType_IsInt_doFn) *MoqFloat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_IsInt_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_IsInt_doReturnFn) *MoqFloat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_IsInt_doFn
		DoReturnFn MoqFloat_starGenType_IsInt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_IsInt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_IsInt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsInt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_IsInt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_IsInt_paramsKey]*MoqFloat_starGenType_IsInt_results{},
		}
		r.Moq.ResultsByParams_IsInt = append(r.Moq.ResultsByParams_IsInt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsInt) {
			copy(r.Moq.ResultsByParams_IsInt[insertAt+1:], r.Moq.ResultsByParams_IsInt[insertAt:0])
			r.Moq.ResultsByParams_IsInt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsInt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_IsInt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_IsInt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_IsInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_IsInt_doFn
				DoReturnFn MoqFloat_starGenType_IsInt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_IsInt(params MoqFloat_starGenType_IsInt_params) string {
	return fmt.Sprintf("IsInt()")
}

func (m *MoqFloat_starGenType) ParamsKey_IsInt(params MoqFloat_starGenType_IsInt_params, anyParams uint64) MoqFloat_starGenType_IsInt_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_IsInt_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) SetUint64(x uint64) *MoqFloat_starGenType_SetUint64_fnRecorder {
	return &MoqFloat_starGenType_SetUint64_fnRecorder{
		Params: MoqFloat_starGenType_SetUint64_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_SetUint64_fnRecorder) Any() *MoqFloat_starGenType_SetUint64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint64(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_SetUint64_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_SetUint64_anyParams) X() *MoqFloat_starGenType_SetUint64_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_SetUint64_fnRecorder) Seq() *MoqFloat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_SetUint64_fnRecorder) NoSeq() *MoqFloat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_SetUint64_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetUint64_doFn
		DoReturnFn MoqFloat_starGenType_SetUint64_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_SetUint64_fnRecorder) AndDo(fn MoqFloat_starGenType_SetUint64_doFn) *MoqFloat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_SetUint64_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_SetUint64_doReturnFn) *MoqFloat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetUint64_doFn
		DoReturnFn MoqFloat_starGenType_SetUint64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_SetUint64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_SetUint64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetUint64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_SetUint64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_SetUint64_paramsKey]*MoqFloat_starGenType_SetUint64_results{},
		}
		r.Moq.ResultsByParams_SetUint64 = append(r.Moq.ResultsByParams_SetUint64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetUint64) {
			copy(r.Moq.ResultsByParams_SetUint64[insertAt+1:], r.Moq.ResultsByParams_SetUint64[insertAt:0])
			r.Moq.ResultsByParams_SetUint64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetUint64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_SetUint64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_SetUint64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_SetUint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_SetUint64_doFn
				DoReturnFn MoqFloat_starGenType_SetUint64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_SetUint64(params MoqFloat_starGenType_SetUint64_params) string {
	return fmt.Sprintf("SetUint64(%#v)", params.X)
}

func (m *MoqFloat_starGenType) ParamsKey_SetUint64(params MoqFloat_starGenType_SetUint64_params, anyParams uint64) MoqFloat_starGenType_SetUint64_paramsKey {
	m.Scene.T.Helper()
	var xUsed uint64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetUint64.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqFloat_starGenType_SetUint64_paramsKey{
		Params: struct{ X uint64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) SetInt64(x int64) *MoqFloat_starGenType_SetInt64_fnRecorder {
	return &MoqFloat_starGenType_SetInt64_fnRecorder{
		Params: MoqFloat_starGenType_SetInt64_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_SetInt64_fnRecorder) Any() *MoqFloat_starGenType_SetInt64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt64(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_SetInt64_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_SetInt64_anyParams) X() *MoqFloat_starGenType_SetInt64_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_SetInt64_fnRecorder) Seq() *MoqFloat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_SetInt64_fnRecorder) NoSeq() *MoqFloat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_SetInt64_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetInt64_doFn
		DoReturnFn MoqFloat_starGenType_SetInt64_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_SetInt64_fnRecorder) AndDo(fn MoqFloat_starGenType_SetInt64_doFn) *MoqFloat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_SetInt64_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_SetInt64_doReturnFn) *MoqFloat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetInt64_doFn
		DoReturnFn MoqFloat_starGenType_SetInt64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_SetInt64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_SetInt64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetInt64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_SetInt64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_SetInt64_paramsKey]*MoqFloat_starGenType_SetInt64_results{},
		}
		r.Moq.ResultsByParams_SetInt64 = append(r.Moq.ResultsByParams_SetInt64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetInt64) {
			copy(r.Moq.ResultsByParams_SetInt64[insertAt+1:], r.Moq.ResultsByParams_SetInt64[insertAt:0])
			r.Moq.ResultsByParams_SetInt64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetInt64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_SetInt64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_SetInt64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_SetInt64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_SetInt64_doFn
				DoReturnFn MoqFloat_starGenType_SetInt64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_SetInt64(params MoqFloat_starGenType_SetInt64_params) string {
	return fmt.Sprintf("SetInt64(%#v)", params.X)
}

func (m *MoqFloat_starGenType) ParamsKey_SetInt64(params MoqFloat_starGenType_SetInt64_params, anyParams uint64) MoqFloat_starGenType_SetInt64_paramsKey {
	m.Scene.T.Helper()
	var xUsed int64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetInt64.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqFloat_starGenType_SetInt64_paramsKey{
		Params: struct{ X int64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) SetFloat64(x float64) *MoqFloat_starGenType_SetFloat64_fnRecorder {
	return &MoqFloat_starGenType_SetFloat64_fnRecorder{
		Params: MoqFloat_starGenType_SetFloat64_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_SetFloat64_fnRecorder) Any() *MoqFloat_starGenType_SetFloat64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFloat64(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_SetFloat64_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_SetFloat64_anyParams) X() *MoqFloat_starGenType_SetFloat64_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_SetFloat64_fnRecorder) Seq() *MoqFloat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFloat64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_SetFloat64_fnRecorder) NoSeq() *MoqFloat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFloat64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_SetFloat64_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetFloat64_doFn
		DoReturnFn MoqFloat_starGenType_SetFloat64_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_SetFloat64_fnRecorder) AndDo(fn MoqFloat_starGenType_SetFloat64_doFn) *MoqFloat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_SetFloat64_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_SetFloat64_doReturnFn) *MoqFloat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetFloat64_doFn
		DoReturnFn MoqFloat_starGenType_SetFloat64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_SetFloat64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_SetFloat64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetFloat64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_SetFloat64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_SetFloat64_paramsKey]*MoqFloat_starGenType_SetFloat64_results{},
		}
		r.Moq.ResultsByParams_SetFloat64 = append(r.Moq.ResultsByParams_SetFloat64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetFloat64) {
			copy(r.Moq.ResultsByParams_SetFloat64[insertAt+1:], r.Moq.ResultsByParams_SetFloat64[insertAt:0])
			r.Moq.ResultsByParams_SetFloat64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetFloat64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_SetFloat64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_SetFloat64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_SetFloat64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_SetFloat64_doFn
				DoReturnFn MoqFloat_starGenType_SetFloat64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_SetFloat64(params MoqFloat_starGenType_SetFloat64_params) string {
	return fmt.Sprintf("SetFloat64(%#v)", params.X)
}

func (m *MoqFloat_starGenType) ParamsKey_SetFloat64(params MoqFloat_starGenType_SetFloat64_params, anyParams uint64) MoqFloat_starGenType_SetFloat64_paramsKey {
	m.Scene.T.Helper()
	var xUsed float64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetFloat64.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqFloat_starGenType_SetFloat64_paramsKey{
		Params: struct{ X float64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) SetInt(x *big.Int) *MoqFloat_starGenType_SetInt_fnRecorder {
	return &MoqFloat_starGenType_SetInt_fnRecorder{
		Params: MoqFloat_starGenType_SetInt_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_SetInt_fnRecorder) Any() *MoqFloat_starGenType_SetInt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_SetInt_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_SetInt_anyParams) X() *MoqFloat_starGenType_SetInt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_SetInt_fnRecorder) Seq() *MoqFloat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_SetInt_fnRecorder) NoSeq() *MoqFloat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_SetInt_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetInt_doFn
		DoReturnFn MoqFloat_starGenType_SetInt_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_SetInt_fnRecorder) AndDo(fn MoqFloat_starGenType_SetInt_doFn) *MoqFloat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_SetInt_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_SetInt_doReturnFn) *MoqFloat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetInt_doFn
		DoReturnFn MoqFloat_starGenType_SetInt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_SetInt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_SetInt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetInt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_SetInt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_SetInt_paramsKey]*MoqFloat_starGenType_SetInt_results{},
		}
		r.Moq.ResultsByParams_SetInt = append(r.Moq.ResultsByParams_SetInt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetInt) {
			copy(r.Moq.ResultsByParams_SetInt[insertAt+1:], r.Moq.ResultsByParams_SetInt[insertAt:0])
			r.Moq.ResultsByParams_SetInt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetInt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_SetInt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_SetInt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_SetInt_doFn
				DoReturnFn MoqFloat_starGenType_SetInt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_SetInt(params MoqFloat_starGenType_SetInt_params) string {
	return fmt.Sprintf("SetInt(%#v)", params.X)
}

func (m *MoqFloat_starGenType) ParamsKey_SetInt(params MoqFloat_starGenType_SetInt_params, anyParams uint64) MoqFloat_starGenType_SetInt_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetInt.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqFloat_starGenType_SetInt_paramsKey{
		Params: struct{ X *big.Int }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) SetRat(x *big.Rat) *MoqFloat_starGenType_SetRat_fnRecorder {
	return &MoqFloat_starGenType_SetRat_fnRecorder{
		Params: MoqFloat_starGenType_SetRat_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_SetRat_fnRecorder) Any() *MoqFloat_starGenType_SetRat_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetRat(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_SetRat_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_SetRat_anyParams) X() *MoqFloat_starGenType_SetRat_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_SetRat_fnRecorder) Seq() *MoqFloat_starGenType_SetRat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetRat(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_SetRat_fnRecorder) NoSeq() *MoqFloat_starGenType_SetRat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetRat(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_SetRat_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_SetRat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetRat_doFn
		DoReturnFn MoqFloat_starGenType_SetRat_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_SetRat_fnRecorder) AndDo(fn MoqFloat_starGenType_SetRat_doFn) *MoqFloat_starGenType_SetRat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_SetRat_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_SetRat_doReturnFn) *MoqFloat_starGenType_SetRat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetRat_doFn
		DoReturnFn MoqFloat_starGenType_SetRat_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_SetRat_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_SetRat_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetRat {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_SetRat_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_SetRat_paramsKey]*MoqFloat_starGenType_SetRat_results{},
		}
		r.Moq.ResultsByParams_SetRat = append(r.Moq.ResultsByParams_SetRat, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetRat) {
			copy(r.Moq.ResultsByParams_SetRat[insertAt+1:], r.Moq.ResultsByParams_SetRat[insertAt:0])
			r.Moq.ResultsByParams_SetRat[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetRat(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_SetRat_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_SetRat_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_SetRat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_SetRat_doFn
				DoReturnFn MoqFloat_starGenType_SetRat_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_SetRat(params MoqFloat_starGenType_SetRat_params) string {
	return fmt.Sprintf("SetRat(%#v)", params.X)
}

func (m *MoqFloat_starGenType) ParamsKey_SetRat(params MoqFloat_starGenType_SetRat_params, anyParams uint64) MoqFloat_starGenType_SetRat_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Rat
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetRat.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqFloat_starGenType_SetRat_paramsKey{
		Params: struct{ X *big.Rat }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) SetInf(signbit bool) *MoqFloat_starGenType_SetInf_fnRecorder {
	return &MoqFloat_starGenType_SetInf_fnRecorder{
		Params: MoqFloat_starGenType_SetInf_params{
			Signbit: signbit,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_SetInf_fnRecorder) Any() *MoqFloat_starGenType_SetInf_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInf(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_SetInf_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_SetInf_anyParams) Signbit() *MoqFloat_starGenType_SetInf_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_SetInf_fnRecorder) Seq() *MoqFloat_starGenType_SetInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInf(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_SetInf_fnRecorder) NoSeq() *MoqFloat_starGenType_SetInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInf(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_SetInf_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_SetInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetInf_doFn
		DoReturnFn MoqFloat_starGenType_SetInf_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_SetInf_fnRecorder) AndDo(fn MoqFloat_starGenType_SetInf_doFn) *MoqFloat_starGenType_SetInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_SetInf_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_SetInf_doReturnFn) *MoqFloat_starGenType_SetInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetInf_doFn
		DoReturnFn MoqFloat_starGenType_SetInf_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_SetInf_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_SetInf_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetInf {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_SetInf_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_SetInf_paramsKey]*MoqFloat_starGenType_SetInf_results{},
		}
		r.Moq.ResultsByParams_SetInf = append(r.Moq.ResultsByParams_SetInf, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetInf) {
			copy(r.Moq.ResultsByParams_SetInf[insertAt+1:], r.Moq.ResultsByParams_SetInf[insertAt:0])
			r.Moq.ResultsByParams_SetInf[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetInf(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_SetInf_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_SetInf_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_SetInf_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_SetInf_doFn
				DoReturnFn MoqFloat_starGenType_SetInf_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_SetInf(params MoqFloat_starGenType_SetInf_params) string {
	return fmt.Sprintf("SetInf(%#v)", params.Signbit)
}

func (m *MoqFloat_starGenType) ParamsKey_SetInf(params MoqFloat_starGenType_SetInf_params, anyParams uint64) MoqFloat_starGenType_SetInf_paramsKey {
	m.Scene.T.Helper()
	var signbitUsed bool
	var signbitUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetInf.Signbit == moq.ParamIndexByValue {
			signbitUsed = params.Signbit
		} else {
			signbitUsedHash = hash.DeepHash(params.Signbit)
		}
	}
	return MoqFloat_starGenType_SetInf_paramsKey{
		Params: struct{ Signbit bool }{
			Signbit: signbitUsed,
		},
		Hashes: struct{ Signbit hash.Hash }{
			Signbit: signbitUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Set(x *big.Float) *MoqFloat_starGenType_Set_fnRecorder {
	return &MoqFloat_starGenType_Set_fnRecorder{
		Params: MoqFloat_starGenType_Set_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Set_fnRecorder) Any() *MoqFloat_starGenType_Set_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Set_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Set_anyParams) X() *MoqFloat_starGenType_Set_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_Set_fnRecorder) Seq() *MoqFloat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Set_fnRecorder) NoSeq() *MoqFloat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Set_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Set_doFn
		DoReturnFn MoqFloat_starGenType_Set_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Set_fnRecorder) AndDo(fn MoqFloat_starGenType_Set_doFn) *MoqFloat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Set_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Set_doReturnFn) *MoqFloat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Set_doFn
		DoReturnFn MoqFloat_starGenType_Set_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Set_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Set_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Set {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Set_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Set_paramsKey]*MoqFloat_starGenType_Set_results{},
		}
		r.Moq.ResultsByParams_Set = append(r.Moq.ResultsByParams_Set, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Set) {
			copy(r.Moq.ResultsByParams_Set[insertAt+1:], r.Moq.ResultsByParams_Set[insertAt:0])
			r.Moq.ResultsByParams_Set[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Set(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Set_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Set_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Set_doFn
				DoReturnFn MoqFloat_starGenType_Set_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Set(params MoqFloat_starGenType_Set_params) string {
	return fmt.Sprintf("Set(%#v)", params.X)
}

func (m *MoqFloat_starGenType) ParamsKey_Set(params MoqFloat_starGenType_Set_params, anyParams uint64) MoqFloat_starGenType_Set_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Float
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Set.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqFloat_starGenType_Set_paramsKey{
		Params: struct{ X *big.Float }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Copy(x *big.Float) *MoqFloat_starGenType_Copy_fnRecorder {
	return &MoqFloat_starGenType_Copy_fnRecorder{
		Params: MoqFloat_starGenType_Copy_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Copy_fnRecorder) Any() *MoqFloat_starGenType_Copy_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Copy(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Copy_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Copy_anyParams) X() *MoqFloat_starGenType_Copy_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_Copy_fnRecorder) Seq() *MoqFloat_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Copy(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Copy_fnRecorder) NoSeq() *MoqFloat_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Copy(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Copy_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Copy_doFn
		DoReturnFn MoqFloat_starGenType_Copy_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Copy_fnRecorder) AndDo(fn MoqFloat_starGenType_Copy_doFn) *MoqFloat_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Copy_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Copy_doReturnFn) *MoqFloat_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Copy_doFn
		DoReturnFn MoqFloat_starGenType_Copy_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Copy_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Copy_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Copy {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Copy_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Copy_paramsKey]*MoqFloat_starGenType_Copy_results{},
		}
		r.Moq.ResultsByParams_Copy = append(r.Moq.ResultsByParams_Copy, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Copy) {
			copy(r.Moq.ResultsByParams_Copy[insertAt+1:], r.Moq.ResultsByParams_Copy[insertAt:0])
			r.Moq.ResultsByParams_Copy[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Copy(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Copy_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Copy_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Copy_doFn
				DoReturnFn MoqFloat_starGenType_Copy_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Copy(params MoqFloat_starGenType_Copy_params) string {
	return fmt.Sprintf("Copy(%#v)", params.X)
}

func (m *MoqFloat_starGenType) ParamsKey_Copy(params MoqFloat_starGenType_Copy_params, anyParams uint64) MoqFloat_starGenType_Copy_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Float
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Copy.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqFloat_starGenType_Copy_paramsKey{
		Params: struct{ X *big.Float }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Uint64() *MoqFloat_starGenType_Uint64_fnRecorder {
	return &MoqFloat_starGenType_Uint64_fnRecorder{
		Params:   MoqFloat_starGenType_Uint64_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Uint64_fnRecorder) Any() *MoqFloat_starGenType_Uint64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Uint64(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Uint64_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_Uint64_fnRecorder) Seq() *MoqFloat_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Uint64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Uint64_fnRecorder) NoSeq() *MoqFloat_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Uint64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Uint64_fnRecorder) ReturnResults(result1 uint64, result2 big.Accuracy) *MoqFloat_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint64
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Uint64_doFn
		DoReturnFn MoqFloat_starGenType_Uint64_doReturnFn
	}{
		Values: &struct {
			Result1 uint64
			Result2 big.Accuracy
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Uint64_fnRecorder) AndDo(fn MoqFloat_starGenType_Uint64_doFn) *MoqFloat_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Uint64_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Uint64_doReturnFn) *MoqFloat_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint64
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Uint64_doFn
		DoReturnFn MoqFloat_starGenType_Uint64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Uint64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Uint64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Uint64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Uint64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Uint64_paramsKey]*MoqFloat_starGenType_Uint64_results{},
		}
		r.Moq.ResultsByParams_Uint64 = append(r.Moq.ResultsByParams_Uint64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Uint64) {
			copy(r.Moq.ResultsByParams_Uint64[insertAt+1:], r.Moq.ResultsByParams_Uint64[insertAt:0])
			r.Moq.ResultsByParams_Uint64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Uint64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Uint64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Uint64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Uint64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 uint64
					Result2 big.Accuracy
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Uint64_doFn
				DoReturnFn MoqFloat_starGenType_Uint64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Uint64(params MoqFloat_starGenType_Uint64_params) string {
	return fmt.Sprintf("Uint64()")
}

func (m *MoqFloat_starGenType) ParamsKey_Uint64(params MoqFloat_starGenType_Uint64_params, anyParams uint64) MoqFloat_starGenType_Uint64_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_Uint64_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) Int64() *MoqFloat_starGenType_Int64_fnRecorder {
	return &MoqFloat_starGenType_Int64_fnRecorder{
		Params:   MoqFloat_starGenType_Int64_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Int64_fnRecorder) Any() *MoqFloat_starGenType_Int64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int64(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Int64_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_Int64_fnRecorder) Seq() *MoqFloat_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Int64_fnRecorder) NoSeq() *MoqFloat_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Int64_fnRecorder) ReturnResults(result1 int64, result2 big.Accuracy) *MoqFloat_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Int64_doFn
		DoReturnFn MoqFloat_starGenType_Int64_doReturnFn
	}{
		Values: &struct {
			Result1 int64
			Result2 big.Accuracy
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Int64_fnRecorder) AndDo(fn MoqFloat_starGenType_Int64_doFn) *MoqFloat_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Int64_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Int64_doReturnFn) *MoqFloat_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Int64_doFn
		DoReturnFn MoqFloat_starGenType_Int64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Int64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Int64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Int64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Int64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Int64_paramsKey]*MoqFloat_starGenType_Int64_results{},
		}
		r.Moq.ResultsByParams_Int64 = append(r.Moq.ResultsByParams_Int64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Int64) {
			copy(r.Moq.ResultsByParams_Int64[insertAt+1:], r.Moq.ResultsByParams_Int64[insertAt:0])
			r.Moq.ResultsByParams_Int64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Int64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Int64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Int64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Int64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int64
					Result2 big.Accuracy
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Int64_doFn
				DoReturnFn MoqFloat_starGenType_Int64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Int64(params MoqFloat_starGenType_Int64_params) string {
	return fmt.Sprintf("Int64()")
}

func (m *MoqFloat_starGenType) ParamsKey_Int64(params MoqFloat_starGenType_Int64_params, anyParams uint64) MoqFloat_starGenType_Int64_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_Int64_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) Float32() *MoqFloat_starGenType_Float32_fnRecorder {
	return &MoqFloat_starGenType_Float32_fnRecorder{
		Params:   MoqFloat_starGenType_Float32_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Float32_fnRecorder) Any() *MoqFloat_starGenType_Float32_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float32(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Float32_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_Float32_fnRecorder) Seq() *MoqFloat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float32(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Float32_fnRecorder) NoSeq() *MoqFloat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float32(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Float32_fnRecorder) ReturnResults(result1 float32, result2 big.Accuracy) *MoqFloat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 float32
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Float32_doFn
		DoReturnFn MoqFloat_starGenType_Float32_doReturnFn
	}{
		Values: &struct {
			Result1 float32
			Result2 big.Accuracy
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Float32_fnRecorder) AndDo(fn MoqFloat_starGenType_Float32_doFn) *MoqFloat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Float32_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Float32_doReturnFn) *MoqFloat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 float32
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Float32_doFn
		DoReturnFn MoqFloat_starGenType_Float32_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Float32_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Float32_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Float32 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Float32_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Float32_paramsKey]*MoqFloat_starGenType_Float32_results{},
		}
		r.Moq.ResultsByParams_Float32 = append(r.Moq.ResultsByParams_Float32, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Float32) {
			copy(r.Moq.ResultsByParams_Float32[insertAt+1:], r.Moq.ResultsByParams_Float32[insertAt:0])
			r.Moq.ResultsByParams_Float32[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Float32(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Float32_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Float32_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Float32_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 float32
					Result2 big.Accuracy
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Float32_doFn
				DoReturnFn MoqFloat_starGenType_Float32_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Float32(params MoqFloat_starGenType_Float32_params) string {
	return fmt.Sprintf("Float32()")
}

func (m *MoqFloat_starGenType) ParamsKey_Float32(params MoqFloat_starGenType_Float32_params, anyParams uint64) MoqFloat_starGenType_Float32_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_Float32_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) Float64() *MoqFloat_starGenType_Float64_fnRecorder {
	return &MoqFloat_starGenType_Float64_fnRecorder{
		Params:   MoqFloat_starGenType_Float64_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Float64_fnRecorder) Any() *MoqFloat_starGenType_Float64_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float64(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Float64_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_Float64_fnRecorder) Seq() *MoqFloat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float64(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Float64_fnRecorder) NoSeq() *MoqFloat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float64(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Float64_fnRecorder) ReturnResults(result1 float64, result2 big.Accuracy) *MoqFloat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 float64
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Float64_doFn
		DoReturnFn MoqFloat_starGenType_Float64_doReturnFn
	}{
		Values: &struct {
			Result1 float64
			Result2 big.Accuracy
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Float64_fnRecorder) AndDo(fn MoqFloat_starGenType_Float64_doFn) *MoqFloat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Float64_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Float64_doReturnFn) *MoqFloat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 float64
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Float64_doFn
		DoReturnFn MoqFloat_starGenType_Float64_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Float64_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Float64_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Float64 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Float64_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Float64_paramsKey]*MoqFloat_starGenType_Float64_results{},
		}
		r.Moq.ResultsByParams_Float64 = append(r.Moq.ResultsByParams_Float64, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Float64) {
			copy(r.Moq.ResultsByParams_Float64[insertAt+1:], r.Moq.ResultsByParams_Float64[insertAt:0])
			r.Moq.ResultsByParams_Float64[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Float64(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Float64_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Float64_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Float64_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 float64
					Result2 big.Accuracy
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Float64_doFn
				DoReturnFn MoqFloat_starGenType_Float64_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Float64(params MoqFloat_starGenType_Float64_params) string {
	return fmt.Sprintf("Float64()")
}

func (m *MoqFloat_starGenType) ParamsKey_Float64(params MoqFloat_starGenType_Float64_params, anyParams uint64) MoqFloat_starGenType_Float64_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_Float64_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) Int(z *big.Int) *MoqFloat_starGenType_Int_fnRecorder {
	return &MoqFloat_starGenType_Int_fnRecorder{
		Params: MoqFloat_starGenType_Int_params{
			Z: z,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Int_fnRecorder) Any() *MoqFloat_starGenType_Int_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Int_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Int_anyParams) Z() *MoqFloat_starGenType_Int_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_Int_fnRecorder) Seq() *MoqFloat_starGenType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Int_fnRecorder) NoSeq() *MoqFloat_starGenType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Int_fnRecorder) ReturnResults(result1 *big.Int, result2 big.Accuracy) *MoqFloat_starGenType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Int_doFn
		DoReturnFn MoqFloat_starGenType_Int_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Int
			Result2 big.Accuracy
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Int_fnRecorder) AndDo(fn MoqFloat_starGenType_Int_doFn) *MoqFloat_starGenType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Int_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Int_doReturnFn) *MoqFloat_starGenType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Int
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Int_doFn
		DoReturnFn MoqFloat_starGenType_Int_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Int_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Int_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Int {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Int_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Int_paramsKey]*MoqFloat_starGenType_Int_results{},
		}
		r.Moq.ResultsByParams_Int = append(r.Moq.ResultsByParams_Int, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Int) {
			copy(r.Moq.ResultsByParams_Int[insertAt+1:], r.Moq.ResultsByParams_Int[insertAt:0])
			r.Moq.ResultsByParams_Int[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Int(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Int_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Int_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Int
					Result2 big.Accuracy
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Int_doFn
				DoReturnFn MoqFloat_starGenType_Int_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Int(params MoqFloat_starGenType_Int_params) string {
	return fmt.Sprintf("Int(%#v)", params.Z)
}

func (m *MoqFloat_starGenType) ParamsKey_Int(params MoqFloat_starGenType_Int_params, anyParams uint64) MoqFloat_starGenType_Int_paramsKey {
	m.Scene.T.Helper()
	var zUsed *big.Int
	var zUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Int.Z == moq.ParamIndexByValue {
			zUsed = params.Z
		} else {
			zUsedHash = hash.DeepHash(params.Z)
		}
	}
	return MoqFloat_starGenType_Int_paramsKey{
		Params: struct{ Z *big.Int }{
			Z: zUsed,
		},
		Hashes: struct{ Z hash.Hash }{
			Z: zUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Rat(z *big.Rat) *MoqFloat_starGenType_Rat_fnRecorder {
	return &MoqFloat_starGenType_Rat_fnRecorder{
		Params: MoqFloat_starGenType_Rat_params{
			Z: z,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Rat_fnRecorder) Any() *MoqFloat_starGenType_Rat_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rat(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Rat_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Rat_anyParams) Z() *MoqFloat_starGenType_Rat_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_Rat_fnRecorder) Seq() *MoqFloat_starGenType_Rat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rat(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Rat_fnRecorder) NoSeq() *MoqFloat_starGenType_Rat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rat(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Rat_fnRecorder) ReturnResults(result1 *big.Rat, result2 big.Accuracy) *MoqFloat_starGenType_Rat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Rat_doFn
		DoReturnFn MoqFloat_starGenType_Rat_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Rat
			Result2 big.Accuracy
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Rat_fnRecorder) AndDo(fn MoqFloat_starGenType_Rat_doFn) *MoqFloat_starGenType_Rat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Rat_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Rat_doReturnFn) *MoqFloat_starGenType_Rat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Rat
			Result2 big.Accuracy
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Rat_doFn
		DoReturnFn MoqFloat_starGenType_Rat_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Rat_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Rat_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Rat {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Rat_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Rat_paramsKey]*MoqFloat_starGenType_Rat_results{},
		}
		r.Moq.ResultsByParams_Rat = append(r.Moq.ResultsByParams_Rat, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Rat) {
			copy(r.Moq.ResultsByParams_Rat[insertAt+1:], r.Moq.ResultsByParams_Rat[insertAt:0])
			r.Moq.ResultsByParams_Rat[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Rat(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Rat_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Rat_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Rat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Rat
					Result2 big.Accuracy
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Rat_doFn
				DoReturnFn MoqFloat_starGenType_Rat_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Rat(params MoqFloat_starGenType_Rat_params) string {
	return fmt.Sprintf("Rat(%#v)", params.Z)
}

func (m *MoqFloat_starGenType) ParamsKey_Rat(params MoqFloat_starGenType_Rat_params, anyParams uint64) MoqFloat_starGenType_Rat_paramsKey {
	m.Scene.T.Helper()
	var zUsed *big.Rat
	var zUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Rat.Z == moq.ParamIndexByValue {
			zUsed = params.Z
		} else {
			zUsedHash = hash.DeepHash(params.Z)
		}
	}
	return MoqFloat_starGenType_Rat_paramsKey{
		Params: struct{ Z *big.Rat }{
			Z: zUsed,
		},
		Hashes: struct{ Z hash.Hash }{
			Z: zUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Abs(x *big.Float) *MoqFloat_starGenType_Abs_fnRecorder {
	return &MoqFloat_starGenType_Abs_fnRecorder{
		Params: MoqFloat_starGenType_Abs_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Abs_fnRecorder) Any() *MoqFloat_starGenType_Abs_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Abs(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Abs_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Abs_anyParams) X() *MoqFloat_starGenType_Abs_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_Abs_fnRecorder) Seq() *MoqFloat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Abs(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Abs_fnRecorder) NoSeq() *MoqFloat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Abs(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Abs_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Abs_doFn
		DoReturnFn MoqFloat_starGenType_Abs_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Abs_fnRecorder) AndDo(fn MoqFloat_starGenType_Abs_doFn) *MoqFloat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Abs_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Abs_doReturnFn) *MoqFloat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Abs_doFn
		DoReturnFn MoqFloat_starGenType_Abs_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Abs_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Abs_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Abs {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Abs_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Abs_paramsKey]*MoqFloat_starGenType_Abs_results{},
		}
		r.Moq.ResultsByParams_Abs = append(r.Moq.ResultsByParams_Abs, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Abs) {
			copy(r.Moq.ResultsByParams_Abs[insertAt+1:], r.Moq.ResultsByParams_Abs[insertAt:0])
			r.Moq.ResultsByParams_Abs[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Abs(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Abs_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Abs_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Abs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Abs_doFn
				DoReturnFn MoqFloat_starGenType_Abs_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Abs(params MoqFloat_starGenType_Abs_params) string {
	return fmt.Sprintf("Abs(%#v)", params.X)
}

func (m *MoqFloat_starGenType) ParamsKey_Abs(params MoqFloat_starGenType_Abs_params, anyParams uint64) MoqFloat_starGenType_Abs_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Float
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Abs.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqFloat_starGenType_Abs_paramsKey{
		Params: struct{ X *big.Float }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Neg(x *big.Float) *MoqFloat_starGenType_Neg_fnRecorder {
	return &MoqFloat_starGenType_Neg_fnRecorder{
		Params: MoqFloat_starGenType_Neg_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Neg_fnRecorder) Any() *MoqFloat_starGenType_Neg_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Neg(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Neg_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Neg_anyParams) X() *MoqFloat_starGenType_Neg_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_Neg_fnRecorder) Seq() *MoqFloat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Neg(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Neg_fnRecorder) NoSeq() *MoqFloat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Neg(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Neg_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Neg_doFn
		DoReturnFn MoqFloat_starGenType_Neg_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Neg_fnRecorder) AndDo(fn MoqFloat_starGenType_Neg_doFn) *MoqFloat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Neg_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Neg_doReturnFn) *MoqFloat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Neg_doFn
		DoReturnFn MoqFloat_starGenType_Neg_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Neg_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Neg_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Neg {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Neg_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Neg_paramsKey]*MoqFloat_starGenType_Neg_results{},
		}
		r.Moq.ResultsByParams_Neg = append(r.Moq.ResultsByParams_Neg, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Neg) {
			copy(r.Moq.ResultsByParams_Neg[insertAt+1:], r.Moq.ResultsByParams_Neg[insertAt:0])
			r.Moq.ResultsByParams_Neg[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Neg(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Neg_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Neg_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Neg_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Neg_doFn
				DoReturnFn MoqFloat_starGenType_Neg_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Neg(params MoqFloat_starGenType_Neg_params) string {
	return fmt.Sprintf("Neg(%#v)", params.X)
}

func (m *MoqFloat_starGenType) ParamsKey_Neg(params MoqFloat_starGenType_Neg_params, anyParams uint64) MoqFloat_starGenType_Neg_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Float
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Neg.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqFloat_starGenType_Neg_paramsKey{
		Params: struct{ X *big.Float }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Add(x, y *big.Float) *MoqFloat_starGenType_Add_fnRecorder {
	return &MoqFloat_starGenType_Add_fnRecorder{
		Params: MoqFloat_starGenType_Add_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Add_fnRecorder) Any() *MoqFloat_starGenType_Add_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Add_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Add_anyParams) X() *MoqFloat_starGenType_Add_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFloat_starGenType_Add_anyParams) Y() *MoqFloat_starGenType_Add_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFloat_starGenType_Add_fnRecorder) Seq() *MoqFloat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Add_fnRecorder) NoSeq() *MoqFloat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Add_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Add_doFn
		DoReturnFn MoqFloat_starGenType_Add_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Add_fnRecorder) AndDo(fn MoqFloat_starGenType_Add_doFn) *MoqFloat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Add_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Add_doReturnFn) *MoqFloat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Add_doFn
		DoReturnFn MoqFloat_starGenType_Add_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Add_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Add_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Add {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Add_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Add_paramsKey]*MoqFloat_starGenType_Add_results{},
		}
		r.Moq.ResultsByParams_Add = append(r.Moq.ResultsByParams_Add, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Add) {
			copy(r.Moq.ResultsByParams_Add[insertAt+1:], r.Moq.ResultsByParams_Add[insertAt:0])
			r.Moq.ResultsByParams_Add[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Add(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Add_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Add_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Add_doFn
				DoReturnFn MoqFloat_starGenType_Add_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Add(params MoqFloat_starGenType_Add_params) string {
	return fmt.Sprintf("Add(%#v, %#v)", params.X, params.Y)
}

func (m *MoqFloat_starGenType) ParamsKey_Add(params MoqFloat_starGenType_Add_params, anyParams uint64) MoqFloat_starGenType_Add_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Float
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Add.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Float
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Add.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqFloat_starGenType_Add_paramsKey{
		Params: struct{ X, Y *big.Float }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Sub(x, y *big.Float) *MoqFloat_starGenType_Sub_fnRecorder {
	return &MoqFloat_starGenType_Sub_fnRecorder{
		Params: MoqFloat_starGenType_Sub_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Sub_fnRecorder) Any() *MoqFloat_starGenType_Sub_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Sub_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Sub_anyParams) X() *MoqFloat_starGenType_Sub_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFloat_starGenType_Sub_anyParams) Y() *MoqFloat_starGenType_Sub_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFloat_starGenType_Sub_fnRecorder) Seq() *MoqFloat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Sub_fnRecorder) NoSeq() *MoqFloat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Sub_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Sub_doFn
		DoReturnFn MoqFloat_starGenType_Sub_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Sub_fnRecorder) AndDo(fn MoqFloat_starGenType_Sub_doFn) *MoqFloat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Sub_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Sub_doReturnFn) *MoqFloat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Sub_doFn
		DoReturnFn MoqFloat_starGenType_Sub_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Sub_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Sub_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Sub {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Sub_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Sub_paramsKey]*MoqFloat_starGenType_Sub_results{},
		}
		r.Moq.ResultsByParams_Sub = append(r.Moq.ResultsByParams_Sub, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Sub) {
			copy(r.Moq.ResultsByParams_Sub[insertAt+1:], r.Moq.ResultsByParams_Sub[insertAt:0])
			r.Moq.ResultsByParams_Sub[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Sub(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Sub_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Sub_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Sub_doFn
				DoReturnFn MoqFloat_starGenType_Sub_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Sub(params MoqFloat_starGenType_Sub_params) string {
	return fmt.Sprintf("Sub(%#v, %#v)", params.X, params.Y)
}

func (m *MoqFloat_starGenType) ParamsKey_Sub(params MoqFloat_starGenType_Sub_params, anyParams uint64) MoqFloat_starGenType_Sub_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Float
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Sub.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Float
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Sub.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqFloat_starGenType_Sub_paramsKey{
		Params: struct{ X, Y *big.Float }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Mul(x, y *big.Float) *MoqFloat_starGenType_Mul_fnRecorder {
	return &MoqFloat_starGenType_Mul_fnRecorder{
		Params: MoqFloat_starGenType_Mul_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Mul_fnRecorder) Any() *MoqFloat_starGenType_Mul_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mul(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Mul_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Mul_anyParams) X() *MoqFloat_starGenType_Mul_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFloat_starGenType_Mul_anyParams) Y() *MoqFloat_starGenType_Mul_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFloat_starGenType_Mul_fnRecorder) Seq() *MoqFloat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mul(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Mul_fnRecorder) NoSeq() *MoqFloat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mul(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Mul_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Mul_doFn
		DoReturnFn MoqFloat_starGenType_Mul_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Mul_fnRecorder) AndDo(fn MoqFloat_starGenType_Mul_doFn) *MoqFloat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Mul_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Mul_doReturnFn) *MoqFloat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Mul_doFn
		DoReturnFn MoqFloat_starGenType_Mul_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Mul_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Mul_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Mul {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Mul_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Mul_paramsKey]*MoqFloat_starGenType_Mul_results{},
		}
		r.Moq.ResultsByParams_Mul = append(r.Moq.ResultsByParams_Mul, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Mul) {
			copy(r.Moq.ResultsByParams_Mul[insertAt+1:], r.Moq.ResultsByParams_Mul[insertAt:0])
			r.Moq.ResultsByParams_Mul[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Mul(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Mul_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Mul_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Mul_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Mul_doFn
				DoReturnFn MoqFloat_starGenType_Mul_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Mul(params MoqFloat_starGenType_Mul_params) string {
	return fmt.Sprintf("Mul(%#v, %#v)", params.X, params.Y)
}

func (m *MoqFloat_starGenType) ParamsKey_Mul(params MoqFloat_starGenType_Mul_params, anyParams uint64) MoqFloat_starGenType_Mul_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Float
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Mul.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Float
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Mul.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqFloat_starGenType_Mul_paramsKey{
		Params: struct{ X, Y *big.Float }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Quo(x, y *big.Float) *MoqFloat_starGenType_Quo_fnRecorder {
	return &MoqFloat_starGenType_Quo_fnRecorder{
		Params: MoqFloat_starGenType_Quo_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Quo_fnRecorder) Any() *MoqFloat_starGenType_Quo_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quo(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Quo_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Quo_anyParams) X() *MoqFloat_starGenType_Quo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFloat_starGenType_Quo_anyParams) Y() *MoqFloat_starGenType_Quo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFloat_starGenType_Quo_fnRecorder) Seq() *MoqFloat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quo(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Quo_fnRecorder) NoSeq() *MoqFloat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quo(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Quo_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Quo_doFn
		DoReturnFn MoqFloat_starGenType_Quo_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Quo_fnRecorder) AndDo(fn MoqFloat_starGenType_Quo_doFn) *MoqFloat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Quo_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Quo_doReturnFn) *MoqFloat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Quo_doFn
		DoReturnFn MoqFloat_starGenType_Quo_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Quo_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Quo_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Quo {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Quo_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Quo_paramsKey]*MoqFloat_starGenType_Quo_results{},
		}
		r.Moq.ResultsByParams_Quo = append(r.Moq.ResultsByParams_Quo, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Quo) {
			copy(r.Moq.ResultsByParams_Quo[insertAt+1:], r.Moq.ResultsByParams_Quo[insertAt:0])
			r.Moq.ResultsByParams_Quo[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Quo(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Quo_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Quo_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Quo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Quo_doFn
				DoReturnFn MoqFloat_starGenType_Quo_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Quo(params MoqFloat_starGenType_Quo_params) string {
	return fmt.Sprintf("Quo(%#v, %#v)", params.X, params.Y)
}

func (m *MoqFloat_starGenType) ParamsKey_Quo(params MoqFloat_starGenType_Quo_params, anyParams uint64) MoqFloat_starGenType_Quo_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Float
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Quo.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed *big.Float
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Quo.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqFloat_starGenType_Quo_paramsKey{
		Params: struct{ X, Y *big.Float }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Cmp(y *big.Float) *MoqFloat_starGenType_Cmp_fnRecorder {
	return &MoqFloat_starGenType_Cmp_fnRecorder{
		Params: MoqFloat_starGenType_Cmp_params{
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Cmp_fnRecorder) Any() *MoqFloat_starGenType_Cmp_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cmp(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Cmp_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Cmp_anyParams) Y() *MoqFloat_starGenType_Cmp_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_Cmp_fnRecorder) Seq() *MoqFloat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cmp(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Cmp_fnRecorder) NoSeq() *MoqFloat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cmp(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Cmp_fnRecorder) ReturnResults(result1 int) *MoqFloat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Cmp_doFn
		DoReturnFn MoqFloat_starGenType_Cmp_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Cmp_fnRecorder) AndDo(fn MoqFloat_starGenType_Cmp_doFn) *MoqFloat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Cmp_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Cmp_doReturnFn) *MoqFloat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Cmp_doFn
		DoReturnFn MoqFloat_starGenType_Cmp_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Cmp_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Cmp_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Cmp {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Cmp_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Cmp_paramsKey]*MoqFloat_starGenType_Cmp_results{},
		}
		r.Moq.ResultsByParams_Cmp = append(r.Moq.ResultsByParams_Cmp, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Cmp) {
			copy(r.Moq.ResultsByParams_Cmp[insertAt+1:], r.Moq.ResultsByParams_Cmp[insertAt:0])
			r.Moq.ResultsByParams_Cmp[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Cmp(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Cmp_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Cmp_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Cmp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Cmp_doFn
				DoReturnFn MoqFloat_starGenType_Cmp_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Cmp(params MoqFloat_starGenType_Cmp_params) string {
	return fmt.Sprintf("Cmp(%#v)", params.Y)
}

func (m *MoqFloat_starGenType) ParamsKey_Cmp(params MoqFloat_starGenType_Cmp_params, anyParams uint64) MoqFloat_starGenType_Cmp_paramsKey {
	m.Scene.T.Helper()
	var yUsed *big.Float
	var yUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Cmp.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqFloat_starGenType_Cmp_paramsKey{
		Params: struct{ Y *big.Float }{
			Y: yUsed,
		},
		Hashes: struct{ Y hash.Hash }{
			Y: yUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) SetString(s string) *MoqFloat_starGenType_SetString_fnRecorder {
	return &MoqFloat_starGenType_SetString_fnRecorder{
		Params: MoqFloat_starGenType_SetString_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_SetString_fnRecorder) Any() *MoqFloat_starGenType_SetString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_SetString_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_SetString_anyParams) S() *MoqFloat_starGenType_SetString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_SetString_fnRecorder) Seq() *MoqFloat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_SetString_fnRecorder) NoSeq() *MoqFloat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_SetString_fnRecorder) ReturnResults(result1 *big.Float, result2 bool) *MoqFloat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetString_doFn
		DoReturnFn MoqFloat_starGenType_SetString_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
			Result2 bool
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_SetString_fnRecorder) AndDo(fn MoqFloat_starGenType_SetString_doFn) *MoqFloat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_SetString_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_SetString_doReturnFn) *MoqFloat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_SetString_doFn
		DoReturnFn MoqFloat_starGenType_SetString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_SetString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_SetString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_SetString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_SetString_paramsKey]*MoqFloat_starGenType_SetString_results{},
		}
		r.Moq.ResultsByParams_SetString = append(r.Moq.ResultsByParams_SetString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetString) {
			copy(r.Moq.ResultsByParams_SetString[insertAt+1:], r.Moq.ResultsByParams_SetString[insertAt:0])
			r.Moq.ResultsByParams_SetString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_SetString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_SetString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
					Result2 bool
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_SetString_doFn
				DoReturnFn MoqFloat_starGenType_SetString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_SetString(params MoqFloat_starGenType_SetString_params) string {
	return fmt.Sprintf("SetString(%#v)", params.S)
}

func (m *MoqFloat_starGenType) ParamsKey_SetString(params MoqFloat_starGenType_SetString_params, anyParams uint64) MoqFloat_starGenType_SetString_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetString.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqFloat_starGenType_SetString_paramsKey{
		Params: struct{ S string }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Parse(s string, base int) *MoqFloat_starGenType_Parse_fnRecorder {
	return &MoqFloat_starGenType_Parse_fnRecorder{
		Params: MoqFloat_starGenType_Parse_params{
			S:    s,
			Base: base,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Parse_fnRecorder) Any() *MoqFloat_starGenType_Parse_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parse(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Parse_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Parse_anyParams) S() *MoqFloat_starGenType_Parse_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFloat_starGenType_Parse_anyParams) Base() *MoqFloat_starGenType_Parse_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFloat_starGenType_Parse_fnRecorder) Seq() *MoqFloat_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parse(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Parse_fnRecorder) NoSeq() *MoqFloat_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parse(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Parse_fnRecorder) ReturnResults(f *big.Float, b int, err error) *MoqFloat_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			F   *big.Float
			B   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Parse_doFn
		DoReturnFn MoqFloat_starGenType_Parse_doReturnFn
	}{
		Values: &struct {
			F   *big.Float
			B   int
			Err error
		}{
			F:   f,
			B:   b,
			Err: err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Parse_fnRecorder) AndDo(fn MoqFloat_starGenType_Parse_doFn) *MoqFloat_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Parse_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Parse_doReturnFn) *MoqFloat_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			F   *big.Float
			B   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Parse_doFn
		DoReturnFn MoqFloat_starGenType_Parse_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Parse_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Parse_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Parse {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Parse_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Parse_paramsKey]*MoqFloat_starGenType_Parse_results{},
		}
		r.Moq.ResultsByParams_Parse = append(r.Moq.ResultsByParams_Parse, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Parse) {
			copy(r.Moq.ResultsByParams_Parse[insertAt+1:], r.Moq.ResultsByParams_Parse[insertAt:0])
			r.Moq.ResultsByParams_Parse[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Parse(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Parse_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Parse_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					F   *big.Float
					B   int
					Err error
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Parse_doFn
				DoReturnFn MoqFloat_starGenType_Parse_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Parse(params MoqFloat_starGenType_Parse_params) string {
	return fmt.Sprintf("Parse(%#v, %#v)", params.S, params.Base)
}

func (m *MoqFloat_starGenType) ParamsKey_Parse(params MoqFloat_starGenType_Parse_params, anyParams uint64) MoqFloat_starGenType_Parse_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Parse.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var baseUsed int
	var baseUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Parse.Base == moq.ParamIndexByValue {
			baseUsed = params.Base
		} else {
			baseUsedHash = hash.DeepHash(params.Base)
		}
	}
	return MoqFloat_starGenType_Parse_paramsKey{
		Params: struct {
			S    string
			Base int
		}{
			S:    sUsed,
			Base: baseUsed,
		},
		Hashes: struct {
			S    hash.Hash
			Base hash.Hash
		}{
			S:    sUsedHash,
			Base: baseUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Scan(s fmt.ScanState, ch rune) *MoqFloat_starGenType_Scan_fnRecorder {
	return &MoqFloat_starGenType_Scan_fnRecorder{
		Params: MoqFloat_starGenType_Scan_params{
			S:  s,
			Ch: ch,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Scan_fnRecorder) Any() *MoqFloat_starGenType_Scan_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Scan(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Scan_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Scan_anyParams) S() *MoqFloat_starGenType_Scan_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFloat_starGenType_Scan_anyParams) Ch() *MoqFloat_starGenType_Scan_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFloat_starGenType_Scan_fnRecorder) Seq() *MoqFloat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Scan(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Scan_fnRecorder) NoSeq() *MoqFloat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Scan(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Scan_fnRecorder) ReturnResults(result1 error) *MoqFloat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Scan_doFn
		DoReturnFn MoqFloat_starGenType_Scan_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Scan_fnRecorder) AndDo(fn MoqFloat_starGenType_Scan_doFn) *MoqFloat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Scan_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Scan_doReturnFn) *MoqFloat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Scan_doFn
		DoReturnFn MoqFloat_starGenType_Scan_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Scan_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Scan_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Scan {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Scan_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Scan_paramsKey]*MoqFloat_starGenType_Scan_results{},
		}
		r.Moq.ResultsByParams_Scan = append(r.Moq.ResultsByParams_Scan, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Scan) {
			copy(r.Moq.ResultsByParams_Scan[insertAt+1:], r.Moq.ResultsByParams_Scan[insertAt:0])
			r.Moq.ResultsByParams_Scan[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Scan(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Scan_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Scan_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Scan_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Scan_doFn
				DoReturnFn MoqFloat_starGenType_Scan_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Scan(params MoqFloat_starGenType_Scan_params) string {
	return fmt.Sprintf("Scan(%#v, %#v)", params.S, params.Ch)
}

func (m *MoqFloat_starGenType) ParamsKey_Scan(params MoqFloat_starGenType_Scan_params, anyParams uint64) MoqFloat_starGenType_Scan_paramsKey {
	m.Scene.T.Helper()
	var sUsed fmt.ScanState
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Scan.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var chUsed rune
	var chUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Scan.Ch == moq.ParamIndexByValue {
			chUsed = params.Ch
		} else {
			chUsedHash = hash.DeepHash(params.Ch)
		}
	}
	return MoqFloat_starGenType_Scan_paramsKey{
		Params: struct {
			S  fmt.ScanState
			Ch rune
		}{
			S:  sUsed,
			Ch: chUsed,
		},
		Hashes: struct {
			S  hash.Hash
			Ch hash.Hash
		}{
			S:  sUsedHash,
			Ch: chUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) GobEncode() *MoqFloat_starGenType_GobEncode_fnRecorder {
	return &MoqFloat_starGenType_GobEncode_fnRecorder{
		Params:   MoqFloat_starGenType_GobEncode_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_GobEncode_fnRecorder) Any() *MoqFloat_starGenType_GobEncode_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_GobEncode_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_GobEncode_fnRecorder) Seq() *MoqFloat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_GobEncode_fnRecorder) NoSeq() *MoqFloat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_GobEncode_fnRecorder) ReturnResults(result1 []byte, result2 error) *MoqFloat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_GobEncode_doFn
		DoReturnFn MoqFloat_starGenType_GobEncode_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_GobEncode_fnRecorder) AndDo(fn MoqFloat_starGenType_GobEncode_doFn) *MoqFloat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_GobEncode_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_GobEncode_doReturnFn) *MoqFloat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_GobEncode_doFn
		DoReturnFn MoqFloat_starGenType_GobEncode_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_GobEncode_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_GobEncode_resultsByParams
	for n, res := range r.Moq.ResultsByParams_GobEncode {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_GobEncode_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_GobEncode_paramsKey]*MoqFloat_starGenType_GobEncode_results{},
		}
		r.Moq.ResultsByParams_GobEncode = append(r.Moq.ResultsByParams_GobEncode, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_GobEncode) {
			copy(r.Moq.ResultsByParams_GobEncode[insertAt+1:], r.Moq.ResultsByParams_GobEncode[insertAt:0])
			r.Moq.ResultsByParams_GobEncode[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_GobEncode(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_GobEncode_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_GobEncode_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_GobEncode_doFn
				DoReturnFn MoqFloat_starGenType_GobEncode_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_GobEncode(params MoqFloat_starGenType_GobEncode_params) string {
	return fmt.Sprintf("GobEncode()")
}

func (m *MoqFloat_starGenType) ParamsKey_GobEncode(params MoqFloat_starGenType_GobEncode_params, anyParams uint64) MoqFloat_starGenType_GobEncode_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_GobEncode_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) GobDecode(buf []byte) *MoqFloat_starGenType_GobDecode_fnRecorder {
	return &MoqFloat_starGenType_GobDecode_fnRecorder{
		Params: MoqFloat_starGenType_GobDecode_params{
			Buf: buf,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_GobDecode_fnRecorder) Any() *MoqFloat_starGenType_GobDecode_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobDecode(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_GobDecode_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_GobDecode_anyParams) Buf() *MoqFloat_starGenType_GobDecode_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_GobDecode_fnRecorder) Seq() *MoqFloat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobDecode(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_GobDecode_fnRecorder) NoSeq() *MoqFloat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobDecode(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_GobDecode_fnRecorder) ReturnResults(result1 error) *MoqFloat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_GobDecode_doFn
		DoReturnFn MoqFloat_starGenType_GobDecode_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_GobDecode_fnRecorder) AndDo(fn MoqFloat_starGenType_GobDecode_doFn) *MoqFloat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_GobDecode_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_GobDecode_doReturnFn) *MoqFloat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_GobDecode_doFn
		DoReturnFn MoqFloat_starGenType_GobDecode_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_GobDecode_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_GobDecode_resultsByParams
	for n, res := range r.Moq.ResultsByParams_GobDecode {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_GobDecode_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_GobDecode_paramsKey]*MoqFloat_starGenType_GobDecode_results{},
		}
		r.Moq.ResultsByParams_GobDecode = append(r.Moq.ResultsByParams_GobDecode, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_GobDecode) {
			copy(r.Moq.ResultsByParams_GobDecode[insertAt+1:], r.Moq.ResultsByParams_GobDecode[insertAt:0])
			r.Moq.ResultsByParams_GobDecode[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_GobDecode(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_GobDecode_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_GobDecode_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_GobDecode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_GobDecode_doFn
				DoReturnFn MoqFloat_starGenType_GobDecode_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_GobDecode(params MoqFloat_starGenType_GobDecode_params) string {
	return fmt.Sprintf("GobDecode(%#v)", params.Buf)
}

func (m *MoqFloat_starGenType) ParamsKey_GobDecode(params MoqFloat_starGenType_GobDecode_params, anyParams uint64) MoqFloat_starGenType_GobDecode_paramsKey {
	m.Scene.T.Helper()
	var bufUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.GobDecode.Buf == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The buf parameter of the GobDecode function can't be indexed by value")
		}
		bufUsedHash = hash.DeepHash(params.Buf)
	}
	return MoqFloat_starGenType_GobDecode_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Buf hash.Hash }{
			Buf: bufUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) MarshalText() *MoqFloat_starGenType_MarshalText_fnRecorder {
	return &MoqFloat_starGenType_MarshalText_fnRecorder{
		Params:   MoqFloat_starGenType_MarshalText_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_MarshalText_fnRecorder) Any() *MoqFloat_starGenType_MarshalText_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_MarshalText_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_MarshalText_fnRecorder) Seq() *MoqFloat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_MarshalText_fnRecorder) NoSeq() *MoqFloat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_MarshalText_fnRecorder) ReturnResults(text []byte, err error) *MoqFloat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_MarshalText_doFn
		DoReturnFn MoqFloat_starGenType_MarshalText_doReturnFn
	}{
		Values: &struct {
			Text []byte
			Err  error
		}{
			Text: text,
			Err:  err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_MarshalText_fnRecorder) AndDo(fn MoqFloat_starGenType_MarshalText_doFn) *MoqFloat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_MarshalText_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_MarshalText_doReturnFn) *MoqFloat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_MarshalText_doFn
		DoReturnFn MoqFloat_starGenType_MarshalText_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_MarshalText_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_MarshalText_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MarshalText {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_MarshalText_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_MarshalText_paramsKey]*MoqFloat_starGenType_MarshalText_results{},
		}
		r.Moq.ResultsByParams_MarshalText = append(r.Moq.ResultsByParams_MarshalText, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MarshalText) {
			copy(r.Moq.ResultsByParams_MarshalText[insertAt+1:], r.Moq.ResultsByParams_MarshalText[insertAt:0])
			r.Moq.ResultsByParams_MarshalText[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MarshalText(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_MarshalText_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_MarshalText_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Text []byte
					Err  error
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_MarshalText_doFn
				DoReturnFn MoqFloat_starGenType_MarshalText_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_MarshalText(params MoqFloat_starGenType_MarshalText_params) string {
	return fmt.Sprintf("MarshalText()")
}

func (m *MoqFloat_starGenType) ParamsKey_MarshalText(params MoqFloat_starGenType_MarshalText_params, anyParams uint64) MoqFloat_starGenType_MarshalText_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_MarshalText_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) UnmarshalText(text []byte) *MoqFloat_starGenType_UnmarshalText_fnRecorder {
	return &MoqFloat_starGenType_UnmarshalText_fnRecorder{
		Params: MoqFloat_starGenType_UnmarshalText_params{
			Text: text,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_UnmarshalText_fnRecorder) Any() *MoqFloat_starGenType_UnmarshalText_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalText(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_UnmarshalText_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_UnmarshalText_anyParams) Text() *MoqFloat_starGenType_UnmarshalText_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_UnmarshalText_fnRecorder) Seq() *MoqFloat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalText(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_UnmarshalText_fnRecorder) NoSeq() *MoqFloat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalText(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_UnmarshalText_fnRecorder) ReturnResults(result1 error) *MoqFloat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_UnmarshalText_doFn
		DoReturnFn MoqFloat_starGenType_UnmarshalText_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_UnmarshalText_fnRecorder) AndDo(fn MoqFloat_starGenType_UnmarshalText_doFn) *MoqFloat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_UnmarshalText_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_UnmarshalText_doReturnFn) *MoqFloat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_UnmarshalText_doFn
		DoReturnFn MoqFloat_starGenType_UnmarshalText_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_UnmarshalText_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_UnmarshalText_resultsByParams
	for n, res := range r.Moq.ResultsByParams_UnmarshalText {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_UnmarshalText_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_UnmarshalText_paramsKey]*MoqFloat_starGenType_UnmarshalText_results{},
		}
		r.Moq.ResultsByParams_UnmarshalText = append(r.Moq.ResultsByParams_UnmarshalText, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_UnmarshalText) {
			copy(r.Moq.ResultsByParams_UnmarshalText[insertAt+1:], r.Moq.ResultsByParams_UnmarshalText[insertAt:0])
			r.Moq.ResultsByParams_UnmarshalText[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_UnmarshalText(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_UnmarshalText_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_UnmarshalText_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_UnmarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_UnmarshalText_doFn
				DoReturnFn MoqFloat_starGenType_UnmarshalText_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_UnmarshalText(params MoqFloat_starGenType_UnmarshalText_params) string {
	return fmt.Sprintf("UnmarshalText(%#v)", params.Text)
}

func (m *MoqFloat_starGenType) ParamsKey_UnmarshalText(params MoqFloat_starGenType_UnmarshalText_params, anyParams uint64) MoqFloat_starGenType_UnmarshalText_paramsKey {
	m.Scene.T.Helper()
	var textUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.UnmarshalText.Text == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The text parameter of the UnmarshalText function can't be indexed by value")
		}
		textUsedHash = hash.DeepHash(params.Text)
	}
	return MoqFloat_starGenType_UnmarshalText_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Text hash.Hash }{
			Text: textUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Text(format byte, prec int) *MoqFloat_starGenType_Text_fnRecorder {
	return &MoqFloat_starGenType_Text_fnRecorder{
		Params: MoqFloat_starGenType_Text_params{
			Format: format,
			Prec:   prec,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Text_fnRecorder) Any() *MoqFloat_starGenType_Text_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Text(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Text_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Text_anyParams) Format() *MoqFloat_starGenType_Text_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFloat_starGenType_Text_anyParams) Prec() *MoqFloat_starGenType_Text_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFloat_starGenType_Text_fnRecorder) Seq() *MoqFloat_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Text(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Text_fnRecorder) NoSeq() *MoqFloat_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Text(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Text_fnRecorder) ReturnResults(result1 string) *MoqFloat_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Text_doFn
		DoReturnFn MoqFloat_starGenType_Text_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Text_fnRecorder) AndDo(fn MoqFloat_starGenType_Text_doFn) *MoqFloat_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Text_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Text_doReturnFn) *MoqFloat_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Text_doFn
		DoReturnFn MoqFloat_starGenType_Text_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Text_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Text_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Text {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Text_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Text_paramsKey]*MoqFloat_starGenType_Text_results{},
		}
		r.Moq.ResultsByParams_Text = append(r.Moq.ResultsByParams_Text, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Text) {
			copy(r.Moq.ResultsByParams_Text[insertAt+1:], r.Moq.ResultsByParams_Text[insertAt:0])
			r.Moq.ResultsByParams_Text[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Text(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Text_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Text_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Text_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Text_doFn
				DoReturnFn MoqFloat_starGenType_Text_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Text(params MoqFloat_starGenType_Text_params) string {
	return fmt.Sprintf("Text(%#v, %#v)", params.Format, params.Prec)
}

func (m *MoqFloat_starGenType) ParamsKey_Text(params MoqFloat_starGenType_Text_params, anyParams uint64) MoqFloat_starGenType_Text_paramsKey {
	m.Scene.T.Helper()
	var formatUsed byte
	var formatUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Text.Format == moq.ParamIndexByValue {
			formatUsed = params.Format
		} else {
			formatUsedHash = hash.DeepHash(params.Format)
		}
	}
	var precUsed int
	var precUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Text.Prec == moq.ParamIndexByValue {
			precUsed = params.Prec
		} else {
			precUsedHash = hash.DeepHash(params.Prec)
		}
	}
	return MoqFloat_starGenType_Text_paramsKey{
		Params: struct {
			Format byte
			Prec   int
		}{
			Format: formatUsed,
			Prec:   precUsed,
		},
		Hashes: struct {
			Format hash.Hash
			Prec   hash.Hash
		}{
			Format: formatUsedHash,
			Prec:   precUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) String() *MoqFloat_starGenType_String_fnRecorder {
	return &MoqFloat_starGenType_String_fnRecorder{
		Params:   MoqFloat_starGenType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_String_fnRecorder) Any() *MoqFloat_starGenType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_String_anyParams{Recorder: r}
}

func (r *MoqFloat_starGenType_String_fnRecorder) Seq() *MoqFloat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_String_fnRecorder) NoSeq() *MoqFloat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_String_fnRecorder) ReturnResults(result1 string) *MoqFloat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_String_doFn
		DoReturnFn MoqFloat_starGenType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_String_fnRecorder) AndDo(fn MoqFloat_starGenType_String_doFn) *MoqFloat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_String_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_String_doReturnFn) *MoqFloat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_String_doFn
		DoReturnFn MoqFloat_starGenType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_String_paramsKey]*MoqFloat_starGenType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_String_doFn
				DoReturnFn MoqFloat_starGenType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_String(params MoqFloat_starGenType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqFloat_starGenType) ParamsKey_String(params MoqFloat_starGenType_String_params, anyParams uint64) MoqFloat_starGenType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqFloat_starGenType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFloat_starGenType_recorder) Append(buf []byte, fmt byte, prec int) *MoqFloat_starGenType_Append_fnRecorder {
	return &MoqFloat_starGenType_Append_fnRecorder{
		Params: MoqFloat_starGenType_Append_params{
			Buf:  buf,
			Fmt:  fmt,
			Prec: prec,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Append_fnRecorder) Any() *MoqFloat_starGenType_Append_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Append(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Append_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Append_anyParams) Buf() *MoqFloat_starGenType_Append_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFloat_starGenType_Append_anyParams) Fmt() *MoqFloat_starGenType_Append_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqFloat_starGenType_Append_anyParams) Prec() *MoqFloat_starGenType_Append_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqFloat_starGenType_Append_fnRecorder) Seq() *MoqFloat_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Append(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Append_fnRecorder) NoSeq() *MoqFloat_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Append(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Append_fnRecorder) ReturnResults(result1 []byte) *MoqFloat_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Append_doFn
		DoReturnFn MoqFloat_starGenType_Append_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Append_fnRecorder) AndDo(fn MoqFloat_starGenType_Append_doFn) *MoqFloat_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Append_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Append_doReturnFn) *MoqFloat_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Append_doFn
		DoReturnFn MoqFloat_starGenType_Append_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Append_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Append_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Append {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Append_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Append_paramsKey]*MoqFloat_starGenType_Append_results{},
		}
		r.Moq.ResultsByParams_Append = append(r.Moq.ResultsByParams_Append, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Append) {
			copy(r.Moq.ResultsByParams_Append[insertAt+1:], r.Moq.ResultsByParams_Append[insertAt:0])
			r.Moq.ResultsByParams_Append[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Append(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Append_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Append_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Append_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Append_doFn
				DoReturnFn MoqFloat_starGenType_Append_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Append(params MoqFloat_starGenType_Append_params) string {
	return fmt.Sprintf("Append(%#v, %#v, %#v)", params.Buf, params.Fmt, params.Prec)
}

func (m *MoqFloat_starGenType) ParamsKey_Append(params MoqFloat_starGenType_Append_params, anyParams uint64) MoqFloat_starGenType_Append_paramsKey {
	m.Scene.T.Helper()
	var bufUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Append.Buf == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The buf parameter of the Append function can't be indexed by value")
		}
		bufUsedHash = hash.DeepHash(params.Buf)
	}
	var fmtUsed byte
	var fmtUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Append.Fmt == moq.ParamIndexByValue {
			fmtUsed = params.Fmt
		} else {
			fmtUsedHash = hash.DeepHash(params.Fmt)
		}
	}
	var precUsed int
	var precUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.Append.Prec == moq.ParamIndexByValue {
			precUsed = params.Prec
		} else {
			precUsedHash = hash.DeepHash(params.Prec)
		}
	}
	return MoqFloat_starGenType_Append_paramsKey{
		Params: struct {
			Fmt  byte
			Prec int
		}{
			Fmt:  fmtUsed,
			Prec: precUsed,
		},
		Hashes: struct {
			Buf  hash.Hash
			Fmt  hash.Hash
			Prec hash.Hash
		}{
			Buf:  bufUsedHash,
			Fmt:  fmtUsedHash,
			Prec: precUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Format(s fmt.State, format rune) *MoqFloat_starGenType_Format_fnRecorder {
	return &MoqFloat_starGenType_Format_fnRecorder{
		Params: MoqFloat_starGenType_Format_params{
			S:      s,
			Format: format,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Format_fnRecorder) Any() *MoqFloat_starGenType_Format_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Format(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Format_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Format_anyParams) S() *MoqFloat_starGenType_Format_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFloat_starGenType_Format_anyParams) Format() *MoqFloat_starGenType_Format_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFloat_starGenType_Format_fnRecorder) Seq() *MoqFloat_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Format(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Format_fnRecorder) NoSeq() *MoqFloat_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Format(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Format_fnRecorder) ReturnResults() *MoqFloat_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Format_doFn
		DoReturnFn MoqFloat_starGenType_Format_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Format_fnRecorder) AndDo(fn MoqFloat_starGenType_Format_doFn) *MoqFloat_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Format_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Format_doReturnFn) *MoqFloat_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Format_doFn
		DoReturnFn MoqFloat_starGenType_Format_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Format_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Format_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Format {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Format_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Format_paramsKey]*MoqFloat_starGenType_Format_results{},
		}
		r.Moq.ResultsByParams_Format = append(r.Moq.ResultsByParams_Format, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Format) {
			copy(r.Moq.ResultsByParams_Format[insertAt+1:], r.Moq.ResultsByParams_Format[insertAt:0])
			r.Moq.ResultsByParams_Format[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Format(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Format_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Format_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Format_doFn
				DoReturnFn MoqFloat_starGenType_Format_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Format(params MoqFloat_starGenType_Format_params) string {
	return fmt.Sprintf("Format(%#v, %#v)", params.S, params.Format)
}

func (m *MoqFloat_starGenType) ParamsKey_Format(params MoqFloat_starGenType_Format_params, anyParams uint64) MoqFloat_starGenType_Format_paramsKey {
	m.Scene.T.Helper()
	var sUsed fmt.State
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Format.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var formatUsed rune
	var formatUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Format.Format == moq.ParamIndexByValue {
			formatUsed = params.Format
		} else {
			formatUsedHash = hash.DeepHash(params.Format)
		}
	}
	return MoqFloat_starGenType_Format_paramsKey{
		Params: struct {
			S      fmt.State
			Format rune
		}{
			S:      sUsed,
			Format: formatUsed,
		},
		Hashes: struct {
			S      hash.Hash
			Format hash.Hash
		}{
			S:      sUsedHash,
			Format: formatUsedHash,
		},
	}
}

func (m *MoqFloat_starGenType_recorder) Sqrt(x *big.Float) *MoqFloat_starGenType_Sqrt_fnRecorder {
	return &MoqFloat_starGenType_Sqrt_fnRecorder{
		Params: MoqFloat_starGenType_Sqrt_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFloat_starGenType_Sqrt_fnRecorder) Any() *MoqFloat_starGenType_Sqrt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sqrt(r.Params))
		return nil
	}
	return &MoqFloat_starGenType_Sqrt_anyParams{Recorder: r}
}

func (a *MoqFloat_starGenType_Sqrt_anyParams) X() *MoqFloat_starGenType_Sqrt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFloat_starGenType_Sqrt_fnRecorder) Seq() *MoqFloat_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sqrt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFloat_starGenType_Sqrt_fnRecorder) NoSeq() *MoqFloat_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sqrt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFloat_starGenType_Sqrt_fnRecorder) ReturnResults(result1 *big.Float) *MoqFloat_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Sqrt_doFn
		DoReturnFn MoqFloat_starGenType_Sqrt_doReturnFn
	}{
		Values: &struct {
			Result1 *big.Float
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFloat_starGenType_Sqrt_fnRecorder) AndDo(fn MoqFloat_starGenType_Sqrt_doFn) *MoqFloat_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFloat_starGenType_Sqrt_fnRecorder) DoReturnResults(fn MoqFloat_starGenType_Sqrt_doReturnFn) *MoqFloat_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *big.Float
		}
		Sequence   uint32
		DoFn       MoqFloat_starGenType_Sqrt_doFn
		DoReturnFn MoqFloat_starGenType_Sqrt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFloat_starGenType_Sqrt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFloat_starGenType_Sqrt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Sqrt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFloat_starGenType_Sqrt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFloat_starGenType_Sqrt_paramsKey]*MoqFloat_starGenType_Sqrt_results{},
		}
		r.Moq.ResultsByParams_Sqrt = append(r.Moq.ResultsByParams_Sqrt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Sqrt) {
			copy(r.Moq.ResultsByParams_Sqrt[insertAt+1:], r.Moq.ResultsByParams_Sqrt[insertAt:0])
			r.Moq.ResultsByParams_Sqrt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Sqrt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFloat_starGenType_Sqrt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFloat_starGenType_Sqrt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFloat_starGenType_Sqrt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *big.Float
				}
				Sequence   uint32
				DoFn       MoqFloat_starGenType_Sqrt_doFn
				DoReturnFn MoqFloat_starGenType_Sqrt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFloat_starGenType) PrettyParams_Sqrt(params MoqFloat_starGenType_Sqrt_params) string {
	return fmt.Sprintf("Sqrt(%#v)", params.X)
}

func (m *MoqFloat_starGenType) ParamsKey_Sqrt(params MoqFloat_starGenType_Sqrt_params, anyParams uint64) MoqFloat_starGenType_Sqrt_paramsKey {
	m.Scene.T.Helper()
	var xUsed *big.Float
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Sqrt.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqFloat_starGenType_Sqrt_paramsKey{
		Params: struct{ X *big.Float }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqFloat_starGenType) Reset() {
	m.ResultsByParams_SetPrec = nil
	m.ResultsByParams_SetMode = nil
	m.ResultsByParams_Prec = nil
	m.ResultsByParams_MinPrec = nil
	m.ResultsByParams_Mode = nil
	m.ResultsByParams_Acc = nil
	m.ResultsByParams_Sign = nil
	m.ResultsByParams_MantExp = nil
	m.ResultsByParams_SetMantExp = nil
	m.ResultsByParams_Signbit = nil
	m.ResultsByParams_IsInf = nil
	m.ResultsByParams_IsInt = nil
	m.ResultsByParams_SetUint64 = nil
	m.ResultsByParams_SetInt64 = nil
	m.ResultsByParams_SetFloat64 = nil
	m.ResultsByParams_SetInt = nil
	m.ResultsByParams_SetRat = nil
	m.ResultsByParams_SetInf = nil
	m.ResultsByParams_Set = nil
	m.ResultsByParams_Copy = nil
	m.ResultsByParams_Uint64 = nil
	m.ResultsByParams_Int64 = nil
	m.ResultsByParams_Float32 = nil
	m.ResultsByParams_Float64 = nil
	m.ResultsByParams_Int = nil
	m.ResultsByParams_Rat = nil
	m.ResultsByParams_Abs = nil
	m.ResultsByParams_Neg = nil
	m.ResultsByParams_Add = nil
	m.ResultsByParams_Sub = nil
	m.ResultsByParams_Mul = nil
	m.ResultsByParams_Quo = nil
	m.ResultsByParams_Cmp = nil
	m.ResultsByParams_SetString = nil
	m.ResultsByParams_Parse = nil
	m.ResultsByParams_Scan = nil
	m.ResultsByParams_GobEncode = nil
	m.ResultsByParams_GobDecode = nil
	m.ResultsByParams_MarshalText = nil
	m.ResultsByParams_UnmarshalText = nil
	m.ResultsByParams_Text = nil
	m.ResultsByParams_String = nil
	m.ResultsByParams_Append = nil
	m.ResultsByParams_Format = nil
	m.ResultsByParams_Sqrt = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqFloat_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_SetPrec {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetPrec(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetMode {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetMode(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Prec {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Prec(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MinPrec {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MinPrec(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Mode {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Mode(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Acc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Acc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Sign {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Sign(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MantExp {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MantExp(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetMantExp {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetMantExp(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Signbit {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Signbit(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsInf {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsInf(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsInt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsInt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetUint64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetUint64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetInt64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetInt64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetFloat64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetFloat64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetInt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetInt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetRat {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetRat(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetInf {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetInf(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Set {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Set(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Copy {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Copy(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Uint64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Uint64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Int64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Int64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Float32 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Float32(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Float64 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Float64(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Int {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Int(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Rat {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Rat(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Abs {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Abs(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Neg {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Neg(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Add {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Add(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Sub {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Sub(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Mul {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Mul(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Quo {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Quo(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Cmp {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Cmp(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Parse {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Parse(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Scan {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Scan(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_GobEncode {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_GobEncode(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_GobDecode {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_GobDecode(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MarshalText {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MarshalText(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_UnmarshalText {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_UnmarshalText(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Text {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Text(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Append {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Append(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Format {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Format(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Sqrt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Sqrt(results.Params))
			}
		}
	}
}
