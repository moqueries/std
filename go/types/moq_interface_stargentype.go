// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package types

import (
	"fmt"
	"go/types"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that types.Interface_starGenType is
// mocked completely
var _ Interface_starGenType = (*MoqInterface_starGenType_mock)(nil)

// Interface_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Interface_starGenType interface {
	NumExplicitMethods() int
	ExplicitMethod(i int) *types.Func
	NumEmbeddeds() int
	Embedded(i int) *types.Named
	EmbeddedType(i int) types.Type
	NumMethods() int
	Method(i int) *types.Func
	Empty() bool
	Complete() *types.Interface
	Underlying() types.Type
	String() string
}

// MoqInterface_starGenType holds the state of a moq of the
// Interface_starGenType type
type MoqInterface_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqInterface_starGenType_mock

	ResultsByParams_NumExplicitMethods []MoqInterface_starGenType_NumExplicitMethods_resultsByParams
	ResultsByParams_ExplicitMethod     []MoqInterface_starGenType_ExplicitMethod_resultsByParams
	ResultsByParams_NumEmbeddeds       []MoqInterface_starGenType_NumEmbeddeds_resultsByParams
	ResultsByParams_Embedded           []MoqInterface_starGenType_Embedded_resultsByParams
	ResultsByParams_EmbeddedType       []MoqInterface_starGenType_EmbeddedType_resultsByParams
	ResultsByParams_NumMethods         []MoqInterface_starGenType_NumMethods_resultsByParams
	ResultsByParams_Method             []MoqInterface_starGenType_Method_resultsByParams
	ResultsByParams_Empty              []MoqInterface_starGenType_Empty_resultsByParams
	ResultsByParams_Complete           []MoqInterface_starGenType_Complete_resultsByParams
	ResultsByParams_Underlying         []MoqInterface_starGenType_Underlying_resultsByParams
	ResultsByParams_String             []MoqInterface_starGenType_String_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			NumExplicitMethods struct{}
			ExplicitMethod     struct {
				Param1 moq.ParamIndexing
			}
			NumEmbeddeds struct{}
			Embedded     struct {
				Param1 moq.ParamIndexing
			}
			EmbeddedType struct {
				Param1 moq.ParamIndexing
			}
			NumMethods struct{}
			Method     struct {
				Param1 moq.ParamIndexing
			}
			Empty      struct{}
			Complete   struct{}
			Underlying struct{}
			String     struct{}
		}
	}
}

// MoqInterface_starGenType_mock isolates the mock interface of the
// Interface_starGenType type
type MoqInterface_starGenType_mock struct {
	Moq *MoqInterface_starGenType
}

// MoqInterface_starGenType_recorder isolates the recorder interface of the
// Interface_starGenType type
type MoqInterface_starGenType_recorder struct {
	Moq *MoqInterface_starGenType
}

// MoqInterface_starGenType_NumExplicitMethods_params holds the params of the
// Interface_starGenType type
type MoqInterface_starGenType_NumExplicitMethods_params struct{}

// MoqInterface_starGenType_NumExplicitMethods_paramsKey holds the map key
// params of the Interface_starGenType type
type MoqInterface_starGenType_NumExplicitMethods_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInterface_starGenType_NumExplicitMethods_resultsByParams contains the
// results for a given set of parameters for the Interface_starGenType type
type MoqInterface_starGenType_NumExplicitMethods_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInterface_starGenType_NumExplicitMethods_paramsKey]*MoqInterface_starGenType_NumExplicitMethods_results
}

// MoqInterface_starGenType_NumExplicitMethods_doFn defines the type of
// function needed when calling AndDo for the Interface_starGenType type
type MoqInterface_starGenType_NumExplicitMethods_doFn func()

// MoqInterface_starGenType_NumExplicitMethods_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Interface_starGenType
// type
type MoqInterface_starGenType_NumExplicitMethods_doReturnFn func() int

// MoqInterface_starGenType_NumExplicitMethods_results holds the results of the
// Interface_starGenType type
type MoqInterface_starGenType_NumExplicitMethods_results struct {
	Params  MoqInterface_starGenType_NumExplicitMethods_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_NumExplicitMethods_doFn
		DoReturnFn MoqInterface_starGenType_NumExplicitMethods_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInterface_starGenType_NumExplicitMethods_fnRecorder routes recorded
// function calls to the MoqInterface_starGenType moq
type MoqInterface_starGenType_NumExplicitMethods_fnRecorder struct {
	Params    MoqInterface_starGenType_NumExplicitMethods_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInterface_starGenType_NumExplicitMethods_results
	Moq       *MoqInterface_starGenType
}

// MoqInterface_starGenType_NumExplicitMethods_anyParams isolates the any
// params functions of the Interface_starGenType type
type MoqInterface_starGenType_NumExplicitMethods_anyParams struct {
	Recorder *MoqInterface_starGenType_NumExplicitMethods_fnRecorder
}

// MoqInterface_starGenType_ExplicitMethod_params holds the params of the
// Interface_starGenType type
type MoqInterface_starGenType_ExplicitMethod_params struct{ Param1 int }

// MoqInterface_starGenType_ExplicitMethod_paramsKey holds the map key params
// of the Interface_starGenType type
type MoqInterface_starGenType_ExplicitMethod_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqInterface_starGenType_ExplicitMethod_resultsByParams contains the results
// for a given set of parameters for the Interface_starGenType type
type MoqInterface_starGenType_ExplicitMethod_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInterface_starGenType_ExplicitMethod_paramsKey]*MoqInterface_starGenType_ExplicitMethod_results
}

// MoqInterface_starGenType_ExplicitMethod_doFn defines the type of function
// needed when calling AndDo for the Interface_starGenType type
type MoqInterface_starGenType_ExplicitMethod_doFn func(i int)

// MoqInterface_starGenType_ExplicitMethod_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Interface_starGenType
// type
type MoqInterface_starGenType_ExplicitMethod_doReturnFn func(i int) *types.Func

// MoqInterface_starGenType_ExplicitMethod_results holds the results of the
// Interface_starGenType type
type MoqInterface_starGenType_ExplicitMethod_results struct {
	Params  MoqInterface_starGenType_ExplicitMethod_params
	Results []struct {
		Values *struct {
			Result1 *types.Func
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_ExplicitMethod_doFn
		DoReturnFn MoqInterface_starGenType_ExplicitMethod_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInterface_starGenType_ExplicitMethod_fnRecorder routes recorded function
// calls to the MoqInterface_starGenType moq
type MoqInterface_starGenType_ExplicitMethod_fnRecorder struct {
	Params    MoqInterface_starGenType_ExplicitMethod_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInterface_starGenType_ExplicitMethod_results
	Moq       *MoqInterface_starGenType
}

// MoqInterface_starGenType_ExplicitMethod_anyParams isolates the any params
// functions of the Interface_starGenType type
type MoqInterface_starGenType_ExplicitMethod_anyParams struct {
	Recorder *MoqInterface_starGenType_ExplicitMethod_fnRecorder
}

// MoqInterface_starGenType_NumEmbeddeds_params holds the params of the
// Interface_starGenType type
type MoqInterface_starGenType_NumEmbeddeds_params struct{}

// MoqInterface_starGenType_NumEmbeddeds_paramsKey holds the map key params of
// the Interface_starGenType type
type MoqInterface_starGenType_NumEmbeddeds_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInterface_starGenType_NumEmbeddeds_resultsByParams contains the results
// for a given set of parameters for the Interface_starGenType type
type MoqInterface_starGenType_NumEmbeddeds_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInterface_starGenType_NumEmbeddeds_paramsKey]*MoqInterface_starGenType_NumEmbeddeds_results
}

// MoqInterface_starGenType_NumEmbeddeds_doFn defines the type of function
// needed when calling AndDo for the Interface_starGenType type
type MoqInterface_starGenType_NumEmbeddeds_doFn func()

// MoqInterface_starGenType_NumEmbeddeds_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Interface_starGenType
// type
type MoqInterface_starGenType_NumEmbeddeds_doReturnFn func() int

// MoqInterface_starGenType_NumEmbeddeds_results holds the results of the
// Interface_starGenType type
type MoqInterface_starGenType_NumEmbeddeds_results struct {
	Params  MoqInterface_starGenType_NumEmbeddeds_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_NumEmbeddeds_doFn
		DoReturnFn MoqInterface_starGenType_NumEmbeddeds_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInterface_starGenType_NumEmbeddeds_fnRecorder routes recorded function
// calls to the MoqInterface_starGenType moq
type MoqInterface_starGenType_NumEmbeddeds_fnRecorder struct {
	Params    MoqInterface_starGenType_NumEmbeddeds_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInterface_starGenType_NumEmbeddeds_results
	Moq       *MoqInterface_starGenType
}

// MoqInterface_starGenType_NumEmbeddeds_anyParams isolates the any params
// functions of the Interface_starGenType type
type MoqInterface_starGenType_NumEmbeddeds_anyParams struct {
	Recorder *MoqInterface_starGenType_NumEmbeddeds_fnRecorder
}

// MoqInterface_starGenType_Embedded_params holds the params of the
// Interface_starGenType type
type MoqInterface_starGenType_Embedded_params struct{ Param1 int }

// MoqInterface_starGenType_Embedded_paramsKey holds the map key params of the
// Interface_starGenType type
type MoqInterface_starGenType_Embedded_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqInterface_starGenType_Embedded_resultsByParams contains the results for a
// given set of parameters for the Interface_starGenType type
type MoqInterface_starGenType_Embedded_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInterface_starGenType_Embedded_paramsKey]*MoqInterface_starGenType_Embedded_results
}

// MoqInterface_starGenType_Embedded_doFn defines the type of function needed
// when calling AndDo for the Interface_starGenType type
type MoqInterface_starGenType_Embedded_doFn func(i int)

// MoqInterface_starGenType_Embedded_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Interface_starGenType type
type MoqInterface_starGenType_Embedded_doReturnFn func(i int) *types.Named

// MoqInterface_starGenType_Embedded_results holds the results of the
// Interface_starGenType type
type MoqInterface_starGenType_Embedded_results struct {
	Params  MoqInterface_starGenType_Embedded_params
	Results []struct {
		Values *struct {
			Result1 *types.Named
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Embedded_doFn
		DoReturnFn MoqInterface_starGenType_Embedded_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInterface_starGenType_Embedded_fnRecorder routes recorded function calls
// to the MoqInterface_starGenType moq
type MoqInterface_starGenType_Embedded_fnRecorder struct {
	Params    MoqInterface_starGenType_Embedded_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInterface_starGenType_Embedded_results
	Moq       *MoqInterface_starGenType
}

// MoqInterface_starGenType_Embedded_anyParams isolates the any params
// functions of the Interface_starGenType type
type MoqInterface_starGenType_Embedded_anyParams struct {
	Recorder *MoqInterface_starGenType_Embedded_fnRecorder
}

// MoqInterface_starGenType_EmbeddedType_params holds the params of the
// Interface_starGenType type
type MoqInterface_starGenType_EmbeddedType_params struct{ Param1 int }

// MoqInterface_starGenType_EmbeddedType_paramsKey holds the map key params of
// the Interface_starGenType type
type MoqInterface_starGenType_EmbeddedType_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqInterface_starGenType_EmbeddedType_resultsByParams contains the results
// for a given set of parameters for the Interface_starGenType type
type MoqInterface_starGenType_EmbeddedType_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInterface_starGenType_EmbeddedType_paramsKey]*MoqInterface_starGenType_EmbeddedType_results
}

// MoqInterface_starGenType_EmbeddedType_doFn defines the type of function
// needed when calling AndDo for the Interface_starGenType type
type MoqInterface_starGenType_EmbeddedType_doFn func(i int)

// MoqInterface_starGenType_EmbeddedType_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Interface_starGenType
// type
type MoqInterface_starGenType_EmbeddedType_doReturnFn func(i int) types.Type

// MoqInterface_starGenType_EmbeddedType_results holds the results of the
// Interface_starGenType type
type MoqInterface_starGenType_EmbeddedType_results struct {
	Params  MoqInterface_starGenType_EmbeddedType_params
	Results []struct {
		Values *struct {
			Result1 types.Type
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_EmbeddedType_doFn
		DoReturnFn MoqInterface_starGenType_EmbeddedType_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInterface_starGenType_EmbeddedType_fnRecorder routes recorded function
// calls to the MoqInterface_starGenType moq
type MoqInterface_starGenType_EmbeddedType_fnRecorder struct {
	Params    MoqInterface_starGenType_EmbeddedType_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInterface_starGenType_EmbeddedType_results
	Moq       *MoqInterface_starGenType
}

// MoqInterface_starGenType_EmbeddedType_anyParams isolates the any params
// functions of the Interface_starGenType type
type MoqInterface_starGenType_EmbeddedType_anyParams struct {
	Recorder *MoqInterface_starGenType_EmbeddedType_fnRecorder
}

// MoqInterface_starGenType_NumMethods_params holds the params of the
// Interface_starGenType type
type MoqInterface_starGenType_NumMethods_params struct{}

// MoqInterface_starGenType_NumMethods_paramsKey holds the map key params of
// the Interface_starGenType type
type MoqInterface_starGenType_NumMethods_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInterface_starGenType_NumMethods_resultsByParams contains the results for
// a given set of parameters for the Interface_starGenType type
type MoqInterface_starGenType_NumMethods_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInterface_starGenType_NumMethods_paramsKey]*MoqInterface_starGenType_NumMethods_results
}

// MoqInterface_starGenType_NumMethods_doFn defines the type of function needed
// when calling AndDo for the Interface_starGenType type
type MoqInterface_starGenType_NumMethods_doFn func()

// MoqInterface_starGenType_NumMethods_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Interface_starGenType type
type MoqInterface_starGenType_NumMethods_doReturnFn func() int

// MoqInterface_starGenType_NumMethods_results holds the results of the
// Interface_starGenType type
type MoqInterface_starGenType_NumMethods_results struct {
	Params  MoqInterface_starGenType_NumMethods_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_NumMethods_doFn
		DoReturnFn MoqInterface_starGenType_NumMethods_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInterface_starGenType_NumMethods_fnRecorder routes recorded function
// calls to the MoqInterface_starGenType moq
type MoqInterface_starGenType_NumMethods_fnRecorder struct {
	Params    MoqInterface_starGenType_NumMethods_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInterface_starGenType_NumMethods_results
	Moq       *MoqInterface_starGenType
}

// MoqInterface_starGenType_NumMethods_anyParams isolates the any params
// functions of the Interface_starGenType type
type MoqInterface_starGenType_NumMethods_anyParams struct {
	Recorder *MoqInterface_starGenType_NumMethods_fnRecorder
}

// MoqInterface_starGenType_Method_params holds the params of the
// Interface_starGenType type
type MoqInterface_starGenType_Method_params struct{ Param1 int }

// MoqInterface_starGenType_Method_paramsKey holds the map key params of the
// Interface_starGenType type
type MoqInterface_starGenType_Method_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqInterface_starGenType_Method_resultsByParams contains the results for a
// given set of parameters for the Interface_starGenType type
type MoqInterface_starGenType_Method_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInterface_starGenType_Method_paramsKey]*MoqInterface_starGenType_Method_results
}

// MoqInterface_starGenType_Method_doFn defines the type of function needed
// when calling AndDo for the Interface_starGenType type
type MoqInterface_starGenType_Method_doFn func(i int)

// MoqInterface_starGenType_Method_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Interface_starGenType type
type MoqInterface_starGenType_Method_doReturnFn func(i int) *types.Func

// MoqInterface_starGenType_Method_results holds the results of the
// Interface_starGenType type
type MoqInterface_starGenType_Method_results struct {
	Params  MoqInterface_starGenType_Method_params
	Results []struct {
		Values *struct {
			Result1 *types.Func
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Method_doFn
		DoReturnFn MoqInterface_starGenType_Method_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInterface_starGenType_Method_fnRecorder routes recorded function calls to
// the MoqInterface_starGenType moq
type MoqInterface_starGenType_Method_fnRecorder struct {
	Params    MoqInterface_starGenType_Method_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInterface_starGenType_Method_results
	Moq       *MoqInterface_starGenType
}

// MoqInterface_starGenType_Method_anyParams isolates the any params functions
// of the Interface_starGenType type
type MoqInterface_starGenType_Method_anyParams struct {
	Recorder *MoqInterface_starGenType_Method_fnRecorder
}

// MoqInterface_starGenType_Empty_params holds the params of the
// Interface_starGenType type
type MoqInterface_starGenType_Empty_params struct{}

// MoqInterface_starGenType_Empty_paramsKey holds the map key params of the
// Interface_starGenType type
type MoqInterface_starGenType_Empty_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInterface_starGenType_Empty_resultsByParams contains the results for a
// given set of parameters for the Interface_starGenType type
type MoqInterface_starGenType_Empty_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInterface_starGenType_Empty_paramsKey]*MoqInterface_starGenType_Empty_results
}

// MoqInterface_starGenType_Empty_doFn defines the type of function needed when
// calling AndDo for the Interface_starGenType type
type MoqInterface_starGenType_Empty_doFn func()

// MoqInterface_starGenType_Empty_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Interface_starGenType type
type MoqInterface_starGenType_Empty_doReturnFn func() bool

// MoqInterface_starGenType_Empty_results holds the results of the
// Interface_starGenType type
type MoqInterface_starGenType_Empty_results struct {
	Params  MoqInterface_starGenType_Empty_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Empty_doFn
		DoReturnFn MoqInterface_starGenType_Empty_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInterface_starGenType_Empty_fnRecorder routes recorded function calls to
// the MoqInterface_starGenType moq
type MoqInterface_starGenType_Empty_fnRecorder struct {
	Params    MoqInterface_starGenType_Empty_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInterface_starGenType_Empty_results
	Moq       *MoqInterface_starGenType
}

// MoqInterface_starGenType_Empty_anyParams isolates the any params functions
// of the Interface_starGenType type
type MoqInterface_starGenType_Empty_anyParams struct {
	Recorder *MoqInterface_starGenType_Empty_fnRecorder
}

// MoqInterface_starGenType_Complete_params holds the params of the
// Interface_starGenType type
type MoqInterface_starGenType_Complete_params struct{}

// MoqInterface_starGenType_Complete_paramsKey holds the map key params of the
// Interface_starGenType type
type MoqInterface_starGenType_Complete_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInterface_starGenType_Complete_resultsByParams contains the results for a
// given set of parameters for the Interface_starGenType type
type MoqInterface_starGenType_Complete_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInterface_starGenType_Complete_paramsKey]*MoqInterface_starGenType_Complete_results
}

// MoqInterface_starGenType_Complete_doFn defines the type of function needed
// when calling AndDo for the Interface_starGenType type
type MoqInterface_starGenType_Complete_doFn func()

// MoqInterface_starGenType_Complete_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Interface_starGenType type
type MoqInterface_starGenType_Complete_doReturnFn func() *types.Interface

// MoqInterface_starGenType_Complete_results holds the results of the
// Interface_starGenType type
type MoqInterface_starGenType_Complete_results struct {
	Params  MoqInterface_starGenType_Complete_params
	Results []struct {
		Values *struct {
			Result1 *types.Interface
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Complete_doFn
		DoReturnFn MoqInterface_starGenType_Complete_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInterface_starGenType_Complete_fnRecorder routes recorded function calls
// to the MoqInterface_starGenType moq
type MoqInterface_starGenType_Complete_fnRecorder struct {
	Params    MoqInterface_starGenType_Complete_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInterface_starGenType_Complete_results
	Moq       *MoqInterface_starGenType
}

// MoqInterface_starGenType_Complete_anyParams isolates the any params
// functions of the Interface_starGenType type
type MoqInterface_starGenType_Complete_anyParams struct {
	Recorder *MoqInterface_starGenType_Complete_fnRecorder
}

// MoqInterface_starGenType_Underlying_params holds the params of the
// Interface_starGenType type
type MoqInterface_starGenType_Underlying_params struct{}

// MoqInterface_starGenType_Underlying_paramsKey holds the map key params of
// the Interface_starGenType type
type MoqInterface_starGenType_Underlying_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInterface_starGenType_Underlying_resultsByParams contains the results for
// a given set of parameters for the Interface_starGenType type
type MoqInterface_starGenType_Underlying_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInterface_starGenType_Underlying_paramsKey]*MoqInterface_starGenType_Underlying_results
}

// MoqInterface_starGenType_Underlying_doFn defines the type of function needed
// when calling AndDo for the Interface_starGenType type
type MoqInterface_starGenType_Underlying_doFn func()

// MoqInterface_starGenType_Underlying_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Interface_starGenType type
type MoqInterface_starGenType_Underlying_doReturnFn func() types.Type

// MoqInterface_starGenType_Underlying_results holds the results of the
// Interface_starGenType type
type MoqInterface_starGenType_Underlying_results struct {
	Params  MoqInterface_starGenType_Underlying_params
	Results []struct {
		Values *struct {
			Result1 types.Type
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Underlying_doFn
		DoReturnFn MoqInterface_starGenType_Underlying_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInterface_starGenType_Underlying_fnRecorder routes recorded function
// calls to the MoqInterface_starGenType moq
type MoqInterface_starGenType_Underlying_fnRecorder struct {
	Params    MoqInterface_starGenType_Underlying_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInterface_starGenType_Underlying_results
	Moq       *MoqInterface_starGenType
}

// MoqInterface_starGenType_Underlying_anyParams isolates the any params
// functions of the Interface_starGenType type
type MoqInterface_starGenType_Underlying_anyParams struct {
	Recorder *MoqInterface_starGenType_Underlying_fnRecorder
}

// MoqInterface_starGenType_String_params holds the params of the
// Interface_starGenType type
type MoqInterface_starGenType_String_params struct{}

// MoqInterface_starGenType_String_paramsKey holds the map key params of the
// Interface_starGenType type
type MoqInterface_starGenType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqInterface_starGenType_String_resultsByParams contains the results for a
// given set of parameters for the Interface_starGenType type
type MoqInterface_starGenType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqInterface_starGenType_String_paramsKey]*MoqInterface_starGenType_String_results
}

// MoqInterface_starGenType_String_doFn defines the type of function needed
// when calling AndDo for the Interface_starGenType type
type MoqInterface_starGenType_String_doFn func()

// MoqInterface_starGenType_String_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Interface_starGenType type
type MoqInterface_starGenType_String_doReturnFn func() string

// MoqInterface_starGenType_String_results holds the results of the
// Interface_starGenType type
type MoqInterface_starGenType_String_results struct {
	Params  MoqInterface_starGenType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_String_doFn
		DoReturnFn MoqInterface_starGenType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqInterface_starGenType_String_fnRecorder routes recorded function calls to
// the MoqInterface_starGenType moq
type MoqInterface_starGenType_String_fnRecorder struct {
	Params    MoqInterface_starGenType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqInterface_starGenType_String_results
	Moq       *MoqInterface_starGenType
}

// MoqInterface_starGenType_String_anyParams isolates the any params functions
// of the Interface_starGenType type
type MoqInterface_starGenType_String_anyParams struct {
	Recorder *MoqInterface_starGenType_String_fnRecorder
}

// NewMoqInterface_starGenType creates a new moq of the Interface_starGenType
// type
func NewMoqInterface_starGenType(scene *moq.Scene, config *moq.Config) *MoqInterface_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqInterface_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqInterface_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				NumExplicitMethods struct{}
				ExplicitMethod     struct {
					Param1 moq.ParamIndexing
				}
				NumEmbeddeds struct{}
				Embedded     struct {
					Param1 moq.ParamIndexing
				}
				EmbeddedType struct {
					Param1 moq.ParamIndexing
				}
				NumMethods struct{}
				Method     struct {
					Param1 moq.ParamIndexing
				}
				Empty      struct{}
				Complete   struct{}
				Underlying struct{}
				String     struct{}
			}
		}{ParameterIndexing: struct {
			NumExplicitMethods struct{}
			ExplicitMethod     struct {
				Param1 moq.ParamIndexing
			}
			NumEmbeddeds struct{}
			Embedded     struct {
				Param1 moq.ParamIndexing
			}
			EmbeddedType struct {
				Param1 moq.ParamIndexing
			}
			NumMethods struct{}
			Method     struct {
				Param1 moq.ParamIndexing
			}
			Empty      struct{}
			Complete   struct{}
			Underlying struct{}
			String     struct{}
		}{
			NumExplicitMethods: struct{}{},
			ExplicitMethod: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			NumEmbeddeds: struct{}{},
			Embedded: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			EmbeddedType: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			NumMethods: struct{}{},
			Method: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			Empty:      struct{}{},
			Complete:   struct{}{},
			Underlying: struct{}{},
			String:     struct{}{},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Interface_starGenType type
func (m *MoqInterface_starGenType) Mock() *MoqInterface_starGenType_mock { return m.Moq }

func (m *MoqInterface_starGenType_mock) NumExplicitMethods() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqInterface_starGenType_NumExplicitMethods_params{}
	var results *MoqInterface_starGenType_NumExplicitMethods_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumExplicitMethods {
		paramsKey := m.Moq.ParamsKey_NumExplicitMethods(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumExplicitMethods(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumExplicitMethods(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumExplicitMethods(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInterface_starGenType_mock) ExplicitMethod(param1 int) (result1 *types.Func) {
	m.Moq.Scene.T.Helper()
	params := MoqInterface_starGenType_ExplicitMethod_params{
		Param1: param1,
	}
	var results *MoqInterface_starGenType_ExplicitMethod_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ExplicitMethod {
		paramsKey := m.Moq.ParamsKey_ExplicitMethod(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ExplicitMethod(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ExplicitMethod(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ExplicitMethod(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqInterface_starGenType_mock) NumEmbeddeds() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqInterface_starGenType_NumEmbeddeds_params{}
	var results *MoqInterface_starGenType_NumEmbeddeds_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumEmbeddeds {
		paramsKey := m.Moq.ParamsKey_NumEmbeddeds(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumEmbeddeds(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumEmbeddeds(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumEmbeddeds(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInterface_starGenType_mock) Embedded(param1 int) (result1 *types.Named) {
	m.Moq.Scene.T.Helper()
	params := MoqInterface_starGenType_Embedded_params{
		Param1: param1,
	}
	var results *MoqInterface_starGenType_Embedded_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Embedded {
		paramsKey := m.Moq.ParamsKey_Embedded(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Embedded(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Embedded(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Embedded(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqInterface_starGenType_mock) EmbeddedType(param1 int) (result1 types.Type) {
	m.Moq.Scene.T.Helper()
	params := MoqInterface_starGenType_EmbeddedType_params{
		Param1: param1,
	}
	var results *MoqInterface_starGenType_EmbeddedType_results
	for _, resultsByParams := range m.Moq.ResultsByParams_EmbeddedType {
		paramsKey := m.Moq.ParamsKey_EmbeddedType(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_EmbeddedType(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_EmbeddedType(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_EmbeddedType(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqInterface_starGenType_mock) NumMethods() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqInterface_starGenType_NumMethods_params{}
	var results *MoqInterface_starGenType_NumMethods_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumMethods {
		paramsKey := m.Moq.ParamsKey_NumMethods(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumMethods(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumMethods(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumMethods(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInterface_starGenType_mock) Method(param1 int) (result1 *types.Func) {
	m.Moq.Scene.T.Helper()
	params := MoqInterface_starGenType_Method_params{
		Param1: param1,
	}
	var results *MoqInterface_starGenType_Method_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Method {
		paramsKey := m.Moq.ParamsKey_Method(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Method(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Method(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Method(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqInterface_starGenType_mock) Empty() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqInterface_starGenType_Empty_params{}
	var results *MoqInterface_starGenType_Empty_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Empty {
		paramsKey := m.Moq.ParamsKey_Empty(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Empty(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Empty(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Empty(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInterface_starGenType_mock) Complete() (result1 *types.Interface) {
	m.Moq.Scene.T.Helper()
	params := MoqInterface_starGenType_Complete_params{}
	var results *MoqInterface_starGenType_Complete_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Complete {
		paramsKey := m.Moq.ParamsKey_Complete(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Complete(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Complete(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Complete(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInterface_starGenType_mock) Underlying() (result1 types.Type) {
	m.Moq.Scene.T.Helper()
	params := MoqInterface_starGenType_Underlying_params{}
	var results *MoqInterface_starGenType_Underlying_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Underlying {
		paramsKey := m.Moq.ParamsKey_Underlying(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Underlying(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Underlying(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Underlying(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqInterface_starGenType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqInterface_starGenType_String_params{}
	var results *MoqInterface_starGenType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

// OnCall returns the recorder implementation of the Interface_starGenType type
func (m *MoqInterface_starGenType) OnCall() *MoqInterface_starGenType_recorder {
	return &MoqInterface_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqInterface_starGenType_recorder) NumExplicitMethods() *MoqInterface_starGenType_NumExplicitMethods_fnRecorder {
	return &MoqInterface_starGenType_NumExplicitMethods_fnRecorder{
		Params:   MoqInterface_starGenType_NumExplicitMethods_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInterface_starGenType_NumExplicitMethods_fnRecorder) Any() *MoqInterface_starGenType_NumExplicitMethods_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumExplicitMethods(r.Params))
		return nil
	}
	return &MoqInterface_starGenType_NumExplicitMethods_anyParams{Recorder: r}
}

func (r *MoqInterface_starGenType_NumExplicitMethods_fnRecorder) Seq() *MoqInterface_starGenType_NumExplicitMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumExplicitMethods(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInterface_starGenType_NumExplicitMethods_fnRecorder) NoSeq() *MoqInterface_starGenType_NumExplicitMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumExplicitMethods(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInterface_starGenType_NumExplicitMethods_fnRecorder) ReturnResults(result1 int) *MoqInterface_starGenType_NumExplicitMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_NumExplicitMethods_doFn
		DoReturnFn MoqInterface_starGenType_NumExplicitMethods_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInterface_starGenType_NumExplicitMethods_fnRecorder) AndDo(fn MoqInterface_starGenType_NumExplicitMethods_doFn) *MoqInterface_starGenType_NumExplicitMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInterface_starGenType_NumExplicitMethods_fnRecorder) DoReturnResults(fn MoqInterface_starGenType_NumExplicitMethods_doReturnFn) *MoqInterface_starGenType_NumExplicitMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_NumExplicitMethods_doFn
		DoReturnFn MoqInterface_starGenType_NumExplicitMethods_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInterface_starGenType_NumExplicitMethods_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInterface_starGenType_NumExplicitMethods_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumExplicitMethods {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInterface_starGenType_NumExplicitMethods_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInterface_starGenType_NumExplicitMethods_paramsKey]*MoqInterface_starGenType_NumExplicitMethods_results{},
		}
		r.Moq.ResultsByParams_NumExplicitMethods = append(r.Moq.ResultsByParams_NumExplicitMethods, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumExplicitMethods) {
			copy(r.Moq.ResultsByParams_NumExplicitMethods[insertAt+1:], r.Moq.ResultsByParams_NumExplicitMethods[insertAt:0])
			r.Moq.ResultsByParams_NumExplicitMethods[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumExplicitMethods(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInterface_starGenType_NumExplicitMethods_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInterface_starGenType_NumExplicitMethods_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInterface_starGenType_NumExplicitMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqInterface_starGenType_NumExplicitMethods_doFn
				DoReturnFn MoqInterface_starGenType_NumExplicitMethods_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInterface_starGenType) PrettyParams_NumExplicitMethods(params MoqInterface_starGenType_NumExplicitMethods_params) string {
	return fmt.Sprintf("NumExplicitMethods()")
}

func (m *MoqInterface_starGenType) ParamsKey_NumExplicitMethods(params MoqInterface_starGenType_NumExplicitMethods_params, anyParams uint64) MoqInterface_starGenType_NumExplicitMethods_paramsKey {
	m.Scene.T.Helper()
	return MoqInterface_starGenType_NumExplicitMethods_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInterface_starGenType_recorder) ExplicitMethod(param1 int) *MoqInterface_starGenType_ExplicitMethod_fnRecorder {
	return &MoqInterface_starGenType_ExplicitMethod_fnRecorder{
		Params: MoqInterface_starGenType_ExplicitMethod_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInterface_starGenType_ExplicitMethod_fnRecorder) Any() *MoqInterface_starGenType_ExplicitMethod_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ExplicitMethod(r.Params))
		return nil
	}
	return &MoqInterface_starGenType_ExplicitMethod_anyParams{Recorder: r}
}

func (a *MoqInterface_starGenType_ExplicitMethod_anyParams) Param1() *MoqInterface_starGenType_ExplicitMethod_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInterface_starGenType_ExplicitMethod_fnRecorder) Seq() *MoqInterface_starGenType_ExplicitMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ExplicitMethod(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInterface_starGenType_ExplicitMethod_fnRecorder) NoSeq() *MoqInterface_starGenType_ExplicitMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ExplicitMethod(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInterface_starGenType_ExplicitMethod_fnRecorder) ReturnResults(result1 *types.Func) *MoqInterface_starGenType_ExplicitMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Func
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_ExplicitMethod_doFn
		DoReturnFn MoqInterface_starGenType_ExplicitMethod_doReturnFn
	}{
		Values: &struct {
			Result1 *types.Func
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInterface_starGenType_ExplicitMethod_fnRecorder) AndDo(fn MoqInterface_starGenType_ExplicitMethod_doFn) *MoqInterface_starGenType_ExplicitMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInterface_starGenType_ExplicitMethod_fnRecorder) DoReturnResults(fn MoqInterface_starGenType_ExplicitMethod_doReturnFn) *MoqInterface_starGenType_ExplicitMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Func
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_ExplicitMethod_doFn
		DoReturnFn MoqInterface_starGenType_ExplicitMethod_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInterface_starGenType_ExplicitMethod_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInterface_starGenType_ExplicitMethod_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ExplicitMethod {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInterface_starGenType_ExplicitMethod_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInterface_starGenType_ExplicitMethod_paramsKey]*MoqInterface_starGenType_ExplicitMethod_results{},
		}
		r.Moq.ResultsByParams_ExplicitMethod = append(r.Moq.ResultsByParams_ExplicitMethod, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ExplicitMethod) {
			copy(r.Moq.ResultsByParams_ExplicitMethod[insertAt+1:], r.Moq.ResultsByParams_ExplicitMethod[insertAt:0])
			r.Moq.ResultsByParams_ExplicitMethod[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ExplicitMethod(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInterface_starGenType_ExplicitMethod_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInterface_starGenType_ExplicitMethod_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInterface_starGenType_ExplicitMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.Func
				}
				Sequence   uint32
				DoFn       MoqInterface_starGenType_ExplicitMethod_doFn
				DoReturnFn MoqInterface_starGenType_ExplicitMethod_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInterface_starGenType) PrettyParams_ExplicitMethod(params MoqInterface_starGenType_ExplicitMethod_params) string {
	return fmt.Sprintf("ExplicitMethod(%#v)", params.Param1)
}

func (m *MoqInterface_starGenType) ParamsKey_ExplicitMethod(params MoqInterface_starGenType_ExplicitMethod_params, anyParams uint64) MoqInterface_starGenType_ExplicitMethod_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ExplicitMethod.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqInterface_starGenType_ExplicitMethod_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqInterface_starGenType_recorder) NumEmbeddeds() *MoqInterface_starGenType_NumEmbeddeds_fnRecorder {
	return &MoqInterface_starGenType_NumEmbeddeds_fnRecorder{
		Params:   MoqInterface_starGenType_NumEmbeddeds_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInterface_starGenType_NumEmbeddeds_fnRecorder) Any() *MoqInterface_starGenType_NumEmbeddeds_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumEmbeddeds(r.Params))
		return nil
	}
	return &MoqInterface_starGenType_NumEmbeddeds_anyParams{Recorder: r}
}

func (r *MoqInterface_starGenType_NumEmbeddeds_fnRecorder) Seq() *MoqInterface_starGenType_NumEmbeddeds_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumEmbeddeds(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInterface_starGenType_NumEmbeddeds_fnRecorder) NoSeq() *MoqInterface_starGenType_NumEmbeddeds_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumEmbeddeds(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInterface_starGenType_NumEmbeddeds_fnRecorder) ReturnResults(result1 int) *MoqInterface_starGenType_NumEmbeddeds_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_NumEmbeddeds_doFn
		DoReturnFn MoqInterface_starGenType_NumEmbeddeds_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInterface_starGenType_NumEmbeddeds_fnRecorder) AndDo(fn MoqInterface_starGenType_NumEmbeddeds_doFn) *MoqInterface_starGenType_NumEmbeddeds_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInterface_starGenType_NumEmbeddeds_fnRecorder) DoReturnResults(fn MoqInterface_starGenType_NumEmbeddeds_doReturnFn) *MoqInterface_starGenType_NumEmbeddeds_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_NumEmbeddeds_doFn
		DoReturnFn MoqInterface_starGenType_NumEmbeddeds_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInterface_starGenType_NumEmbeddeds_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInterface_starGenType_NumEmbeddeds_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumEmbeddeds {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInterface_starGenType_NumEmbeddeds_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInterface_starGenType_NumEmbeddeds_paramsKey]*MoqInterface_starGenType_NumEmbeddeds_results{},
		}
		r.Moq.ResultsByParams_NumEmbeddeds = append(r.Moq.ResultsByParams_NumEmbeddeds, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumEmbeddeds) {
			copy(r.Moq.ResultsByParams_NumEmbeddeds[insertAt+1:], r.Moq.ResultsByParams_NumEmbeddeds[insertAt:0])
			r.Moq.ResultsByParams_NumEmbeddeds[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumEmbeddeds(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInterface_starGenType_NumEmbeddeds_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInterface_starGenType_NumEmbeddeds_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInterface_starGenType_NumEmbeddeds_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqInterface_starGenType_NumEmbeddeds_doFn
				DoReturnFn MoqInterface_starGenType_NumEmbeddeds_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInterface_starGenType) PrettyParams_NumEmbeddeds(params MoqInterface_starGenType_NumEmbeddeds_params) string {
	return fmt.Sprintf("NumEmbeddeds()")
}

func (m *MoqInterface_starGenType) ParamsKey_NumEmbeddeds(params MoqInterface_starGenType_NumEmbeddeds_params, anyParams uint64) MoqInterface_starGenType_NumEmbeddeds_paramsKey {
	m.Scene.T.Helper()
	return MoqInterface_starGenType_NumEmbeddeds_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInterface_starGenType_recorder) Embedded(param1 int) *MoqInterface_starGenType_Embedded_fnRecorder {
	return &MoqInterface_starGenType_Embedded_fnRecorder{
		Params: MoqInterface_starGenType_Embedded_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInterface_starGenType_Embedded_fnRecorder) Any() *MoqInterface_starGenType_Embedded_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Embedded(r.Params))
		return nil
	}
	return &MoqInterface_starGenType_Embedded_anyParams{Recorder: r}
}

func (a *MoqInterface_starGenType_Embedded_anyParams) Param1() *MoqInterface_starGenType_Embedded_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInterface_starGenType_Embedded_fnRecorder) Seq() *MoqInterface_starGenType_Embedded_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Embedded(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInterface_starGenType_Embedded_fnRecorder) NoSeq() *MoqInterface_starGenType_Embedded_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Embedded(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInterface_starGenType_Embedded_fnRecorder) ReturnResults(result1 *types.Named) *MoqInterface_starGenType_Embedded_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Named
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Embedded_doFn
		DoReturnFn MoqInterface_starGenType_Embedded_doReturnFn
	}{
		Values: &struct {
			Result1 *types.Named
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInterface_starGenType_Embedded_fnRecorder) AndDo(fn MoqInterface_starGenType_Embedded_doFn) *MoqInterface_starGenType_Embedded_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInterface_starGenType_Embedded_fnRecorder) DoReturnResults(fn MoqInterface_starGenType_Embedded_doReturnFn) *MoqInterface_starGenType_Embedded_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Named
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Embedded_doFn
		DoReturnFn MoqInterface_starGenType_Embedded_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInterface_starGenType_Embedded_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInterface_starGenType_Embedded_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Embedded {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInterface_starGenType_Embedded_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInterface_starGenType_Embedded_paramsKey]*MoqInterface_starGenType_Embedded_results{},
		}
		r.Moq.ResultsByParams_Embedded = append(r.Moq.ResultsByParams_Embedded, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Embedded) {
			copy(r.Moq.ResultsByParams_Embedded[insertAt+1:], r.Moq.ResultsByParams_Embedded[insertAt:0])
			r.Moq.ResultsByParams_Embedded[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Embedded(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInterface_starGenType_Embedded_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInterface_starGenType_Embedded_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInterface_starGenType_Embedded_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.Named
				}
				Sequence   uint32
				DoFn       MoqInterface_starGenType_Embedded_doFn
				DoReturnFn MoqInterface_starGenType_Embedded_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInterface_starGenType) PrettyParams_Embedded(params MoqInterface_starGenType_Embedded_params) string {
	return fmt.Sprintf("Embedded(%#v)", params.Param1)
}

func (m *MoqInterface_starGenType) ParamsKey_Embedded(params MoqInterface_starGenType_Embedded_params, anyParams uint64) MoqInterface_starGenType_Embedded_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Embedded.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqInterface_starGenType_Embedded_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqInterface_starGenType_recorder) EmbeddedType(param1 int) *MoqInterface_starGenType_EmbeddedType_fnRecorder {
	return &MoqInterface_starGenType_EmbeddedType_fnRecorder{
		Params: MoqInterface_starGenType_EmbeddedType_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInterface_starGenType_EmbeddedType_fnRecorder) Any() *MoqInterface_starGenType_EmbeddedType_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_EmbeddedType(r.Params))
		return nil
	}
	return &MoqInterface_starGenType_EmbeddedType_anyParams{Recorder: r}
}

func (a *MoqInterface_starGenType_EmbeddedType_anyParams) Param1() *MoqInterface_starGenType_EmbeddedType_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInterface_starGenType_EmbeddedType_fnRecorder) Seq() *MoqInterface_starGenType_EmbeddedType_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_EmbeddedType(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInterface_starGenType_EmbeddedType_fnRecorder) NoSeq() *MoqInterface_starGenType_EmbeddedType_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_EmbeddedType(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInterface_starGenType_EmbeddedType_fnRecorder) ReturnResults(result1 types.Type) *MoqInterface_starGenType_EmbeddedType_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 types.Type
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_EmbeddedType_doFn
		DoReturnFn MoqInterface_starGenType_EmbeddedType_doReturnFn
	}{
		Values: &struct {
			Result1 types.Type
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInterface_starGenType_EmbeddedType_fnRecorder) AndDo(fn MoqInterface_starGenType_EmbeddedType_doFn) *MoqInterface_starGenType_EmbeddedType_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInterface_starGenType_EmbeddedType_fnRecorder) DoReturnResults(fn MoqInterface_starGenType_EmbeddedType_doReturnFn) *MoqInterface_starGenType_EmbeddedType_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 types.Type
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_EmbeddedType_doFn
		DoReturnFn MoqInterface_starGenType_EmbeddedType_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInterface_starGenType_EmbeddedType_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInterface_starGenType_EmbeddedType_resultsByParams
	for n, res := range r.Moq.ResultsByParams_EmbeddedType {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInterface_starGenType_EmbeddedType_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInterface_starGenType_EmbeddedType_paramsKey]*MoqInterface_starGenType_EmbeddedType_results{},
		}
		r.Moq.ResultsByParams_EmbeddedType = append(r.Moq.ResultsByParams_EmbeddedType, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_EmbeddedType) {
			copy(r.Moq.ResultsByParams_EmbeddedType[insertAt+1:], r.Moq.ResultsByParams_EmbeddedType[insertAt:0])
			r.Moq.ResultsByParams_EmbeddedType[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_EmbeddedType(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInterface_starGenType_EmbeddedType_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInterface_starGenType_EmbeddedType_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInterface_starGenType_EmbeddedType_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 types.Type
				}
				Sequence   uint32
				DoFn       MoqInterface_starGenType_EmbeddedType_doFn
				DoReturnFn MoqInterface_starGenType_EmbeddedType_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInterface_starGenType) PrettyParams_EmbeddedType(params MoqInterface_starGenType_EmbeddedType_params) string {
	return fmt.Sprintf("EmbeddedType(%#v)", params.Param1)
}

func (m *MoqInterface_starGenType) ParamsKey_EmbeddedType(params MoqInterface_starGenType_EmbeddedType_params, anyParams uint64) MoqInterface_starGenType_EmbeddedType_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.EmbeddedType.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqInterface_starGenType_EmbeddedType_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqInterface_starGenType_recorder) NumMethods() *MoqInterface_starGenType_NumMethods_fnRecorder {
	return &MoqInterface_starGenType_NumMethods_fnRecorder{
		Params:   MoqInterface_starGenType_NumMethods_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInterface_starGenType_NumMethods_fnRecorder) Any() *MoqInterface_starGenType_NumMethods_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethods(r.Params))
		return nil
	}
	return &MoqInterface_starGenType_NumMethods_anyParams{Recorder: r}
}

func (r *MoqInterface_starGenType_NumMethods_fnRecorder) Seq() *MoqInterface_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethods(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInterface_starGenType_NumMethods_fnRecorder) NoSeq() *MoqInterface_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethods(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInterface_starGenType_NumMethods_fnRecorder) ReturnResults(result1 int) *MoqInterface_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_NumMethods_doFn
		DoReturnFn MoqInterface_starGenType_NumMethods_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInterface_starGenType_NumMethods_fnRecorder) AndDo(fn MoqInterface_starGenType_NumMethods_doFn) *MoqInterface_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInterface_starGenType_NumMethods_fnRecorder) DoReturnResults(fn MoqInterface_starGenType_NumMethods_doReturnFn) *MoqInterface_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_NumMethods_doFn
		DoReturnFn MoqInterface_starGenType_NumMethods_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInterface_starGenType_NumMethods_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInterface_starGenType_NumMethods_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumMethods {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInterface_starGenType_NumMethods_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInterface_starGenType_NumMethods_paramsKey]*MoqInterface_starGenType_NumMethods_results{},
		}
		r.Moq.ResultsByParams_NumMethods = append(r.Moq.ResultsByParams_NumMethods, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumMethods) {
			copy(r.Moq.ResultsByParams_NumMethods[insertAt+1:], r.Moq.ResultsByParams_NumMethods[insertAt:0])
			r.Moq.ResultsByParams_NumMethods[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumMethods(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInterface_starGenType_NumMethods_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInterface_starGenType_NumMethods_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInterface_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqInterface_starGenType_NumMethods_doFn
				DoReturnFn MoqInterface_starGenType_NumMethods_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInterface_starGenType) PrettyParams_NumMethods(params MoqInterface_starGenType_NumMethods_params) string {
	return fmt.Sprintf("NumMethods()")
}

func (m *MoqInterface_starGenType) ParamsKey_NumMethods(params MoqInterface_starGenType_NumMethods_params, anyParams uint64) MoqInterface_starGenType_NumMethods_paramsKey {
	m.Scene.T.Helper()
	return MoqInterface_starGenType_NumMethods_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInterface_starGenType_recorder) Method(param1 int) *MoqInterface_starGenType_Method_fnRecorder {
	return &MoqInterface_starGenType_Method_fnRecorder{
		Params: MoqInterface_starGenType_Method_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInterface_starGenType_Method_fnRecorder) Any() *MoqInterface_starGenType_Method_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	return &MoqInterface_starGenType_Method_anyParams{Recorder: r}
}

func (a *MoqInterface_starGenType_Method_anyParams) Param1() *MoqInterface_starGenType_Method_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqInterface_starGenType_Method_fnRecorder) Seq() *MoqInterface_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInterface_starGenType_Method_fnRecorder) NoSeq() *MoqInterface_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInterface_starGenType_Method_fnRecorder) ReturnResults(result1 *types.Func) *MoqInterface_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Func
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Method_doFn
		DoReturnFn MoqInterface_starGenType_Method_doReturnFn
	}{
		Values: &struct {
			Result1 *types.Func
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInterface_starGenType_Method_fnRecorder) AndDo(fn MoqInterface_starGenType_Method_doFn) *MoqInterface_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInterface_starGenType_Method_fnRecorder) DoReturnResults(fn MoqInterface_starGenType_Method_doReturnFn) *MoqInterface_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Func
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Method_doFn
		DoReturnFn MoqInterface_starGenType_Method_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInterface_starGenType_Method_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInterface_starGenType_Method_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Method {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInterface_starGenType_Method_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInterface_starGenType_Method_paramsKey]*MoqInterface_starGenType_Method_results{},
		}
		r.Moq.ResultsByParams_Method = append(r.Moq.ResultsByParams_Method, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Method) {
			copy(r.Moq.ResultsByParams_Method[insertAt+1:], r.Moq.ResultsByParams_Method[insertAt:0])
			r.Moq.ResultsByParams_Method[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Method(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInterface_starGenType_Method_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInterface_starGenType_Method_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInterface_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.Func
				}
				Sequence   uint32
				DoFn       MoqInterface_starGenType_Method_doFn
				DoReturnFn MoqInterface_starGenType_Method_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInterface_starGenType) PrettyParams_Method(params MoqInterface_starGenType_Method_params) string {
	return fmt.Sprintf("Method(%#v)", params.Param1)
}

func (m *MoqInterface_starGenType) ParamsKey_Method(params MoqInterface_starGenType_Method_params, anyParams uint64) MoqInterface_starGenType_Method_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Method.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqInterface_starGenType_Method_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqInterface_starGenType_recorder) Empty() *MoqInterface_starGenType_Empty_fnRecorder {
	return &MoqInterface_starGenType_Empty_fnRecorder{
		Params:   MoqInterface_starGenType_Empty_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInterface_starGenType_Empty_fnRecorder) Any() *MoqInterface_starGenType_Empty_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Empty(r.Params))
		return nil
	}
	return &MoqInterface_starGenType_Empty_anyParams{Recorder: r}
}

func (r *MoqInterface_starGenType_Empty_fnRecorder) Seq() *MoqInterface_starGenType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Empty(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInterface_starGenType_Empty_fnRecorder) NoSeq() *MoqInterface_starGenType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Empty(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInterface_starGenType_Empty_fnRecorder) ReturnResults(result1 bool) *MoqInterface_starGenType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Empty_doFn
		DoReturnFn MoqInterface_starGenType_Empty_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInterface_starGenType_Empty_fnRecorder) AndDo(fn MoqInterface_starGenType_Empty_doFn) *MoqInterface_starGenType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInterface_starGenType_Empty_fnRecorder) DoReturnResults(fn MoqInterface_starGenType_Empty_doReturnFn) *MoqInterface_starGenType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Empty_doFn
		DoReturnFn MoqInterface_starGenType_Empty_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInterface_starGenType_Empty_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInterface_starGenType_Empty_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Empty {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInterface_starGenType_Empty_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInterface_starGenType_Empty_paramsKey]*MoqInterface_starGenType_Empty_results{},
		}
		r.Moq.ResultsByParams_Empty = append(r.Moq.ResultsByParams_Empty, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Empty) {
			copy(r.Moq.ResultsByParams_Empty[insertAt+1:], r.Moq.ResultsByParams_Empty[insertAt:0])
			r.Moq.ResultsByParams_Empty[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Empty(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInterface_starGenType_Empty_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInterface_starGenType_Empty_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInterface_starGenType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqInterface_starGenType_Empty_doFn
				DoReturnFn MoqInterface_starGenType_Empty_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInterface_starGenType) PrettyParams_Empty(params MoqInterface_starGenType_Empty_params) string {
	return fmt.Sprintf("Empty()")
}

func (m *MoqInterface_starGenType) ParamsKey_Empty(params MoqInterface_starGenType_Empty_params, anyParams uint64) MoqInterface_starGenType_Empty_paramsKey {
	m.Scene.T.Helper()
	return MoqInterface_starGenType_Empty_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInterface_starGenType_recorder) Complete() *MoqInterface_starGenType_Complete_fnRecorder {
	return &MoqInterface_starGenType_Complete_fnRecorder{
		Params:   MoqInterface_starGenType_Complete_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInterface_starGenType_Complete_fnRecorder) Any() *MoqInterface_starGenType_Complete_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Complete(r.Params))
		return nil
	}
	return &MoqInterface_starGenType_Complete_anyParams{Recorder: r}
}

func (r *MoqInterface_starGenType_Complete_fnRecorder) Seq() *MoqInterface_starGenType_Complete_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Complete(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInterface_starGenType_Complete_fnRecorder) NoSeq() *MoqInterface_starGenType_Complete_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Complete(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInterface_starGenType_Complete_fnRecorder) ReturnResults(result1 *types.Interface) *MoqInterface_starGenType_Complete_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Interface
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Complete_doFn
		DoReturnFn MoqInterface_starGenType_Complete_doReturnFn
	}{
		Values: &struct {
			Result1 *types.Interface
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInterface_starGenType_Complete_fnRecorder) AndDo(fn MoqInterface_starGenType_Complete_doFn) *MoqInterface_starGenType_Complete_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInterface_starGenType_Complete_fnRecorder) DoReturnResults(fn MoqInterface_starGenType_Complete_doReturnFn) *MoqInterface_starGenType_Complete_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Interface
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Complete_doFn
		DoReturnFn MoqInterface_starGenType_Complete_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInterface_starGenType_Complete_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInterface_starGenType_Complete_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Complete {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInterface_starGenType_Complete_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInterface_starGenType_Complete_paramsKey]*MoqInterface_starGenType_Complete_results{},
		}
		r.Moq.ResultsByParams_Complete = append(r.Moq.ResultsByParams_Complete, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Complete) {
			copy(r.Moq.ResultsByParams_Complete[insertAt+1:], r.Moq.ResultsByParams_Complete[insertAt:0])
			r.Moq.ResultsByParams_Complete[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Complete(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInterface_starGenType_Complete_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInterface_starGenType_Complete_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInterface_starGenType_Complete_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.Interface
				}
				Sequence   uint32
				DoFn       MoqInterface_starGenType_Complete_doFn
				DoReturnFn MoqInterface_starGenType_Complete_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInterface_starGenType) PrettyParams_Complete(params MoqInterface_starGenType_Complete_params) string {
	return fmt.Sprintf("Complete()")
}

func (m *MoqInterface_starGenType) ParamsKey_Complete(params MoqInterface_starGenType_Complete_params, anyParams uint64) MoqInterface_starGenType_Complete_paramsKey {
	m.Scene.T.Helper()
	return MoqInterface_starGenType_Complete_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInterface_starGenType_recorder) Underlying() *MoqInterface_starGenType_Underlying_fnRecorder {
	return &MoqInterface_starGenType_Underlying_fnRecorder{
		Params:   MoqInterface_starGenType_Underlying_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInterface_starGenType_Underlying_fnRecorder) Any() *MoqInterface_starGenType_Underlying_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Underlying(r.Params))
		return nil
	}
	return &MoqInterface_starGenType_Underlying_anyParams{Recorder: r}
}

func (r *MoqInterface_starGenType_Underlying_fnRecorder) Seq() *MoqInterface_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Underlying(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInterface_starGenType_Underlying_fnRecorder) NoSeq() *MoqInterface_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Underlying(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInterface_starGenType_Underlying_fnRecorder) ReturnResults(result1 types.Type) *MoqInterface_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 types.Type
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Underlying_doFn
		DoReturnFn MoqInterface_starGenType_Underlying_doReturnFn
	}{
		Values: &struct {
			Result1 types.Type
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInterface_starGenType_Underlying_fnRecorder) AndDo(fn MoqInterface_starGenType_Underlying_doFn) *MoqInterface_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInterface_starGenType_Underlying_fnRecorder) DoReturnResults(fn MoqInterface_starGenType_Underlying_doReturnFn) *MoqInterface_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 types.Type
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_Underlying_doFn
		DoReturnFn MoqInterface_starGenType_Underlying_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInterface_starGenType_Underlying_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInterface_starGenType_Underlying_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Underlying {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInterface_starGenType_Underlying_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInterface_starGenType_Underlying_paramsKey]*MoqInterface_starGenType_Underlying_results{},
		}
		r.Moq.ResultsByParams_Underlying = append(r.Moq.ResultsByParams_Underlying, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Underlying) {
			copy(r.Moq.ResultsByParams_Underlying[insertAt+1:], r.Moq.ResultsByParams_Underlying[insertAt:0])
			r.Moq.ResultsByParams_Underlying[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Underlying(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInterface_starGenType_Underlying_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInterface_starGenType_Underlying_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInterface_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 types.Type
				}
				Sequence   uint32
				DoFn       MoqInterface_starGenType_Underlying_doFn
				DoReturnFn MoqInterface_starGenType_Underlying_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInterface_starGenType) PrettyParams_Underlying(params MoqInterface_starGenType_Underlying_params) string {
	return fmt.Sprintf("Underlying()")
}

func (m *MoqInterface_starGenType) ParamsKey_Underlying(params MoqInterface_starGenType_Underlying_params, anyParams uint64) MoqInterface_starGenType_Underlying_paramsKey {
	m.Scene.T.Helper()
	return MoqInterface_starGenType_Underlying_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqInterface_starGenType_recorder) String() *MoqInterface_starGenType_String_fnRecorder {
	return &MoqInterface_starGenType_String_fnRecorder{
		Params:   MoqInterface_starGenType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqInterface_starGenType_String_fnRecorder) Any() *MoqInterface_starGenType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqInterface_starGenType_String_anyParams{Recorder: r}
}

func (r *MoqInterface_starGenType_String_fnRecorder) Seq() *MoqInterface_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqInterface_starGenType_String_fnRecorder) NoSeq() *MoqInterface_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqInterface_starGenType_String_fnRecorder) ReturnResults(result1 string) *MoqInterface_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_String_doFn
		DoReturnFn MoqInterface_starGenType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqInterface_starGenType_String_fnRecorder) AndDo(fn MoqInterface_starGenType_String_doFn) *MoqInterface_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqInterface_starGenType_String_fnRecorder) DoReturnResults(fn MoqInterface_starGenType_String_doReturnFn) *MoqInterface_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqInterface_starGenType_String_doFn
		DoReturnFn MoqInterface_starGenType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqInterface_starGenType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqInterface_starGenType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqInterface_starGenType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqInterface_starGenType_String_paramsKey]*MoqInterface_starGenType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqInterface_starGenType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqInterface_starGenType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqInterface_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqInterface_starGenType_String_doFn
				DoReturnFn MoqInterface_starGenType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqInterface_starGenType) PrettyParams_String(params MoqInterface_starGenType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqInterface_starGenType) ParamsKey_String(params MoqInterface_starGenType_String_params, anyParams uint64) MoqInterface_starGenType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqInterface_starGenType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqInterface_starGenType) Reset() {
	m.ResultsByParams_NumExplicitMethods = nil
	m.ResultsByParams_ExplicitMethod = nil
	m.ResultsByParams_NumEmbeddeds = nil
	m.ResultsByParams_Embedded = nil
	m.ResultsByParams_EmbeddedType = nil
	m.ResultsByParams_NumMethods = nil
	m.ResultsByParams_Method = nil
	m.ResultsByParams_Empty = nil
	m.ResultsByParams_Complete = nil
	m.ResultsByParams_Underlying = nil
	m.ResultsByParams_String = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqInterface_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_NumExplicitMethods {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumExplicitMethods(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ExplicitMethod {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ExplicitMethod(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_NumEmbeddeds {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumEmbeddeds(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Embedded {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Embedded(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_EmbeddedType {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_EmbeddedType(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_NumMethods {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumMethods(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Method {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Method(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Empty {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Empty(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Complete {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Complete(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Underlying {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Underlying(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
}
