// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package types

import (
	"fmt"
	"go/token"
	"go/types"
	"io"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that types.Scope_starGenType is mocked
// completely
var _ Scope_starGenType = (*MoqScope_starGenType_mock)(nil)

// Scope_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Scope_starGenType interface {
	Parent() *types.Scope
	Len() int
	Names() []string
	NumChildren() int
	Child(i int) *types.Scope
	Lookup(name string) types.Object
	LookupParent(name string, pos token.Pos) (*types.Scope, types.Object)
	Insert(obj types.Object) types.Object
	Pos() token.Pos
	End() token.Pos
	Contains(pos token.Pos) bool
	Innermost(pos token.Pos) *types.Scope
	WriteTo(w io.Writer, n int, recurse bool)
	String() string
}

// MoqScope_starGenType holds the state of a moq of the Scope_starGenType type
type MoqScope_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqScope_starGenType_mock

	ResultsByParams_Parent       []MoqScope_starGenType_Parent_resultsByParams
	ResultsByParams_Len          []MoqScope_starGenType_Len_resultsByParams
	ResultsByParams_Names        []MoqScope_starGenType_Names_resultsByParams
	ResultsByParams_NumChildren  []MoqScope_starGenType_NumChildren_resultsByParams
	ResultsByParams_Child        []MoqScope_starGenType_Child_resultsByParams
	ResultsByParams_Lookup       []MoqScope_starGenType_Lookup_resultsByParams
	ResultsByParams_LookupParent []MoqScope_starGenType_LookupParent_resultsByParams
	ResultsByParams_Insert       []MoqScope_starGenType_Insert_resultsByParams
	ResultsByParams_Pos          []MoqScope_starGenType_Pos_resultsByParams
	ResultsByParams_End          []MoqScope_starGenType_End_resultsByParams
	ResultsByParams_Contains     []MoqScope_starGenType_Contains_resultsByParams
	ResultsByParams_Innermost    []MoqScope_starGenType_Innermost_resultsByParams
	ResultsByParams_WriteTo      []MoqScope_starGenType_WriteTo_resultsByParams
	ResultsByParams_String       []MoqScope_starGenType_String_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Parent      struct{}
			Len         struct{}
			Names       struct{}
			NumChildren struct{}
			Child       struct {
				Param1 moq.ParamIndexing
			}
			Lookup struct {
				Name moq.ParamIndexing
			}
			LookupParent struct {
				Name moq.ParamIndexing
				Pos  moq.ParamIndexing
			}
			Insert struct {
				Obj moq.ParamIndexing
			}
			Pos      struct{}
			End      struct{}
			Contains struct {
				Pos moq.ParamIndexing
			}
			Innermost struct {
				Pos moq.ParamIndexing
			}
			WriteTo struct {
				W       moq.ParamIndexing
				N       moq.ParamIndexing
				Recurse moq.ParamIndexing
			}
			String struct{}
		}
	}
}

// MoqScope_starGenType_mock isolates the mock interface of the
// Scope_starGenType type
type MoqScope_starGenType_mock struct {
	Moq *MoqScope_starGenType
}

// MoqScope_starGenType_recorder isolates the recorder interface of the
// Scope_starGenType type
type MoqScope_starGenType_recorder struct {
	Moq *MoqScope_starGenType
}

// MoqScope_starGenType_Parent_params holds the params of the Scope_starGenType
// type
type MoqScope_starGenType_Parent_params struct{}

// MoqScope_starGenType_Parent_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_Parent_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqScope_starGenType_Parent_resultsByParams contains the results for a given
// set of parameters for the Scope_starGenType type
type MoqScope_starGenType_Parent_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_Parent_paramsKey]*MoqScope_starGenType_Parent_results
}

// MoqScope_starGenType_Parent_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_Parent_doFn func()

// MoqScope_starGenType_Parent_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_Parent_doReturnFn func() *types.Scope

// MoqScope_starGenType_Parent_results holds the results of the
// Scope_starGenType type
type MoqScope_starGenType_Parent_results struct {
	Params  MoqScope_starGenType_Parent_params
	Results []struct {
		Values *struct {
			Result1 *types.Scope
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Parent_doFn
		DoReturnFn MoqScope_starGenType_Parent_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_Parent_fnRecorder routes recorded function calls to the
// MoqScope_starGenType moq
type MoqScope_starGenType_Parent_fnRecorder struct {
	Params    MoqScope_starGenType_Parent_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_Parent_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_Parent_anyParams isolates the any params functions of
// the Scope_starGenType type
type MoqScope_starGenType_Parent_anyParams struct {
	Recorder *MoqScope_starGenType_Parent_fnRecorder
}

// MoqScope_starGenType_Len_params holds the params of the Scope_starGenType
// type
type MoqScope_starGenType_Len_params struct{}

// MoqScope_starGenType_Len_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_Len_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqScope_starGenType_Len_resultsByParams contains the results for a given
// set of parameters for the Scope_starGenType type
type MoqScope_starGenType_Len_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_Len_paramsKey]*MoqScope_starGenType_Len_results
}

// MoqScope_starGenType_Len_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_Len_doFn func()

// MoqScope_starGenType_Len_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_Len_doReturnFn func() int

// MoqScope_starGenType_Len_results holds the results of the Scope_starGenType
// type
type MoqScope_starGenType_Len_results struct {
	Params  MoqScope_starGenType_Len_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Len_doFn
		DoReturnFn MoqScope_starGenType_Len_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_Len_fnRecorder routes recorded function calls to the
// MoqScope_starGenType moq
type MoqScope_starGenType_Len_fnRecorder struct {
	Params    MoqScope_starGenType_Len_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_Len_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_Len_anyParams isolates the any params functions of the
// Scope_starGenType type
type MoqScope_starGenType_Len_anyParams struct {
	Recorder *MoqScope_starGenType_Len_fnRecorder
}

// MoqScope_starGenType_Names_params holds the params of the Scope_starGenType
// type
type MoqScope_starGenType_Names_params struct{}

// MoqScope_starGenType_Names_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_Names_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqScope_starGenType_Names_resultsByParams contains the results for a given
// set of parameters for the Scope_starGenType type
type MoqScope_starGenType_Names_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_Names_paramsKey]*MoqScope_starGenType_Names_results
}

// MoqScope_starGenType_Names_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_Names_doFn func()

// MoqScope_starGenType_Names_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_Names_doReturnFn func() []string

// MoqScope_starGenType_Names_results holds the results of the
// Scope_starGenType type
type MoqScope_starGenType_Names_results struct {
	Params  MoqScope_starGenType_Names_params
	Results []struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Names_doFn
		DoReturnFn MoqScope_starGenType_Names_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_Names_fnRecorder routes recorded function calls to the
// MoqScope_starGenType moq
type MoqScope_starGenType_Names_fnRecorder struct {
	Params    MoqScope_starGenType_Names_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_Names_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_Names_anyParams isolates the any params functions of
// the Scope_starGenType type
type MoqScope_starGenType_Names_anyParams struct {
	Recorder *MoqScope_starGenType_Names_fnRecorder
}

// MoqScope_starGenType_NumChildren_params holds the params of the
// Scope_starGenType type
type MoqScope_starGenType_NumChildren_params struct{}

// MoqScope_starGenType_NumChildren_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_NumChildren_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqScope_starGenType_NumChildren_resultsByParams contains the results for a
// given set of parameters for the Scope_starGenType type
type MoqScope_starGenType_NumChildren_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_NumChildren_paramsKey]*MoqScope_starGenType_NumChildren_results
}

// MoqScope_starGenType_NumChildren_doFn defines the type of function needed
// when calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_NumChildren_doFn func()

// MoqScope_starGenType_NumChildren_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_NumChildren_doReturnFn func() int

// MoqScope_starGenType_NumChildren_results holds the results of the
// Scope_starGenType type
type MoqScope_starGenType_NumChildren_results struct {
	Params  MoqScope_starGenType_NumChildren_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_NumChildren_doFn
		DoReturnFn MoqScope_starGenType_NumChildren_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_NumChildren_fnRecorder routes recorded function calls
// to the MoqScope_starGenType moq
type MoqScope_starGenType_NumChildren_fnRecorder struct {
	Params    MoqScope_starGenType_NumChildren_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_NumChildren_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_NumChildren_anyParams isolates the any params functions
// of the Scope_starGenType type
type MoqScope_starGenType_NumChildren_anyParams struct {
	Recorder *MoqScope_starGenType_NumChildren_fnRecorder
}

// MoqScope_starGenType_Child_params holds the params of the Scope_starGenType
// type
type MoqScope_starGenType_Child_params struct{ Param1 int }

// MoqScope_starGenType_Child_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_Child_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqScope_starGenType_Child_resultsByParams contains the results for a given
// set of parameters for the Scope_starGenType type
type MoqScope_starGenType_Child_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_Child_paramsKey]*MoqScope_starGenType_Child_results
}

// MoqScope_starGenType_Child_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_Child_doFn func(i int)

// MoqScope_starGenType_Child_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_Child_doReturnFn func(i int) *types.Scope

// MoqScope_starGenType_Child_results holds the results of the
// Scope_starGenType type
type MoqScope_starGenType_Child_results struct {
	Params  MoqScope_starGenType_Child_params
	Results []struct {
		Values *struct {
			Result1 *types.Scope
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Child_doFn
		DoReturnFn MoqScope_starGenType_Child_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_Child_fnRecorder routes recorded function calls to the
// MoqScope_starGenType moq
type MoqScope_starGenType_Child_fnRecorder struct {
	Params    MoqScope_starGenType_Child_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_Child_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_Child_anyParams isolates the any params functions of
// the Scope_starGenType type
type MoqScope_starGenType_Child_anyParams struct {
	Recorder *MoqScope_starGenType_Child_fnRecorder
}

// MoqScope_starGenType_Lookup_params holds the params of the Scope_starGenType
// type
type MoqScope_starGenType_Lookup_params struct{ Name string }

// MoqScope_starGenType_Lookup_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_Lookup_paramsKey struct {
	Params struct{ Name string }
	Hashes struct{ Name hash.Hash }
}

// MoqScope_starGenType_Lookup_resultsByParams contains the results for a given
// set of parameters for the Scope_starGenType type
type MoqScope_starGenType_Lookup_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_Lookup_paramsKey]*MoqScope_starGenType_Lookup_results
}

// MoqScope_starGenType_Lookup_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_Lookup_doFn func(name string)

// MoqScope_starGenType_Lookup_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_Lookup_doReturnFn func(name string) types.Object

// MoqScope_starGenType_Lookup_results holds the results of the
// Scope_starGenType type
type MoqScope_starGenType_Lookup_results struct {
	Params  MoqScope_starGenType_Lookup_params
	Results []struct {
		Values *struct {
			Result1 types.Object
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Lookup_doFn
		DoReturnFn MoqScope_starGenType_Lookup_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_Lookup_fnRecorder routes recorded function calls to the
// MoqScope_starGenType moq
type MoqScope_starGenType_Lookup_fnRecorder struct {
	Params    MoqScope_starGenType_Lookup_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_Lookup_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_Lookup_anyParams isolates the any params functions of
// the Scope_starGenType type
type MoqScope_starGenType_Lookup_anyParams struct {
	Recorder *MoqScope_starGenType_Lookup_fnRecorder
}

// MoqScope_starGenType_LookupParent_params holds the params of the
// Scope_starGenType type
type MoqScope_starGenType_LookupParent_params struct {
	Name string
	Pos  token.Pos
}

// MoqScope_starGenType_LookupParent_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_LookupParent_paramsKey struct {
	Params struct {
		Name string
		Pos  token.Pos
	}
	Hashes struct {
		Name hash.Hash
		Pos  hash.Hash
	}
}

// MoqScope_starGenType_LookupParent_resultsByParams contains the results for a
// given set of parameters for the Scope_starGenType type
type MoqScope_starGenType_LookupParent_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_LookupParent_paramsKey]*MoqScope_starGenType_LookupParent_results
}

// MoqScope_starGenType_LookupParent_doFn defines the type of function needed
// when calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_LookupParent_doFn func(name string, pos token.Pos)

// MoqScope_starGenType_LookupParent_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_LookupParent_doReturnFn func(name string, pos token.Pos) (*types.Scope, types.Object)

// MoqScope_starGenType_LookupParent_results holds the results of the
// Scope_starGenType type
type MoqScope_starGenType_LookupParent_results struct {
	Params  MoqScope_starGenType_LookupParent_params
	Results []struct {
		Values *struct {
			Result1 *types.Scope
			Result2 types.Object
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_LookupParent_doFn
		DoReturnFn MoqScope_starGenType_LookupParent_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_LookupParent_fnRecorder routes recorded function calls
// to the MoqScope_starGenType moq
type MoqScope_starGenType_LookupParent_fnRecorder struct {
	Params    MoqScope_starGenType_LookupParent_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_LookupParent_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_LookupParent_anyParams isolates the any params
// functions of the Scope_starGenType type
type MoqScope_starGenType_LookupParent_anyParams struct {
	Recorder *MoqScope_starGenType_LookupParent_fnRecorder
}

// MoqScope_starGenType_Insert_params holds the params of the Scope_starGenType
// type
type MoqScope_starGenType_Insert_params struct{ Obj types.Object }

// MoqScope_starGenType_Insert_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_Insert_paramsKey struct {
	Params struct{ Obj types.Object }
	Hashes struct{ Obj hash.Hash }
}

// MoqScope_starGenType_Insert_resultsByParams contains the results for a given
// set of parameters for the Scope_starGenType type
type MoqScope_starGenType_Insert_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_Insert_paramsKey]*MoqScope_starGenType_Insert_results
}

// MoqScope_starGenType_Insert_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_Insert_doFn func(obj types.Object)

// MoqScope_starGenType_Insert_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_Insert_doReturnFn func(obj types.Object) types.Object

// MoqScope_starGenType_Insert_results holds the results of the
// Scope_starGenType type
type MoqScope_starGenType_Insert_results struct {
	Params  MoqScope_starGenType_Insert_params
	Results []struct {
		Values *struct {
			Result1 types.Object
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Insert_doFn
		DoReturnFn MoqScope_starGenType_Insert_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_Insert_fnRecorder routes recorded function calls to the
// MoqScope_starGenType moq
type MoqScope_starGenType_Insert_fnRecorder struct {
	Params    MoqScope_starGenType_Insert_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_Insert_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_Insert_anyParams isolates the any params functions of
// the Scope_starGenType type
type MoqScope_starGenType_Insert_anyParams struct {
	Recorder *MoqScope_starGenType_Insert_fnRecorder
}

// MoqScope_starGenType_Pos_params holds the params of the Scope_starGenType
// type
type MoqScope_starGenType_Pos_params struct{}

// MoqScope_starGenType_Pos_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_Pos_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqScope_starGenType_Pos_resultsByParams contains the results for a given
// set of parameters for the Scope_starGenType type
type MoqScope_starGenType_Pos_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_Pos_paramsKey]*MoqScope_starGenType_Pos_results
}

// MoqScope_starGenType_Pos_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_Pos_doFn func()

// MoqScope_starGenType_Pos_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_Pos_doReturnFn func() token.Pos

// MoqScope_starGenType_Pos_results holds the results of the Scope_starGenType
// type
type MoqScope_starGenType_Pos_results struct {
	Params  MoqScope_starGenType_Pos_params
	Results []struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Pos_doFn
		DoReturnFn MoqScope_starGenType_Pos_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_Pos_fnRecorder routes recorded function calls to the
// MoqScope_starGenType moq
type MoqScope_starGenType_Pos_fnRecorder struct {
	Params    MoqScope_starGenType_Pos_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_Pos_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_Pos_anyParams isolates the any params functions of the
// Scope_starGenType type
type MoqScope_starGenType_Pos_anyParams struct {
	Recorder *MoqScope_starGenType_Pos_fnRecorder
}

// MoqScope_starGenType_End_params holds the params of the Scope_starGenType
// type
type MoqScope_starGenType_End_params struct{}

// MoqScope_starGenType_End_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_End_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqScope_starGenType_End_resultsByParams contains the results for a given
// set of parameters for the Scope_starGenType type
type MoqScope_starGenType_End_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_End_paramsKey]*MoqScope_starGenType_End_results
}

// MoqScope_starGenType_End_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_End_doFn func()

// MoqScope_starGenType_End_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_End_doReturnFn func() token.Pos

// MoqScope_starGenType_End_results holds the results of the Scope_starGenType
// type
type MoqScope_starGenType_End_results struct {
	Params  MoqScope_starGenType_End_params
	Results []struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_End_doFn
		DoReturnFn MoqScope_starGenType_End_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_End_fnRecorder routes recorded function calls to the
// MoqScope_starGenType moq
type MoqScope_starGenType_End_fnRecorder struct {
	Params    MoqScope_starGenType_End_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_End_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_End_anyParams isolates the any params functions of the
// Scope_starGenType type
type MoqScope_starGenType_End_anyParams struct {
	Recorder *MoqScope_starGenType_End_fnRecorder
}

// MoqScope_starGenType_Contains_params holds the params of the
// Scope_starGenType type
type MoqScope_starGenType_Contains_params struct{ Pos token.Pos }

// MoqScope_starGenType_Contains_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_Contains_paramsKey struct {
	Params struct{ Pos token.Pos }
	Hashes struct{ Pos hash.Hash }
}

// MoqScope_starGenType_Contains_resultsByParams contains the results for a
// given set of parameters for the Scope_starGenType type
type MoqScope_starGenType_Contains_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_Contains_paramsKey]*MoqScope_starGenType_Contains_results
}

// MoqScope_starGenType_Contains_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_Contains_doFn func(pos token.Pos)

// MoqScope_starGenType_Contains_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_Contains_doReturnFn func(pos token.Pos) bool

// MoqScope_starGenType_Contains_results holds the results of the
// Scope_starGenType type
type MoqScope_starGenType_Contains_results struct {
	Params  MoqScope_starGenType_Contains_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Contains_doFn
		DoReturnFn MoqScope_starGenType_Contains_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_Contains_fnRecorder routes recorded function calls to
// the MoqScope_starGenType moq
type MoqScope_starGenType_Contains_fnRecorder struct {
	Params    MoqScope_starGenType_Contains_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_Contains_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_Contains_anyParams isolates the any params functions of
// the Scope_starGenType type
type MoqScope_starGenType_Contains_anyParams struct {
	Recorder *MoqScope_starGenType_Contains_fnRecorder
}

// MoqScope_starGenType_Innermost_params holds the params of the
// Scope_starGenType type
type MoqScope_starGenType_Innermost_params struct{ Pos token.Pos }

// MoqScope_starGenType_Innermost_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_Innermost_paramsKey struct {
	Params struct{ Pos token.Pos }
	Hashes struct{ Pos hash.Hash }
}

// MoqScope_starGenType_Innermost_resultsByParams contains the results for a
// given set of parameters for the Scope_starGenType type
type MoqScope_starGenType_Innermost_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_Innermost_paramsKey]*MoqScope_starGenType_Innermost_results
}

// MoqScope_starGenType_Innermost_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_Innermost_doFn func(pos token.Pos)

// MoqScope_starGenType_Innermost_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_Innermost_doReturnFn func(pos token.Pos) *types.Scope

// MoqScope_starGenType_Innermost_results holds the results of the
// Scope_starGenType type
type MoqScope_starGenType_Innermost_results struct {
	Params  MoqScope_starGenType_Innermost_params
	Results []struct {
		Values *struct {
			Result1 *types.Scope
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Innermost_doFn
		DoReturnFn MoqScope_starGenType_Innermost_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_Innermost_fnRecorder routes recorded function calls to
// the MoqScope_starGenType moq
type MoqScope_starGenType_Innermost_fnRecorder struct {
	Params    MoqScope_starGenType_Innermost_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_Innermost_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_Innermost_anyParams isolates the any params functions
// of the Scope_starGenType type
type MoqScope_starGenType_Innermost_anyParams struct {
	Recorder *MoqScope_starGenType_Innermost_fnRecorder
}

// MoqScope_starGenType_WriteTo_params holds the params of the
// Scope_starGenType type
type MoqScope_starGenType_WriteTo_params struct {
	W       io.Writer
	N       int
	Recurse bool
}

// MoqScope_starGenType_WriteTo_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_WriteTo_paramsKey struct {
	Params struct {
		W       io.Writer
		N       int
		Recurse bool
	}
	Hashes struct {
		W       hash.Hash
		N       hash.Hash
		Recurse hash.Hash
	}
}

// MoqScope_starGenType_WriteTo_resultsByParams contains the results for a
// given set of parameters for the Scope_starGenType type
type MoqScope_starGenType_WriteTo_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_WriteTo_paramsKey]*MoqScope_starGenType_WriteTo_results
}

// MoqScope_starGenType_WriteTo_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_WriteTo_doFn func(w io.Writer, n int, recurse bool)

// MoqScope_starGenType_WriteTo_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_WriteTo_doReturnFn func(w io.Writer, n int, recurse bool)

// MoqScope_starGenType_WriteTo_results holds the results of the
// Scope_starGenType type
type MoqScope_starGenType_WriteTo_results struct {
	Params  MoqScope_starGenType_WriteTo_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqScope_starGenType_WriteTo_doFn
		DoReturnFn MoqScope_starGenType_WriteTo_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_WriteTo_fnRecorder routes recorded function calls to
// the MoqScope_starGenType moq
type MoqScope_starGenType_WriteTo_fnRecorder struct {
	Params    MoqScope_starGenType_WriteTo_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_WriteTo_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_WriteTo_anyParams isolates the any params functions of
// the Scope_starGenType type
type MoqScope_starGenType_WriteTo_anyParams struct {
	Recorder *MoqScope_starGenType_WriteTo_fnRecorder
}

// MoqScope_starGenType_String_params holds the params of the Scope_starGenType
// type
type MoqScope_starGenType_String_params struct{}

// MoqScope_starGenType_String_paramsKey holds the map key params of the
// Scope_starGenType type
type MoqScope_starGenType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqScope_starGenType_String_resultsByParams contains the results for a given
// set of parameters for the Scope_starGenType type
type MoqScope_starGenType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqScope_starGenType_String_paramsKey]*MoqScope_starGenType_String_results
}

// MoqScope_starGenType_String_doFn defines the type of function needed when
// calling AndDo for the Scope_starGenType type
type MoqScope_starGenType_String_doFn func()

// MoqScope_starGenType_String_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Scope_starGenType type
type MoqScope_starGenType_String_doReturnFn func() string

// MoqScope_starGenType_String_results holds the results of the
// Scope_starGenType type
type MoqScope_starGenType_String_results struct {
	Params  MoqScope_starGenType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_String_doFn
		DoReturnFn MoqScope_starGenType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqScope_starGenType_String_fnRecorder routes recorded function calls to the
// MoqScope_starGenType moq
type MoqScope_starGenType_String_fnRecorder struct {
	Params    MoqScope_starGenType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqScope_starGenType_String_results
	Moq       *MoqScope_starGenType
}

// MoqScope_starGenType_String_anyParams isolates the any params functions of
// the Scope_starGenType type
type MoqScope_starGenType_String_anyParams struct {
	Recorder *MoqScope_starGenType_String_fnRecorder
}

// NewMoqScope_starGenType creates a new moq of the Scope_starGenType type
func NewMoqScope_starGenType(scene *moq.Scene, config *moq.Config) *MoqScope_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqScope_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqScope_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Parent      struct{}
				Len         struct{}
				Names       struct{}
				NumChildren struct{}
				Child       struct {
					Param1 moq.ParamIndexing
				}
				Lookup struct {
					Name moq.ParamIndexing
				}
				LookupParent struct {
					Name moq.ParamIndexing
					Pos  moq.ParamIndexing
				}
				Insert struct {
					Obj moq.ParamIndexing
				}
				Pos      struct{}
				End      struct{}
				Contains struct {
					Pos moq.ParamIndexing
				}
				Innermost struct {
					Pos moq.ParamIndexing
				}
				WriteTo struct {
					W       moq.ParamIndexing
					N       moq.ParamIndexing
					Recurse moq.ParamIndexing
				}
				String struct{}
			}
		}{ParameterIndexing: struct {
			Parent      struct{}
			Len         struct{}
			Names       struct{}
			NumChildren struct{}
			Child       struct {
				Param1 moq.ParamIndexing
			}
			Lookup struct {
				Name moq.ParamIndexing
			}
			LookupParent struct {
				Name moq.ParamIndexing
				Pos  moq.ParamIndexing
			}
			Insert struct {
				Obj moq.ParamIndexing
			}
			Pos      struct{}
			End      struct{}
			Contains struct {
				Pos moq.ParamIndexing
			}
			Innermost struct {
				Pos moq.ParamIndexing
			}
			WriteTo struct {
				W       moq.ParamIndexing
				N       moq.ParamIndexing
				Recurse moq.ParamIndexing
			}
			String struct{}
		}{
			Parent:      struct{}{},
			Len:         struct{}{},
			Names:       struct{}{},
			NumChildren: struct{}{},
			Child: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			Lookup: struct {
				Name moq.ParamIndexing
			}{
				Name: moq.ParamIndexByValue,
			},
			LookupParent: struct {
				Name moq.ParamIndexing
				Pos  moq.ParamIndexing
			}{
				Name: moq.ParamIndexByValue,
				Pos:  moq.ParamIndexByValue,
			},
			Insert: struct {
				Obj moq.ParamIndexing
			}{
				Obj: moq.ParamIndexByHash,
			},
			Pos: struct{}{},
			End: struct{}{},
			Contains: struct {
				Pos moq.ParamIndexing
			}{
				Pos: moq.ParamIndexByValue,
			},
			Innermost: struct {
				Pos moq.ParamIndexing
			}{
				Pos: moq.ParamIndexByValue,
			},
			WriteTo: struct {
				W       moq.ParamIndexing
				N       moq.ParamIndexing
				Recurse moq.ParamIndexing
			}{
				W:       moq.ParamIndexByHash,
				N:       moq.ParamIndexByValue,
				Recurse: moq.ParamIndexByValue,
			},
			String: struct{}{},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Scope_starGenType type
func (m *MoqScope_starGenType) Mock() *MoqScope_starGenType_mock { return m.Moq }

func (m *MoqScope_starGenType_mock) Parent() (result1 *types.Scope) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_Parent_params{}
	var results *MoqScope_starGenType_Parent_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Parent {
		paramsKey := m.Moq.ParamsKey_Parent(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Parent(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Parent(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Parent(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqScope_starGenType_mock) Len() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_Len_params{}
	var results *MoqScope_starGenType_Len_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Len {
		paramsKey := m.Moq.ParamsKey_Len(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Len(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Len(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Len(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqScope_starGenType_mock) Names() (result1 []string) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_Names_params{}
	var results *MoqScope_starGenType_Names_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Names {
		paramsKey := m.Moq.ParamsKey_Names(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Names(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Names(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Names(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqScope_starGenType_mock) NumChildren() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_NumChildren_params{}
	var results *MoqScope_starGenType_NumChildren_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumChildren {
		paramsKey := m.Moq.ParamsKey_NumChildren(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumChildren(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumChildren(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumChildren(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqScope_starGenType_mock) Child(param1 int) (result1 *types.Scope) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_Child_params{
		Param1: param1,
	}
	var results *MoqScope_starGenType_Child_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Child {
		paramsKey := m.Moq.ParamsKey_Child(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Child(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Child(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Child(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqScope_starGenType_mock) Lookup(name string) (result1 types.Object) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_Lookup_params{
		Name: name,
	}
	var results *MoqScope_starGenType_Lookup_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Lookup {
		paramsKey := m.Moq.ParamsKey_Lookup(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Lookup(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Lookup(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Lookup(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(name)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(name)
	}
	return
}

func (m *MoqScope_starGenType_mock) LookupParent(name string, pos token.Pos) (result1 *types.Scope, result2 types.Object) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_LookupParent_params{
		Name: name,
		Pos:  pos,
	}
	var results *MoqScope_starGenType_LookupParent_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LookupParent {
		paramsKey := m.Moq.ParamsKey_LookupParent(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LookupParent(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LookupParent(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LookupParent(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(name, pos)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(name, pos)
	}
	return
}

func (m *MoqScope_starGenType_mock) Insert(obj types.Object) (result1 types.Object) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_Insert_params{
		Obj: obj,
	}
	var results *MoqScope_starGenType_Insert_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Insert {
		paramsKey := m.Moq.ParamsKey_Insert(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Insert(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Insert(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Insert(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(obj)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(obj)
	}
	return
}

func (m *MoqScope_starGenType_mock) Pos() (result1 token.Pos) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_Pos_params{}
	var results *MoqScope_starGenType_Pos_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Pos {
		paramsKey := m.Moq.ParamsKey_Pos(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Pos(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Pos(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Pos(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqScope_starGenType_mock) End() (result1 token.Pos) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_End_params{}
	var results *MoqScope_starGenType_End_results
	for _, resultsByParams := range m.Moq.ResultsByParams_End {
		paramsKey := m.Moq.ParamsKey_End(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_End(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_End(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_End(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqScope_starGenType_mock) Contains(pos token.Pos) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_Contains_params{
		Pos: pos,
	}
	var results *MoqScope_starGenType_Contains_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Contains {
		paramsKey := m.Moq.ParamsKey_Contains(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Contains(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Contains(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Contains(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(pos)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(pos)
	}
	return
}

func (m *MoqScope_starGenType_mock) Innermost(pos token.Pos) (result1 *types.Scope) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_Innermost_params{
		Pos: pos,
	}
	var results *MoqScope_starGenType_Innermost_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Innermost {
		paramsKey := m.Moq.ParamsKey_Innermost(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Innermost(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Innermost(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Innermost(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(pos)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(pos)
	}
	return
}

func (m *MoqScope_starGenType_mock) WriteTo(w io.Writer, n int, recurse bool) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_WriteTo_params{
		W:       w,
		N:       n,
		Recurse: recurse,
	}
	var results *MoqScope_starGenType_WriteTo_results
	for _, resultsByParams := range m.Moq.ResultsByParams_WriteTo {
		paramsKey := m.Moq.ParamsKey_WriteTo(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_WriteTo(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_WriteTo(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_WriteTo(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(w, n, recurse)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(w, n, recurse)
	}
	return
}

func (m *MoqScope_starGenType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqScope_starGenType_String_params{}
	var results *MoqScope_starGenType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

// OnCall returns the recorder implementation of the Scope_starGenType type
func (m *MoqScope_starGenType) OnCall() *MoqScope_starGenType_recorder {
	return &MoqScope_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqScope_starGenType_recorder) Parent() *MoqScope_starGenType_Parent_fnRecorder {
	return &MoqScope_starGenType_Parent_fnRecorder{
		Params:   MoqScope_starGenType_Parent_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_Parent_fnRecorder) Any() *MoqScope_starGenType_Parent_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parent(r.Params))
		return nil
	}
	return &MoqScope_starGenType_Parent_anyParams{Recorder: r}
}

func (r *MoqScope_starGenType_Parent_fnRecorder) Seq() *MoqScope_starGenType_Parent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parent(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_Parent_fnRecorder) NoSeq() *MoqScope_starGenType_Parent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parent(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_Parent_fnRecorder) ReturnResults(result1 *types.Scope) *MoqScope_starGenType_Parent_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Scope
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Parent_doFn
		DoReturnFn MoqScope_starGenType_Parent_doReturnFn
	}{
		Values: &struct {
			Result1 *types.Scope
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_Parent_fnRecorder) AndDo(fn MoqScope_starGenType_Parent_doFn) *MoqScope_starGenType_Parent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_Parent_fnRecorder) DoReturnResults(fn MoqScope_starGenType_Parent_doReturnFn) *MoqScope_starGenType_Parent_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Scope
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Parent_doFn
		DoReturnFn MoqScope_starGenType_Parent_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_Parent_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_Parent_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Parent {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_Parent_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_Parent_paramsKey]*MoqScope_starGenType_Parent_results{},
		}
		r.Moq.ResultsByParams_Parent = append(r.Moq.ResultsByParams_Parent, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Parent) {
			copy(r.Moq.ResultsByParams_Parent[insertAt+1:], r.Moq.ResultsByParams_Parent[insertAt:0])
			r.Moq.ResultsByParams_Parent[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Parent(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_Parent_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_Parent_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_Parent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.Scope
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_Parent_doFn
				DoReturnFn MoqScope_starGenType_Parent_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_Parent(params MoqScope_starGenType_Parent_params) string {
	return fmt.Sprintf("Parent()")
}

func (m *MoqScope_starGenType) ParamsKey_Parent(params MoqScope_starGenType_Parent_params, anyParams uint64) MoqScope_starGenType_Parent_paramsKey {
	m.Scene.T.Helper()
	return MoqScope_starGenType_Parent_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqScope_starGenType_recorder) Len() *MoqScope_starGenType_Len_fnRecorder {
	return &MoqScope_starGenType_Len_fnRecorder{
		Params:   MoqScope_starGenType_Len_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_Len_fnRecorder) Any() *MoqScope_starGenType_Len_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	return &MoqScope_starGenType_Len_anyParams{Recorder: r}
}

func (r *MoqScope_starGenType_Len_fnRecorder) Seq() *MoqScope_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_Len_fnRecorder) NoSeq() *MoqScope_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_Len_fnRecorder) ReturnResults(result1 int) *MoqScope_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Len_doFn
		DoReturnFn MoqScope_starGenType_Len_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_Len_fnRecorder) AndDo(fn MoqScope_starGenType_Len_doFn) *MoqScope_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_Len_fnRecorder) DoReturnResults(fn MoqScope_starGenType_Len_doReturnFn) *MoqScope_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Len_doFn
		DoReturnFn MoqScope_starGenType_Len_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_Len_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_Len_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Len {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_Len_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_Len_paramsKey]*MoqScope_starGenType_Len_results{},
		}
		r.Moq.ResultsByParams_Len = append(r.Moq.ResultsByParams_Len, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Len) {
			copy(r.Moq.ResultsByParams_Len[insertAt+1:], r.Moq.ResultsByParams_Len[insertAt:0])
			r.Moq.ResultsByParams_Len[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Len(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_Len_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_Len_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_Len_doFn
				DoReturnFn MoqScope_starGenType_Len_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_Len(params MoqScope_starGenType_Len_params) string {
	return fmt.Sprintf("Len()")
}

func (m *MoqScope_starGenType) ParamsKey_Len(params MoqScope_starGenType_Len_params, anyParams uint64) MoqScope_starGenType_Len_paramsKey {
	m.Scene.T.Helper()
	return MoqScope_starGenType_Len_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqScope_starGenType_recorder) Names() *MoqScope_starGenType_Names_fnRecorder {
	return &MoqScope_starGenType_Names_fnRecorder{
		Params:   MoqScope_starGenType_Names_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_Names_fnRecorder) Any() *MoqScope_starGenType_Names_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Names(r.Params))
		return nil
	}
	return &MoqScope_starGenType_Names_anyParams{Recorder: r}
}

func (r *MoqScope_starGenType_Names_fnRecorder) Seq() *MoqScope_starGenType_Names_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Names(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_Names_fnRecorder) NoSeq() *MoqScope_starGenType_Names_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Names(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_Names_fnRecorder) ReturnResults(result1 []string) *MoqScope_starGenType_Names_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Names_doFn
		DoReturnFn MoqScope_starGenType_Names_doReturnFn
	}{
		Values: &struct {
			Result1 []string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_Names_fnRecorder) AndDo(fn MoqScope_starGenType_Names_doFn) *MoqScope_starGenType_Names_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_Names_fnRecorder) DoReturnResults(fn MoqScope_starGenType_Names_doReturnFn) *MoqScope_starGenType_Names_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Names_doFn
		DoReturnFn MoqScope_starGenType_Names_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_Names_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_Names_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Names {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_Names_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_Names_paramsKey]*MoqScope_starGenType_Names_results{},
		}
		r.Moq.ResultsByParams_Names = append(r.Moq.ResultsByParams_Names, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Names) {
			copy(r.Moq.ResultsByParams_Names[insertAt+1:], r.Moq.ResultsByParams_Names[insertAt:0])
			r.Moq.ResultsByParams_Names[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Names(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_Names_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_Names_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_Names_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []string
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_Names_doFn
				DoReturnFn MoqScope_starGenType_Names_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_Names(params MoqScope_starGenType_Names_params) string {
	return fmt.Sprintf("Names()")
}

func (m *MoqScope_starGenType) ParamsKey_Names(params MoqScope_starGenType_Names_params, anyParams uint64) MoqScope_starGenType_Names_paramsKey {
	m.Scene.T.Helper()
	return MoqScope_starGenType_Names_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqScope_starGenType_recorder) NumChildren() *MoqScope_starGenType_NumChildren_fnRecorder {
	return &MoqScope_starGenType_NumChildren_fnRecorder{
		Params:   MoqScope_starGenType_NumChildren_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_NumChildren_fnRecorder) Any() *MoqScope_starGenType_NumChildren_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumChildren(r.Params))
		return nil
	}
	return &MoqScope_starGenType_NumChildren_anyParams{Recorder: r}
}

func (r *MoqScope_starGenType_NumChildren_fnRecorder) Seq() *MoqScope_starGenType_NumChildren_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumChildren(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_NumChildren_fnRecorder) NoSeq() *MoqScope_starGenType_NumChildren_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumChildren(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_NumChildren_fnRecorder) ReturnResults(result1 int) *MoqScope_starGenType_NumChildren_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_NumChildren_doFn
		DoReturnFn MoqScope_starGenType_NumChildren_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_NumChildren_fnRecorder) AndDo(fn MoqScope_starGenType_NumChildren_doFn) *MoqScope_starGenType_NumChildren_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_NumChildren_fnRecorder) DoReturnResults(fn MoqScope_starGenType_NumChildren_doReturnFn) *MoqScope_starGenType_NumChildren_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_NumChildren_doFn
		DoReturnFn MoqScope_starGenType_NumChildren_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_NumChildren_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_NumChildren_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumChildren {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_NumChildren_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_NumChildren_paramsKey]*MoqScope_starGenType_NumChildren_results{},
		}
		r.Moq.ResultsByParams_NumChildren = append(r.Moq.ResultsByParams_NumChildren, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumChildren) {
			copy(r.Moq.ResultsByParams_NumChildren[insertAt+1:], r.Moq.ResultsByParams_NumChildren[insertAt:0])
			r.Moq.ResultsByParams_NumChildren[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumChildren(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_NumChildren_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_NumChildren_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_NumChildren_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_NumChildren_doFn
				DoReturnFn MoqScope_starGenType_NumChildren_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_NumChildren(params MoqScope_starGenType_NumChildren_params) string {
	return fmt.Sprintf("NumChildren()")
}

func (m *MoqScope_starGenType) ParamsKey_NumChildren(params MoqScope_starGenType_NumChildren_params, anyParams uint64) MoqScope_starGenType_NumChildren_paramsKey {
	m.Scene.T.Helper()
	return MoqScope_starGenType_NumChildren_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqScope_starGenType_recorder) Child(param1 int) *MoqScope_starGenType_Child_fnRecorder {
	return &MoqScope_starGenType_Child_fnRecorder{
		Params: MoqScope_starGenType_Child_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_Child_fnRecorder) Any() *MoqScope_starGenType_Child_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Child(r.Params))
		return nil
	}
	return &MoqScope_starGenType_Child_anyParams{Recorder: r}
}

func (a *MoqScope_starGenType_Child_anyParams) Param1() *MoqScope_starGenType_Child_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqScope_starGenType_Child_fnRecorder) Seq() *MoqScope_starGenType_Child_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Child(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_Child_fnRecorder) NoSeq() *MoqScope_starGenType_Child_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Child(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_Child_fnRecorder) ReturnResults(result1 *types.Scope) *MoqScope_starGenType_Child_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Scope
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Child_doFn
		DoReturnFn MoqScope_starGenType_Child_doReturnFn
	}{
		Values: &struct {
			Result1 *types.Scope
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_Child_fnRecorder) AndDo(fn MoqScope_starGenType_Child_doFn) *MoqScope_starGenType_Child_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_Child_fnRecorder) DoReturnResults(fn MoqScope_starGenType_Child_doReturnFn) *MoqScope_starGenType_Child_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Scope
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Child_doFn
		DoReturnFn MoqScope_starGenType_Child_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_Child_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_Child_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Child {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_Child_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_Child_paramsKey]*MoqScope_starGenType_Child_results{},
		}
		r.Moq.ResultsByParams_Child = append(r.Moq.ResultsByParams_Child, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Child) {
			copy(r.Moq.ResultsByParams_Child[insertAt+1:], r.Moq.ResultsByParams_Child[insertAt:0])
			r.Moq.ResultsByParams_Child[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Child(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_Child_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_Child_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_Child_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.Scope
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_Child_doFn
				DoReturnFn MoqScope_starGenType_Child_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_Child(params MoqScope_starGenType_Child_params) string {
	return fmt.Sprintf("Child(%#v)", params.Param1)
}

func (m *MoqScope_starGenType) ParamsKey_Child(params MoqScope_starGenType_Child_params, anyParams uint64) MoqScope_starGenType_Child_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Child.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqScope_starGenType_Child_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqScope_starGenType_recorder) Lookup(name string) *MoqScope_starGenType_Lookup_fnRecorder {
	return &MoqScope_starGenType_Lookup_fnRecorder{
		Params: MoqScope_starGenType_Lookup_params{
			Name: name,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_Lookup_fnRecorder) Any() *MoqScope_starGenType_Lookup_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Lookup(r.Params))
		return nil
	}
	return &MoqScope_starGenType_Lookup_anyParams{Recorder: r}
}

func (a *MoqScope_starGenType_Lookup_anyParams) Name() *MoqScope_starGenType_Lookup_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqScope_starGenType_Lookup_fnRecorder) Seq() *MoqScope_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Lookup(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_Lookup_fnRecorder) NoSeq() *MoqScope_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Lookup(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_Lookup_fnRecorder) ReturnResults(result1 types.Object) *MoqScope_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 types.Object
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Lookup_doFn
		DoReturnFn MoqScope_starGenType_Lookup_doReturnFn
	}{
		Values: &struct {
			Result1 types.Object
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_Lookup_fnRecorder) AndDo(fn MoqScope_starGenType_Lookup_doFn) *MoqScope_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_Lookup_fnRecorder) DoReturnResults(fn MoqScope_starGenType_Lookup_doReturnFn) *MoqScope_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 types.Object
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Lookup_doFn
		DoReturnFn MoqScope_starGenType_Lookup_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_Lookup_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_Lookup_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Lookup {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_Lookup_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_Lookup_paramsKey]*MoqScope_starGenType_Lookup_results{},
		}
		r.Moq.ResultsByParams_Lookup = append(r.Moq.ResultsByParams_Lookup, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Lookup) {
			copy(r.Moq.ResultsByParams_Lookup[insertAt+1:], r.Moq.ResultsByParams_Lookup[insertAt:0])
			r.Moq.ResultsByParams_Lookup[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Lookup(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_Lookup_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_Lookup_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 types.Object
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_Lookup_doFn
				DoReturnFn MoqScope_starGenType_Lookup_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_Lookup(params MoqScope_starGenType_Lookup_params) string {
	return fmt.Sprintf("Lookup(%#v)", params.Name)
}

func (m *MoqScope_starGenType) ParamsKey_Lookup(params MoqScope_starGenType_Lookup_params, anyParams uint64) MoqScope_starGenType_Lookup_paramsKey {
	m.Scene.T.Helper()
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Lookup.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	return MoqScope_starGenType_Lookup_paramsKey{
		Params: struct{ Name string }{
			Name: nameUsed,
		},
		Hashes: struct{ Name hash.Hash }{
			Name: nameUsedHash,
		},
	}
}

func (m *MoqScope_starGenType_recorder) LookupParent(name string, pos token.Pos) *MoqScope_starGenType_LookupParent_fnRecorder {
	return &MoqScope_starGenType_LookupParent_fnRecorder{
		Params: MoqScope_starGenType_LookupParent_params{
			Name: name,
			Pos:  pos,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_LookupParent_fnRecorder) Any() *MoqScope_starGenType_LookupParent_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupParent(r.Params))
		return nil
	}
	return &MoqScope_starGenType_LookupParent_anyParams{Recorder: r}
}

func (a *MoqScope_starGenType_LookupParent_anyParams) Name() *MoqScope_starGenType_LookupParent_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqScope_starGenType_LookupParent_anyParams) Pos() *MoqScope_starGenType_LookupParent_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqScope_starGenType_LookupParent_fnRecorder) Seq() *MoqScope_starGenType_LookupParent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupParent(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_LookupParent_fnRecorder) NoSeq() *MoqScope_starGenType_LookupParent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupParent(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_LookupParent_fnRecorder) ReturnResults(result1 *types.Scope, result2 types.Object) *MoqScope_starGenType_LookupParent_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Scope
			Result2 types.Object
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_LookupParent_doFn
		DoReturnFn MoqScope_starGenType_LookupParent_doReturnFn
	}{
		Values: &struct {
			Result1 *types.Scope
			Result2 types.Object
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_LookupParent_fnRecorder) AndDo(fn MoqScope_starGenType_LookupParent_doFn) *MoqScope_starGenType_LookupParent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_LookupParent_fnRecorder) DoReturnResults(fn MoqScope_starGenType_LookupParent_doReturnFn) *MoqScope_starGenType_LookupParent_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Scope
			Result2 types.Object
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_LookupParent_doFn
		DoReturnFn MoqScope_starGenType_LookupParent_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_LookupParent_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_LookupParent_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LookupParent {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_LookupParent_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_LookupParent_paramsKey]*MoqScope_starGenType_LookupParent_results{},
		}
		r.Moq.ResultsByParams_LookupParent = append(r.Moq.ResultsByParams_LookupParent, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LookupParent) {
			copy(r.Moq.ResultsByParams_LookupParent[insertAt+1:], r.Moq.ResultsByParams_LookupParent[insertAt:0])
			r.Moq.ResultsByParams_LookupParent[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LookupParent(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_LookupParent_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_LookupParent_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_LookupParent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.Scope
					Result2 types.Object
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_LookupParent_doFn
				DoReturnFn MoqScope_starGenType_LookupParent_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_LookupParent(params MoqScope_starGenType_LookupParent_params) string {
	return fmt.Sprintf("LookupParent(%#v, %#v)", params.Name, params.Pos)
}

func (m *MoqScope_starGenType) ParamsKey_LookupParent(params MoqScope_starGenType_LookupParent_params, anyParams uint64) MoqScope_starGenType_LookupParent_paramsKey {
	m.Scene.T.Helper()
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LookupParent.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	var posUsed token.Pos
	var posUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.LookupParent.Pos == moq.ParamIndexByValue {
			posUsed = params.Pos
		} else {
			posUsedHash = hash.DeepHash(params.Pos)
		}
	}
	return MoqScope_starGenType_LookupParent_paramsKey{
		Params: struct {
			Name string
			Pos  token.Pos
		}{
			Name: nameUsed,
			Pos:  posUsed,
		},
		Hashes: struct {
			Name hash.Hash
			Pos  hash.Hash
		}{
			Name: nameUsedHash,
			Pos:  posUsedHash,
		},
	}
}

func (m *MoqScope_starGenType_recorder) Insert(obj types.Object) *MoqScope_starGenType_Insert_fnRecorder {
	return &MoqScope_starGenType_Insert_fnRecorder{
		Params: MoqScope_starGenType_Insert_params{
			Obj: obj,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_Insert_fnRecorder) Any() *MoqScope_starGenType_Insert_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Insert(r.Params))
		return nil
	}
	return &MoqScope_starGenType_Insert_anyParams{Recorder: r}
}

func (a *MoqScope_starGenType_Insert_anyParams) Obj() *MoqScope_starGenType_Insert_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqScope_starGenType_Insert_fnRecorder) Seq() *MoqScope_starGenType_Insert_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Insert(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_Insert_fnRecorder) NoSeq() *MoqScope_starGenType_Insert_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Insert(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_Insert_fnRecorder) ReturnResults(result1 types.Object) *MoqScope_starGenType_Insert_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 types.Object
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Insert_doFn
		DoReturnFn MoqScope_starGenType_Insert_doReturnFn
	}{
		Values: &struct {
			Result1 types.Object
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_Insert_fnRecorder) AndDo(fn MoqScope_starGenType_Insert_doFn) *MoqScope_starGenType_Insert_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_Insert_fnRecorder) DoReturnResults(fn MoqScope_starGenType_Insert_doReturnFn) *MoqScope_starGenType_Insert_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 types.Object
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Insert_doFn
		DoReturnFn MoqScope_starGenType_Insert_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_Insert_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_Insert_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Insert {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_Insert_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_Insert_paramsKey]*MoqScope_starGenType_Insert_results{},
		}
		r.Moq.ResultsByParams_Insert = append(r.Moq.ResultsByParams_Insert, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Insert) {
			copy(r.Moq.ResultsByParams_Insert[insertAt+1:], r.Moq.ResultsByParams_Insert[insertAt:0])
			r.Moq.ResultsByParams_Insert[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Insert(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_Insert_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_Insert_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_Insert_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 types.Object
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_Insert_doFn
				DoReturnFn MoqScope_starGenType_Insert_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_Insert(params MoqScope_starGenType_Insert_params) string {
	return fmt.Sprintf("Insert(%#v)", params.Obj)
}

func (m *MoqScope_starGenType) ParamsKey_Insert(params MoqScope_starGenType_Insert_params, anyParams uint64) MoqScope_starGenType_Insert_paramsKey {
	m.Scene.T.Helper()
	var objUsed types.Object
	var objUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Insert.Obj == moq.ParamIndexByValue {
			objUsed = params.Obj
		} else {
			objUsedHash = hash.DeepHash(params.Obj)
		}
	}
	return MoqScope_starGenType_Insert_paramsKey{
		Params: struct{ Obj types.Object }{
			Obj: objUsed,
		},
		Hashes: struct{ Obj hash.Hash }{
			Obj: objUsedHash,
		},
	}
}

func (m *MoqScope_starGenType_recorder) Pos() *MoqScope_starGenType_Pos_fnRecorder {
	return &MoqScope_starGenType_Pos_fnRecorder{
		Params:   MoqScope_starGenType_Pos_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_Pos_fnRecorder) Any() *MoqScope_starGenType_Pos_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Pos(r.Params))
		return nil
	}
	return &MoqScope_starGenType_Pos_anyParams{Recorder: r}
}

func (r *MoqScope_starGenType_Pos_fnRecorder) Seq() *MoqScope_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Pos(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_Pos_fnRecorder) NoSeq() *MoqScope_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Pos(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_Pos_fnRecorder) ReturnResults(result1 token.Pos) *MoqScope_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Pos_doFn
		DoReturnFn MoqScope_starGenType_Pos_doReturnFn
	}{
		Values: &struct {
			Result1 token.Pos
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_Pos_fnRecorder) AndDo(fn MoqScope_starGenType_Pos_doFn) *MoqScope_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_Pos_fnRecorder) DoReturnResults(fn MoqScope_starGenType_Pos_doReturnFn) *MoqScope_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Pos_doFn
		DoReturnFn MoqScope_starGenType_Pos_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_Pos_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_Pos_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Pos {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_Pos_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_Pos_paramsKey]*MoqScope_starGenType_Pos_results{},
		}
		r.Moq.ResultsByParams_Pos = append(r.Moq.ResultsByParams_Pos, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Pos) {
			copy(r.Moq.ResultsByParams_Pos[insertAt+1:], r.Moq.ResultsByParams_Pos[insertAt:0])
			r.Moq.ResultsByParams_Pos[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Pos(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_Pos_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_Pos_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 token.Pos
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_Pos_doFn
				DoReturnFn MoqScope_starGenType_Pos_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_Pos(params MoqScope_starGenType_Pos_params) string {
	return fmt.Sprintf("Pos()")
}

func (m *MoqScope_starGenType) ParamsKey_Pos(params MoqScope_starGenType_Pos_params, anyParams uint64) MoqScope_starGenType_Pos_paramsKey {
	m.Scene.T.Helper()
	return MoqScope_starGenType_Pos_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqScope_starGenType_recorder) End() *MoqScope_starGenType_End_fnRecorder {
	return &MoqScope_starGenType_End_fnRecorder{
		Params:   MoqScope_starGenType_End_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_End_fnRecorder) Any() *MoqScope_starGenType_End_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_End(r.Params))
		return nil
	}
	return &MoqScope_starGenType_End_anyParams{Recorder: r}
}

func (r *MoqScope_starGenType_End_fnRecorder) Seq() *MoqScope_starGenType_End_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_End(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_End_fnRecorder) NoSeq() *MoqScope_starGenType_End_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_End(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_End_fnRecorder) ReturnResults(result1 token.Pos) *MoqScope_starGenType_End_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_End_doFn
		DoReturnFn MoqScope_starGenType_End_doReturnFn
	}{
		Values: &struct {
			Result1 token.Pos
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_End_fnRecorder) AndDo(fn MoqScope_starGenType_End_doFn) *MoqScope_starGenType_End_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_End_fnRecorder) DoReturnResults(fn MoqScope_starGenType_End_doReturnFn) *MoqScope_starGenType_End_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_End_doFn
		DoReturnFn MoqScope_starGenType_End_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_End_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_End_resultsByParams
	for n, res := range r.Moq.ResultsByParams_End {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_End_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_End_paramsKey]*MoqScope_starGenType_End_results{},
		}
		r.Moq.ResultsByParams_End = append(r.Moq.ResultsByParams_End, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_End) {
			copy(r.Moq.ResultsByParams_End[insertAt+1:], r.Moq.ResultsByParams_End[insertAt:0])
			r.Moq.ResultsByParams_End[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_End(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_End_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_End_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_End_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 token.Pos
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_End_doFn
				DoReturnFn MoqScope_starGenType_End_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_End(params MoqScope_starGenType_End_params) string {
	return fmt.Sprintf("End()")
}

func (m *MoqScope_starGenType) ParamsKey_End(params MoqScope_starGenType_End_params, anyParams uint64) MoqScope_starGenType_End_paramsKey {
	m.Scene.T.Helper()
	return MoqScope_starGenType_End_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqScope_starGenType_recorder) Contains(pos token.Pos) *MoqScope_starGenType_Contains_fnRecorder {
	return &MoqScope_starGenType_Contains_fnRecorder{
		Params: MoqScope_starGenType_Contains_params{
			Pos: pos,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_Contains_fnRecorder) Any() *MoqScope_starGenType_Contains_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Contains(r.Params))
		return nil
	}
	return &MoqScope_starGenType_Contains_anyParams{Recorder: r}
}

func (a *MoqScope_starGenType_Contains_anyParams) Pos() *MoqScope_starGenType_Contains_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqScope_starGenType_Contains_fnRecorder) Seq() *MoqScope_starGenType_Contains_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Contains(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_Contains_fnRecorder) NoSeq() *MoqScope_starGenType_Contains_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Contains(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_Contains_fnRecorder) ReturnResults(result1 bool) *MoqScope_starGenType_Contains_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Contains_doFn
		DoReturnFn MoqScope_starGenType_Contains_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_Contains_fnRecorder) AndDo(fn MoqScope_starGenType_Contains_doFn) *MoqScope_starGenType_Contains_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_Contains_fnRecorder) DoReturnResults(fn MoqScope_starGenType_Contains_doReturnFn) *MoqScope_starGenType_Contains_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Contains_doFn
		DoReturnFn MoqScope_starGenType_Contains_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_Contains_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_Contains_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Contains {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_Contains_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_Contains_paramsKey]*MoqScope_starGenType_Contains_results{},
		}
		r.Moq.ResultsByParams_Contains = append(r.Moq.ResultsByParams_Contains, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Contains) {
			copy(r.Moq.ResultsByParams_Contains[insertAt+1:], r.Moq.ResultsByParams_Contains[insertAt:0])
			r.Moq.ResultsByParams_Contains[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Contains(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_Contains_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_Contains_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_Contains_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_Contains_doFn
				DoReturnFn MoqScope_starGenType_Contains_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_Contains(params MoqScope_starGenType_Contains_params) string {
	return fmt.Sprintf("Contains(%#v)", params.Pos)
}

func (m *MoqScope_starGenType) ParamsKey_Contains(params MoqScope_starGenType_Contains_params, anyParams uint64) MoqScope_starGenType_Contains_paramsKey {
	m.Scene.T.Helper()
	var posUsed token.Pos
	var posUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Contains.Pos == moq.ParamIndexByValue {
			posUsed = params.Pos
		} else {
			posUsedHash = hash.DeepHash(params.Pos)
		}
	}
	return MoqScope_starGenType_Contains_paramsKey{
		Params: struct{ Pos token.Pos }{
			Pos: posUsed,
		},
		Hashes: struct{ Pos hash.Hash }{
			Pos: posUsedHash,
		},
	}
}

func (m *MoqScope_starGenType_recorder) Innermost(pos token.Pos) *MoqScope_starGenType_Innermost_fnRecorder {
	return &MoqScope_starGenType_Innermost_fnRecorder{
		Params: MoqScope_starGenType_Innermost_params{
			Pos: pos,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_Innermost_fnRecorder) Any() *MoqScope_starGenType_Innermost_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Innermost(r.Params))
		return nil
	}
	return &MoqScope_starGenType_Innermost_anyParams{Recorder: r}
}

func (a *MoqScope_starGenType_Innermost_anyParams) Pos() *MoqScope_starGenType_Innermost_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqScope_starGenType_Innermost_fnRecorder) Seq() *MoqScope_starGenType_Innermost_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Innermost(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_Innermost_fnRecorder) NoSeq() *MoqScope_starGenType_Innermost_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Innermost(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_Innermost_fnRecorder) ReturnResults(result1 *types.Scope) *MoqScope_starGenType_Innermost_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Scope
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Innermost_doFn
		DoReturnFn MoqScope_starGenType_Innermost_doReturnFn
	}{
		Values: &struct {
			Result1 *types.Scope
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_Innermost_fnRecorder) AndDo(fn MoqScope_starGenType_Innermost_doFn) *MoqScope_starGenType_Innermost_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_Innermost_fnRecorder) DoReturnResults(fn MoqScope_starGenType_Innermost_doReturnFn) *MoqScope_starGenType_Innermost_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Scope
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_Innermost_doFn
		DoReturnFn MoqScope_starGenType_Innermost_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_Innermost_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_Innermost_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Innermost {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_Innermost_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_Innermost_paramsKey]*MoqScope_starGenType_Innermost_results{},
		}
		r.Moq.ResultsByParams_Innermost = append(r.Moq.ResultsByParams_Innermost, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Innermost) {
			copy(r.Moq.ResultsByParams_Innermost[insertAt+1:], r.Moq.ResultsByParams_Innermost[insertAt:0])
			r.Moq.ResultsByParams_Innermost[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Innermost(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_Innermost_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_Innermost_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_Innermost_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.Scope
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_Innermost_doFn
				DoReturnFn MoqScope_starGenType_Innermost_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_Innermost(params MoqScope_starGenType_Innermost_params) string {
	return fmt.Sprintf("Innermost(%#v)", params.Pos)
}

func (m *MoqScope_starGenType) ParamsKey_Innermost(params MoqScope_starGenType_Innermost_params, anyParams uint64) MoqScope_starGenType_Innermost_paramsKey {
	m.Scene.T.Helper()
	var posUsed token.Pos
	var posUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Innermost.Pos == moq.ParamIndexByValue {
			posUsed = params.Pos
		} else {
			posUsedHash = hash.DeepHash(params.Pos)
		}
	}
	return MoqScope_starGenType_Innermost_paramsKey{
		Params: struct{ Pos token.Pos }{
			Pos: posUsed,
		},
		Hashes: struct{ Pos hash.Hash }{
			Pos: posUsedHash,
		},
	}
}

func (m *MoqScope_starGenType_recorder) WriteTo(w io.Writer, n int, recurse bool) *MoqScope_starGenType_WriteTo_fnRecorder {
	return &MoqScope_starGenType_WriteTo_fnRecorder{
		Params: MoqScope_starGenType_WriteTo_params{
			W:       w,
			N:       n,
			Recurse: recurse,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_WriteTo_fnRecorder) Any() *MoqScope_starGenType_WriteTo_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteTo(r.Params))
		return nil
	}
	return &MoqScope_starGenType_WriteTo_anyParams{Recorder: r}
}

func (a *MoqScope_starGenType_WriteTo_anyParams) W() *MoqScope_starGenType_WriteTo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqScope_starGenType_WriteTo_anyParams) N() *MoqScope_starGenType_WriteTo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqScope_starGenType_WriteTo_anyParams) Recurse() *MoqScope_starGenType_WriteTo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqScope_starGenType_WriteTo_fnRecorder) Seq() *MoqScope_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteTo(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_WriteTo_fnRecorder) NoSeq() *MoqScope_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteTo(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_WriteTo_fnRecorder) ReturnResults() *MoqScope_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqScope_starGenType_WriteTo_doFn
		DoReturnFn MoqScope_starGenType_WriteTo_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_WriteTo_fnRecorder) AndDo(fn MoqScope_starGenType_WriteTo_doFn) *MoqScope_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_WriteTo_fnRecorder) DoReturnResults(fn MoqScope_starGenType_WriteTo_doReturnFn) *MoqScope_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqScope_starGenType_WriteTo_doFn
		DoReturnFn MoqScope_starGenType_WriteTo_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_WriteTo_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_WriteTo_resultsByParams
	for n, res := range r.Moq.ResultsByParams_WriteTo {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_WriteTo_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_WriteTo_paramsKey]*MoqScope_starGenType_WriteTo_results{},
		}
		r.Moq.ResultsByParams_WriteTo = append(r.Moq.ResultsByParams_WriteTo, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_WriteTo) {
			copy(r.Moq.ResultsByParams_WriteTo[insertAt+1:], r.Moq.ResultsByParams_WriteTo[insertAt:0])
			r.Moq.ResultsByParams_WriteTo[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_WriteTo(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_WriteTo_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_WriteTo_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_WriteTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqScope_starGenType_WriteTo_doFn
				DoReturnFn MoqScope_starGenType_WriteTo_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_WriteTo(params MoqScope_starGenType_WriteTo_params) string {
	return fmt.Sprintf("WriteTo(%#v, %#v, %#v)", params.W, params.N, params.Recurse)
}

func (m *MoqScope_starGenType) ParamsKey_WriteTo(params MoqScope_starGenType_WriteTo_params, anyParams uint64) MoqScope_starGenType_WriteTo_paramsKey {
	m.Scene.T.Helper()
	var wUsed io.Writer
	var wUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.WriteTo.W == moq.ParamIndexByValue {
			wUsed = params.W
		} else {
			wUsedHash = hash.DeepHash(params.W)
		}
	}
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.WriteTo.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	var recurseUsed bool
	var recurseUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.WriteTo.Recurse == moq.ParamIndexByValue {
			recurseUsed = params.Recurse
		} else {
			recurseUsedHash = hash.DeepHash(params.Recurse)
		}
	}
	return MoqScope_starGenType_WriteTo_paramsKey{
		Params: struct {
			W       io.Writer
			N       int
			Recurse bool
		}{
			W:       wUsed,
			N:       nUsed,
			Recurse: recurseUsed,
		},
		Hashes: struct {
			W       hash.Hash
			N       hash.Hash
			Recurse hash.Hash
		}{
			W:       wUsedHash,
			N:       nUsedHash,
			Recurse: recurseUsedHash,
		},
	}
}

func (m *MoqScope_starGenType_recorder) String() *MoqScope_starGenType_String_fnRecorder {
	return &MoqScope_starGenType_String_fnRecorder{
		Params:   MoqScope_starGenType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqScope_starGenType_String_fnRecorder) Any() *MoqScope_starGenType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqScope_starGenType_String_anyParams{Recorder: r}
}

func (r *MoqScope_starGenType_String_fnRecorder) Seq() *MoqScope_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqScope_starGenType_String_fnRecorder) NoSeq() *MoqScope_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqScope_starGenType_String_fnRecorder) ReturnResults(result1 string) *MoqScope_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_String_doFn
		DoReturnFn MoqScope_starGenType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqScope_starGenType_String_fnRecorder) AndDo(fn MoqScope_starGenType_String_doFn) *MoqScope_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqScope_starGenType_String_fnRecorder) DoReturnResults(fn MoqScope_starGenType_String_doReturnFn) *MoqScope_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqScope_starGenType_String_doFn
		DoReturnFn MoqScope_starGenType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqScope_starGenType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqScope_starGenType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqScope_starGenType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqScope_starGenType_String_paramsKey]*MoqScope_starGenType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqScope_starGenType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqScope_starGenType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqScope_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqScope_starGenType_String_doFn
				DoReturnFn MoqScope_starGenType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqScope_starGenType) PrettyParams_String(params MoqScope_starGenType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqScope_starGenType) ParamsKey_String(params MoqScope_starGenType_String_params, anyParams uint64) MoqScope_starGenType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqScope_starGenType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqScope_starGenType) Reset() {
	m.ResultsByParams_Parent = nil
	m.ResultsByParams_Len = nil
	m.ResultsByParams_Names = nil
	m.ResultsByParams_NumChildren = nil
	m.ResultsByParams_Child = nil
	m.ResultsByParams_Lookup = nil
	m.ResultsByParams_LookupParent = nil
	m.ResultsByParams_Insert = nil
	m.ResultsByParams_Pos = nil
	m.ResultsByParams_End = nil
	m.ResultsByParams_Contains = nil
	m.ResultsByParams_Innermost = nil
	m.ResultsByParams_WriteTo = nil
	m.ResultsByParams_String = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqScope_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Parent {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Parent(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Len {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Len(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Names {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Names(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_NumChildren {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumChildren(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Child {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Child(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Lookup {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Lookup(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LookupParent {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LookupParent(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Insert {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Insert(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Pos {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Pos(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_End {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_End(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Contains {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Contains(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Innermost {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Innermost(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_WriteTo {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_WriteTo(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
}
