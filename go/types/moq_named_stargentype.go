// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package types

import (
	"fmt"
	"go/types"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that types.Named_starGenType is mocked
// completely
var _ Named_starGenType = (*MoqNamed_starGenType_mock)(nil)

// Named_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Named_starGenType interface {
	Obj() *types.TypeName
	Origin() *types.Named
	TypeParams() *types.TypeParamList
	SetTypeParams(tparams []*types.TypeParam)
	TypeArgs() *types.TypeList
	NumMethods() int
	Method(i int) *types.Func
	SetUnderlying(underlying types.Type)
	AddMethod(m *types.Func)
	Underlying() types.Type
	String() string
}

// MoqNamed_starGenType holds the state of a moq of the Named_starGenType type
type MoqNamed_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqNamed_starGenType_mock

	ResultsByParams_Obj           []MoqNamed_starGenType_Obj_resultsByParams
	ResultsByParams_Origin        []MoqNamed_starGenType_Origin_resultsByParams
	ResultsByParams_TypeParams    []MoqNamed_starGenType_TypeParams_resultsByParams
	ResultsByParams_SetTypeParams []MoqNamed_starGenType_SetTypeParams_resultsByParams
	ResultsByParams_TypeArgs      []MoqNamed_starGenType_TypeArgs_resultsByParams
	ResultsByParams_NumMethods    []MoqNamed_starGenType_NumMethods_resultsByParams
	ResultsByParams_Method        []MoqNamed_starGenType_Method_resultsByParams
	ResultsByParams_SetUnderlying []MoqNamed_starGenType_SetUnderlying_resultsByParams
	ResultsByParams_AddMethod     []MoqNamed_starGenType_AddMethod_resultsByParams
	ResultsByParams_Underlying    []MoqNamed_starGenType_Underlying_resultsByParams
	ResultsByParams_String        []MoqNamed_starGenType_String_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Obj           struct{}
			Origin        struct{}
			TypeParams    struct{}
			SetTypeParams struct {
				Tparams moq.ParamIndexing
			}
			TypeArgs   struct{}
			NumMethods struct{}
			Method     struct {
				Param1 moq.ParamIndexing
			}
			SetUnderlying struct {
				Underlying moq.ParamIndexing
			}
			AddMethod struct {
				Param1 moq.ParamIndexing
			}
			Underlying struct{}
			String     struct{}
		}
	}
}

// MoqNamed_starGenType_mock isolates the mock interface of the
// Named_starGenType type
type MoqNamed_starGenType_mock struct {
	Moq *MoqNamed_starGenType
}

// MoqNamed_starGenType_recorder isolates the recorder interface of the
// Named_starGenType type
type MoqNamed_starGenType_recorder struct {
	Moq *MoqNamed_starGenType
}

// MoqNamed_starGenType_Obj_params holds the params of the Named_starGenType
// type
type MoqNamed_starGenType_Obj_params struct{}

// MoqNamed_starGenType_Obj_paramsKey holds the map key params of the
// Named_starGenType type
type MoqNamed_starGenType_Obj_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqNamed_starGenType_Obj_resultsByParams contains the results for a given
// set of parameters for the Named_starGenType type
type MoqNamed_starGenType_Obj_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqNamed_starGenType_Obj_paramsKey]*MoqNamed_starGenType_Obj_results
}

// MoqNamed_starGenType_Obj_doFn defines the type of function needed when
// calling AndDo for the Named_starGenType type
type MoqNamed_starGenType_Obj_doFn func()

// MoqNamed_starGenType_Obj_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Named_starGenType type
type MoqNamed_starGenType_Obj_doReturnFn func() *types.TypeName

// MoqNamed_starGenType_Obj_results holds the results of the Named_starGenType
// type
type MoqNamed_starGenType_Obj_results struct {
	Params  MoqNamed_starGenType_Obj_params
	Results []struct {
		Values *struct {
			Result1 *types.TypeName
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Obj_doFn
		DoReturnFn MoqNamed_starGenType_Obj_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqNamed_starGenType_Obj_fnRecorder routes recorded function calls to the
// MoqNamed_starGenType moq
type MoqNamed_starGenType_Obj_fnRecorder struct {
	Params    MoqNamed_starGenType_Obj_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqNamed_starGenType_Obj_results
	Moq       *MoqNamed_starGenType
}

// MoqNamed_starGenType_Obj_anyParams isolates the any params functions of the
// Named_starGenType type
type MoqNamed_starGenType_Obj_anyParams struct {
	Recorder *MoqNamed_starGenType_Obj_fnRecorder
}

// MoqNamed_starGenType_Origin_params holds the params of the Named_starGenType
// type
type MoqNamed_starGenType_Origin_params struct{}

// MoqNamed_starGenType_Origin_paramsKey holds the map key params of the
// Named_starGenType type
type MoqNamed_starGenType_Origin_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqNamed_starGenType_Origin_resultsByParams contains the results for a given
// set of parameters for the Named_starGenType type
type MoqNamed_starGenType_Origin_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqNamed_starGenType_Origin_paramsKey]*MoqNamed_starGenType_Origin_results
}

// MoqNamed_starGenType_Origin_doFn defines the type of function needed when
// calling AndDo for the Named_starGenType type
type MoqNamed_starGenType_Origin_doFn func()

// MoqNamed_starGenType_Origin_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Named_starGenType type
type MoqNamed_starGenType_Origin_doReturnFn func() *types.Named

// MoqNamed_starGenType_Origin_results holds the results of the
// Named_starGenType type
type MoqNamed_starGenType_Origin_results struct {
	Params  MoqNamed_starGenType_Origin_params
	Results []struct {
		Values *struct {
			Result1 *types.Named
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Origin_doFn
		DoReturnFn MoqNamed_starGenType_Origin_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqNamed_starGenType_Origin_fnRecorder routes recorded function calls to the
// MoqNamed_starGenType moq
type MoqNamed_starGenType_Origin_fnRecorder struct {
	Params    MoqNamed_starGenType_Origin_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqNamed_starGenType_Origin_results
	Moq       *MoqNamed_starGenType
}

// MoqNamed_starGenType_Origin_anyParams isolates the any params functions of
// the Named_starGenType type
type MoqNamed_starGenType_Origin_anyParams struct {
	Recorder *MoqNamed_starGenType_Origin_fnRecorder
}

// MoqNamed_starGenType_TypeParams_params holds the params of the
// Named_starGenType type
type MoqNamed_starGenType_TypeParams_params struct{}

// MoqNamed_starGenType_TypeParams_paramsKey holds the map key params of the
// Named_starGenType type
type MoqNamed_starGenType_TypeParams_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqNamed_starGenType_TypeParams_resultsByParams contains the results for a
// given set of parameters for the Named_starGenType type
type MoqNamed_starGenType_TypeParams_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqNamed_starGenType_TypeParams_paramsKey]*MoqNamed_starGenType_TypeParams_results
}

// MoqNamed_starGenType_TypeParams_doFn defines the type of function needed
// when calling AndDo for the Named_starGenType type
type MoqNamed_starGenType_TypeParams_doFn func()

// MoqNamed_starGenType_TypeParams_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Named_starGenType type
type MoqNamed_starGenType_TypeParams_doReturnFn func() *types.TypeParamList

// MoqNamed_starGenType_TypeParams_results holds the results of the
// Named_starGenType type
type MoqNamed_starGenType_TypeParams_results struct {
	Params  MoqNamed_starGenType_TypeParams_params
	Results []struct {
		Values *struct {
			Result1 *types.TypeParamList
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_TypeParams_doFn
		DoReturnFn MoqNamed_starGenType_TypeParams_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqNamed_starGenType_TypeParams_fnRecorder routes recorded function calls to
// the MoqNamed_starGenType moq
type MoqNamed_starGenType_TypeParams_fnRecorder struct {
	Params    MoqNamed_starGenType_TypeParams_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqNamed_starGenType_TypeParams_results
	Moq       *MoqNamed_starGenType
}

// MoqNamed_starGenType_TypeParams_anyParams isolates the any params functions
// of the Named_starGenType type
type MoqNamed_starGenType_TypeParams_anyParams struct {
	Recorder *MoqNamed_starGenType_TypeParams_fnRecorder
}

// MoqNamed_starGenType_SetTypeParams_params holds the params of the
// Named_starGenType type
type MoqNamed_starGenType_SetTypeParams_params struct{ Tparams []*types.TypeParam }

// MoqNamed_starGenType_SetTypeParams_paramsKey holds the map key params of the
// Named_starGenType type
type MoqNamed_starGenType_SetTypeParams_paramsKey struct {
	Params struct{}
	Hashes struct{ Tparams hash.Hash }
}

// MoqNamed_starGenType_SetTypeParams_resultsByParams contains the results for
// a given set of parameters for the Named_starGenType type
type MoqNamed_starGenType_SetTypeParams_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqNamed_starGenType_SetTypeParams_paramsKey]*MoqNamed_starGenType_SetTypeParams_results
}

// MoqNamed_starGenType_SetTypeParams_doFn defines the type of function needed
// when calling AndDo for the Named_starGenType type
type MoqNamed_starGenType_SetTypeParams_doFn func(tparams []*types.TypeParam)

// MoqNamed_starGenType_SetTypeParams_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Named_starGenType type
type MoqNamed_starGenType_SetTypeParams_doReturnFn func(tparams []*types.TypeParam)

// MoqNamed_starGenType_SetTypeParams_results holds the results of the
// Named_starGenType type
type MoqNamed_starGenType_SetTypeParams_results struct {
	Params  MoqNamed_starGenType_SetTypeParams_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_SetTypeParams_doFn
		DoReturnFn MoqNamed_starGenType_SetTypeParams_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqNamed_starGenType_SetTypeParams_fnRecorder routes recorded function calls
// to the MoqNamed_starGenType moq
type MoqNamed_starGenType_SetTypeParams_fnRecorder struct {
	Params    MoqNamed_starGenType_SetTypeParams_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqNamed_starGenType_SetTypeParams_results
	Moq       *MoqNamed_starGenType
}

// MoqNamed_starGenType_SetTypeParams_anyParams isolates the any params
// functions of the Named_starGenType type
type MoqNamed_starGenType_SetTypeParams_anyParams struct {
	Recorder *MoqNamed_starGenType_SetTypeParams_fnRecorder
}

// MoqNamed_starGenType_TypeArgs_params holds the params of the
// Named_starGenType type
type MoqNamed_starGenType_TypeArgs_params struct{}

// MoqNamed_starGenType_TypeArgs_paramsKey holds the map key params of the
// Named_starGenType type
type MoqNamed_starGenType_TypeArgs_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqNamed_starGenType_TypeArgs_resultsByParams contains the results for a
// given set of parameters for the Named_starGenType type
type MoqNamed_starGenType_TypeArgs_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqNamed_starGenType_TypeArgs_paramsKey]*MoqNamed_starGenType_TypeArgs_results
}

// MoqNamed_starGenType_TypeArgs_doFn defines the type of function needed when
// calling AndDo for the Named_starGenType type
type MoqNamed_starGenType_TypeArgs_doFn func()

// MoqNamed_starGenType_TypeArgs_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Named_starGenType type
type MoqNamed_starGenType_TypeArgs_doReturnFn func() *types.TypeList

// MoqNamed_starGenType_TypeArgs_results holds the results of the
// Named_starGenType type
type MoqNamed_starGenType_TypeArgs_results struct {
	Params  MoqNamed_starGenType_TypeArgs_params
	Results []struct {
		Values *struct {
			Result1 *types.TypeList
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_TypeArgs_doFn
		DoReturnFn MoqNamed_starGenType_TypeArgs_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqNamed_starGenType_TypeArgs_fnRecorder routes recorded function calls to
// the MoqNamed_starGenType moq
type MoqNamed_starGenType_TypeArgs_fnRecorder struct {
	Params    MoqNamed_starGenType_TypeArgs_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqNamed_starGenType_TypeArgs_results
	Moq       *MoqNamed_starGenType
}

// MoqNamed_starGenType_TypeArgs_anyParams isolates the any params functions of
// the Named_starGenType type
type MoqNamed_starGenType_TypeArgs_anyParams struct {
	Recorder *MoqNamed_starGenType_TypeArgs_fnRecorder
}

// MoqNamed_starGenType_NumMethods_params holds the params of the
// Named_starGenType type
type MoqNamed_starGenType_NumMethods_params struct{}

// MoqNamed_starGenType_NumMethods_paramsKey holds the map key params of the
// Named_starGenType type
type MoqNamed_starGenType_NumMethods_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqNamed_starGenType_NumMethods_resultsByParams contains the results for a
// given set of parameters for the Named_starGenType type
type MoqNamed_starGenType_NumMethods_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqNamed_starGenType_NumMethods_paramsKey]*MoqNamed_starGenType_NumMethods_results
}

// MoqNamed_starGenType_NumMethods_doFn defines the type of function needed
// when calling AndDo for the Named_starGenType type
type MoqNamed_starGenType_NumMethods_doFn func()

// MoqNamed_starGenType_NumMethods_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Named_starGenType type
type MoqNamed_starGenType_NumMethods_doReturnFn func() int

// MoqNamed_starGenType_NumMethods_results holds the results of the
// Named_starGenType type
type MoqNamed_starGenType_NumMethods_results struct {
	Params  MoqNamed_starGenType_NumMethods_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_NumMethods_doFn
		DoReturnFn MoqNamed_starGenType_NumMethods_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqNamed_starGenType_NumMethods_fnRecorder routes recorded function calls to
// the MoqNamed_starGenType moq
type MoqNamed_starGenType_NumMethods_fnRecorder struct {
	Params    MoqNamed_starGenType_NumMethods_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqNamed_starGenType_NumMethods_results
	Moq       *MoqNamed_starGenType
}

// MoqNamed_starGenType_NumMethods_anyParams isolates the any params functions
// of the Named_starGenType type
type MoqNamed_starGenType_NumMethods_anyParams struct {
	Recorder *MoqNamed_starGenType_NumMethods_fnRecorder
}

// MoqNamed_starGenType_Method_params holds the params of the Named_starGenType
// type
type MoqNamed_starGenType_Method_params struct{ Param1 int }

// MoqNamed_starGenType_Method_paramsKey holds the map key params of the
// Named_starGenType type
type MoqNamed_starGenType_Method_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqNamed_starGenType_Method_resultsByParams contains the results for a given
// set of parameters for the Named_starGenType type
type MoqNamed_starGenType_Method_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqNamed_starGenType_Method_paramsKey]*MoqNamed_starGenType_Method_results
}

// MoqNamed_starGenType_Method_doFn defines the type of function needed when
// calling AndDo for the Named_starGenType type
type MoqNamed_starGenType_Method_doFn func(i int)

// MoqNamed_starGenType_Method_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Named_starGenType type
type MoqNamed_starGenType_Method_doReturnFn func(i int) *types.Func

// MoqNamed_starGenType_Method_results holds the results of the
// Named_starGenType type
type MoqNamed_starGenType_Method_results struct {
	Params  MoqNamed_starGenType_Method_params
	Results []struct {
		Values *struct {
			Result1 *types.Func
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Method_doFn
		DoReturnFn MoqNamed_starGenType_Method_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqNamed_starGenType_Method_fnRecorder routes recorded function calls to the
// MoqNamed_starGenType moq
type MoqNamed_starGenType_Method_fnRecorder struct {
	Params    MoqNamed_starGenType_Method_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqNamed_starGenType_Method_results
	Moq       *MoqNamed_starGenType
}

// MoqNamed_starGenType_Method_anyParams isolates the any params functions of
// the Named_starGenType type
type MoqNamed_starGenType_Method_anyParams struct {
	Recorder *MoqNamed_starGenType_Method_fnRecorder
}

// MoqNamed_starGenType_SetUnderlying_params holds the params of the
// Named_starGenType type
type MoqNamed_starGenType_SetUnderlying_params struct{ Underlying types.Type }

// MoqNamed_starGenType_SetUnderlying_paramsKey holds the map key params of the
// Named_starGenType type
type MoqNamed_starGenType_SetUnderlying_paramsKey struct {
	Params struct{ Underlying types.Type }
	Hashes struct{ Underlying hash.Hash }
}

// MoqNamed_starGenType_SetUnderlying_resultsByParams contains the results for
// a given set of parameters for the Named_starGenType type
type MoqNamed_starGenType_SetUnderlying_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqNamed_starGenType_SetUnderlying_paramsKey]*MoqNamed_starGenType_SetUnderlying_results
}

// MoqNamed_starGenType_SetUnderlying_doFn defines the type of function needed
// when calling AndDo for the Named_starGenType type
type MoqNamed_starGenType_SetUnderlying_doFn func(underlying types.Type)

// MoqNamed_starGenType_SetUnderlying_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Named_starGenType type
type MoqNamed_starGenType_SetUnderlying_doReturnFn func(underlying types.Type)

// MoqNamed_starGenType_SetUnderlying_results holds the results of the
// Named_starGenType type
type MoqNamed_starGenType_SetUnderlying_results struct {
	Params  MoqNamed_starGenType_SetUnderlying_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_SetUnderlying_doFn
		DoReturnFn MoqNamed_starGenType_SetUnderlying_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqNamed_starGenType_SetUnderlying_fnRecorder routes recorded function calls
// to the MoqNamed_starGenType moq
type MoqNamed_starGenType_SetUnderlying_fnRecorder struct {
	Params    MoqNamed_starGenType_SetUnderlying_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqNamed_starGenType_SetUnderlying_results
	Moq       *MoqNamed_starGenType
}

// MoqNamed_starGenType_SetUnderlying_anyParams isolates the any params
// functions of the Named_starGenType type
type MoqNamed_starGenType_SetUnderlying_anyParams struct {
	Recorder *MoqNamed_starGenType_SetUnderlying_fnRecorder
}

// MoqNamed_starGenType_AddMethod_params holds the params of the
// Named_starGenType type
type MoqNamed_starGenType_AddMethod_params struct{ Param1 *types.Func }

// MoqNamed_starGenType_AddMethod_paramsKey holds the map key params of the
// Named_starGenType type
type MoqNamed_starGenType_AddMethod_paramsKey struct {
	Params struct{ Param1 *types.Func }
	Hashes struct{ Param1 hash.Hash }
}

// MoqNamed_starGenType_AddMethod_resultsByParams contains the results for a
// given set of parameters for the Named_starGenType type
type MoqNamed_starGenType_AddMethod_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqNamed_starGenType_AddMethod_paramsKey]*MoqNamed_starGenType_AddMethod_results
}

// MoqNamed_starGenType_AddMethod_doFn defines the type of function needed when
// calling AndDo for the Named_starGenType type
type MoqNamed_starGenType_AddMethod_doFn func(m *types.Func)

// MoqNamed_starGenType_AddMethod_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Named_starGenType type
type MoqNamed_starGenType_AddMethod_doReturnFn func(m *types.Func)

// MoqNamed_starGenType_AddMethod_results holds the results of the
// Named_starGenType type
type MoqNamed_starGenType_AddMethod_results struct {
	Params  MoqNamed_starGenType_AddMethod_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_AddMethod_doFn
		DoReturnFn MoqNamed_starGenType_AddMethod_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqNamed_starGenType_AddMethod_fnRecorder routes recorded function calls to
// the MoqNamed_starGenType moq
type MoqNamed_starGenType_AddMethod_fnRecorder struct {
	Params    MoqNamed_starGenType_AddMethod_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqNamed_starGenType_AddMethod_results
	Moq       *MoqNamed_starGenType
}

// MoqNamed_starGenType_AddMethod_anyParams isolates the any params functions
// of the Named_starGenType type
type MoqNamed_starGenType_AddMethod_anyParams struct {
	Recorder *MoqNamed_starGenType_AddMethod_fnRecorder
}

// MoqNamed_starGenType_Underlying_params holds the params of the
// Named_starGenType type
type MoqNamed_starGenType_Underlying_params struct{}

// MoqNamed_starGenType_Underlying_paramsKey holds the map key params of the
// Named_starGenType type
type MoqNamed_starGenType_Underlying_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqNamed_starGenType_Underlying_resultsByParams contains the results for a
// given set of parameters for the Named_starGenType type
type MoqNamed_starGenType_Underlying_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqNamed_starGenType_Underlying_paramsKey]*MoqNamed_starGenType_Underlying_results
}

// MoqNamed_starGenType_Underlying_doFn defines the type of function needed
// when calling AndDo for the Named_starGenType type
type MoqNamed_starGenType_Underlying_doFn func()

// MoqNamed_starGenType_Underlying_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Named_starGenType type
type MoqNamed_starGenType_Underlying_doReturnFn func() types.Type

// MoqNamed_starGenType_Underlying_results holds the results of the
// Named_starGenType type
type MoqNamed_starGenType_Underlying_results struct {
	Params  MoqNamed_starGenType_Underlying_params
	Results []struct {
		Values *struct {
			Result1 types.Type
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Underlying_doFn
		DoReturnFn MoqNamed_starGenType_Underlying_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqNamed_starGenType_Underlying_fnRecorder routes recorded function calls to
// the MoqNamed_starGenType moq
type MoqNamed_starGenType_Underlying_fnRecorder struct {
	Params    MoqNamed_starGenType_Underlying_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqNamed_starGenType_Underlying_results
	Moq       *MoqNamed_starGenType
}

// MoqNamed_starGenType_Underlying_anyParams isolates the any params functions
// of the Named_starGenType type
type MoqNamed_starGenType_Underlying_anyParams struct {
	Recorder *MoqNamed_starGenType_Underlying_fnRecorder
}

// MoqNamed_starGenType_String_params holds the params of the Named_starGenType
// type
type MoqNamed_starGenType_String_params struct{}

// MoqNamed_starGenType_String_paramsKey holds the map key params of the
// Named_starGenType type
type MoqNamed_starGenType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqNamed_starGenType_String_resultsByParams contains the results for a given
// set of parameters for the Named_starGenType type
type MoqNamed_starGenType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqNamed_starGenType_String_paramsKey]*MoqNamed_starGenType_String_results
}

// MoqNamed_starGenType_String_doFn defines the type of function needed when
// calling AndDo for the Named_starGenType type
type MoqNamed_starGenType_String_doFn func()

// MoqNamed_starGenType_String_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Named_starGenType type
type MoqNamed_starGenType_String_doReturnFn func() string

// MoqNamed_starGenType_String_results holds the results of the
// Named_starGenType type
type MoqNamed_starGenType_String_results struct {
	Params  MoqNamed_starGenType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_String_doFn
		DoReturnFn MoqNamed_starGenType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqNamed_starGenType_String_fnRecorder routes recorded function calls to the
// MoqNamed_starGenType moq
type MoqNamed_starGenType_String_fnRecorder struct {
	Params    MoqNamed_starGenType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqNamed_starGenType_String_results
	Moq       *MoqNamed_starGenType
}

// MoqNamed_starGenType_String_anyParams isolates the any params functions of
// the Named_starGenType type
type MoqNamed_starGenType_String_anyParams struct {
	Recorder *MoqNamed_starGenType_String_fnRecorder
}

// NewMoqNamed_starGenType creates a new moq of the Named_starGenType type
func NewMoqNamed_starGenType(scene *moq.Scene, config *moq.Config) *MoqNamed_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqNamed_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqNamed_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Obj           struct{}
				Origin        struct{}
				TypeParams    struct{}
				SetTypeParams struct {
					Tparams moq.ParamIndexing
				}
				TypeArgs   struct{}
				NumMethods struct{}
				Method     struct {
					Param1 moq.ParamIndexing
				}
				SetUnderlying struct {
					Underlying moq.ParamIndexing
				}
				AddMethod struct {
					Param1 moq.ParamIndexing
				}
				Underlying struct{}
				String     struct{}
			}
		}{ParameterIndexing: struct {
			Obj           struct{}
			Origin        struct{}
			TypeParams    struct{}
			SetTypeParams struct {
				Tparams moq.ParamIndexing
			}
			TypeArgs   struct{}
			NumMethods struct{}
			Method     struct {
				Param1 moq.ParamIndexing
			}
			SetUnderlying struct {
				Underlying moq.ParamIndexing
			}
			AddMethod struct {
				Param1 moq.ParamIndexing
			}
			Underlying struct{}
			String     struct{}
		}{
			Obj:        struct{}{},
			Origin:     struct{}{},
			TypeParams: struct{}{},
			SetTypeParams: struct {
				Tparams moq.ParamIndexing
			}{
				Tparams: moq.ParamIndexByHash,
			},
			TypeArgs:   struct{}{},
			NumMethods: struct{}{},
			Method: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			SetUnderlying: struct {
				Underlying moq.ParamIndexing
			}{
				Underlying: moq.ParamIndexByHash,
			},
			AddMethod: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByHash,
			},
			Underlying: struct{}{},
			String:     struct{}{},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Named_starGenType type
func (m *MoqNamed_starGenType) Mock() *MoqNamed_starGenType_mock { return m.Moq }

func (m *MoqNamed_starGenType_mock) Obj() (result1 *types.TypeName) {
	m.Moq.Scene.T.Helper()
	params := MoqNamed_starGenType_Obj_params{}
	var results *MoqNamed_starGenType_Obj_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Obj {
		paramsKey := m.Moq.ParamsKey_Obj(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Obj(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Obj(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Obj(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqNamed_starGenType_mock) Origin() (result1 *types.Named) {
	m.Moq.Scene.T.Helper()
	params := MoqNamed_starGenType_Origin_params{}
	var results *MoqNamed_starGenType_Origin_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Origin {
		paramsKey := m.Moq.ParamsKey_Origin(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Origin(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Origin(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Origin(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqNamed_starGenType_mock) TypeParams() (result1 *types.TypeParamList) {
	m.Moq.Scene.T.Helper()
	params := MoqNamed_starGenType_TypeParams_params{}
	var results *MoqNamed_starGenType_TypeParams_results
	for _, resultsByParams := range m.Moq.ResultsByParams_TypeParams {
		paramsKey := m.Moq.ParamsKey_TypeParams(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_TypeParams(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_TypeParams(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_TypeParams(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqNamed_starGenType_mock) SetTypeParams(tparams []*types.TypeParam) {
	m.Moq.Scene.T.Helper()
	params := MoqNamed_starGenType_SetTypeParams_params{
		Tparams: tparams,
	}
	var results *MoqNamed_starGenType_SetTypeParams_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetTypeParams {
		paramsKey := m.Moq.ParamsKey_SetTypeParams(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetTypeParams(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetTypeParams(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetTypeParams(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(tparams)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(tparams)
	}
	return
}

func (m *MoqNamed_starGenType_mock) TypeArgs() (result1 *types.TypeList) {
	m.Moq.Scene.T.Helper()
	params := MoqNamed_starGenType_TypeArgs_params{}
	var results *MoqNamed_starGenType_TypeArgs_results
	for _, resultsByParams := range m.Moq.ResultsByParams_TypeArgs {
		paramsKey := m.Moq.ParamsKey_TypeArgs(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_TypeArgs(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_TypeArgs(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_TypeArgs(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqNamed_starGenType_mock) NumMethods() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqNamed_starGenType_NumMethods_params{}
	var results *MoqNamed_starGenType_NumMethods_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumMethods {
		paramsKey := m.Moq.ParamsKey_NumMethods(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumMethods(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumMethods(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumMethods(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqNamed_starGenType_mock) Method(param1 int) (result1 *types.Func) {
	m.Moq.Scene.T.Helper()
	params := MoqNamed_starGenType_Method_params{
		Param1: param1,
	}
	var results *MoqNamed_starGenType_Method_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Method {
		paramsKey := m.Moq.ParamsKey_Method(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Method(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Method(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Method(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqNamed_starGenType_mock) SetUnderlying(underlying types.Type) {
	m.Moq.Scene.T.Helper()
	params := MoqNamed_starGenType_SetUnderlying_params{
		Underlying: underlying,
	}
	var results *MoqNamed_starGenType_SetUnderlying_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetUnderlying {
		paramsKey := m.Moq.ParamsKey_SetUnderlying(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetUnderlying(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetUnderlying(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetUnderlying(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(underlying)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(underlying)
	}
	return
}

func (m *MoqNamed_starGenType_mock) AddMethod(param1 *types.Func) {
	m.Moq.Scene.T.Helper()
	params := MoqNamed_starGenType_AddMethod_params{
		Param1: param1,
	}
	var results *MoqNamed_starGenType_AddMethod_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AddMethod {
		paramsKey := m.Moq.ParamsKey_AddMethod(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AddMethod(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AddMethod(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AddMethod(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(param1)
	}
	return
}

func (m *MoqNamed_starGenType_mock) Underlying() (result1 types.Type) {
	m.Moq.Scene.T.Helper()
	params := MoqNamed_starGenType_Underlying_params{}
	var results *MoqNamed_starGenType_Underlying_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Underlying {
		paramsKey := m.Moq.ParamsKey_Underlying(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Underlying(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Underlying(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Underlying(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqNamed_starGenType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqNamed_starGenType_String_params{}
	var results *MoqNamed_starGenType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

// OnCall returns the recorder implementation of the Named_starGenType type
func (m *MoqNamed_starGenType) OnCall() *MoqNamed_starGenType_recorder {
	return &MoqNamed_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqNamed_starGenType_recorder) Obj() *MoqNamed_starGenType_Obj_fnRecorder {
	return &MoqNamed_starGenType_Obj_fnRecorder{
		Params:   MoqNamed_starGenType_Obj_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqNamed_starGenType_Obj_fnRecorder) Any() *MoqNamed_starGenType_Obj_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Obj(r.Params))
		return nil
	}
	return &MoqNamed_starGenType_Obj_anyParams{Recorder: r}
}

func (r *MoqNamed_starGenType_Obj_fnRecorder) Seq() *MoqNamed_starGenType_Obj_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Obj(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqNamed_starGenType_Obj_fnRecorder) NoSeq() *MoqNamed_starGenType_Obj_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Obj(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqNamed_starGenType_Obj_fnRecorder) ReturnResults(result1 *types.TypeName) *MoqNamed_starGenType_Obj_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.TypeName
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Obj_doFn
		DoReturnFn MoqNamed_starGenType_Obj_doReturnFn
	}{
		Values: &struct {
			Result1 *types.TypeName
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqNamed_starGenType_Obj_fnRecorder) AndDo(fn MoqNamed_starGenType_Obj_doFn) *MoqNamed_starGenType_Obj_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqNamed_starGenType_Obj_fnRecorder) DoReturnResults(fn MoqNamed_starGenType_Obj_doReturnFn) *MoqNamed_starGenType_Obj_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.TypeName
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Obj_doFn
		DoReturnFn MoqNamed_starGenType_Obj_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqNamed_starGenType_Obj_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqNamed_starGenType_Obj_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Obj {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqNamed_starGenType_Obj_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqNamed_starGenType_Obj_paramsKey]*MoqNamed_starGenType_Obj_results{},
		}
		r.Moq.ResultsByParams_Obj = append(r.Moq.ResultsByParams_Obj, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Obj) {
			copy(r.Moq.ResultsByParams_Obj[insertAt+1:], r.Moq.ResultsByParams_Obj[insertAt:0])
			r.Moq.ResultsByParams_Obj[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Obj(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqNamed_starGenType_Obj_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqNamed_starGenType_Obj_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqNamed_starGenType_Obj_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.TypeName
				}
				Sequence   uint32
				DoFn       MoqNamed_starGenType_Obj_doFn
				DoReturnFn MoqNamed_starGenType_Obj_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqNamed_starGenType) PrettyParams_Obj(params MoqNamed_starGenType_Obj_params) string {
	return fmt.Sprintf("Obj()")
}

func (m *MoqNamed_starGenType) ParamsKey_Obj(params MoqNamed_starGenType_Obj_params, anyParams uint64) MoqNamed_starGenType_Obj_paramsKey {
	m.Scene.T.Helper()
	return MoqNamed_starGenType_Obj_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqNamed_starGenType_recorder) Origin() *MoqNamed_starGenType_Origin_fnRecorder {
	return &MoqNamed_starGenType_Origin_fnRecorder{
		Params:   MoqNamed_starGenType_Origin_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqNamed_starGenType_Origin_fnRecorder) Any() *MoqNamed_starGenType_Origin_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Origin(r.Params))
		return nil
	}
	return &MoqNamed_starGenType_Origin_anyParams{Recorder: r}
}

func (r *MoqNamed_starGenType_Origin_fnRecorder) Seq() *MoqNamed_starGenType_Origin_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Origin(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqNamed_starGenType_Origin_fnRecorder) NoSeq() *MoqNamed_starGenType_Origin_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Origin(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqNamed_starGenType_Origin_fnRecorder) ReturnResults(result1 *types.Named) *MoqNamed_starGenType_Origin_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Named
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Origin_doFn
		DoReturnFn MoqNamed_starGenType_Origin_doReturnFn
	}{
		Values: &struct {
			Result1 *types.Named
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqNamed_starGenType_Origin_fnRecorder) AndDo(fn MoqNamed_starGenType_Origin_doFn) *MoqNamed_starGenType_Origin_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqNamed_starGenType_Origin_fnRecorder) DoReturnResults(fn MoqNamed_starGenType_Origin_doReturnFn) *MoqNamed_starGenType_Origin_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Named
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Origin_doFn
		DoReturnFn MoqNamed_starGenType_Origin_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqNamed_starGenType_Origin_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqNamed_starGenType_Origin_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Origin {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqNamed_starGenType_Origin_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqNamed_starGenType_Origin_paramsKey]*MoqNamed_starGenType_Origin_results{},
		}
		r.Moq.ResultsByParams_Origin = append(r.Moq.ResultsByParams_Origin, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Origin) {
			copy(r.Moq.ResultsByParams_Origin[insertAt+1:], r.Moq.ResultsByParams_Origin[insertAt:0])
			r.Moq.ResultsByParams_Origin[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Origin(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqNamed_starGenType_Origin_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqNamed_starGenType_Origin_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqNamed_starGenType_Origin_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.Named
				}
				Sequence   uint32
				DoFn       MoqNamed_starGenType_Origin_doFn
				DoReturnFn MoqNamed_starGenType_Origin_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqNamed_starGenType) PrettyParams_Origin(params MoqNamed_starGenType_Origin_params) string {
	return fmt.Sprintf("Origin()")
}

func (m *MoqNamed_starGenType) ParamsKey_Origin(params MoqNamed_starGenType_Origin_params, anyParams uint64) MoqNamed_starGenType_Origin_paramsKey {
	m.Scene.T.Helper()
	return MoqNamed_starGenType_Origin_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqNamed_starGenType_recorder) TypeParams() *MoqNamed_starGenType_TypeParams_fnRecorder {
	return &MoqNamed_starGenType_TypeParams_fnRecorder{
		Params:   MoqNamed_starGenType_TypeParams_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqNamed_starGenType_TypeParams_fnRecorder) Any() *MoqNamed_starGenType_TypeParams_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TypeParams(r.Params))
		return nil
	}
	return &MoqNamed_starGenType_TypeParams_anyParams{Recorder: r}
}

func (r *MoqNamed_starGenType_TypeParams_fnRecorder) Seq() *MoqNamed_starGenType_TypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TypeParams(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqNamed_starGenType_TypeParams_fnRecorder) NoSeq() *MoqNamed_starGenType_TypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TypeParams(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqNamed_starGenType_TypeParams_fnRecorder) ReturnResults(result1 *types.TypeParamList) *MoqNamed_starGenType_TypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.TypeParamList
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_TypeParams_doFn
		DoReturnFn MoqNamed_starGenType_TypeParams_doReturnFn
	}{
		Values: &struct {
			Result1 *types.TypeParamList
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqNamed_starGenType_TypeParams_fnRecorder) AndDo(fn MoqNamed_starGenType_TypeParams_doFn) *MoqNamed_starGenType_TypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqNamed_starGenType_TypeParams_fnRecorder) DoReturnResults(fn MoqNamed_starGenType_TypeParams_doReturnFn) *MoqNamed_starGenType_TypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.TypeParamList
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_TypeParams_doFn
		DoReturnFn MoqNamed_starGenType_TypeParams_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqNamed_starGenType_TypeParams_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqNamed_starGenType_TypeParams_resultsByParams
	for n, res := range r.Moq.ResultsByParams_TypeParams {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqNamed_starGenType_TypeParams_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqNamed_starGenType_TypeParams_paramsKey]*MoqNamed_starGenType_TypeParams_results{},
		}
		r.Moq.ResultsByParams_TypeParams = append(r.Moq.ResultsByParams_TypeParams, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_TypeParams) {
			copy(r.Moq.ResultsByParams_TypeParams[insertAt+1:], r.Moq.ResultsByParams_TypeParams[insertAt:0])
			r.Moq.ResultsByParams_TypeParams[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_TypeParams(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqNamed_starGenType_TypeParams_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqNamed_starGenType_TypeParams_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqNamed_starGenType_TypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.TypeParamList
				}
				Sequence   uint32
				DoFn       MoqNamed_starGenType_TypeParams_doFn
				DoReturnFn MoqNamed_starGenType_TypeParams_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqNamed_starGenType) PrettyParams_TypeParams(params MoqNamed_starGenType_TypeParams_params) string {
	return fmt.Sprintf("TypeParams()")
}

func (m *MoqNamed_starGenType) ParamsKey_TypeParams(params MoqNamed_starGenType_TypeParams_params, anyParams uint64) MoqNamed_starGenType_TypeParams_paramsKey {
	m.Scene.T.Helper()
	return MoqNamed_starGenType_TypeParams_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqNamed_starGenType_recorder) SetTypeParams(tparams []*types.TypeParam) *MoqNamed_starGenType_SetTypeParams_fnRecorder {
	return &MoqNamed_starGenType_SetTypeParams_fnRecorder{
		Params: MoqNamed_starGenType_SetTypeParams_params{
			Tparams: tparams,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqNamed_starGenType_SetTypeParams_fnRecorder) Any() *MoqNamed_starGenType_SetTypeParams_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetTypeParams(r.Params))
		return nil
	}
	return &MoqNamed_starGenType_SetTypeParams_anyParams{Recorder: r}
}

func (a *MoqNamed_starGenType_SetTypeParams_anyParams) Tparams() *MoqNamed_starGenType_SetTypeParams_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqNamed_starGenType_SetTypeParams_fnRecorder) Seq() *MoqNamed_starGenType_SetTypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetTypeParams(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqNamed_starGenType_SetTypeParams_fnRecorder) NoSeq() *MoqNamed_starGenType_SetTypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetTypeParams(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqNamed_starGenType_SetTypeParams_fnRecorder) ReturnResults() *MoqNamed_starGenType_SetTypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_SetTypeParams_doFn
		DoReturnFn MoqNamed_starGenType_SetTypeParams_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqNamed_starGenType_SetTypeParams_fnRecorder) AndDo(fn MoqNamed_starGenType_SetTypeParams_doFn) *MoqNamed_starGenType_SetTypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqNamed_starGenType_SetTypeParams_fnRecorder) DoReturnResults(fn MoqNamed_starGenType_SetTypeParams_doReturnFn) *MoqNamed_starGenType_SetTypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_SetTypeParams_doFn
		DoReturnFn MoqNamed_starGenType_SetTypeParams_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqNamed_starGenType_SetTypeParams_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqNamed_starGenType_SetTypeParams_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetTypeParams {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqNamed_starGenType_SetTypeParams_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqNamed_starGenType_SetTypeParams_paramsKey]*MoqNamed_starGenType_SetTypeParams_results{},
		}
		r.Moq.ResultsByParams_SetTypeParams = append(r.Moq.ResultsByParams_SetTypeParams, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetTypeParams) {
			copy(r.Moq.ResultsByParams_SetTypeParams[insertAt+1:], r.Moq.ResultsByParams_SetTypeParams[insertAt:0])
			r.Moq.ResultsByParams_SetTypeParams[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetTypeParams(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqNamed_starGenType_SetTypeParams_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqNamed_starGenType_SetTypeParams_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqNamed_starGenType_SetTypeParams_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqNamed_starGenType_SetTypeParams_doFn
				DoReturnFn MoqNamed_starGenType_SetTypeParams_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqNamed_starGenType) PrettyParams_SetTypeParams(params MoqNamed_starGenType_SetTypeParams_params) string {
	return fmt.Sprintf("SetTypeParams(%#v)", params.Tparams)
}

func (m *MoqNamed_starGenType) ParamsKey_SetTypeParams(params MoqNamed_starGenType_SetTypeParams_params, anyParams uint64) MoqNamed_starGenType_SetTypeParams_paramsKey {
	m.Scene.T.Helper()
	var tparamsUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetTypeParams.Tparams == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The tparams parameter of the SetTypeParams function can't be indexed by value")
		}
		tparamsUsedHash = hash.DeepHash(params.Tparams)
	}
	return MoqNamed_starGenType_SetTypeParams_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Tparams hash.Hash }{
			Tparams: tparamsUsedHash,
		},
	}
}

func (m *MoqNamed_starGenType_recorder) TypeArgs() *MoqNamed_starGenType_TypeArgs_fnRecorder {
	return &MoqNamed_starGenType_TypeArgs_fnRecorder{
		Params:   MoqNamed_starGenType_TypeArgs_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqNamed_starGenType_TypeArgs_fnRecorder) Any() *MoqNamed_starGenType_TypeArgs_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TypeArgs(r.Params))
		return nil
	}
	return &MoqNamed_starGenType_TypeArgs_anyParams{Recorder: r}
}

func (r *MoqNamed_starGenType_TypeArgs_fnRecorder) Seq() *MoqNamed_starGenType_TypeArgs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TypeArgs(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqNamed_starGenType_TypeArgs_fnRecorder) NoSeq() *MoqNamed_starGenType_TypeArgs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TypeArgs(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqNamed_starGenType_TypeArgs_fnRecorder) ReturnResults(result1 *types.TypeList) *MoqNamed_starGenType_TypeArgs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.TypeList
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_TypeArgs_doFn
		DoReturnFn MoqNamed_starGenType_TypeArgs_doReturnFn
	}{
		Values: &struct {
			Result1 *types.TypeList
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqNamed_starGenType_TypeArgs_fnRecorder) AndDo(fn MoqNamed_starGenType_TypeArgs_doFn) *MoqNamed_starGenType_TypeArgs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqNamed_starGenType_TypeArgs_fnRecorder) DoReturnResults(fn MoqNamed_starGenType_TypeArgs_doReturnFn) *MoqNamed_starGenType_TypeArgs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.TypeList
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_TypeArgs_doFn
		DoReturnFn MoqNamed_starGenType_TypeArgs_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqNamed_starGenType_TypeArgs_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqNamed_starGenType_TypeArgs_resultsByParams
	for n, res := range r.Moq.ResultsByParams_TypeArgs {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqNamed_starGenType_TypeArgs_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqNamed_starGenType_TypeArgs_paramsKey]*MoqNamed_starGenType_TypeArgs_results{},
		}
		r.Moq.ResultsByParams_TypeArgs = append(r.Moq.ResultsByParams_TypeArgs, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_TypeArgs) {
			copy(r.Moq.ResultsByParams_TypeArgs[insertAt+1:], r.Moq.ResultsByParams_TypeArgs[insertAt:0])
			r.Moq.ResultsByParams_TypeArgs[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_TypeArgs(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqNamed_starGenType_TypeArgs_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqNamed_starGenType_TypeArgs_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqNamed_starGenType_TypeArgs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.TypeList
				}
				Sequence   uint32
				DoFn       MoqNamed_starGenType_TypeArgs_doFn
				DoReturnFn MoqNamed_starGenType_TypeArgs_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqNamed_starGenType) PrettyParams_TypeArgs(params MoqNamed_starGenType_TypeArgs_params) string {
	return fmt.Sprintf("TypeArgs()")
}

func (m *MoqNamed_starGenType) ParamsKey_TypeArgs(params MoqNamed_starGenType_TypeArgs_params, anyParams uint64) MoqNamed_starGenType_TypeArgs_paramsKey {
	m.Scene.T.Helper()
	return MoqNamed_starGenType_TypeArgs_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqNamed_starGenType_recorder) NumMethods() *MoqNamed_starGenType_NumMethods_fnRecorder {
	return &MoqNamed_starGenType_NumMethods_fnRecorder{
		Params:   MoqNamed_starGenType_NumMethods_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqNamed_starGenType_NumMethods_fnRecorder) Any() *MoqNamed_starGenType_NumMethods_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethods(r.Params))
		return nil
	}
	return &MoqNamed_starGenType_NumMethods_anyParams{Recorder: r}
}

func (r *MoqNamed_starGenType_NumMethods_fnRecorder) Seq() *MoqNamed_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethods(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqNamed_starGenType_NumMethods_fnRecorder) NoSeq() *MoqNamed_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethods(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqNamed_starGenType_NumMethods_fnRecorder) ReturnResults(result1 int) *MoqNamed_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_NumMethods_doFn
		DoReturnFn MoqNamed_starGenType_NumMethods_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqNamed_starGenType_NumMethods_fnRecorder) AndDo(fn MoqNamed_starGenType_NumMethods_doFn) *MoqNamed_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqNamed_starGenType_NumMethods_fnRecorder) DoReturnResults(fn MoqNamed_starGenType_NumMethods_doReturnFn) *MoqNamed_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_NumMethods_doFn
		DoReturnFn MoqNamed_starGenType_NumMethods_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqNamed_starGenType_NumMethods_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqNamed_starGenType_NumMethods_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumMethods {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqNamed_starGenType_NumMethods_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqNamed_starGenType_NumMethods_paramsKey]*MoqNamed_starGenType_NumMethods_results{},
		}
		r.Moq.ResultsByParams_NumMethods = append(r.Moq.ResultsByParams_NumMethods, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumMethods) {
			copy(r.Moq.ResultsByParams_NumMethods[insertAt+1:], r.Moq.ResultsByParams_NumMethods[insertAt:0])
			r.Moq.ResultsByParams_NumMethods[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumMethods(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqNamed_starGenType_NumMethods_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqNamed_starGenType_NumMethods_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqNamed_starGenType_NumMethods_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqNamed_starGenType_NumMethods_doFn
				DoReturnFn MoqNamed_starGenType_NumMethods_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqNamed_starGenType) PrettyParams_NumMethods(params MoqNamed_starGenType_NumMethods_params) string {
	return fmt.Sprintf("NumMethods()")
}

func (m *MoqNamed_starGenType) ParamsKey_NumMethods(params MoqNamed_starGenType_NumMethods_params, anyParams uint64) MoqNamed_starGenType_NumMethods_paramsKey {
	m.Scene.T.Helper()
	return MoqNamed_starGenType_NumMethods_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqNamed_starGenType_recorder) Method(param1 int) *MoqNamed_starGenType_Method_fnRecorder {
	return &MoqNamed_starGenType_Method_fnRecorder{
		Params: MoqNamed_starGenType_Method_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqNamed_starGenType_Method_fnRecorder) Any() *MoqNamed_starGenType_Method_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	return &MoqNamed_starGenType_Method_anyParams{Recorder: r}
}

func (a *MoqNamed_starGenType_Method_anyParams) Param1() *MoqNamed_starGenType_Method_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqNamed_starGenType_Method_fnRecorder) Seq() *MoqNamed_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqNamed_starGenType_Method_fnRecorder) NoSeq() *MoqNamed_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqNamed_starGenType_Method_fnRecorder) ReturnResults(result1 *types.Func) *MoqNamed_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Func
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Method_doFn
		DoReturnFn MoqNamed_starGenType_Method_doReturnFn
	}{
		Values: &struct {
			Result1 *types.Func
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqNamed_starGenType_Method_fnRecorder) AndDo(fn MoqNamed_starGenType_Method_doFn) *MoqNamed_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqNamed_starGenType_Method_fnRecorder) DoReturnResults(fn MoqNamed_starGenType_Method_doReturnFn) *MoqNamed_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *types.Func
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Method_doFn
		DoReturnFn MoqNamed_starGenType_Method_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqNamed_starGenType_Method_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqNamed_starGenType_Method_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Method {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqNamed_starGenType_Method_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqNamed_starGenType_Method_paramsKey]*MoqNamed_starGenType_Method_results{},
		}
		r.Moq.ResultsByParams_Method = append(r.Moq.ResultsByParams_Method, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Method) {
			copy(r.Moq.ResultsByParams_Method[insertAt+1:], r.Moq.ResultsByParams_Method[insertAt:0])
			r.Moq.ResultsByParams_Method[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Method(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqNamed_starGenType_Method_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqNamed_starGenType_Method_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqNamed_starGenType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *types.Func
				}
				Sequence   uint32
				DoFn       MoqNamed_starGenType_Method_doFn
				DoReturnFn MoqNamed_starGenType_Method_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqNamed_starGenType) PrettyParams_Method(params MoqNamed_starGenType_Method_params) string {
	return fmt.Sprintf("Method(%#v)", params.Param1)
}

func (m *MoqNamed_starGenType) ParamsKey_Method(params MoqNamed_starGenType_Method_params, anyParams uint64) MoqNamed_starGenType_Method_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Method.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqNamed_starGenType_Method_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqNamed_starGenType_recorder) SetUnderlying(underlying types.Type) *MoqNamed_starGenType_SetUnderlying_fnRecorder {
	return &MoqNamed_starGenType_SetUnderlying_fnRecorder{
		Params: MoqNamed_starGenType_SetUnderlying_params{
			Underlying: underlying,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqNamed_starGenType_SetUnderlying_fnRecorder) Any() *MoqNamed_starGenType_SetUnderlying_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUnderlying(r.Params))
		return nil
	}
	return &MoqNamed_starGenType_SetUnderlying_anyParams{Recorder: r}
}

func (a *MoqNamed_starGenType_SetUnderlying_anyParams) Underlying() *MoqNamed_starGenType_SetUnderlying_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqNamed_starGenType_SetUnderlying_fnRecorder) Seq() *MoqNamed_starGenType_SetUnderlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUnderlying(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqNamed_starGenType_SetUnderlying_fnRecorder) NoSeq() *MoqNamed_starGenType_SetUnderlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUnderlying(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqNamed_starGenType_SetUnderlying_fnRecorder) ReturnResults() *MoqNamed_starGenType_SetUnderlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_SetUnderlying_doFn
		DoReturnFn MoqNamed_starGenType_SetUnderlying_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqNamed_starGenType_SetUnderlying_fnRecorder) AndDo(fn MoqNamed_starGenType_SetUnderlying_doFn) *MoqNamed_starGenType_SetUnderlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqNamed_starGenType_SetUnderlying_fnRecorder) DoReturnResults(fn MoqNamed_starGenType_SetUnderlying_doReturnFn) *MoqNamed_starGenType_SetUnderlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_SetUnderlying_doFn
		DoReturnFn MoqNamed_starGenType_SetUnderlying_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqNamed_starGenType_SetUnderlying_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqNamed_starGenType_SetUnderlying_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetUnderlying {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqNamed_starGenType_SetUnderlying_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqNamed_starGenType_SetUnderlying_paramsKey]*MoqNamed_starGenType_SetUnderlying_results{},
		}
		r.Moq.ResultsByParams_SetUnderlying = append(r.Moq.ResultsByParams_SetUnderlying, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetUnderlying) {
			copy(r.Moq.ResultsByParams_SetUnderlying[insertAt+1:], r.Moq.ResultsByParams_SetUnderlying[insertAt:0])
			r.Moq.ResultsByParams_SetUnderlying[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetUnderlying(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqNamed_starGenType_SetUnderlying_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqNamed_starGenType_SetUnderlying_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqNamed_starGenType_SetUnderlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqNamed_starGenType_SetUnderlying_doFn
				DoReturnFn MoqNamed_starGenType_SetUnderlying_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqNamed_starGenType) PrettyParams_SetUnderlying(params MoqNamed_starGenType_SetUnderlying_params) string {
	return fmt.Sprintf("SetUnderlying(%#v)", params.Underlying)
}

func (m *MoqNamed_starGenType) ParamsKey_SetUnderlying(params MoqNamed_starGenType_SetUnderlying_params, anyParams uint64) MoqNamed_starGenType_SetUnderlying_paramsKey {
	m.Scene.T.Helper()
	var underlyingUsed types.Type
	var underlyingUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetUnderlying.Underlying == moq.ParamIndexByValue {
			underlyingUsed = params.Underlying
		} else {
			underlyingUsedHash = hash.DeepHash(params.Underlying)
		}
	}
	return MoqNamed_starGenType_SetUnderlying_paramsKey{
		Params: struct{ Underlying types.Type }{
			Underlying: underlyingUsed,
		},
		Hashes: struct{ Underlying hash.Hash }{
			Underlying: underlyingUsedHash,
		},
	}
}

func (m *MoqNamed_starGenType_recorder) AddMethod(param1 *types.Func) *MoqNamed_starGenType_AddMethod_fnRecorder {
	return &MoqNamed_starGenType_AddMethod_fnRecorder{
		Params: MoqNamed_starGenType_AddMethod_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqNamed_starGenType_AddMethod_fnRecorder) Any() *MoqNamed_starGenType_AddMethod_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddMethod(r.Params))
		return nil
	}
	return &MoqNamed_starGenType_AddMethod_anyParams{Recorder: r}
}

func (a *MoqNamed_starGenType_AddMethod_anyParams) Param1() *MoqNamed_starGenType_AddMethod_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqNamed_starGenType_AddMethod_fnRecorder) Seq() *MoqNamed_starGenType_AddMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddMethod(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqNamed_starGenType_AddMethod_fnRecorder) NoSeq() *MoqNamed_starGenType_AddMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddMethod(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqNamed_starGenType_AddMethod_fnRecorder) ReturnResults() *MoqNamed_starGenType_AddMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_AddMethod_doFn
		DoReturnFn MoqNamed_starGenType_AddMethod_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqNamed_starGenType_AddMethod_fnRecorder) AndDo(fn MoqNamed_starGenType_AddMethod_doFn) *MoqNamed_starGenType_AddMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqNamed_starGenType_AddMethod_fnRecorder) DoReturnResults(fn MoqNamed_starGenType_AddMethod_doReturnFn) *MoqNamed_starGenType_AddMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_AddMethod_doFn
		DoReturnFn MoqNamed_starGenType_AddMethod_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqNamed_starGenType_AddMethod_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqNamed_starGenType_AddMethod_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AddMethod {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqNamed_starGenType_AddMethod_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqNamed_starGenType_AddMethod_paramsKey]*MoqNamed_starGenType_AddMethod_results{},
		}
		r.Moq.ResultsByParams_AddMethod = append(r.Moq.ResultsByParams_AddMethod, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AddMethod) {
			copy(r.Moq.ResultsByParams_AddMethod[insertAt+1:], r.Moq.ResultsByParams_AddMethod[insertAt:0])
			r.Moq.ResultsByParams_AddMethod[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AddMethod(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqNamed_starGenType_AddMethod_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqNamed_starGenType_AddMethod_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqNamed_starGenType_AddMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqNamed_starGenType_AddMethod_doFn
				DoReturnFn MoqNamed_starGenType_AddMethod_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqNamed_starGenType) PrettyParams_AddMethod(params MoqNamed_starGenType_AddMethod_params) string {
	return fmt.Sprintf("AddMethod(%#v)", params.Param1)
}

func (m *MoqNamed_starGenType) ParamsKey_AddMethod(params MoqNamed_starGenType_AddMethod_params, anyParams uint64) MoqNamed_starGenType_AddMethod_paramsKey {
	m.Scene.T.Helper()
	var param1Used *types.Func
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.AddMethod.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqNamed_starGenType_AddMethod_paramsKey{
		Params: struct{ Param1 *types.Func }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqNamed_starGenType_recorder) Underlying() *MoqNamed_starGenType_Underlying_fnRecorder {
	return &MoqNamed_starGenType_Underlying_fnRecorder{
		Params:   MoqNamed_starGenType_Underlying_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqNamed_starGenType_Underlying_fnRecorder) Any() *MoqNamed_starGenType_Underlying_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Underlying(r.Params))
		return nil
	}
	return &MoqNamed_starGenType_Underlying_anyParams{Recorder: r}
}

func (r *MoqNamed_starGenType_Underlying_fnRecorder) Seq() *MoqNamed_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Underlying(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqNamed_starGenType_Underlying_fnRecorder) NoSeq() *MoqNamed_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Underlying(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqNamed_starGenType_Underlying_fnRecorder) ReturnResults(result1 types.Type) *MoqNamed_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 types.Type
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Underlying_doFn
		DoReturnFn MoqNamed_starGenType_Underlying_doReturnFn
	}{
		Values: &struct {
			Result1 types.Type
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqNamed_starGenType_Underlying_fnRecorder) AndDo(fn MoqNamed_starGenType_Underlying_doFn) *MoqNamed_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqNamed_starGenType_Underlying_fnRecorder) DoReturnResults(fn MoqNamed_starGenType_Underlying_doReturnFn) *MoqNamed_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 types.Type
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_Underlying_doFn
		DoReturnFn MoqNamed_starGenType_Underlying_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqNamed_starGenType_Underlying_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqNamed_starGenType_Underlying_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Underlying {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqNamed_starGenType_Underlying_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqNamed_starGenType_Underlying_paramsKey]*MoqNamed_starGenType_Underlying_results{},
		}
		r.Moq.ResultsByParams_Underlying = append(r.Moq.ResultsByParams_Underlying, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Underlying) {
			copy(r.Moq.ResultsByParams_Underlying[insertAt+1:], r.Moq.ResultsByParams_Underlying[insertAt:0])
			r.Moq.ResultsByParams_Underlying[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Underlying(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqNamed_starGenType_Underlying_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqNamed_starGenType_Underlying_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqNamed_starGenType_Underlying_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 types.Type
				}
				Sequence   uint32
				DoFn       MoqNamed_starGenType_Underlying_doFn
				DoReturnFn MoqNamed_starGenType_Underlying_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqNamed_starGenType) PrettyParams_Underlying(params MoqNamed_starGenType_Underlying_params) string {
	return fmt.Sprintf("Underlying()")
}

func (m *MoqNamed_starGenType) ParamsKey_Underlying(params MoqNamed_starGenType_Underlying_params, anyParams uint64) MoqNamed_starGenType_Underlying_paramsKey {
	m.Scene.T.Helper()
	return MoqNamed_starGenType_Underlying_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqNamed_starGenType_recorder) String() *MoqNamed_starGenType_String_fnRecorder {
	return &MoqNamed_starGenType_String_fnRecorder{
		Params:   MoqNamed_starGenType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqNamed_starGenType_String_fnRecorder) Any() *MoqNamed_starGenType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqNamed_starGenType_String_anyParams{Recorder: r}
}

func (r *MoqNamed_starGenType_String_fnRecorder) Seq() *MoqNamed_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqNamed_starGenType_String_fnRecorder) NoSeq() *MoqNamed_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqNamed_starGenType_String_fnRecorder) ReturnResults(result1 string) *MoqNamed_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_String_doFn
		DoReturnFn MoqNamed_starGenType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqNamed_starGenType_String_fnRecorder) AndDo(fn MoqNamed_starGenType_String_doFn) *MoqNamed_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqNamed_starGenType_String_fnRecorder) DoReturnResults(fn MoqNamed_starGenType_String_doReturnFn) *MoqNamed_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqNamed_starGenType_String_doFn
		DoReturnFn MoqNamed_starGenType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqNamed_starGenType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqNamed_starGenType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqNamed_starGenType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqNamed_starGenType_String_paramsKey]*MoqNamed_starGenType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqNamed_starGenType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqNamed_starGenType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqNamed_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqNamed_starGenType_String_doFn
				DoReturnFn MoqNamed_starGenType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqNamed_starGenType) PrettyParams_String(params MoqNamed_starGenType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqNamed_starGenType) ParamsKey_String(params MoqNamed_starGenType_String_params, anyParams uint64) MoqNamed_starGenType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqNamed_starGenType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqNamed_starGenType) Reset() {
	m.ResultsByParams_Obj = nil
	m.ResultsByParams_Origin = nil
	m.ResultsByParams_TypeParams = nil
	m.ResultsByParams_SetTypeParams = nil
	m.ResultsByParams_TypeArgs = nil
	m.ResultsByParams_NumMethods = nil
	m.ResultsByParams_Method = nil
	m.ResultsByParams_SetUnderlying = nil
	m.ResultsByParams_AddMethod = nil
	m.ResultsByParams_Underlying = nil
	m.ResultsByParams_String = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqNamed_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Obj {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Obj(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Origin {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Origin(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_TypeParams {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_TypeParams(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetTypeParams {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetTypeParams(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_TypeArgs {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_TypeArgs(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_NumMethods {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumMethods(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Method {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Method(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetUnderlying {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetUnderlying(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AddMethod {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AddMethod(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Underlying {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Underlying(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
}
