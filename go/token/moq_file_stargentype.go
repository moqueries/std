// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package token

import (
	"fmt"
	"go/token"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that token.File_starGenType is mocked
// completely
var _ File_starGenType = (*MoqFile_starGenType_mock)(nil)

// File_starGenType is the fabricated implementation type of this mock (emitted
// when mocking a collections of methods directly and not from an interface
// type)
type File_starGenType interface {
	Name() string
	Base() int
	Size() int
	LineCount() int
	AddLine(offset int)
	MergeLine(line int)
	SetLines(lines []int) bool
	SetLinesForContent(content []byte)
	LineStart(line int) token.Pos
	AddLineInfo(offset int, filename string, line int)
	AddLineColumnInfo(offset int, filename string, line, column int)
	Pos(offset int) token.Pos
	Offset(p token.Pos) int
	Line(p token.Pos) int
	PositionFor(p token.Pos, adjusted bool) (pos token.Position)
	Position(p token.Pos) (pos token.Position)
}

// MoqFile_starGenType holds the state of a moq of the File_starGenType type
type MoqFile_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqFile_starGenType_mock

	ResultsByParams_Name               []MoqFile_starGenType_Name_resultsByParams
	ResultsByParams_Base               []MoqFile_starGenType_Base_resultsByParams
	ResultsByParams_Size               []MoqFile_starGenType_Size_resultsByParams
	ResultsByParams_LineCount          []MoqFile_starGenType_LineCount_resultsByParams
	ResultsByParams_AddLine            []MoqFile_starGenType_AddLine_resultsByParams
	ResultsByParams_MergeLine          []MoqFile_starGenType_MergeLine_resultsByParams
	ResultsByParams_SetLines           []MoqFile_starGenType_SetLines_resultsByParams
	ResultsByParams_SetLinesForContent []MoqFile_starGenType_SetLinesForContent_resultsByParams
	ResultsByParams_LineStart          []MoqFile_starGenType_LineStart_resultsByParams
	ResultsByParams_AddLineInfo        []MoqFile_starGenType_AddLineInfo_resultsByParams
	ResultsByParams_AddLineColumnInfo  []MoqFile_starGenType_AddLineColumnInfo_resultsByParams
	ResultsByParams_Pos                []MoqFile_starGenType_Pos_resultsByParams
	ResultsByParams_Offset             []MoqFile_starGenType_Offset_resultsByParams
	ResultsByParams_Line               []MoqFile_starGenType_Line_resultsByParams
	ResultsByParams_PositionFor        []MoqFile_starGenType_PositionFor_resultsByParams
	ResultsByParams_Position           []MoqFile_starGenType_Position_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Name      struct{}
			Base      struct{}
			Size      struct{}
			LineCount struct{}
			AddLine   struct {
				Offset moq.ParamIndexing
			}
			MergeLine struct {
				Line moq.ParamIndexing
			}
			SetLines struct {
				Lines moq.ParamIndexing
			}
			SetLinesForContent struct {
				Content moq.ParamIndexing
			}
			LineStart struct {
				Line moq.ParamIndexing
			}
			AddLineInfo struct {
				Offset   moq.ParamIndexing
				Filename moq.ParamIndexing
				Line     moq.ParamIndexing
			}
			AddLineColumnInfo struct {
				Offset   moq.ParamIndexing
				Filename moq.ParamIndexing
				Line     moq.ParamIndexing
				Column   moq.ParamIndexing
			}
			Pos struct {
				Offset moq.ParamIndexing
			}
			Offset struct {
				P moq.ParamIndexing
			}
			Line struct {
				P moq.ParamIndexing
			}
			PositionFor struct {
				P        moq.ParamIndexing
				Adjusted moq.ParamIndexing
			}
			Position struct {
				P moq.ParamIndexing
			}
		}
	}
	// MoqFile_starGenType_mock isolates the mock interface of the File_starGenType
}

// type
type MoqFile_starGenType_mock struct {
	Moq *MoqFile_starGenType
}

// MoqFile_starGenType_recorder isolates the recorder interface of the
// File_starGenType type
type MoqFile_starGenType_recorder struct {
	Moq *MoqFile_starGenType
}

// MoqFile_starGenType_Name_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Name_params struct{}

// MoqFile_starGenType_Name_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Name_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFile_starGenType_Name_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Name_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Name_paramsKey]*MoqFile_starGenType_Name_results
}

// MoqFile_starGenType_Name_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Name_doFn func()

// MoqFile_starGenType_Name_doReturnFn defines the type of function needed when
// calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Name_doReturnFn func() string

// MoqFile_starGenType_Name_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Name_results struct {
	Params  MoqFile_starGenType_Name_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Name_doFn
		DoReturnFn MoqFile_starGenType_Name_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Name_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Name_fnRecorder struct {
	Params    MoqFile_starGenType_Name_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Name_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Name_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Name_anyParams struct {
	Recorder *MoqFile_starGenType_Name_fnRecorder
}

// MoqFile_starGenType_Base_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Base_params struct{}

// MoqFile_starGenType_Base_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Base_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFile_starGenType_Base_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Base_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Base_paramsKey]*MoqFile_starGenType_Base_results
}

// MoqFile_starGenType_Base_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Base_doFn func()

// MoqFile_starGenType_Base_doReturnFn defines the type of function needed when
// calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Base_doReturnFn func() int

// MoqFile_starGenType_Base_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Base_results struct {
	Params  MoqFile_starGenType_Base_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Base_doFn
		DoReturnFn MoqFile_starGenType_Base_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Base_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Base_fnRecorder struct {
	Params    MoqFile_starGenType_Base_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Base_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Base_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Base_anyParams struct {
	Recorder *MoqFile_starGenType_Base_fnRecorder
}

// MoqFile_starGenType_Size_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Size_params struct{}

// MoqFile_starGenType_Size_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Size_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFile_starGenType_Size_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Size_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Size_paramsKey]*MoqFile_starGenType_Size_results
}

// MoqFile_starGenType_Size_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Size_doFn func()

// MoqFile_starGenType_Size_doReturnFn defines the type of function needed when
// calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Size_doReturnFn func() int

// MoqFile_starGenType_Size_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Size_results struct {
	Params  MoqFile_starGenType_Size_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Size_doFn
		DoReturnFn MoqFile_starGenType_Size_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Size_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Size_fnRecorder struct {
	Params    MoqFile_starGenType_Size_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Size_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Size_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Size_anyParams struct {
	Recorder *MoqFile_starGenType_Size_fnRecorder
}

// MoqFile_starGenType_LineCount_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_LineCount_params struct{}

// MoqFile_starGenType_LineCount_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_LineCount_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFile_starGenType_LineCount_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_LineCount_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_LineCount_paramsKey]*MoqFile_starGenType_LineCount_results
}

// MoqFile_starGenType_LineCount_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_LineCount_doFn func()

// MoqFile_starGenType_LineCount_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_LineCount_doReturnFn func() int

// MoqFile_starGenType_LineCount_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_LineCount_results struct {
	Params  MoqFile_starGenType_LineCount_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_LineCount_doFn
		DoReturnFn MoqFile_starGenType_LineCount_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_LineCount_fnRecorder routes recorded function calls to
// the MoqFile_starGenType moq
type MoqFile_starGenType_LineCount_fnRecorder struct {
	Params    MoqFile_starGenType_LineCount_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_LineCount_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_LineCount_anyParams isolates the any params functions of
// the File_starGenType type
type MoqFile_starGenType_LineCount_anyParams struct {
	Recorder *MoqFile_starGenType_LineCount_fnRecorder
}

// MoqFile_starGenType_AddLine_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_AddLine_params struct{ Offset int }

// MoqFile_starGenType_AddLine_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_AddLine_paramsKey struct {
	Params struct{ Offset int }
	Hashes struct{ Offset hash.Hash }
}

// MoqFile_starGenType_AddLine_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_AddLine_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_AddLine_paramsKey]*MoqFile_starGenType_AddLine_results
}

// MoqFile_starGenType_AddLine_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_AddLine_doFn func(offset int)

// MoqFile_starGenType_AddLine_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_AddLine_doReturnFn func(offset int)

// MoqFile_starGenType_AddLine_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_AddLine_results struct {
	Params  MoqFile_starGenType_AddLine_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_AddLine_doFn
		DoReturnFn MoqFile_starGenType_AddLine_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_AddLine_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_AddLine_fnRecorder struct {
	Params    MoqFile_starGenType_AddLine_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_AddLine_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_AddLine_anyParams isolates the any params functions of
// the File_starGenType type
type MoqFile_starGenType_AddLine_anyParams struct {
	Recorder *MoqFile_starGenType_AddLine_fnRecorder
}

// MoqFile_starGenType_MergeLine_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_MergeLine_params struct{ Line int }

// MoqFile_starGenType_MergeLine_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_MergeLine_paramsKey struct {
	Params struct{ Line int }
	Hashes struct{ Line hash.Hash }
}

// MoqFile_starGenType_MergeLine_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_MergeLine_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_MergeLine_paramsKey]*MoqFile_starGenType_MergeLine_results
}

// MoqFile_starGenType_MergeLine_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_MergeLine_doFn func(line int)

// MoqFile_starGenType_MergeLine_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_MergeLine_doReturnFn func(line int)

// MoqFile_starGenType_MergeLine_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_MergeLine_results struct {
	Params  MoqFile_starGenType_MergeLine_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_MergeLine_doFn
		DoReturnFn MoqFile_starGenType_MergeLine_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_MergeLine_fnRecorder routes recorded function calls to
// the MoqFile_starGenType moq
type MoqFile_starGenType_MergeLine_fnRecorder struct {
	Params    MoqFile_starGenType_MergeLine_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_MergeLine_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_MergeLine_anyParams isolates the any params functions of
// the File_starGenType type
type MoqFile_starGenType_MergeLine_anyParams struct {
	Recorder *MoqFile_starGenType_MergeLine_fnRecorder
}

// MoqFile_starGenType_SetLines_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_SetLines_params struct{ Lines []int }

// MoqFile_starGenType_SetLines_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_SetLines_paramsKey struct {
	Params struct{}
	Hashes struct{ Lines hash.Hash }
}

// MoqFile_starGenType_SetLines_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_SetLines_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_SetLines_paramsKey]*MoqFile_starGenType_SetLines_results
}

// MoqFile_starGenType_SetLines_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_SetLines_doFn func(lines []int)

// MoqFile_starGenType_SetLines_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_SetLines_doReturnFn func(lines []int) bool

// MoqFile_starGenType_SetLines_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_SetLines_results struct {
	Params  MoqFile_starGenType_SetLines_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetLines_doFn
		DoReturnFn MoqFile_starGenType_SetLines_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_SetLines_fnRecorder routes recorded function calls to
// the MoqFile_starGenType moq
type MoqFile_starGenType_SetLines_fnRecorder struct {
	Params    MoqFile_starGenType_SetLines_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_SetLines_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_SetLines_anyParams isolates the any params functions of
// the File_starGenType type
type MoqFile_starGenType_SetLines_anyParams struct {
	Recorder *MoqFile_starGenType_SetLines_fnRecorder
}

// MoqFile_starGenType_SetLinesForContent_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_SetLinesForContent_params struct{ Content []byte }

// MoqFile_starGenType_SetLinesForContent_paramsKey holds the map key params of
// the File_starGenType type
type MoqFile_starGenType_SetLinesForContent_paramsKey struct {
	Params struct{}
	Hashes struct{ Content hash.Hash }
}

// MoqFile_starGenType_SetLinesForContent_resultsByParams contains the results
// for a given set of parameters for the File_starGenType type
type MoqFile_starGenType_SetLinesForContent_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_SetLinesForContent_paramsKey]*MoqFile_starGenType_SetLinesForContent_results
}

// MoqFile_starGenType_SetLinesForContent_doFn defines the type of function
// needed when calling AndDo for the File_starGenType type
type MoqFile_starGenType_SetLinesForContent_doFn func(content []byte)

// MoqFile_starGenType_SetLinesForContent_doReturnFn defines the type of
// function needed when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_SetLinesForContent_doReturnFn func(content []byte)

// MoqFile_starGenType_SetLinesForContent_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_SetLinesForContent_results struct {
	Params  MoqFile_starGenType_SetLinesForContent_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetLinesForContent_doFn
		DoReturnFn MoqFile_starGenType_SetLinesForContent_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_SetLinesForContent_fnRecorder routes recorded function
// calls to the MoqFile_starGenType moq
type MoqFile_starGenType_SetLinesForContent_fnRecorder struct {
	Params    MoqFile_starGenType_SetLinesForContent_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_SetLinesForContent_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_SetLinesForContent_anyParams isolates the any params
// functions of the File_starGenType type
type MoqFile_starGenType_SetLinesForContent_anyParams struct {
	Recorder *MoqFile_starGenType_SetLinesForContent_fnRecorder
}

// MoqFile_starGenType_LineStart_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_LineStart_params struct{ Line int }

// MoqFile_starGenType_LineStart_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_LineStart_paramsKey struct {
	Params struct{ Line int }
	Hashes struct{ Line hash.Hash }
}

// MoqFile_starGenType_LineStart_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_LineStart_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_LineStart_paramsKey]*MoqFile_starGenType_LineStart_results
}

// MoqFile_starGenType_LineStart_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_LineStart_doFn func(line int)

// MoqFile_starGenType_LineStart_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_LineStart_doReturnFn func(line int) token.Pos

// MoqFile_starGenType_LineStart_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_LineStart_results struct {
	Params  MoqFile_starGenType_LineStart_params
	Results []struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_LineStart_doFn
		DoReturnFn MoqFile_starGenType_LineStart_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_LineStart_fnRecorder routes recorded function calls to
// the MoqFile_starGenType moq
type MoqFile_starGenType_LineStart_fnRecorder struct {
	Params    MoqFile_starGenType_LineStart_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_LineStart_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_LineStart_anyParams isolates the any params functions of
// the File_starGenType type
type MoqFile_starGenType_LineStart_anyParams struct {
	Recorder *MoqFile_starGenType_LineStart_fnRecorder
}

// MoqFile_starGenType_AddLineInfo_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_AddLineInfo_params struct {
	Offset   int
	Filename string
	Line     int
}

// MoqFile_starGenType_AddLineInfo_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_AddLineInfo_paramsKey struct {
	Params struct {
		Offset   int
		Filename string
		Line     int
	}
	Hashes struct {
		Offset   hash.Hash
		Filename hash.Hash
		Line     hash.Hash
	}
}

// MoqFile_starGenType_AddLineInfo_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_AddLineInfo_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_AddLineInfo_paramsKey]*MoqFile_starGenType_AddLineInfo_results
}

// MoqFile_starGenType_AddLineInfo_doFn defines the type of function needed
// when calling AndDo for the File_starGenType type
type MoqFile_starGenType_AddLineInfo_doFn func(offset int, filename string, line int)

// MoqFile_starGenType_AddLineInfo_doReturnFn defines the type of function
// needed when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_AddLineInfo_doReturnFn func(offset int, filename string, line int)

// MoqFile_starGenType_AddLineInfo_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_AddLineInfo_results struct {
	Params  MoqFile_starGenType_AddLineInfo_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_AddLineInfo_doFn
		DoReturnFn MoqFile_starGenType_AddLineInfo_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_AddLineInfo_fnRecorder routes recorded function calls to
// the MoqFile_starGenType moq
type MoqFile_starGenType_AddLineInfo_fnRecorder struct {
	Params    MoqFile_starGenType_AddLineInfo_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_AddLineInfo_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_AddLineInfo_anyParams isolates the any params functions
// of the File_starGenType type
type MoqFile_starGenType_AddLineInfo_anyParams struct {
	Recorder *MoqFile_starGenType_AddLineInfo_fnRecorder
}

// MoqFile_starGenType_AddLineColumnInfo_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_AddLineColumnInfo_params struct {
	Offset       int
	Filename     string
	Line, Column int
}

// MoqFile_starGenType_AddLineColumnInfo_paramsKey holds the map key params of
// the File_starGenType type
type MoqFile_starGenType_AddLineColumnInfo_paramsKey struct {
	Params struct {
		Offset       int
		Filename     string
		Line, Column int
	}
	Hashes struct {
		Offset       hash.Hash
		Filename     hash.Hash
		Line, Column hash.Hash
	}
}

// MoqFile_starGenType_AddLineColumnInfo_resultsByParams contains the results
// for a given set of parameters for the File_starGenType type
type MoqFile_starGenType_AddLineColumnInfo_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_AddLineColumnInfo_paramsKey]*MoqFile_starGenType_AddLineColumnInfo_results
}

// MoqFile_starGenType_AddLineColumnInfo_doFn defines the type of function
// needed when calling AndDo for the File_starGenType type
type MoqFile_starGenType_AddLineColumnInfo_doFn func(offset int, filename string, line, column int)

// MoqFile_starGenType_AddLineColumnInfo_doReturnFn defines the type of
// function needed when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_AddLineColumnInfo_doReturnFn func(offset int, filename string, line, column int)

// MoqFile_starGenType_AddLineColumnInfo_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_AddLineColumnInfo_results struct {
	Params  MoqFile_starGenType_AddLineColumnInfo_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_AddLineColumnInfo_doFn
		DoReturnFn MoqFile_starGenType_AddLineColumnInfo_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_AddLineColumnInfo_fnRecorder routes recorded function
// calls to the MoqFile_starGenType moq
type MoqFile_starGenType_AddLineColumnInfo_fnRecorder struct {
	Params    MoqFile_starGenType_AddLineColumnInfo_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_AddLineColumnInfo_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_AddLineColumnInfo_anyParams isolates the any params
// functions of the File_starGenType type
type MoqFile_starGenType_AddLineColumnInfo_anyParams struct {
	Recorder *MoqFile_starGenType_AddLineColumnInfo_fnRecorder
}

// MoqFile_starGenType_Pos_params holds the params of the File_starGenType type
type MoqFile_starGenType_Pos_params struct{ Offset int }

// MoqFile_starGenType_Pos_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Pos_paramsKey struct {
	Params struct{ Offset int }
	Hashes struct{ Offset hash.Hash }
}

// MoqFile_starGenType_Pos_resultsByParams contains the results for a given set
// of parameters for the File_starGenType type
type MoqFile_starGenType_Pos_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Pos_paramsKey]*MoqFile_starGenType_Pos_results
}

// MoqFile_starGenType_Pos_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Pos_doFn func(offset int)

// MoqFile_starGenType_Pos_doReturnFn defines the type of function needed when
// calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Pos_doReturnFn func(offset int) token.Pos

// MoqFile_starGenType_Pos_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Pos_results struct {
	Params  MoqFile_starGenType_Pos_params
	Results []struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Pos_doFn
		DoReturnFn MoqFile_starGenType_Pos_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Pos_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Pos_fnRecorder struct {
	Params    MoqFile_starGenType_Pos_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Pos_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Pos_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Pos_anyParams struct {
	Recorder *MoqFile_starGenType_Pos_fnRecorder
}

// MoqFile_starGenType_Offset_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Offset_params struct{ P token.Pos }

// MoqFile_starGenType_Offset_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Offset_paramsKey struct {
	Params struct{ P token.Pos }
	Hashes struct{ P hash.Hash }
}

// MoqFile_starGenType_Offset_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Offset_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Offset_paramsKey]*MoqFile_starGenType_Offset_results
}

// MoqFile_starGenType_Offset_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Offset_doFn func(p token.Pos)

// MoqFile_starGenType_Offset_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Offset_doReturnFn func(p token.Pos) int

// MoqFile_starGenType_Offset_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Offset_results struct {
	Params  MoqFile_starGenType_Offset_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Offset_doFn
		DoReturnFn MoqFile_starGenType_Offset_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Offset_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Offset_fnRecorder struct {
	Params    MoqFile_starGenType_Offset_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Offset_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Offset_anyParams isolates the any params functions of
// the File_starGenType type
type MoqFile_starGenType_Offset_anyParams struct {
	Recorder *MoqFile_starGenType_Offset_fnRecorder
}

// MoqFile_starGenType_Line_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Line_params struct{ P token.Pos }

// MoqFile_starGenType_Line_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Line_paramsKey struct {
	Params struct{ P token.Pos }
	Hashes struct{ P hash.Hash }
}

// MoqFile_starGenType_Line_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Line_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Line_paramsKey]*MoqFile_starGenType_Line_results
}

// MoqFile_starGenType_Line_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Line_doFn func(p token.Pos)

// MoqFile_starGenType_Line_doReturnFn defines the type of function needed when
// calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Line_doReturnFn func(p token.Pos) int

// MoqFile_starGenType_Line_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Line_results struct {
	Params  MoqFile_starGenType_Line_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Line_doFn
		DoReturnFn MoqFile_starGenType_Line_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Line_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Line_fnRecorder struct {
	Params    MoqFile_starGenType_Line_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Line_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Line_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Line_anyParams struct {
	Recorder *MoqFile_starGenType_Line_fnRecorder
}

// MoqFile_starGenType_PositionFor_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_PositionFor_params struct {
	P        token.Pos
	Adjusted bool
}

// MoqFile_starGenType_PositionFor_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_PositionFor_paramsKey struct {
	Params struct {
		P        token.Pos
		Adjusted bool
	}
	Hashes struct {
		P        hash.Hash
		Adjusted hash.Hash
	}
}

// MoqFile_starGenType_PositionFor_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_PositionFor_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_PositionFor_paramsKey]*MoqFile_starGenType_PositionFor_results
}

// MoqFile_starGenType_PositionFor_doFn defines the type of function needed
// when calling AndDo for the File_starGenType type
type MoqFile_starGenType_PositionFor_doFn func(p token.Pos, adjusted bool)

// MoqFile_starGenType_PositionFor_doReturnFn defines the type of function
// needed when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_PositionFor_doReturnFn func(p token.Pos, adjusted bool) (pos token.Position)

// MoqFile_starGenType_PositionFor_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_PositionFor_results struct {
	Params  MoqFile_starGenType_PositionFor_params
	Results []struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFile_starGenType_PositionFor_doFn
		DoReturnFn MoqFile_starGenType_PositionFor_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_PositionFor_fnRecorder routes recorded function calls to
// the MoqFile_starGenType moq
type MoqFile_starGenType_PositionFor_fnRecorder struct {
	Params    MoqFile_starGenType_PositionFor_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_PositionFor_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_PositionFor_anyParams isolates the any params functions
// of the File_starGenType type
type MoqFile_starGenType_PositionFor_anyParams struct {
	Recorder *MoqFile_starGenType_PositionFor_fnRecorder
}

// MoqFile_starGenType_Position_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Position_params struct{ P token.Pos }

// MoqFile_starGenType_Position_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Position_paramsKey struct {
	Params struct{ P token.Pos }
	Hashes struct{ P hash.Hash }
}

// MoqFile_starGenType_Position_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_Position_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Position_paramsKey]*MoqFile_starGenType_Position_results
}

// MoqFile_starGenType_Position_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Position_doFn func(p token.Pos)

// MoqFile_starGenType_Position_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Position_doReturnFn func(p token.Pos) (pos token.Position)

// MoqFile_starGenType_Position_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_Position_results struct {
	Params  MoqFile_starGenType_Position_params
	Results []struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFile_starGenType_Position_doFn
		DoReturnFn MoqFile_starGenType_Position_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Position_fnRecorder routes recorded function calls to
// the MoqFile_starGenType moq
type MoqFile_starGenType_Position_fnRecorder struct {
	Params    MoqFile_starGenType_Position_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Position_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Position_anyParams isolates the any params functions of
// the File_starGenType type
type MoqFile_starGenType_Position_anyParams struct {
	Recorder *MoqFile_starGenType_Position_fnRecorder
}

// NewMoqFile_starGenType creates a new moq of the File_starGenType type
func NewMoqFile_starGenType(scene *moq.Scene, config *moq.Config) *MoqFile_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqFile_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqFile_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Name      struct{}
				Base      struct{}
				Size      struct{}
				LineCount struct{}
				AddLine   struct {
					Offset moq.ParamIndexing
				}
				MergeLine struct {
					Line moq.ParamIndexing
				}
				SetLines struct {
					Lines moq.ParamIndexing
				}
				SetLinesForContent struct {
					Content moq.ParamIndexing
				}
				LineStart struct {
					Line moq.ParamIndexing
				}
				AddLineInfo struct {
					Offset   moq.ParamIndexing
					Filename moq.ParamIndexing
					Line     moq.ParamIndexing
				}
				AddLineColumnInfo struct {
					Offset   moq.ParamIndexing
					Filename moq.ParamIndexing
					Line     moq.ParamIndexing
					Column   moq.ParamIndexing
				}
				Pos struct {
					Offset moq.ParamIndexing
				}
				Offset struct {
					P moq.ParamIndexing
				}
				Line struct {
					P moq.ParamIndexing
				}
				PositionFor struct {
					P        moq.ParamIndexing
					Adjusted moq.ParamIndexing
				}
				Position struct {
					P moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			Name      struct{}
			Base      struct{}
			Size      struct{}
			LineCount struct{}
			AddLine   struct {
				Offset moq.ParamIndexing
			}
			MergeLine struct {
				Line moq.ParamIndexing
			}
			SetLines struct {
				Lines moq.ParamIndexing
			}
			SetLinesForContent struct {
				Content moq.ParamIndexing
			}
			LineStart struct {
				Line moq.ParamIndexing
			}
			AddLineInfo struct {
				Offset   moq.ParamIndexing
				Filename moq.ParamIndexing
				Line     moq.ParamIndexing
			}
			AddLineColumnInfo struct {
				Offset   moq.ParamIndexing
				Filename moq.ParamIndexing
				Line     moq.ParamIndexing
				Column   moq.ParamIndexing
			}
			Pos struct {
				Offset moq.ParamIndexing
			}
			Offset struct {
				P moq.ParamIndexing
			}
			Line struct {
				P moq.ParamIndexing
			}
			PositionFor struct {
				P        moq.ParamIndexing
				Adjusted moq.ParamIndexing
			}
			Position struct {
				P moq.ParamIndexing
			}
		}{
			Name:      struct{}{},
			Base:      struct{}{},
			Size:      struct{}{},
			LineCount: struct{}{},
			AddLine: struct {
				Offset moq.ParamIndexing
			}{
				Offset: moq.ParamIndexByValue,
			},
			MergeLine: struct {
				Line moq.ParamIndexing
			}{
				Line: moq.ParamIndexByValue,
			},
			SetLines: struct {
				Lines moq.ParamIndexing
			}{
				Lines: moq.ParamIndexByHash,
			},
			SetLinesForContent: struct {
				Content moq.ParamIndexing
			}{
				Content: moq.ParamIndexByHash,
			},
			LineStart: struct {
				Line moq.ParamIndexing
			}{
				Line: moq.ParamIndexByValue,
			},
			AddLineInfo: struct {
				Offset   moq.ParamIndexing
				Filename moq.ParamIndexing
				Line     moq.ParamIndexing
			}{
				Offset:   moq.ParamIndexByValue,
				Filename: moq.ParamIndexByValue,
				Line:     moq.ParamIndexByValue,
			},
			AddLineColumnInfo: struct {
				Offset   moq.ParamIndexing
				Filename moq.ParamIndexing
				Line     moq.ParamIndexing
				Column   moq.ParamIndexing
			}{
				Offset:   moq.ParamIndexByValue,
				Filename: moq.ParamIndexByValue,
				Line:     moq.ParamIndexByValue,
				Column:   moq.ParamIndexByValue,
			},
			Pos: struct {
				Offset moq.ParamIndexing
			}{
				Offset: moq.ParamIndexByValue,
			},
			Offset: struct {
				P moq.ParamIndexing
			}{
				P: moq.ParamIndexByValue,
			},
			Line: struct {
				P moq.ParamIndexing
			}{
				P: moq.ParamIndexByValue,
			},
			PositionFor: struct {
				P        moq.ParamIndexing
				Adjusted moq.ParamIndexing
			}{
				P:        moq.ParamIndexByValue,
				Adjusted: moq.ParamIndexByValue,
			},
			Position: struct {
				P moq.ParamIndexing
			}{
				P: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the File_starGenType type
func (m *MoqFile_starGenType) Mock() *MoqFile_starGenType_mock { return m.Moq }

func (m *MoqFile_starGenType_mock) Name() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Name_params{}
	var results *MoqFile_starGenType_Name_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Name {
		paramsKey := m.Moq.ParamsKey_Name(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Name(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Name(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Name(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFile_starGenType_mock) Base() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Base_params{}
	var results *MoqFile_starGenType_Base_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Base {
		paramsKey := m.Moq.ParamsKey_Base(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Base(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Base(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Base(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFile_starGenType_mock) Size() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Size_params{}
	var results *MoqFile_starGenType_Size_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Size {
		paramsKey := m.Moq.ParamsKey_Size(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Size(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Size(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Size(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFile_starGenType_mock) LineCount() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_LineCount_params{}
	var results *MoqFile_starGenType_LineCount_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LineCount {
		paramsKey := m.Moq.ParamsKey_LineCount(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LineCount(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LineCount(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LineCount(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFile_starGenType_mock) AddLine(offset int) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_AddLine_params{
		Offset: offset,
	}
	var results *MoqFile_starGenType_AddLine_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AddLine {
		paramsKey := m.Moq.ParamsKey_AddLine(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AddLine(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AddLine(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AddLine(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(offset)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(offset)
	}
	return
}

func (m *MoqFile_starGenType_mock) MergeLine(line int) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_MergeLine_params{
		Line: line,
	}
	var results *MoqFile_starGenType_MergeLine_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MergeLine {
		paramsKey := m.Moq.ParamsKey_MergeLine(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MergeLine(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MergeLine(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MergeLine(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(line)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(line)
	}
	return
}

func (m *MoqFile_starGenType_mock) SetLines(lines []int) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_SetLines_params{
		Lines: lines,
	}
	var results *MoqFile_starGenType_SetLines_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetLines {
		paramsKey := m.Moq.ParamsKey_SetLines(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetLines(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetLines(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetLines(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(lines)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(lines)
	}
	return
}

func (m *MoqFile_starGenType_mock) SetLinesForContent(content []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_SetLinesForContent_params{
		Content: content,
	}
	var results *MoqFile_starGenType_SetLinesForContent_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetLinesForContent {
		paramsKey := m.Moq.ParamsKey_SetLinesForContent(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetLinesForContent(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetLinesForContent(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetLinesForContent(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(content)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(content)
	}
	return
}

func (m *MoqFile_starGenType_mock) LineStart(line int) (result1 token.Pos) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_LineStart_params{
		Line: line,
	}
	var results *MoqFile_starGenType_LineStart_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LineStart {
		paramsKey := m.Moq.ParamsKey_LineStart(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LineStart(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LineStart(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LineStart(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(line)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(line)
	}
	return
}

func (m *MoqFile_starGenType_mock) AddLineInfo(offset int, filename string, line int) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_AddLineInfo_params{
		Offset:   offset,
		Filename: filename,
		Line:     line,
	}
	var results *MoqFile_starGenType_AddLineInfo_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AddLineInfo {
		paramsKey := m.Moq.ParamsKey_AddLineInfo(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AddLineInfo(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AddLineInfo(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AddLineInfo(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(offset, filename, line)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(offset, filename, line)
	}
	return
}

func (m *MoqFile_starGenType_mock) AddLineColumnInfo(offset int, filename string, line, column int) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_AddLineColumnInfo_params{
		Offset:   offset,
		Filename: filename,
		Line:     line,
		Column:   column,
	}
	var results *MoqFile_starGenType_AddLineColumnInfo_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AddLineColumnInfo {
		paramsKey := m.Moq.ParamsKey_AddLineColumnInfo(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AddLineColumnInfo(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AddLineColumnInfo(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AddLineColumnInfo(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(offset, filename, line, column)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(offset, filename, line, column)
	}
	return
}

func (m *MoqFile_starGenType_mock) Pos(offset int) (result1 token.Pos) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Pos_params{
		Offset: offset,
	}
	var results *MoqFile_starGenType_Pos_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Pos {
		paramsKey := m.Moq.ParamsKey_Pos(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Pos(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Pos(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Pos(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(offset)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(offset)
	}
	return
}

func (m *MoqFile_starGenType_mock) Offset(p token.Pos) (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Offset_params{
		P: p,
	}
	var results *MoqFile_starGenType_Offset_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Offset {
		paramsKey := m.Moq.ParamsKey_Offset(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Offset(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Offset(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Offset(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(p)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(p)
	}
	return
}

func (m *MoqFile_starGenType_mock) Line(p token.Pos) (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Line_params{
		P: p,
	}
	var results *MoqFile_starGenType_Line_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Line {
		paramsKey := m.Moq.ParamsKey_Line(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Line(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Line(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Line(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(p)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(p)
	}
	return
}

func (m *MoqFile_starGenType_mock) PositionFor(p token.Pos, adjusted bool) (pos token.Position) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_PositionFor_params{
		P:        p,
		Adjusted: adjusted,
	}
	var results *MoqFile_starGenType_PositionFor_results
	for _, resultsByParams := range m.Moq.ResultsByParams_PositionFor {
		paramsKey := m.Moq.ParamsKey_PositionFor(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_PositionFor(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_PositionFor(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_PositionFor(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(p, adjusted)
	}

	if result.Values != nil {
		pos = result.Values.Pos
	}
	if result.DoReturnFn != nil {
		pos = result.DoReturnFn(p, adjusted)
	}
	return
}

func (m *MoqFile_starGenType_mock) Position(p token.Pos) (pos token.Position) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Position_params{
		P: p,
	}
	var results *MoqFile_starGenType_Position_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Position {
		paramsKey := m.Moq.ParamsKey_Position(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Position(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Position(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Position(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(p)
	}

	if result.Values != nil {
		pos = result.Values.Pos
	}
	if result.DoReturnFn != nil {
		pos = result.DoReturnFn(p)
	}
	return
}

// OnCall returns the recorder implementation of the File_starGenType type
func (m *MoqFile_starGenType) OnCall() *MoqFile_starGenType_recorder {
	return &MoqFile_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqFile_starGenType_recorder) Name() *MoqFile_starGenType_Name_fnRecorder {
	return &MoqFile_starGenType_Name_fnRecorder{
		Params:   MoqFile_starGenType_Name_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Name_fnRecorder) Any() *MoqFile_starGenType_Name_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Name_anyParams{Recorder: r}
}

func (r *MoqFile_starGenType_Name_fnRecorder) Seq() *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Name_fnRecorder) NoSeq() *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Name_fnRecorder) ReturnResults(result1 string) *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Name_doFn
		DoReturnFn MoqFile_starGenType_Name_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Name_fnRecorder) AndDo(fn MoqFile_starGenType_Name_doFn) *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Name_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Name_doReturnFn) *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Name_doFn
		DoReturnFn MoqFile_starGenType_Name_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Name_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Name_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Name {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Name_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Name_paramsKey]*MoqFile_starGenType_Name_results{},
		}
		r.Moq.ResultsByParams_Name = append(r.Moq.ResultsByParams_Name, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Name) {
			copy(r.Moq.ResultsByParams_Name[insertAt+1:], r.Moq.ResultsByParams_Name[insertAt:0])
			r.Moq.ResultsByParams_Name[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Name(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Name_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Name_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Name_doFn
				DoReturnFn MoqFile_starGenType_Name_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Name(params MoqFile_starGenType_Name_params) string {
	return fmt.Sprintf("Name()")
}

func (m *MoqFile_starGenType) ParamsKey_Name(params MoqFile_starGenType_Name_params, anyParams uint64) MoqFile_starGenType_Name_paramsKey {
	m.Scene.T.Helper()
	return MoqFile_starGenType_Name_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFile_starGenType_recorder) Base() *MoqFile_starGenType_Base_fnRecorder {
	return &MoqFile_starGenType_Base_fnRecorder{
		Params:   MoqFile_starGenType_Base_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Base_fnRecorder) Any() *MoqFile_starGenType_Base_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Base(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Base_anyParams{Recorder: r}
}

func (r *MoqFile_starGenType_Base_fnRecorder) Seq() *MoqFile_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Base(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Base_fnRecorder) NoSeq() *MoqFile_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Base(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Base_fnRecorder) ReturnResults(result1 int) *MoqFile_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Base_doFn
		DoReturnFn MoqFile_starGenType_Base_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Base_fnRecorder) AndDo(fn MoqFile_starGenType_Base_doFn) *MoqFile_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Base_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Base_doReturnFn) *MoqFile_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Base_doFn
		DoReturnFn MoqFile_starGenType_Base_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Base_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Base_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Base {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Base_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Base_paramsKey]*MoqFile_starGenType_Base_results{},
		}
		r.Moq.ResultsByParams_Base = append(r.Moq.ResultsByParams_Base, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Base) {
			copy(r.Moq.ResultsByParams_Base[insertAt+1:], r.Moq.ResultsByParams_Base[insertAt:0])
			r.Moq.ResultsByParams_Base[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Base(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Base_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Base_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Base_doFn
				DoReturnFn MoqFile_starGenType_Base_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Base(params MoqFile_starGenType_Base_params) string {
	return fmt.Sprintf("Base()")
}

func (m *MoqFile_starGenType) ParamsKey_Base(params MoqFile_starGenType_Base_params, anyParams uint64) MoqFile_starGenType_Base_paramsKey {
	m.Scene.T.Helper()
	return MoqFile_starGenType_Base_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFile_starGenType_recorder) Size() *MoqFile_starGenType_Size_fnRecorder {
	return &MoqFile_starGenType_Size_fnRecorder{
		Params:   MoqFile_starGenType_Size_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Size_fnRecorder) Any() *MoqFile_starGenType_Size_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Size_anyParams{Recorder: r}
}

func (r *MoqFile_starGenType_Size_fnRecorder) Seq() *MoqFile_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Size_fnRecorder) NoSeq() *MoqFile_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Size_fnRecorder) ReturnResults(result1 int) *MoqFile_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Size_doFn
		DoReturnFn MoqFile_starGenType_Size_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Size_fnRecorder) AndDo(fn MoqFile_starGenType_Size_doFn) *MoqFile_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Size_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Size_doReturnFn) *MoqFile_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Size_doFn
		DoReturnFn MoqFile_starGenType_Size_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Size_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Size_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Size {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Size_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Size_paramsKey]*MoqFile_starGenType_Size_results{},
		}
		r.Moq.ResultsByParams_Size = append(r.Moq.ResultsByParams_Size, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Size) {
			copy(r.Moq.ResultsByParams_Size[insertAt+1:], r.Moq.ResultsByParams_Size[insertAt:0])
			r.Moq.ResultsByParams_Size[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Size(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Size_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Size_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Size_doFn
				DoReturnFn MoqFile_starGenType_Size_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Size(params MoqFile_starGenType_Size_params) string {
	return fmt.Sprintf("Size()")
}

func (m *MoqFile_starGenType) ParamsKey_Size(params MoqFile_starGenType_Size_params, anyParams uint64) MoqFile_starGenType_Size_paramsKey {
	m.Scene.T.Helper()
	return MoqFile_starGenType_Size_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFile_starGenType_recorder) LineCount() *MoqFile_starGenType_LineCount_fnRecorder {
	return &MoqFile_starGenType_LineCount_fnRecorder{
		Params:   MoqFile_starGenType_LineCount_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_LineCount_fnRecorder) Any() *MoqFile_starGenType_LineCount_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LineCount(r.Params))
		return nil
	}
	return &MoqFile_starGenType_LineCount_anyParams{Recorder: r}
}

func (r *MoqFile_starGenType_LineCount_fnRecorder) Seq() *MoqFile_starGenType_LineCount_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LineCount(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_LineCount_fnRecorder) NoSeq() *MoqFile_starGenType_LineCount_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LineCount(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_LineCount_fnRecorder) ReturnResults(result1 int) *MoqFile_starGenType_LineCount_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_LineCount_doFn
		DoReturnFn MoqFile_starGenType_LineCount_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_LineCount_fnRecorder) AndDo(fn MoqFile_starGenType_LineCount_doFn) *MoqFile_starGenType_LineCount_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_LineCount_fnRecorder) DoReturnResults(fn MoqFile_starGenType_LineCount_doReturnFn) *MoqFile_starGenType_LineCount_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_LineCount_doFn
		DoReturnFn MoqFile_starGenType_LineCount_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_LineCount_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_LineCount_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LineCount {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_LineCount_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_LineCount_paramsKey]*MoqFile_starGenType_LineCount_results{},
		}
		r.Moq.ResultsByParams_LineCount = append(r.Moq.ResultsByParams_LineCount, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LineCount) {
			copy(r.Moq.ResultsByParams_LineCount[insertAt+1:], r.Moq.ResultsByParams_LineCount[insertAt:0])
			r.Moq.ResultsByParams_LineCount[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LineCount(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_LineCount_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_LineCount_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_LineCount_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_LineCount_doFn
				DoReturnFn MoqFile_starGenType_LineCount_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_LineCount(params MoqFile_starGenType_LineCount_params) string {
	return fmt.Sprintf("LineCount()")
}

func (m *MoqFile_starGenType) ParamsKey_LineCount(params MoqFile_starGenType_LineCount_params, anyParams uint64) MoqFile_starGenType_LineCount_paramsKey {
	m.Scene.T.Helper()
	return MoqFile_starGenType_LineCount_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFile_starGenType_recorder) AddLine(offset int) *MoqFile_starGenType_AddLine_fnRecorder {
	return &MoqFile_starGenType_AddLine_fnRecorder{
		Params: MoqFile_starGenType_AddLine_params{
			Offset: offset,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_AddLine_fnRecorder) Any() *MoqFile_starGenType_AddLine_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddLine(r.Params))
		return nil
	}
	return &MoqFile_starGenType_AddLine_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_AddLine_anyParams) Offset() *MoqFile_starGenType_AddLine_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_AddLine_fnRecorder) Seq() *MoqFile_starGenType_AddLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddLine(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_AddLine_fnRecorder) NoSeq() *MoqFile_starGenType_AddLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddLine(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_AddLine_fnRecorder) ReturnResults() *MoqFile_starGenType_AddLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_AddLine_doFn
		DoReturnFn MoqFile_starGenType_AddLine_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_AddLine_fnRecorder) AndDo(fn MoqFile_starGenType_AddLine_doFn) *MoqFile_starGenType_AddLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_AddLine_fnRecorder) DoReturnResults(fn MoqFile_starGenType_AddLine_doReturnFn) *MoqFile_starGenType_AddLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_AddLine_doFn
		DoReturnFn MoqFile_starGenType_AddLine_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_AddLine_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_AddLine_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AddLine {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_AddLine_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_AddLine_paramsKey]*MoqFile_starGenType_AddLine_results{},
		}
		r.Moq.ResultsByParams_AddLine = append(r.Moq.ResultsByParams_AddLine, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AddLine) {
			copy(r.Moq.ResultsByParams_AddLine[insertAt+1:], r.Moq.ResultsByParams_AddLine[insertAt:0])
			r.Moq.ResultsByParams_AddLine[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AddLine(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_AddLine_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_AddLine_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_AddLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqFile_starGenType_AddLine_doFn
				DoReturnFn MoqFile_starGenType_AddLine_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_AddLine(params MoqFile_starGenType_AddLine_params) string {
	return fmt.Sprintf("AddLine(%#v)", params.Offset)
}

func (m *MoqFile_starGenType) ParamsKey_AddLine(params MoqFile_starGenType_AddLine_params, anyParams uint64) MoqFile_starGenType_AddLine_paramsKey {
	m.Scene.T.Helper()
	var offsetUsed int
	var offsetUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.AddLine.Offset == moq.ParamIndexByValue {
			offsetUsed = params.Offset
		} else {
			offsetUsedHash = hash.DeepHash(params.Offset)
		}
	}
	return MoqFile_starGenType_AddLine_paramsKey{
		Params: struct{ Offset int }{
			Offset: offsetUsed,
		},
		Hashes: struct{ Offset hash.Hash }{
			Offset: offsetUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) MergeLine(line int) *MoqFile_starGenType_MergeLine_fnRecorder {
	return &MoqFile_starGenType_MergeLine_fnRecorder{
		Params: MoqFile_starGenType_MergeLine_params{
			Line: line,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_MergeLine_fnRecorder) Any() *MoqFile_starGenType_MergeLine_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MergeLine(r.Params))
		return nil
	}
	return &MoqFile_starGenType_MergeLine_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_MergeLine_anyParams) Line() *MoqFile_starGenType_MergeLine_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_MergeLine_fnRecorder) Seq() *MoqFile_starGenType_MergeLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MergeLine(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_MergeLine_fnRecorder) NoSeq() *MoqFile_starGenType_MergeLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MergeLine(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_MergeLine_fnRecorder) ReturnResults() *MoqFile_starGenType_MergeLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_MergeLine_doFn
		DoReturnFn MoqFile_starGenType_MergeLine_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_MergeLine_fnRecorder) AndDo(fn MoqFile_starGenType_MergeLine_doFn) *MoqFile_starGenType_MergeLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_MergeLine_fnRecorder) DoReturnResults(fn MoqFile_starGenType_MergeLine_doReturnFn) *MoqFile_starGenType_MergeLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_MergeLine_doFn
		DoReturnFn MoqFile_starGenType_MergeLine_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_MergeLine_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_MergeLine_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MergeLine {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_MergeLine_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_MergeLine_paramsKey]*MoqFile_starGenType_MergeLine_results{},
		}
		r.Moq.ResultsByParams_MergeLine = append(r.Moq.ResultsByParams_MergeLine, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MergeLine) {
			copy(r.Moq.ResultsByParams_MergeLine[insertAt+1:], r.Moq.ResultsByParams_MergeLine[insertAt:0])
			r.Moq.ResultsByParams_MergeLine[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MergeLine(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_MergeLine_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_MergeLine_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_MergeLine_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqFile_starGenType_MergeLine_doFn
				DoReturnFn MoqFile_starGenType_MergeLine_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_MergeLine(params MoqFile_starGenType_MergeLine_params) string {
	return fmt.Sprintf("MergeLine(%#v)", params.Line)
}

func (m *MoqFile_starGenType) ParamsKey_MergeLine(params MoqFile_starGenType_MergeLine_params, anyParams uint64) MoqFile_starGenType_MergeLine_paramsKey {
	m.Scene.T.Helper()
	var lineUsed int
	var lineUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MergeLine.Line == moq.ParamIndexByValue {
			lineUsed = params.Line
		} else {
			lineUsedHash = hash.DeepHash(params.Line)
		}
	}
	return MoqFile_starGenType_MergeLine_paramsKey{
		Params: struct{ Line int }{
			Line: lineUsed,
		},
		Hashes: struct{ Line hash.Hash }{
			Line: lineUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) SetLines(lines []int) *MoqFile_starGenType_SetLines_fnRecorder {
	return &MoqFile_starGenType_SetLines_fnRecorder{
		Params: MoqFile_starGenType_SetLines_params{
			Lines: lines,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_SetLines_fnRecorder) Any() *MoqFile_starGenType_SetLines_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLines(r.Params))
		return nil
	}
	return &MoqFile_starGenType_SetLines_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_SetLines_anyParams) Lines() *MoqFile_starGenType_SetLines_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_SetLines_fnRecorder) Seq() *MoqFile_starGenType_SetLines_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLines(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_SetLines_fnRecorder) NoSeq() *MoqFile_starGenType_SetLines_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLines(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_SetLines_fnRecorder) ReturnResults(result1 bool) *MoqFile_starGenType_SetLines_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetLines_doFn
		DoReturnFn MoqFile_starGenType_SetLines_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_SetLines_fnRecorder) AndDo(fn MoqFile_starGenType_SetLines_doFn) *MoqFile_starGenType_SetLines_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_SetLines_fnRecorder) DoReturnResults(fn MoqFile_starGenType_SetLines_doReturnFn) *MoqFile_starGenType_SetLines_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetLines_doFn
		DoReturnFn MoqFile_starGenType_SetLines_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_SetLines_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_SetLines_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetLines {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_SetLines_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_SetLines_paramsKey]*MoqFile_starGenType_SetLines_results{},
		}
		r.Moq.ResultsByParams_SetLines = append(r.Moq.ResultsByParams_SetLines, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetLines) {
			copy(r.Moq.ResultsByParams_SetLines[insertAt+1:], r.Moq.ResultsByParams_SetLines[insertAt:0])
			r.Moq.ResultsByParams_SetLines[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetLines(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_SetLines_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_SetLines_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_SetLines_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_SetLines_doFn
				DoReturnFn MoqFile_starGenType_SetLines_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_SetLines(params MoqFile_starGenType_SetLines_params) string {
	return fmt.Sprintf("SetLines(%#v)", params.Lines)
}

func (m *MoqFile_starGenType) ParamsKey_SetLines(params MoqFile_starGenType_SetLines_params, anyParams uint64) MoqFile_starGenType_SetLines_paramsKey {
	m.Scene.T.Helper()
	var linesUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetLines.Lines == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The lines parameter of the SetLines function can't be indexed by value")
		}
		linesUsedHash = hash.DeepHash(params.Lines)
	}
	return MoqFile_starGenType_SetLines_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Lines hash.Hash }{
			Lines: linesUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) SetLinesForContent(content []byte) *MoqFile_starGenType_SetLinesForContent_fnRecorder {
	return &MoqFile_starGenType_SetLinesForContent_fnRecorder{
		Params: MoqFile_starGenType_SetLinesForContent_params{
			Content: content,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_SetLinesForContent_fnRecorder) Any() *MoqFile_starGenType_SetLinesForContent_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLinesForContent(r.Params))
		return nil
	}
	return &MoqFile_starGenType_SetLinesForContent_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_SetLinesForContent_anyParams) Content() *MoqFile_starGenType_SetLinesForContent_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_SetLinesForContent_fnRecorder) Seq() *MoqFile_starGenType_SetLinesForContent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLinesForContent(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_SetLinesForContent_fnRecorder) NoSeq() *MoqFile_starGenType_SetLinesForContent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLinesForContent(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_SetLinesForContent_fnRecorder) ReturnResults() *MoqFile_starGenType_SetLinesForContent_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetLinesForContent_doFn
		DoReturnFn MoqFile_starGenType_SetLinesForContent_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_SetLinesForContent_fnRecorder) AndDo(fn MoqFile_starGenType_SetLinesForContent_doFn) *MoqFile_starGenType_SetLinesForContent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_SetLinesForContent_fnRecorder) DoReturnResults(fn MoqFile_starGenType_SetLinesForContent_doReturnFn) *MoqFile_starGenType_SetLinesForContent_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetLinesForContent_doFn
		DoReturnFn MoqFile_starGenType_SetLinesForContent_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_SetLinesForContent_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_SetLinesForContent_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetLinesForContent {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_SetLinesForContent_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_SetLinesForContent_paramsKey]*MoqFile_starGenType_SetLinesForContent_results{},
		}
		r.Moq.ResultsByParams_SetLinesForContent = append(r.Moq.ResultsByParams_SetLinesForContent, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetLinesForContent) {
			copy(r.Moq.ResultsByParams_SetLinesForContent[insertAt+1:], r.Moq.ResultsByParams_SetLinesForContent[insertAt:0])
			r.Moq.ResultsByParams_SetLinesForContent[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetLinesForContent(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_SetLinesForContent_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_SetLinesForContent_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_SetLinesForContent_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqFile_starGenType_SetLinesForContent_doFn
				DoReturnFn MoqFile_starGenType_SetLinesForContent_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_SetLinesForContent(params MoqFile_starGenType_SetLinesForContent_params) string {
	return fmt.Sprintf("SetLinesForContent(%#v)", params.Content)
}

func (m *MoqFile_starGenType) ParamsKey_SetLinesForContent(params MoqFile_starGenType_SetLinesForContent_params, anyParams uint64) MoqFile_starGenType_SetLinesForContent_paramsKey {
	m.Scene.T.Helper()
	var contentUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetLinesForContent.Content == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The content parameter of the SetLinesForContent function can't be indexed by value")
		}
		contentUsedHash = hash.DeepHash(params.Content)
	}
	return MoqFile_starGenType_SetLinesForContent_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Content hash.Hash }{
			Content: contentUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) LineStart(line int) *MoqFile_starGenType_LineStart_fnRecorder {
	return &MoqFile_starGenType_LineStart_fnRecorder{
		Params: MoqFile_starGenType_LineStart_params{
			Line: line,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_LineStart_fnRecorder) Any() *MoqFile_starGenType_LineStart_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LineStart(r.Params))
		return nil
	}
	return &MoqFile_starGenType_LineStart_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_LineStart_anyParams) Line() *MoqFile_starGenType_LineStart_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_LineStart_fnRecorder) Seq() *MoqFile_starGenType_LineStart_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LineStart(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_LineStart_fnRecorder) NoSeq() *MoqFile_starGenType_LineStart_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LineStart(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_LineStart_fnRecorder) ReturnResults(result1 token.Pos) *MoqFile_starGenType_LineStart_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_LineStart_doFn
		DoReturnFn MoqFile_starGenType_LineStart_doReturnFn
	}{
		Values: &struct {
			Result1 token.Pos
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_LineStart_fnRecorder) AndDo(fn MoqFile_starGenType_LineStart_doFn) *MoqFile_starGenType_LineStart_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_LineStart_fnRecorder) DoReturnResults(fn MoqFile_starGenType_LineStart_doReturnFn) *MoqFile_starGenType_LineStart_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_LineStart_doFn
		DoReturnFn MoqFile_starGenType_LineStart_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_LineStart_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_LineStart_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LineStart {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_LineStart_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_LineStart_paramsKey]*MoqFile_starGenType_LineStart_results{},
		}
		r.Moq.ResultsByParams_LineStart = append(r.Moq.ResultsByParams_LineStart, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LineStart) {
			copy(r.Moq.ResultsByParams_LineStart[insertAt+1:], r.Moq.ResultsByParams_LineStart[insertAt:0])
			r.Moq.ResultsByParams_LineStart[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LineStart(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_LineStart_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_LineStart_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_LineStart_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 token.Pos
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_LineStart_doFn
				DoReturnFn MoqFile_starGenType_LineStart_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_LineStart(params MoqFile_starGenType_LineStart_params) string {
	return fmt.Sprintf("LineStart(%#v)", params.Line)
}

func (m *MoqFile_starGenType) ParamsKey_LineStart(params MoqFile_starGenType_LineStart_params, anyParams uint64) MoqFile_starGenType_LineStart_paramsKey {
	m.Scene.T.Helper()
	var lineUsed int
	var lineUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LineStart.Line == moq.ParamIndexByValue {
			lineUsed = params.Line
		} else {
			lineUsedHash = hash.DeepHash(params.Line)
		}
	}
	return MoqFile_starGenType_LineStart_paramsKey{
		Params: struct{ Line int }{
			Line: lineUsed,
		},
		Hashes: struct{ Line hash.Hash }{
			Line: lineUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) AddLineInfo(offset int, filename string, line int) *MoqFile_starGenType_AddLineInfo_fnRecorder {
	return &MoqFile_starGenType_AddLineInfo_fnRecorder{
		Params: MoqFile_starGenType_AddLineInfo_params{
			Offset:   offset,
			Filename: filename,
			Line:     line,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_AddLineInfo_fnRecorder) Any() *MoqFile_starGenType_AddLineInfo_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddLineInfo(r.Params))
		return nil
	}
	return &MoqFile_starGenType_AddLineInfo_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_AddLineInfo_anyParams) Offset() *MoqFile_starGenType_AddLineInfo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFile_starGenType_AddLineInfo_anyParams) Filename() *MoqFile_starGenType_AddLineInfo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqFile_starGenType_AddLineInfo_anyParams) Line() *MoqFile_starGenType_AddLineInfo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqFile_starGenType_AddLineInfo_fnRecorder) Seq() *MoqFile_starGenType_AddLineInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddLineInfo(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_AddLineInfo_fnRecorder) NoSeq() *MoqFile_starGenType_AddLineInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddLineInfo(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_AddLineInfo_fnRecorder) ReturnResults() *MoqFile_starGenType_AddLineInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_AddLineInfo_doFn
		DoReturnFn MoqFile_starGenType_AddLineInfo_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_AddLineInfo_fnRecorder) AndDo(fn MoqFile_starGenType_AddLineInfo_doFn) *MoqFile_starGenType_AddLineInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_AddLineInfo_fnRecorder) DoReturnResults(fn MoqFile_starGenType_AddLineInfo_doReturnFn) *MoqFile_starGenType_AddLineInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_AddLineInfo_doFn
		DoReturnFn MoqFile_starGenType_AddLineInfo_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_AddLineInfo_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_AddLineInfo_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AddLineInfo {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_AddLineInfo_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_AddLineInfo_paramsKey]*MoqFile_starGenType_AddLineInfo_results{},
		}
		r.Moq.ResultsByParams_AddLineInfo = append(r.Moq.ResultsByParams_AddLineInfo, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AddLineInfo) {
			copy(r.Moq.ResultsByParams_AddLineInfo[insertAt+1:], r.Moq.ResultsByParams_AddLineInfo[insertAt:0])
			r.Moq.ResultsByParams_AddLineInfo[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AddLineInfo(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_AddLineInfo_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_AddLineInfo_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_AddLineInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqFile_starGenType_AddLineInfo_doFn
				DoReturnFn MoqFile_starGenType_AddLineInfo_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_AddLineInfo(params MoqFile_starGenType_AddLineInfo_params) string {
	return fmt.Sprintf("AddLineInfo(%#v, %#v, %#v)", params.Offset, params.Filename, params.Line)
}

func (m *MoqFile_starGenType) ParamsKey_AddLineInfo(params MoqFile_starGenType_AddLineInfo_params, anyParams uint64) MoqFile_starGenType_AddLineInfo_paramsKey {
	m.Scene.T.Helper()
	var offsetUsed int
	var offsetUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.AddLineInfo.Offset == moq.ParamIndexByValue {
			offsetUsed = params.Offset
		} else {
			offsetUsedHash = hash.DeepHash(params.Offset)
		}
	}
	var filenameUsed string
	var filenameUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.AddLineInfo.Filename == moq.ParamIndexByValue {
			filenameUsed = params.Filename
		} else {
			filenameUsedHash = hash.DeepHash(params.Filename)
		}
	}
	var lineUsed int
	var lineUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.AddLineInfo.Line == moq.ParamIndexByValue {
			lineUsed = params.Line
		} else {
			lineUsedHash = hash.DeepHash(params.Line)
		}
	}
	return MoqFile_starGenType_AddLineInfo_paramsKey{
		Params: struct {
			Offset   int
			Filename string
			Line     int
		}{
			Offset:   offsetUsed,
			Filename: filenameUsed,
			Line:     lineUsed,
		},
		Hashes: struct {
			Offset   hash.Hash
			Filename hash.Hash
			Line     hash.Hash
		}{
			Offset:   offsetUsedHash,
			Filename: filenameUsedHash,
			Line:     lineUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) AddLineColumnInfo(offset int, filename string, line, column int) *MoqFile_starGenType_AddLineColumnInfo_fnRecorder {
	return &MoqFile_starGenType_AddLineColumnInfo_fnRecorder{
		Params: MoqFile_starGenType_AddLineColumnInfo_params{
			Offset:   offset,
			Filename: filename,
			Line:     line,
			Column:   column,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_AddLineColumnInfo_fnRecorder) Any() *MoqFile_starGenType_AddLineColumnInfo_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddLineColumnInfo(r.Params))
		return nil
	}
	return &MoqFile_starGenType_AddLineColumnInfo_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_AddLineColumnInfo_anyParams) Offset() *MoqFile_starGenType_AddLineColumnInfo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFile_starGenType_AddLineColumnInfo_anyParams) Filename() *MoqFile_starGenType_AddLineColumnInfo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqFile_starGenType_AddLineColumnInfo_anyParams) Line() *MoqFile_starGenType_AddLineColumnInfo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (a *MoqFile_starGenType_AddLineColumnInfo_anyParams) Column() *MoqFile_starGenType_AddLineColumnInfo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 3
	return a.Recorder
}

func (r *MoqFile_starGenType_AddLineColumnInfo_fnRecorder) Seq() *MoqFile_starGenType_AddLineColumnInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddLineColumnInfo(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_AddLineColumnInfo_fnRecorder) NoSeq() *MoqFile_starGenType_AddLineColumnInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddLineColumnInfo(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_AddLineColumnInfo_fnRecorder) ReturnResults() *MoqFile_starGenType_AddLineColumnInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_AddLineColumnInfo_doFn
		DoReturnFn MoqFile_starGenType_AddLineColumnInfo_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_AddLineColumnInfo_fnRecorder) AndDo(fn MoqFile_starGenType_AddLineColumnInfo_doFn) *MoqFile_starGenType_AddLineColumnInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_AddLineColumnInfo_fnRecorder) DoReturnResults(fn MoqFile_starGenType_AddLineColumnInfo_doReturnFn) *MoqFile_starGenType_AddLineColumnInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFile_starGenType_AddLineColumnInfo_doFn
		DoReturnFn MoqFile_starGenType_AddLineColumnInfo_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_AddLineColumnInfo_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_AddLineColumnInfo_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AddLineColumnInfo {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_AddLineColumnInfo_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_AddLineColumnInfo_paramsKey]*MoqFile_starGenType_AddLineColumnInfo_results{},
		}
		r.Moq.ResultsByParams_AddLineColumnInfo = append(r.Moq.ResultsByParams_AddLineColumnInfo, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AddLineColumnInfo) {
			copy(r.Moq.ResultsByParams_AddLineColumnInfo[insertAt+1:], r.Moq.ResultsByParams_AddLineColumnInfo[insertAt:0])
			r.Moq.ResultsByParams_AddLineColumnInfo[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AddLineColumnInfo(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_AddLineColumnInfo_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_AddLineColumnInfo_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_AddLineColumnInfo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqFile_starGenType_AddLineColumnInfo_doFn
				DoReturnFn MoqFile_starGenType_AddLineColumnInfo_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_AddLineColumnInfo(params MoqFile_starGenType_AddLineColumnInfo_params) string {
	return fmt.Sprintf("AddLineColumnInfo(%#v, %#v, %#v, %#v)", params.Offset, params.Filename, params.Line, params.Column)
}

func (m *MoqFile_starGenType) ParamsKey_AddLineColumnInfo(params MoqFile_starGenType_AddLineColumnInfo_params, anyParams uint64) MoqFile_starGenType_AddLineColumnInfo_paramsKey {
	m.Scene.T.Helper()
	var offsetUsed int
	var offsetUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.AddLineColumnInfo.Offset == moq.ParamIndexByValue {
			offsetUsed = params.Offset
		} else {
			offsetUsedHash = hash.DeepHash(params.Offset)
		}
	}
	var filenameUsed string
	var filenameUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.AddLineColumnInfo.Filename == moq.ParamIndexByValue {
			filenameUsed = params.Filename
		} else {
			filenameUsedHash = hash.DeepHash(params.Filename)
		}
	}
	var lineUsed int
	var lineUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.AddLineColumnInfo.Line == moq.ParamIndexByValue {
			lineUsed = params.Line
		} else {
			lineUsedHash = hash.DeepHash(params.Line)
		}
	}
	var columnUsed int
	var columnUsedHash hash.Hash
	if anyParams&(1<<3) == 0 {
		if m.Runtime.ParameterIndexing.AddLineColumnInfo.Column == moq.ParamIndexByValue {
			columnUsed = params.Column
		} else {
			columnUsedHash = hash.DeepHash(params.Column)
		}
	}
	return MoqFile_starGenType_AddLineColumnInfo_paramsKey{
		Params: struct {
			Offset       int
			Filename     string
			Line, Column int
		}{
			Offset:   offsetUsed,
			Filename: filenameUsed,
			Line:     lineUsed,
			Column:   columnUsed,
		},
		Hashes: struct {
			Offset       hash.Hash
			Filename     hash.Hash
			Line, Column hash.Hash
		}{
			Offset:   offsetUsedHash,
			Filename: filenameUsedHash,
			Line:     lineUsedHash,
			Column:   columnUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) Pos(offset int) *MoqFile_starGenType_Pos_fnRecorder {
	return &MoqFile_starGenType_Pos_fnRecorder{
		Params: MoqFile_starGenType_Pos_params{
			Offset: offset,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Pos_fnRecorder) Any() *MoqFile_starGenType_Pos_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Pos(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Pos_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Pos_anyParams) Offset() *MoqFile_starGenType_Pos_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_Pos_fnRecorder) Seq() *MoqFile_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Pos(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Pos_fnRecorder) NoSeq() *MoqFile_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Pos(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Pos_fnRecorder) ReturnResults(result1 token.Pos) *MoqFile_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Pos_doFn
		DoReturnFn MoqFile_starGenType_Pos_doReturnFn
	}{
		Values: &struct {
			Result1 token.Pos
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Pos_fnRecorder) AndDo(fn MoqFile_starGenType_Pos_doFn) *MoqFile_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Pos_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Pos_doReturnFn) *MoqFile_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 token.Pos
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Pos_doFn
		DoReturnFn MoqFile_starGenType_Pos_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Pos_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Pos_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Pos {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Pos_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Pos_paramsKey]*MoqFile_starGenType_Pos_results{},
		}
		r.Moq.ResultsByParams_Pos = append(r.Moq.ResultsByParams_Pos, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Pos) {
			copy(r.Moq.ResultsByParams_Pos[insertAt+1:], r.Moq.ResultsByParams_Pos[insertAt:0])
			r.Moq.ResultsByParams_Pos[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Pos(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Pos_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Pos_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Pos_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 token.Pos
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Pos_doFn
				DoReturnFn MoqFile_starGenType_Pos_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Pos(params MoqFile_starGenType_Pos_params) string {
	return fmt.Sprintf("Pos(%#v)", params.Offset)
}

func (m *MoqFile_starGenType) ParamsKey_Pos(params MoqFile_starGenType_Pos_params, anyParams uint64) MoqFile_starGenType_Pos_paramsKey {
	m.Scene.T.Helper()
	var offsetUsed int
	var offsetUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Pos.Offset == moq.ParamIndexByValue {
			offsetUsed = params.Offset
		} else {
			offsetUsedHash = hash.DeepHash(params.Offset)
		}
	}
	return MoqFile_starGenType_Pos_paramsKey{
		Params: struct{ Offset int }{
			Offset: offsetUsed,
		},
		Hashes: struct{ Offset hash.Hash }{
			Offset: offsetUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) Offset(p token.Pos) *MoqFile_starGenType_Offset_fnRecorder {
	return &MoqFile_starGenType_Offset_fnRecorder{
		Params: MoqFile_starGenType_Offset_params{
			P: p,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Offset_fnRecorder) Any() *MoqFile_starGenType_Offset_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Offset(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Offset_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Offset_anyParams) P() *MoqFile_starGenType_Offset_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_Offset_fnRecorder) Seq() *MoqFile_starGenType_Offset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Offset(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Offset_fnRecorder) NoSeq() *MoqFile_starGenType_Offset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Offset(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Offset_fnRecorder) ReturnResults(result1 int) *MoqFile_starGenType_Offset_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Offset_doFn
		DoReturnFn MoqFile_starGenType_Offset_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Offset_fnRecorder) AndDo(fn MoqFile_starGenType_Offset_doFn) *MoqFile_starGenType_Offset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Offset_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Offset_doReturnFn) *MoqFile_starGenType_Offset_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Offset_doFn
		DoReturnFn MoqFile_starGenType_Offset_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Offset_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Offset_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Offset {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Offset_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Offset_paramsKey]*MoqFile_starGenType_Offset_results{},
		}
		r.Moq.ResultsByParams_Offset = append(r.Moq.ResultsByParams_Offset, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Offset) {
			copy(r.Moq.ResultsByParams_Offset[insertAt+1:], r.Moq.ResultsByParams_Offset[insertAt:0])
			r.Moq.ResultsByParams_Offset[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Offset(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Offset_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Offset_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Offset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Offset_doFn
				DoReturnFn MoqFile_starGenType_Offset_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Offset(params MoqFile_starGenType_Offset_params) string {
	return fmt.Sprintf("Offset(%#v)", params.P)
}

func (m *MoqFile_starGenType) ParamsKey_Offset(params MoqFile_starGenType_Offset_params, anyParams uint64) MoqFile_starGenType_Offset_paramsKey {
	m.Scene.T.Helper()
	var pUsed token.Pos
	var pUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Offset.P == moq.ParamIndexByValue {
			pUsed = params.P
		} else {
			pUsedHash = hash.DeepHash(params.P)
		}
	}
	return MoqFile_starGenType_Offset_paramsKey{
		Params: struct{ P token.Pos }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) Line(p token.Pos) *MoqFile_starGenType_Line_fnRecorder {
	return &MoqFile_starGenType_Line_fnRecorder{
		Params: MoqFile_starGenType_Line_params{
			P: p,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Line_fnRecorder) Any() *MoqFile_starGenType_Line_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Line(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Line_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Line_anyParams) P() *MoqFile_starGenType_Line_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_Line_fnRecorder) Seq() *MoqFile_starGenType_Line_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Line(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Line_fnRecorder) NoSeq() *MoqFile_starGenType_Line_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Line(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Line_fnRecorder) ReturnResults(result1 int) *MoqFile_starGenType_Line_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Line_doFn
		DoReturnFn MoqFile_starGenType_Line_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Line_fnRecorder) AndDo(fn MoqFile_starGenType_Line_doFn) *MoqFile_starGenType_Line_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Line_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Line_doReturnFn) *MoqFile_starGenType_Line_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Line_doFn
		DoReturnFn MoqFile_starGenType_Line_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Line_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Line_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Line {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Line_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Line_paramsKey]*MoqFile_starGenType_Line_results{},
		}
		r.Moq.ResultsByParams_Line = append(r.Moq.ResultsByParams_Line, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Line) {
			copy(r.Moq.ResultsByParams_Line[insertAt+1:], r.Moq.ResultsByParams_Line[insertAt:0])
			r.Moq.ResultsByParams_Line[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Line(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Line_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Line_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Line_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Line_doFn
				DoReturnFn MoqFile_starGenType_Line_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Line(params MoqFile_starGenType_Line_params) string {
	return fmt.Sprintf("Line(%#v)", params.P)
}

func (m *MoqFile_starGenType) ParamsKey_Line(params MoqFile_starGenType_Line_params, anyParams uint64) MoqFile_starGenType_Line_paramsKey {
	m.Scene.T.Helper()
	var pUsed token.Pos
	var pUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Line.P == moq.ParamIndexByValue {
			pUsed = params.P
		} else {
			pUsedHash = hash.DeepHash(params.P)
		}
	}
	return MoqFile_starGenType_Line_paramsKey{
		Params: struct{ P token.Pos }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) PositionFor(p token.Pos, adjusted bool) *MoqFile_starGenType_PositionFor_fnRecorder {
	return &MoqFile_starGenType_PositionFor_fnRecorder{
		Params: MoqFile_starGenType_PositionFor_params{
			P:        p,
			Adjusted: adjusted,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_PositionFor_fnRecorder) Any() *MoqFile_starGenType_PositionFor_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PositionFor(r.Params))
		return nil
	}
	return &MoqFile_starGenType_PositionFor_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_PositionFor_anyParams) P() *MoqFile_starGenType_PositionFor_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFile_starGenType_PositionFor_anyParams) Adjusted() *MoqFile_starGenType_PositionFor_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFile_starGenType_PositionFor_fnRecorder) Seq() *MoqFile_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PositionFor(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_PositionFor_fnRecorder) NoSeq() *MoqFile_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PositionFor(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_PositionFor_fnRecorder) ReturnResults(pos token.Position) *MoqFile_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFile_starGenType_PositionFor_doFn
		DoReturnFn MoqFile_starGenType_PositionFor_doReturnFn
	}{
		Values: &struct{ Pos token.Position }{
			Pos: pos,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_PositionFor_fnRecorder) AndDo(fn MoqFile_starGenType_PositionFor_doFn) *MoqFile_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_PositionFor_fnRecorder) DoReturnResults(fn MoqFile_starGenType_PositionFor_doReturnFn) *MoqFile_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFile_starGenType_PositionFor_doFn
		DoReturnFn MoqFile_starGenType_PositionFor_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_PositionFor_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_PositionFor_resultsByParams
	for n, res := range r.Moq.ResultsByParams_PositionFor {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_PositionFor_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_PositionFor_paramsKey]*MoqFile_starGenType_PositionFor_results{},
		}
		r.Moq.ResultsByParams_PositionFor = append(r.Moq.ResultsByParams_PositionFor, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_PositionFor) {
			copy(r.Moq.ResultsByParams_PositionFor[insertAt+1:], r.Moq.ResultsByParams_PositionFor[insertAt:0])
			r.Moq.ResultsByParams_PositionFor[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_PositionFor(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_PositionFor_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_PositionFor_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Pos token.Position }
				Sequence   uint32
				DoFn       MoqFile_starGenType_PositionFor_doFn
				DoReturnFn MoqFile_starGenType_PositionFor_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_PositionFor(params MoqFile_starGenType_PositionFor_params) string {
	return fmt.Sprintf("PositionFor(%#v, %#v)", params.P, params.Adjusted)
}

func (m *MoqFile_starGenType) ParamsKey_PositionFor(params MoqFile_starGenType_PositionFor_params, anyParams uint64) MoqFile_starGenType_PositionFor_paramsKey {
	m.Scene.T.Helper()
	var pUsed token.Pos
	var pUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.PositionFor.P == moq.ParamIndexByValue {
			pUsed = params.P
		} else {
			pUsedHash = hash.DeepHash(params.P)
		}
	}
	var adjustedUsed bool
	var adjustedUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.PositionFor.Adjusted == moq.ParamIndexByValue {
			adjustedUsed = params.Adjusted
		} else {
			adjustedUsedHash = hash.DeepHash(params.Adjusted)
		}
	}
	return MoqFile_starGenType_PositionFor_paramsKey{
		Params: struct {
			P        token.Pos
			Adjusted bool
		}{
			P:        pUsed,
			Adjusted: adjustedUsed,
		},
		Hashes: struct {
			P        hash.Hash
			Adjusted hash.Hash
		}{
			P:        pUsedHash,
			Adjusted: adjustedUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) Position(p token.Pos) *MoqFile_starGenType_Position_fnRecorder {
	return &MoqFile_starGenType_Position_fnRecorder{
		Params: MoqFile_starGenType_Position_params{
			P: p,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Position_fnRecorder) Any() *MoqFile_starGenType_Position_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Position(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Position_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Position_anyParams) P() *MoqFile_starGenType_Position_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_Position_fnRecorder) Seq() *MoqFile_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Position(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Position_fnRecorder) NoSeq() *MoqFile_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Position(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Position_fnRecorder) ReturnResults(pos token.Position) *MoqFile_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFile_starGenType_Position_doFn
		DoReturnFn MoqFile_starGenType_Position_doReturnFn
	}{
		Values: &struct{ Pos token.Position }{
			Pos: pos,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Position_fnRecorder) AndDo(fn MoqFile_starGenType_Position_doFn) *MoqFile_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Position_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Position_doReturnFn) *MoqFile_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFile_starGenType_Position_doFn
		DoReturnFn MoqFile_starGenType_Position_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Position_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Position_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Position {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Position_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Position_paramsKey]*MoqFile_starGenType_Position_results{},
		}
		r.Moq.ResultsByParams_Position = append(r.Moq.ResultsByParams_Position, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Position) {
			copy(r.Moq.ResultsByParams_Position[insertAt+1:], r.Moq.ResultsByParams_Position[insertAt:0])
			r.Moq.ResultsByParams_Position[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Position(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Position_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Position_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Pos token.Position }
				Sequence   uint32
				DoFn       MoqFile_starGenType_Position_doFn
				DoReturnFn MoqFile_starGenType_Position_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Position(params MoqFile_starGenType_Position_params) string {
	return fmt.Sprintf("Position(%#v)", params.P)
}

func (m *MoqFile_starGenType) ParamsKey_Position(params MoqFile_starGenType_Position_params, anyParams uint64) MoqFile_starGenType_Position_paramsKey {
	m.Scene.T.Helper()
	var pUsed token.Pos
	var pUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Position.P == moq.ParamIndexByValue {
			pUsed = params.P
		} else {
			pUsedHash = hash.DeepHash(params.P)
		}
	}
	return MoqFile_starGenType_Position_paramsKey{
		Params: struct{ P token.Pos }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqFile_starGenType) Reset() {
	m.ResultsByParams_Name = nil
	m.ResultsByParams_Base = nil
	m.ResultsByParams_Size = nil
	m.ResultsByParams_LineCount = nil
	m.ResultsByParams_AddLine = nil
	m.ResultsByParams_MergeLine = nil
	m.ResultsByParams_SetLines = nil
	m.ResultsByParams_SetLinesForContent = nil
	m.ResultsByParams_LineStart = nil
	m.ResultsByParams_AddLineInfo = nil
	m.ResultsByParams_AddLineColumnInfo = nil
	m.ResultsByParams_Pos = nil
	m.ResultsByParams_Offset = nil
	m.ResultsByParams_Line = nil
	m.ResultsByParams_PositionFor = nil
	m.ResultsByParams_Position = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqFile_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Name {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Name(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Base {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Base(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Size {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Size(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LineCount {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LineCount(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AddLine {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AddLine(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MergeLine {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MergeLine(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetLines {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetLines(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetLinesForContent {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetLinesForContent(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LineStart {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LineStart(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AddLineInfo {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AddLineInfo(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AddLineColumnInfo {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AddLineColumnInfo(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Pos {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Pos(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Offset {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Offset(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Line {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Line(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_PositionFor {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_PositionFor(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Position {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Position(results.Params))
			}
		}
	}
}
