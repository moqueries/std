// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package token

import (
	"fmt"
	"go/token"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that token.FileSet_starGenType is
// mocked completely
var _ FileSet_starGenType = (*MoqFileSet_starGenType_mock)(nil)

// FileSet_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type FileSet_starGenType interface {
	Base() int
	AddFile(filename string, base, size int) *token.File
	Iterate(f func(*token.File) bool)
	File(p token.Pos) (f *token.File)
	PositionFor(p token.Pos, adjusted bool) (pos token.Position)
	Position(p token.Pos) (pos token.Position)
	Read(decode func(any) error) error
	Write(encode func(any) error) error
}

// MoqFileSet_starGenType holds the state of a moq of the FileSet_starGenType
// type
type MoqFileSet_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqFileSet_starGenType_mock

	ResultsByParams_Base        []MoqFileSet_starGenType_Base_resultsByParams
	ResultsByParams_AddFile     []MoqFileSet_starGenType_AddFile_resultsByParams
	ResultsByParams_Iterate     []MoqFileSet_starGenType_Iterate_resultsByParams
	ResultsByParams_File        []MoqFileSet_starGenType_File_resultsByParams
	ResultsByParams_PositionFor []MoqFileSet_starGenType_PositionFor_resultsByParams
	ResultsByParams_Position    []MoqFileSet_starGenType_Position_resultsByParams
	ResultsByParams_Read        []MoqFileSet_starGenType_Read_resultsByParams
	ResultsByParams_Write       []MoqFileSet_starGenType_Write_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Base    struct{}
			AddFile struct {
				Filename moq.ParamIndexing
				Base     moq.ParamIndexing
				Size     moq.ParamIndexing
			}
			Iterate struct {
				F moq.ParamIndexing
			}
			File struct {
				P moq.ParamIndexing
			}
			PositionFor struct {
				P        moq.ParamIndexing
				Adjusted moq.ParamIndexing
			}
			Position struct {
				P moq.ParamIndexing
			}
			Read struct {
				Decode moq.ParamIndexing
			}
			Write struct {
				Encode moq.ParamIndexing
			}
		}
	}
	// MoqFileSet_starGenType_mock isolates the mock interface of the
}

// FileSet_starGenType type
type MoqFileSet_starGenType_mock struct {
	Moq *MoqFileSet_starGenType
}

// MoqFileSet_starGenType_recorder isolates the recorder interface of the
// FileSet_starGenType type
type MoqFileSet_starGenType_recorder struct {
	Moq *MoqFileSet_starGenType
}

// MoqFileSet_starGenType_Base_params holds the params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Base_params struct{}

// MoqFileSet_starGenType_Base_paramsKey holds the map key params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Base_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFileSet_starGenType_Base_resultsByParams contains the results for a given
// set of parameters for the FileSet_starGenType type
type MoqFileSet_starGenType_Base_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFileSet_starGenType_Base_paramsKey]*MoqFileSet_starGenType_Base_results
}

// MoqFileSet_starGenType_Base_doFn defines the type of function needed when
// calling AndDo for the FileSet_starGenType type
type MoqFileSet_starGenType_Base_doFn func()

// MoqFileSet_starGenType_Base_doReturnFn defines the type of function needed
// when calling DoReturnResults for the FileSet_starGenType type
type MoqFileSet_starGenType_Base_doReturnFn func() int

// MoqFileSet_starGenType_Base_results holds the results of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Base_results struct {
	Params  MoqFileSet_starGenType_Base_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Base_doFn
		DoReturnFn MoqFileSet_starGenType_Base_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFileSet_starGenType_Base_fnRecorder routes recorded function calls to the
// MoqFileSet_starGenType moq
type MoqFileSet_starGenType_Base_fnRecorder struct {
	Params    MoqFileSet_starGenType_Base_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFileSet_starGenType_Base_results
	Moq       *MoqFileSet_starGenType
}

// MoqFileSet_starGenType_Base_anyParams isolates the any params functions of
// the FileSet_starGenType type
type MoqFileSet_starGenType_Base_anyParams struct {
	Recorder *MoqFileSet_starGenType_Base_fnRecorder
}

// MoqFileSet_starGenType_AddFile_params holds the params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_AddFile_params struct {
	Filename   string
	Base, Size int
}

// MoqFileSet_starGenType_AddFile_paramsKey holds the map key params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_AddFile_paramsKey struct {
	Params struct {
		Filename   string
		Base, Size int
	}
	Hashes struct {
		Filename   hash.Hash
		Base, Size hash.Hash
	}
}

// MoqFileSet_starGenType_AddFile_resultsByParams contains the results for a
// given set of parameters for the FileSet_starGenType type
type MoqFileSet_starGenType_AddFile_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFileSet_starGenType_AddFile_paramsKey]*MoqFileSet_starGenType_AddFile_results
}

// MoqFileSet_starGenType_AddFile_doFn defines the type of function needed when
// calling AndDo for the FileSet_starGenType type
type MoqFileSet_starGenType_AddFile_doFn func(filename string, base, size int)

// MoqFileSet_starGenType_AddFile_doReturnFn defines the type of function
// needed when calling DoReturnResults for the FileSet_starGenType type
type MoqFileSet_starGenType_AddFile_doReturnFn func(filename string, base, size int) *token.File

// MoqFileSet_starGenType_AddFile_results holds the results of the
// FileSet_starGenType type
type MoqFileSet_starGenType_AddFile_results struct {
	Params  MoqFileSet_starGenType_AddFile_params
	Results []struct {
		Values *struct {
			Result1 *token.File
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_AddFile_doFn
		DoReturnFn MoqFileSet_starGenType_AddFile_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFileSet_starGenType_AddFile_fnRecorder routes recorded function calls to
// the MoqFileSet_starGenType moq
type MoqFileSet_starGenType_AddFile_fnRecorder struct {
	Params    MoqFileSet_starGenType_AddFile_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFileSet_starGenType_AddFile_results
	Moq       *MoqFileSet_starGenType
}

// MoqFileSet_starGenType_AddFile_anyParams isolates the any params functions
// of the FileSet_starGenType type
type MoqFileSet_starGenType_AddFile_anyParams struct {
	Recorder *MoqFileSet_starGenType_AddFile_fnRecorder
}

// MoqFileSet_starGenType_Iterate_params holds the params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Iterate_params struct{ F func(*token.File) bool }

// MoqFileSet_starGenType_Iterate_paramsKey holds the map key params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Iterate_paramsKey struct {
	Params struct{}
	Hashes struct{ F hash.Hash }
}

// MoqFileSet_starGenType_Iterate_resultsByParams contains the results for a
// given set of parameters for the FileSet_starGenType type
type MoqFileSet_starGenType_Iterate_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFileSet_starGenType_Iterate_paramsKey]*MoqFileSet_starGenType_Iterate_results
}

// MoqFileSet_starGenType_Iterate_doFn defines the type of function needed when
// calling AndDo for the FileSet_starGenType type
type MoqFileSet_starGenType_Iterate_doFn func(f func(*token.File) bool)

// MoqFileSet_starGenType_Iterate_doReturnFn defines the type of function
// needed when calling DoReturnResults for the FileSet_starGenType type
type MoqFileSet_starGenType_Iterate_doReturnFn func(f func(*token.File) bool)

// MoqFileSet_starGenType_Iterate_results holds the results of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Iterate_results struct {
	Params  MoqFileSet_starGenType_Iterate_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Iterate_doFn
		DoReturnFn MoqFileSet_starGenType_Iterate_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFileSet_starGenType_Iterate_fnRecorder routes recorded function calls to
// the MoqFileSet_starGenType moq
type MoqFileSet_starGenType_Iterate_fnRecorder struct {
	Params    MoqFileSet_starGenType_Iterate_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFileSet_starGenType_Iterate_results
	Moq       *MoqFileSet_starGenType
}

// MoqFileSet_starGenType_Iterate_anyParams isolates the any params functions
// of the FileSet_starGenType type
type MoqFileSet_starGenType_Iterate_anyParams struct {
	Recorder *MoqFileSet_starGenType_Iterate_fnRecorder
}

// MoqFileSet_starGenType_File_params holds the params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_File_params struct{ P token.Pos }

// MoqFileSet_starGenType_File_paramsKey holds the map key params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_File_paramsKey struct {
	Params struct{ P token.Pos }
	Hashes struct{ P hash.Hash }
}

// MoqFileSet_starGenType_File_resultsByParams contains the results for a given
// set of parameters for the FileSet_starGenType type
type MoqFileSet_starGenType_File_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFileSet_starGenType_File_paramsKey]*MoqFileSet_starGenType_File_results
}

// MoqFileSet_starGenType_File_doFn defines the type of function needed when
// calling AndDo for the FileSet_starGenType type
type MoqFileSet_starGenType_File_doFn func(p token.Pos)

// MoqFileSet_starGenType_File_doReturnFn defines the type of function needed
// when calling DoReturnResults for the FileSet_starGenType type
type MoqFileSet_starGenType_File_doReturnFn func(p token.Pos) (f *token.File)

// MoqFileSet_starGenType_File_results holds the results of the
// FileSet_starGenType type
type MoqFileSet_starGenType_File_results struct {
	Params  MoqFileSet_starGenType_File_params
	Results []struct {
		Values     *struct{ F *token.File }
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_File_doFn
		DoReturnFn MoqFileSet_starGenType_File_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFileSet_starGenType_File_fnRecorder routes recorded function calls to the
// MoqFileSet_starGenType moq
type MoqFileSet_starGenType_File_fnRecorder struct {
	Params    MoqFileSet_starGenType_File_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFileSet_starGenType_File_results
	Moq       *MoqFileSet_starGenType
}

// MoqFileSet_starGenType_File_anyParams isolates the any params functions of
// the FileSet_starGenType type
type MoqFileSet_starGenType_File_anyParams struct {
	Recorder *MoqFileSet_starGenType_File_fnRecorder
}

// MoqFileSet_starGenType_PositionFor_params holds the params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_PositionFor_params struct {
	P        token.Pos
	Adjusted bool
}

// MoqFileSet_starGenType_PositionFor_paramsKey holds the map key params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_PositionFor_paramsKey struct {
	Params struct {
		P        token.Pos
		Adjusted bool
	}
	Hashes struct {
		P        hash.Hash
		Adjusted hash.Hash
	}
}

// MoqFileSet_starGenType_PositionFor_resultsByParams contains the results for
// a given set of parameters for the FileSet_starGenType type
type MoqFileSet_starGenType_PositionFor_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFileSet_starGenType_PositionFor_paramsKey]*MoqFileSet_starGenType_PositionFor_results
}

// MoqFileSet_starGenType_PositionFor_doFn defines the type of function needed
// when calling AndDo for the FileSet_starGenType type
type MoqFileSet_starGenType_PositionFor_doFn func(p token.Pos, adjusted bool)

// MoqFileSet_starGenType_PositionFor_doReturnFn defines the type of function
// needed when calling DoReturnResults for the FileSet_starGenType type
type MoqFileSet_starGenType_PositionFor_doReturnFn func(p token.Pos, adjusted bool) (pos token.Position)

// MoqFileSet_starGenType_PositionFor_results holds the results of the
// FileSet_starGenType type
type MoqFileSet_starGenType_PositionFor_results struct {
	Params  MoqFileSet_starGenType_PositionFor_params
	Results []struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_PositionFor_doFn
		DoReturnFn MoqFileSet_starGenType_PositionFor_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFileSet_starGenType_PositionFor_fnRecorder routes recorded function calls
// to the MoqFileSet_starGenType moq
type MoqFileSet_starGenType_PositionFor_fnRecorder struct {
	Params    MoqFileSet_starGenType_PositionFor_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFileSet_starGenType_PositionFor_results
	Moq       *MoqFileSet_starGenType
}

// MoqFileSet_starGenType_PositionFor_anyParams isolates the any params
// functions of the FileSet_starGenType type
type MoqFileSet_starGenType_PositionFor_anyParams struct {
	Recorder *MoqFileSet_starGenType_PositionFor_fnRecorder
}

// MoqFileSet_starGenType_Position_params holds the params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Position_params struct{ P token.Pos }

// MoqFileSet_starGenType_Position_paramsKey holds the map key params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Position_paramsKey struct {
	Params struct{ P token.Pos }
	Hashes struct{ P hash.Hash }
}

// MoqFileSet_starGenType_Position_resultsByParams contains the results for a
// given set of parameters for the FileSet_starGenType type
type MoqFileSet_starGenType_Position_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFileSet_starGenType_Position_paramsKey]*MoqFileSet_starGenType_Position_results
}

// MoqFileSet_starGenType_Position_doFn defines the type of function needed
// when calling AndDo for the FileSet_starGenType type
type MoqFileSet_starGenType_Position_doFn func(p token.Pos)

// MoqFileSet_starGenType_Position_doReturnFn defines the type of function
// needed when calling DoReturnResults for the FileSet_starGenType type
type MoqFileSet_starGenType_Position_doReturnFn func(p token.Pos) (pos token.Position)

// MoqFileSet_starGenType_Position_results holds the results of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Position_results struct {
	Params  MoqFileSet_starGenType_Position_params
	Results []struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Position_doFn
		DoReturnFn MoqFileSet_starGenType_Position_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFileSet_starGenType_Position_fnRecorder routes recorded function calls to
// the MoqFileSet_starGenType moq
type MoqFileSet_starGenType_Position_fnRecorder struct {
	Params    MoqFileSet_starGenType_Position_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFileSet_starGenType_Position_results
	Moq       *MoqFileSet_starGenType
}

// MoqFileSet_starGenType_Position_anyParams isolates the any params functions
// of the FileSet_starGenType type
type MoqFileSet_starGenType_Position_anyParams struct {
	Recorder *MoqFileSet_starGenType_Position_fnRecorder
}

// MoqFileSet_starGenType_Read_params holds the params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Read_params struct{ Decode func(any) error }

// MoqFileSet_starGenType_Read_paramsKey holds the map key params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Read_paramsKey struct {
	Params struct{}
	Hashes struct{ Decode hash.Hash }
}

// MoqFileSet_starGenType_Read_resultsByParams contains the results for a given
// set of parameters for the FileSet_starGenType type
type MoqFileSet_starGenType_Read_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFileSet_starGenType_Read_paramsKey]*MoqFileSet_starGenType_Read_results
}

// MoqFileSet_starGenType_Read_doFn defines the type of function needed when
// calling AndDo for the FileSet_starGenType type
type MoqFileSet_starGenType_Read_doFn func(decode func(any) error)

// MoqFileSet_starGenType_Read_doReturnFn defines the type of function needed
// when calling DoReturnResults for the FileSet_starGenType type
type MoqFileSet_starGenType_Read_doReturnFn func(decode func(any) error) error

// MoqFileSet_starGenType_Read_results holds the results of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Read_results struct {
	Params  MoqFileSet_starGenType_Read_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Read_doFn
		DoReturnFn MoqFileSet_starGenType_Read_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFileSet_starGenType_Read_fnRecorder routes recorded function calls to the
// MoqFileSet_starGenType moq
type MoqFileSet_starGenType_Read_fnRecorder struct {
	Params    MoqFileSet_starGenType_Read_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFileSet_starGenType_Read_results
	Moq       *MoqFileSet_starGenType
}

// MoqFileSet_starGenType_Read_anyParams isolates the any params functions of
// the FileSet_starGenType type
type MoqFileSet_starGenType_Read_anyParams struct {
	Recorder *MoqFileSet_starGenType_Read_fnRecorder
}

// MoqFileSet_starGenType_Write_params holds the params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Write_params struct{ Encode func(any) error }

// MoqFileSet_starGenType_Write_paramsKey holds the map key params of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Write_paramsKey struct {
	Params struct{}
	Hashes struct{ Encode hash.Hash }
}

// MoqFileSet_starGenType_Write_resultsByParams contains the results for a
// given set of parameters for the FileSet_starGenType type
type MoqFileSet_starGenType_Write_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFileSet_starGenType_Write_paramsKey]*MoqFileSet_starGenType_Write_results
}

// MoqFileSet_starGenType_Write_doFn defines the type of function needed when
// calling AndDo for the FileSet_starGenType type
type MoqFileSet_starGenType_Write_doFn func(encode func(any) error)

// MoqFileSet_starGenType_Write_doReturnFn defines the type of function needed
// when calling DoReturnResults for the FileSet_starGenType type
type MoqFileSet_starGenType_Write_doReturnFn func(encode func(any) error) error

// MoqFileSet_starGenType_Write_results holds the results of the
// FileSet_starGenType type
type MoqFileSet_starGenType_Write_results struct {
	Params  MoqFileSet_starGenType_Write_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Write_doFn
		DoReturnFn MoqFileSet_starGenType_Write_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFileSet_starGenType_Write_fnRecorder routes recorded function calls to
// the MoqFileSet_starGenType moq
type MoqFileSet_starGenType_Write_fnRecorder struct {
	Params    MoqFileSet_starGenType_Write_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFileSet_starGenType_Write_results
	Moq       *MoqFileSet_starGenType
}

// MoqFileSet_starGenType_Write_anyParams isolates the any params functions of
// the FileSet_starGenType type
type MoqFileSet_starGenType_Write_anyParams struct {
	Recorder *MoqFileSet_starGenType_Write_fnRecorder
}

// NewMoqFileSet_starGenType creates a new moq of the FileSet_starGenType type
func NewMoqFileSet_starGenType(scene *moq.Scene, config *moq.Config) *MoqFileSet_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqFileSet_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqFileSet_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Base    struct{}
				AddFile struct {
					Filename moq.ParamIndexing
					Base     moq.ParamIndexing
					Size     moq.ParamIndexing
				}
				Iterate struct {
					F moq.ParamIndexing
				}
				File struct {
					P moq.ParamIndexing
				}
				PositionFor struct {
					P        moq.ParamIndexing
					Adjusted moq.ParamIndexing
				}
				Position struct {
					P moq.ParamIndexing
				}
				Read struct {
					Decode moq.ParamIndexing
				}
				Write struct {
					Encode moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			Base    struct{}
			AddFile struct {
				Filename moq.ParamIndexing
				Base     moq.ParamIndexing
				Size     moq.ParamIndexing
			}
			Iterate struct {
				F moq.ParamIndexing
			}
			File struct {
				P moq.ParamIndexing
			}
			PositionFor struct {
				P        moq.ParamIndexing
				Adjusted moq.ParamIndexing
			}
			Position struct {
				P moq.ParamIndexing
			}
			Read struct {
				Decode moq.ParamIndexing
			}
			Write struct {
				Encode moq.ParamIndexing
			}
		}{
			Base: struct{}{},
			AddFile: struct {
				Filename moq.ParamIndexing
				Base     moq.ParamIndexing
				Size     moq.ParamIndexing
			}{
				Filename: moq.ParamIndexByValue,
				Base:     moq.ParamIndexByValue,
				Size:     moq.ParamIndexByValue,
			},
			Iterate: struct {
				F moq.ParamIndexing
			}{
				F: moq.ParamIndexByHash,
			},
			File: struct {
				P moq.ParamIndexing
			}{
				P: moq.ParamIndexByValue,
			},
			PositionFor: struct {
				P        moq.ParamIndexing
				Adjusted moq.ParamIndexing
			}{
				P:        moq.ParamIndexByValue,
				Adjusted: moq.ParamIndexByValue,
			},
			Position: struct {
				P moq.ParamIndexing
			}{
				P: moq.ParamIndexByValue,
			},
			Read: struct {
				Decode moq.ParamIndexing
			}{
				Decode: moq.ParamIndexByHash,
			},
			Write: struct {
				Encode moq.ParamIndexing
			}{
				Encode: moq.ParamIndexByHash,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the FileSet_starGenType type
func (m *MoqFileSet_starGenType) Mock() *MoqFileSet_starGenType_mock { return m.Moq }

func (m *MoqFileSet_starGenType_mock) Base() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqFileSet_starGenType_Base_params{}
	var results *MoqFileSet_starGenType_Base_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Base {
		paramsKey := m.Moq.ParamsKey_Base(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Base(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Base(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Base(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFileSet_starGenType_mock) AddFile(filename string, base, size int) (result1 *token.File) {
	m.Moq.Scene.T.Helper()
	params := MoqFileSet_starGenType_AddFile_params{
		Filename: filename,
		Base:     base,
		Size:     size,
	}
	var results *MoqFileSet_starGenType_AddFile_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AddFile {
		paramsKey := m.Moq.ParamsKey_AddFile(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AddFile(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AddFile(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AddFile(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(filename, base, size)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(filename, base, size)
	}
	return
}

func (m *MoqFileSet_starGenType_mock) Iterate(f func(*token.File) bool) {
	m.Moq.Scene.T.Helper()
	params := MoqFileSet_starGenType_Iterate_params{
		F: f,
	}
	var results *MoqFileSet_starGenType_Iterate_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Iterate {
		paramsKey := m.Moq.ParamsKey_Iterate(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Iterate(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Iterate(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Iterate(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(f)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(f)
	}
	return
}

func (m *MoqFileSet_starGenType_mock) File(p token.Pos) (f *token.File) {
	m.Moq.Scene.T.Helper()
	params := MoqFileSet_starGenType_File_params{
		P: p,
	}
	var results *MoqFileSet_starGenType_File_results
	for _, resultsByParams := range m.Moq.ResultsByParams_File {
		paramsKey := m.Moq.ParamsKey_File(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_File(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_File(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_File(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(p)
	}

	if result.Values != nil {
		f = result.Values.F
	}
	if result.DoReturnFn != nil {
		f = result.DoReturnFn(p)
	}
	return
}

func (m *MoqFileSet_starGenType_mock) PositionFor(p token.Pos, adjusted bool) (pos token.Position) {
	m.Moq.Scene.T.Helper()
	params := MoqFileSet_starGenType_PositionFor_params{
		P:        p,
		Adjusted: adjusted,
	}
	var results *MoqFileSet_starGenType_PositionFor_results
	for _, resultsByParams := range m.Moq.ResultsByParams_PositionFor {
		paramsKey := m.Moq.ParamsKey_PositionFor(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_PositionFor(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_PositionFor(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_PositionFor(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(p, adjusted)
	}

	if result.Values != nil {
		pos = result.Values.Pos
	}
	if result.DoReturnFn != nil {
		pos = result.DoReturnFn(p, adjusted)
	}
	return
}

func (m *MoqFileSet_starGenType_mock) Position(p token.Pos) (pos token.Position) {
	m.Moq.Scene.T.Helper()
	params := MoqFileSet_starGenType_Position_params{
		P: p,
	}
	var results *MoqFileSet_starGenType_Position_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Position {
		paramsKey := m.Moq.ParamsKey_Position(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Position(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Position(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Position(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(p)
	}

	if result.Values != nil {
		pos = result.Values.Pos
	}
	if result.DoReturnFn != nil {
		pos = result.DoReturnFn(p)
	}
	return
}

func (m *MoqFileSet_starGenType_mock) Read(decode func(any) error) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFileSet_starGenType_Read_params{
		Decode: decode,
	}
	var results *MoqFileSet_starGenType_Read_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Read {
		paramsKey := m.Moq.ParamsKey_Read(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Read(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Read(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Read(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(decode)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(decode)
	}
	return
}

func (m *MoqFileSet_starGenType_mock) Write(encode func(any) error) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFileSet_starGenType_Write_params{
		Encode: encode,
	}
	var results *MoqFileSet_starGenType_Write_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Write {
		paramsKey := m.Moq.ParamsKey_Write(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Write(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Write(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Write(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(encode)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(encode)
	}
	return
}

// OnCall returns the recorder implementation of the FileSet_starGenType type
func (m *MoqFileSet_starGenType) OnCall() *MoqFileSet_starGenType_recorder {
	return &MoqFileSet_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqFileSet_starGenType_recorder) Base() *MoqFileSet_starGenType_Base_fnRecorder {
	return &MoqFileSet_starGenType_Base_fnRecorder{
		Params:   MoqFileSet_starGenType_Base_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFileSet_starGenType_Base_fnRecorder) Any() *MoqFileSet_starGenType_Base_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Base(r.Params))
		return nil
	}
	return &MoqFileSet_starGenType_Base_anyParams{Recorder: r}
}

func (r *MoqFileSet_starGenType_Base_fnRecorder) Seq() *MoqFileSet_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Base(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFileSet_starGenType_Base_fnRecorder) NoSeq() *MoqFileSet_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Base(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFileSet_starGenType_Base_fnRecorder) ReturnResults(result1 int) *MoqFileSet_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Base_doFn
		DoReturnFn MoqFileSet_starGenType_Base_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFileSet_starGenType_Base_fnRecorder) AndDo(fn MoqFileSet_starGenType_Base_doFn) *MoqFileSet_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFileSet_starGenType_Base_fnRecorder) DoReturnResults(fn MoqFileSet_starGenType_Base_doReturnFn) *MoqFileSet_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Base_doFn
		DoReturnFn MoqFileSet_starGenType_Base_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFileSet_starGenType_Base_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFileSet_starGenType_Base_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Base {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFileSet_starGenType_Base_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFileSet_starGenType_Base_paramsKey]*MoqFileSet_starGenType_Base_results{},
		}
		r.Moq.ResultsByParams_Base = append(r.Moq.ResultsByParams_Base, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Base) {
			copy(r.Moq.ResultsByParams_Base[insertAt+1:], r.Moq.ResultsByParams_Base[insertAt:0])
			r.Moq.ResultsByParams_Base[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Base(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFileSet_starGenType_Base_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFileSet_starGenType_Base_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFileSet_starGenType_Base_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqFileSet_starGenType_Base_doFn
				DoReturnFn MoqFileSet_starGenType_Base_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFileSet_starGenType) PrettyParams_Base(params MoqFileSet_starGenType_Base_params) string {
	return fmt.Sprintf("Base()")
}

func (m *MoqFileSet_starGenType) ParamsKey_Base(params MoqFileSet_starGenType_Base_params, anyParams uint64) MoqFileSet_starGenType_Base_paramsKey {
	m.Scene.T.Helper()
	return MoqFileSet_starGenType_Base_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFileSet_starGenType_recorder) AddFile(filename string, base, size int) *MoqFileSet_starGenType_AddFile_fnRecorder {
	return &MoqFileSet_starGenType_AddFile_fnRecorder{
		Params: MoqFileSet_starGenType_AddFile_params{
			Filename: filename,
			Base:     base,
			Size:     size,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFileSet_starGenType_AddFile_fnRecorder) Any() *MoqFileSet_starGenType_AddFile_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddFile(r.Params))
		return nil
	}
	return &MoqFileSet_starGenType_AddFile_anyParams{Recorder: r}
}

func (a *MoqFileSet_starGenType_AddFile_anyParams) Filename() *MoqFileSet_starGenType_AddFile_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFileSet_starGenType_AddFile_anyParams) Base() *MoqFileSet_starGenType_AddFile_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqFileSet_starGenType_AddFile_anyParams) Size() *MoqFileSet_starGenType_AddFile_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqFileSet_starGenType_AddFile_fnRecorder) Seq() *MoqFileSet_starGenType_AddFile_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddFile(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFileSet_starGenType_AddFile_fnRecorder) NoSeq() *MoqFileSet_starGenType_AddFile_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddFile(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFileSet_starGenType_AddFile_fnRecorder) ReturnResults(result1 *token.File) *MoqFileSet_starGenType_AddFile_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *token.File
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_AddFile_doFn
		DoReturnFn MoqFileSet_starGenType_AddFile_doReturnFn
	}{
		Values: &struct {
			Result1 *token.File
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFileSet_starGenType_AddFile_fnRecorder) AndDo(fn MoqFileSet_starGenType_AddFile_doFn) *MoqFileSet_starGenType_AddFile_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFileSet_starGenType_AddFile_fnRecorder) DoReturnResults(fn MoqFileSet_starGenType_AddFile_doReturnFn) *MoqFileSet_starGenType_AddFile_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *token.File
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_AddFile_doFn
		DoReturnFn MoqFileSet_starGenType_AddFile_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFileSet_starGenType_AddFile_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFileSet_starGenType_AddFile_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AddFile {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFileSet_starGenType_AddFile_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFileSet_starGenType_AddFile_paramsKey]*MoqFileSet_starGenType_AddFile_results{},
		}
		r.Moq.ResultsByParams_AddFile = append(r.Moq.ResultsByParams_AddFile, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AddFile) {
			copy(r.Moq.ResultsByParams_AddFile[insertAt+1:], r.Moq.ResultsByParams_AddFile[insertAt:0])
			r.Moq.ResultsByParams_AddFile[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AddFile(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFileSet_starGenType_AddFile_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFileSet_starGenType_AddFile_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFileSet_starGenType_AddFile_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *token.File
				}
				Sequence   uint32
				DoFn       MoqFileSet_starGenType_AddFile_doFn
				DoReturnFn MoqFileSet_starGenType_AddFile_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFileSet_starGenType) PrettyParams_AddFile(params MoqFileSet_starGenType_AddFile_params) string {
	return fmt.Sprintf("AddFile(%#v, %#v, %#v)", params.Filename, params.Base, params.Size)
}

func (m *MoqFileSet_starGenType) ParamsKey_AddFile(params MoqFileSet_starGenType_AddFile_params, anyParams uint64) MoqFileSet_starGenType_AddFile_paramsKey {
	m.Scene.T.Helper()
	var filenameUsed string
	var filenameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.AddFile.Filename == moq.ParamIndexByValue {
			filenameUsed = params.Filename
		} else {
			filenameUsedHash = hash.DeepHash(params.Filename)
		}
	}
	var baseUsed int
	var baseUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.AddFile.Base == moq.ParamIndexByValue {
			baseUsed = params.Base
		} else {
			baseUsedHash = hash.DeepHash(params.Base)
		}
	}
	var sizeUsed int
	var sizeUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.AddFile.Size == moq.ParamIndexByValue {
			sizeUsed = params.Size
		} else {
			sizeUsedHash = hash.DeepHash(params.Size)
		}
	}
	return MoqFileSet_starGenType_AddFile_paramsKey{
		Params: struct {
			Filename   string
			Base, Size int
		}{
			Filename: filenameUsed,
			Base:     baseUsed,
			Size:     sizeUsed,
		},
		Hashes: struct {
			Filename   hash.Hash
			Base, Size hash.Hash
		}{
			Filename: filenameUsedHash,
			Base:     baseUsedHash,
			Size:     sizeUsedHash,
		},
	}
}

func (m *MoqFileSet_starGenType_recorder) Iterate(f func(*token.File) bool) *MoqFileSet_starGenType_Iterate_fnRecorder {
	return &MoqFileSet_starGenType_Iterate_fnRecorder{
		Params: MoqFileSet_starGenType_Iterate_params{
			F: f,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFileSet_starGenType_Iterate_fnRecorder) Any() *MoqFileSet_starGenType_Iterate_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Iterate(r.Params))
		return nil
	}
	return &MoqFileSet_starGenType_Iterate_anyParams{Recorder: r}
}

func (a *MoqFileSet_starGenType_Iterate_anyParams) F() *MoqFileSet_starGenType_Iterate_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFileSet_starGenType_Iterate_fnRecorder) Seq() *MoqFileSet_starGenType_Iterate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Iterate(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFileSet_starGenType_Iterate_fnRecorder) NoSeq() *MoqFileSet_starGenType_Iterate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Iterate(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFileSet_starGenType_Iterate_fnRecorder) ReturnResults() *MoqFileSet_starGenType_Iterate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Iterate_doFn
		DoReturnFn MoqFileSet_starGenType_Iterate_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFileSet_starGenType_Iterate_fnRecorder) AndDo(fn MoqFileSet_starGenType_Iterate_doFn) *MoqFileSet_starGenType_Iterate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFileSet_starGenType_Iterate_fnRecorder) DoReturnResults(fn MoqFileSet_starGenType_Iterate_doReturnFn) *MoqFileSet_starGenType_Iterate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Iterate_doFn
		DoReturnFn MoqFileSet_starGenType_Iterate_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFileSet_starGenType_Iterate_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFileSet_starGenType_Iterate_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Iterate {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFileSet_starGenType_Iterate_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFileSet_starGenType_Iterate_paramsKey]*MoqFileSet_starGenType_Iterate_results{},
		}
		r.Moq.ResultsByParams_Iterate = append(r.Moq.ResultsByParams_Iterate, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Iterate) {
			copy(r.Moq.ResultsByParams_Iterate[insertAt+1:], r.Moq.ResultsByParams_Iterate[insertAt:0])
			r.Moq.ResultsByParams_Iterate[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Iterate(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFileSet_starGenType_Iterate_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFileSet_starGenType_Iterate_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFileSet_starGenType_Iterate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqFileSet_starGenType_Iterate_doFn
				DoReturnFn MoqFileSet_starGenType_Iterate_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFileSet_starGenType) PrettyParams_Iterate(params MoqFileSet_starGenType_Iterate_params) string {
	return fmt.Sprintf("Iterate(%#v)", params.F)
}

func (m *MoqFileSet_starGenType) ParamsKey_Iterate(params MoqFileSet_starGenType_Iterate_params, anyParams uint64) MoqFileSet_starGenType_Iterate_paramsKey {
	m.Scene.T.Helper()
	var fUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Iterate.F == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The f parameter of the Iterate function can't be indexed by value")
		}
		fUsedHash = hash.DeepHash(params.F)
	}
	return MoqFileSet_starGenType_Iterate_paramsKey{
		Params: struct{}{},
		Hashes: struct{ F hash.Hash }{
			F: fUsedHash,
		},
	}
}

func (m *MoqFileSet_starGenType_recorder) File(p token.Pos) *MoqFileSet_starGenType_File_fnRecorder {
	return &MoqFileSet_starGenType_File_fnRecorder{
		Params: MoqFileSet_starGenType_File_params{
			P: p,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFileSet_starGenType_File_fnRecorder) Any() *MoqFileSet_starGenType_File_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_File(r.Params))
		return nil
	}
	return &MoqFileSet_starGenType_File_anyParams{Recorder: r}
}

func (a *MoqFileSet_starGenType_File_anyParams) P() *MoqFileSet_starGenType_File_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFileSet_starGenType_File_fnRecorder) Seq() *MoqFileSet_starGenType_File_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_File(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFileSet_starGenType_File_fnRecorder) NoSeq() *MoqFileSet_starGenType_File_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_File(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFileSet_starGenType_File_fnRecorder) ReturnResults(f *token.File) *MoqFileSet_starGenType_File_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ F *token.File }
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_File_doFn
		DoReturnFn MoqFileSet_starGenType_File_doReturnFn
	}{
		Values: &struct{ F *token.File }{
			F: f,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFileSet_starGenType_File_fnRecorder) AndDo(fn MoqFileSet_starGenType_File_doFn) *MoqFileSet_starGenType_File_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFileSet_starGenType_File_fnRecorder) DoReturnResults(fn MoqFileSet_starGenType_File_doReturnFn) *MoqFileSet_starGenType_File_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ F *token.File }
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_File_doFn
		DoReturnFn MoqFileSet_starGenType_File_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFileSet_starGenType_File_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFileSet_starGenType_File_resultsByParams
	for n, res := range r.Moq.ResultsByParams_File {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFileSet_starGenType_File_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFileSet_starGenType_File_paramsKey]*MoqFileSet_starGenType_File_results{},
		}
		r.Moq.ResultsByParams_File = append(r.Moq.ResultsByParams_File, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_File) {
			copy(r.Moq.ResultsByParams_File[insertAt+1:], r.Moq.ResultsByParams_File[insertAt:0])
			r.Moq.ResultsByParams_File[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_File(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFileSet_starGenType_File_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFileSet_starGenType_File_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFileSet_starGenType_File_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ F *token.File }
				Sequence   uint32
				DoFn       MoqFileSet_starGenType_File_doFn
				DoReturnFn MoqFileSet_starGenType_File_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFileSet_starGenType) PrettyParams_File(params MoqFileSet_starGenType_File_params) string {
	return fmt.Sprintf("File(%#v)", params.P)
}

func (m *MoqFileSet_starGenType) ParamsKey_File(params MoqFileSet_starGenType_File_params, anyParams uint64) MoqFileSet_starGenType_File_paramsKey {
	m.Scene.T.Helper()
	var pUsed token.Pos
	var pUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.File.P == moq.ParamIndexByValue {
			pUsed = params.P
		} else {
			pUsedHash = hash.DeepHash(params.P)
		}
	}
	return MoqFileSet_starGenType_File_paramsKey{
		Params: struct{ P token.Pos }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqFileSet_starGenType_recorder) PositionFor(p token.Pos, adjusted bool) *MoqFileSet_starGenType_PositionFor_fnRecorder {
	return &MoqFileSet_starGenType_PositionFor_fnRecorder{
		Params: MoqFileSet_starGenType_PositionFor_params{
			P:        p,
			Adjusted: adjusted,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFileSet_starGenType_PositionFor_fnRecorder) Any() *MoqFileSet_starGenType_PositionFor_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PositionFor(r.Params))
		return nil
	}
	return &MoqFileSet_starGenType_PositionFor_anyParams{Recorder: r}
}

func (a *MoqFileSet_starGenType_PositionFor_anyParams) P() *MoqFileSet_starGenType_PositionFor_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFileSet_starGenType_PositionFor_anyParams) Adjusted() *MoqFileSet_starGenType_PositionFor_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFileSet_starGenType_PositionFor_fnRecorder) Seq() *MoqFileSet_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PositionFor(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFileSet_starGenType_PositionFor_fnRecorder) NoSeq() *MoqFileSet_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PositionFor(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFileSet_starGenType_PositionFor_fnRecorder) ReturnResults(pos token.Position) *MoqFileSet_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_PositionFor_doFn
		DoReturnFn MoqFileSet_starGenType_PositionFor_doReturnFn
	}{
		Values: &struct{ Pos token.Position }{
			Pos: pos,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFileSet_starGenType_PositionFor_fnRecorder) AndDo(fn MoqFileSet_starGenType_PositionFor_doFn) *MoqFileSet_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFileSet_starGenType_PositionFor_fnRecorder) DoReturnResults(fn MoqFileSet_starGenType_PositionFor_doReturnFn) *MoqFileSet_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_PositionFor_doFn
		DoReturnFn MoqFileSet_starGenType_PositionFor_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFileSet_starGenType_PositionFor_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFileSet_starGenType_PositionFor_resultsByParams
	for n, res := range r.Moq.ResultsByParams_PositionFor {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFileSet_starGenType_PositionFor_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFileSet_starGenType_PositionFor_paramsKey]*MoqFileSet_starGenType_PositionFor_results{},
		}
		r.Moq.ResultsByParams_PositionFor = append(r.Moq.ResultsByParams_PositionFor, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_PositionFor) {
			copy(r.Moq.ResultsByParams_PositionFor[insertAt+1:], r.Moq.ResultsByParams_PositionFor[insertAt:0])
			r.Moq.ResultsByParams_PositionFor[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_PositionFor(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFileSet_starGenType_PositionFor_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFileSet_starGenType_PositionFor_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFileSet_starGenType_PositionFor_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Pos token.Position }
				Sequence   uint32
				DoFn       MoqFileSet_starGenType_PositionFor_doFn
				DoReturnFn MoqFileSet_starGenType_PositionFor_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFileSet_starGenType) PrettyParams_PositionFor(params MoqFileSet_starGenType_PositionFor_params) string {
	return fmt.Sprintf("PositionFor(%#v, %#v)", params.P, params.Adjusted)
}

func (m *MoqFileSet_starGenType) ParamsKey_PositionFor(params MoqFileSet_starGenType_PositionFor_params, anyParams uint64) MoqFileSet_starGenType_PositionFor_paramsKey {
	m.Scene.T.Helper()
	var pUsed token.Pos
	var pUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.PositionFor.P == moq.ParamIndexByValue {
			pUsed = params.P
		} else {
			pUsedHash = hash.DeepHash(params.P)
		}
	}
	var adjustedUsed bool
	var adjustedUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.PositionFor.Adjusted == moq.ParamIndexByValue {
			adjustedUsed = params.Adjusted
		} else {
			adjustedUsedHash = hash.DeepHash(params.Adjusted)
		}
	}
	return MoqFileSet_starGenType_PositionFor_paramsKey{
		Params: struct {
			P        token.Pos
			Adjusted bool
		}{
			P:        pUsed,
			Adjusted: adjustedUsed,
		},
		Hashes: struct {
			P        hash.Hash
			Adjusted hash.Hash
		}{
			P:        pUsedHash,
			Adjusted: adjustedUsedHash,
		},
	}
}

func (m *MoqFileSet_starGenType_recorder) Position(p token.Pos) *MoqFileSet_starGenType_Position_fnRecorder {
	return &MoqFileSet_starGenType_Position_fnRecorder{
		Params: MoqFileSet_starGenType_Position_params{
			P: p,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFileSet_starGenType_Position_fnRecorder) Any() *MoqFileSet_starGenType_Position_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Position(r.Params))
		return nil
	}
	return &MoqFileSet_starGenType_Position_anyParams{Recorder: r}
}

func (a *MoqFileSet_starGenType_Position_anyParams) P() *MoqFileSet_starGenType_Position_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFileSet_starGenType_Position_fnRecorder) Seq() *MoqFileSet_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Position(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFileSet_starGenType_Position_fnRecorder) NoSeq() *MoqFileSet_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Position(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFileSet_starGenType_Position_fnRecorder) ReturnResults(pos token.Position) *MoqFileSet_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Position_doFn
		DoReturnFn MoqFileSet_starGenType_Position_doReturnFn
	}{
		Values: &struct{ Pos token.Position }{
			Pos: pos,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFileSet_starGenType_Position_fnRecorder) AndDo(fn MoqFileSet_starGenType_Position_doFn) *MoqFileSet_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFileSet_starGenType_Position_fnRecorder) DoReturnResults(fn MoqFileSet_starGenType_Position_doReturnFn) *MoqFileSet_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Pos token.Position }
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Position_doFn
		DoReturnFn MoqFileSet_starGenType_Position_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFileSet_starGenType_Position_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFileSet_starGenType_Position_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Position {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFileSet_starGenType_Position_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFileSet_starGenType_Position_paramsKey]*MoqFileSet_starGenType_Position_results{},
		}
		r.Moq.ResultsByParams_Position = append(r.Moq.ResultsByParams_Position, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Position) {
			copy(r.Moq.ResultsByParams_Position[insertAt+1:], r.Moq.ResultsByParams_Position[insertAt:0])
			r.Moq.ResultsByParams_Position[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Position(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFileSet_starGenType_Position_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFileSet_starGenType_Position_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFileSet_starGenType_Position_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Pos token.Position }
				Sequence   uint32
				DoFn       MoqFileSet_starGenType_Position_doFn
				DoReturnFn MoqFileSet_starGenType_Position_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFileSet_starGenType) PrettyParams_Position(params MoqFileSet_starGenType_Position_params) string {
	return fmt.Sprintf("Position(%#v)", params.P)
}

func (m *MoqFileSet_starGenType) ParamsKey_Position(params MoqFileSet_starGenType_Position_params, anyParams uint64) MoqFileSet_starGenType_Position_paramsKey {
	m.Scene.T.Helper()
	var pUsed token.Pos
	var pUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Position.P == moq.ParamIndexByValue {
			pUsed = params.P
		} else {
			pUsedHash = hash.DeepHash(params.P)
		}
	}
	return MoqFileSet_starGenType_Position_paramsKey{
		Params: struct{ P token.Pos }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqFileSet_starGenType_recorder) Read(decode func(any) error) *MoqFileSet_starGenType_Read_fnRecorder {
	return &MoqFileSet_starGenType_Read_fnRecorder{
		Params: MoqFileSet_starGenType_Read_params{
			Decode: decode,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFileSet_starGenType_Read_fnRecorder) Any() *MoqFileSet_starGenType_Read_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Read(r.Params))
		return nil
	}
	return &MoqFileSet_starGenType_Read_anyParams{Recorder: r}
}

func (a *MoqFileSet_starGenType_Read_anyParams) Decode() *MoqFileSet_starGenType_Read_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFileSet_starGenType_Read_fnRecorder) Seq() *MoqFileSet_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Read(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFileSet_starGenType_Read_fnRecorder) NoSeq() *MoqFileSet_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Read(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFileSet_starGenType_Read_fnRecorder) ReturnResults(result1 error) *MoqFileSet_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Read_doFn
		DoReturnFn MoqFileSet_starGenType_Read_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFileSet_starGenType_Read_fnRecorder) AndDo(fn MoqFileSet_starGenType_Read_doFn) *MoqFileSet_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFileSet_starGenType_Read_fnRecorder) DoReturnResults(fn MoqFileSet_starGenType_Read_doReturnFn) *MoqFileSet_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Read_doFn
		DoReturnFn MoqFileSet_starGenType_Read_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFileSet_starGenType_Read_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFileSet_starGenType_Read_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Read {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFileSet_starGenType_Read_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFileSet_starGenType_Read_paramsKey]*MoqFileSet_starGenType_Read_results{},
		}
		r.Moq.ResultsByParams_Read = append(r.Moq.ResultsByParams_Read, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Read) {
			copy(r.Moq.ResultsByParams_Read[insertAt+1:], r.Moq.ResultsByParams_Read[insertAt:0])
			r.Moq.ResultsByParams_Read[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Read(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFileSet_starGenType_Read_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFileSet_starGenType_Read_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFileSet_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFileSet_starGenType_Read_doFn
				DoReturnFn MoqFileSet_starGenType_Read_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFileSet_starGenType) PrettyParams_Read(params MoqFileSet_starGenType_Read_params) string {
	return fmt.Sprintf("Read(%#v)", params.Decode)
}

func (m *MoqFileSet_starGenType) ParamsKey_Read(params MoqFileSet_starGenType_Read_params, anyParams uint64) MoqFileSet_starGenType_Read_paramsKey {
	m.Scene.T.Helper()
	var decodeUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Read.Decode == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The decode parameter of the Read function can't be indexed by value")
		}
		decodeUsedHash = hash.DeepHash(params.Decode)
	}
	return MoqFileSet_starGenType_Read_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Decode hash.Hash }{
			Decode: decodeUsedHash,
		},
	}
}

func (m *MoqFileSet_starGenType_recorder) Write(encode func(any) error) *MoqFileSet_starGenType_Write_fnRecorder {
	return &MoqFileSet_starGenType_Write_fnRecorder{
		Params: MoqFileSet_starGenType_Write_params{
			Encode: encode,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFileSet_starGenType_Write_fnRecorder) Any() *MoqFileSet_starGenType_Write_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Write(r.Params))
		return nil
	}
	return &MoqFileSet_starGenType_Write_anyParams{Recorder: r}
}

func (a *MoqFileSet_starGenType_Write_anyParams) Encode() *MoqFileSet_starGenType_Write_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFileSet_starGenType_Write_fnRecorder) Seq() *MoqFileSet_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Write(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFileSet_starGenType_Write_fnRecorder) NoSeq() *MoqFileSet_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Write(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFileSet_starGenType_Write_fnRecorder) ReturnResults(result1 error) *MoqFileSet_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Write_doFn
		DoReturnFn MoqFileSet_starGenType_Write_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFileSet_starGenType_Write_fnRecorder) AndDo(fn MoqFileSet_starGenType_Write_doFn) *MoqFileSet_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFileSet_starGenType_Write_fnRecorder) DoReturnResults(fn MoqFileSet_starGenType_Write_doReturnFn) *MoqFileSet_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFileSet_starGenType_Write_doFn
		DoReturnFn MoqFileSet_starGenType_Write_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFileSet_starGenType_Write_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFileSet_starGenType_Write_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Write {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFileSet_starGenType_Write_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFileSet_starGenType_Write_paramsKey]*MoqFileSet_starGenType_Write_results{},
		}
		r.Moq.ResultsByParams_Write = append(r.Moq.ResultsByParams_Write, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Write) {
			copy(r.Moq.ResultsByParams_Write[insertAt+1:], r.Moq.ResultsByParams_Write[insertAt:0])
			r.Moq.ResultsByParams_Write[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Write(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFileSet_starGenType_Write_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFileSet_starGenType_Write_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFileSet_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFileSet_starGenType_Write_doFn
				DoReturnFn MoqFileSet_starGenType_Write_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFileSet_starGenType) PrettyParams_Write(params MoqFileSet_starGenType_Write_params) string {
	return fmt.Sprintf("Write(%#v)", params.Encode)
}

func (m *MoqFileSet_starGenType) ParamsKey_Write(params MoqFileSet_starGenType_Write_params, anyParams uint64) MoqFileSet_starGenType_Write_paramsKey {
	m.Scene.T.Helper()
	var encodeUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Write.Encode == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The encode parameter of the Write function can't be indexed by value")
		}
		encodeUsedHash = hash.DeepHash(params.Encode)
	}
	return MoqFileSet_starGenType_Write_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Encode hash.Hash }{
			Encode: encodeUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqFileSet_starGenType) Reset() {
	m.ResultsByParams_Base = nil
	m.ResultsByParams_AddFile = nil
	m.ResultsByParams_Iterate = nil
	m.ResultsByParams_File = nil
	m.ResultsByParams_PositionFor = nil
	m.ResultsByParams_Position = nil
	m.ResultsByParams_Read = nil
	m.ResultsByParams_Write = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqFileSet_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Base {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Base(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AddFile {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AddFile(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Iterate {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Iterate(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_File {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_File(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_PositionFor {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_PositionFor(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Position {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Position(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Read {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Read(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Write {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Write(results.Params))
			}
		}
	}
}
