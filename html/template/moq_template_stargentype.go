// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package template

import (
	"fmt"
	"html/template"
	"io"
	"math/bits"
	"sync/atomic"
	"text/template/parse"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that template.Template_starGenType is
// mocked completely
var _ Template_starGenType = (*MoqTemplate_starGenType_mock)(nil)

// Template_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Template_starGenType interface {
	Templates() []*template.Template
	Option(opt ...string) *template.Template
	Execute(wr io.Writer, data interface{}) error
	ExecuteTemplate(wr io.Writer, name string, data interface{}) error
	DefinedTemplates() string
	Parse(text string) (*template.Template, error)
	AddParseTree(name string, tree *parse.Tree) (*template.Template, error)
	Clone() (*template.Template, error)
	New(name string) *template.Template
	Name() string
	Funcs(funcMap template.FuncMap) *template.Template
	Delims(left, right string) *template.Template
	Lookup(name string) *template.Template
	ParseFiles(filenames ...string) (*template.Template, error)
	ParseGlob(pattern string) (*template.Template, error)
}

// MoqTemplate_starGenType holds the state of a moq of the Template_starGenType
// type
type MoqTemplate_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqTemplate_starGenType_mock

	ResultsByParams_Templates        []MoqTemplate_starGenType_Templates_resultsByParams
	ResultsByParams_Option           []MoqTemplate_starGenType_Option_resultsByParams
	ResultsByParams_Execute          []MoqTemplate_starGenType_Execute_resultsByParams
	ResultsByParams_ExecuteTemplate  []MoqTemplate_starGenType_ExecuteTemplate_resultsByParams
	ResultsByParams_DefinedTemplates []MoqTemplate_starGenType_DefinedTemplates_resultsByParams
	ResultsByParams_Parse            []MoqTemplate_starGenType_Parse_resultsByParams
	ResultsByParams_AddParseTree     []MoqTemplate_starGenType_AddParseTree_resultsByParams
	ResultsByParams_Clone            []MoqTemplate_starGenType_Clone_resultsByParams
	ResultsByParams_New              []MoqTemplate_starGenType_New_resultsByParams
	ResultsByParams_Name             []MoqTemplate_starGenType_Name_resultsByParams
	ResultsByParams_Funcs            []MoqTemplate_starGenType_Funcs_resultsByParams
	ResultsByParams_Delims           []MoqTemplate_starGenType_Delims_resultsByParams
	ResultsByParams_Lookup           []MoqTemplate_starGenType_Lookup_resultsByParams
	ResultsByParams_ParseFiles       []MoqTemplate_starGenType_ParseFiles_resultsByParams
	ResultsByParams_ParseGlob        []MoqTemplate_starGenType_ParseGlob_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Templates struct{}
			Option    struct {
				Opt moq.ParamIndexing
			}
			Execute struct {
				Wr   moq.ParamIndexing
				Data moq.ParamIndexing
			}
			ExecuteTemplate struct {
				Wr   moq.ParamIndexing
				Name moq.ParamIndexing
				Data moq.ParamIndexing
			}
			DefinedTemplates struct{}
			Parse            struct {
				Text moq.ParamIndexing
			}
			AddParseTree struct {
				Name moq.ParamIndexing
				Tree moq.ParamIndexing
			}
			Clone struct{}
			New   struct {
				Name moq.ParamIndexing
			}
			Name  struct{}
			Funcs struct {
				FuncMap moq.ParamIndexing
			}
			Delims struct {
				Left  moq.ParamIndexing
				Right moq.ParamIndexing
			}
			Lookup struct {
				Name moq.ParamIndexing
			}
			ParseFiles struct {
				Filenames moq.ParamIndexing
			}
			ParseGlob struct {
				Pattern moq.ParamIndexing
			}
		}
	}
	// MoqTemplate_starGenType_mock isolates the mock interface of the
}

// Template_starGenType type
type MoqTemplate_starGenType_mock struct {
	Moq *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_recorder isolates the recorder interface of the
// Template_starGenType type
type MoqTemplate_starGenType_recorder struct {
	Moq *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_Templates_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_Templates_params struct{}

// MoqTemplate_starGenType_Templates_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_Templates_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTemplate_starGenType_Templates_resultsByParams contains the results for a
// given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_Templates_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_Templates_paramsKey]*MoqTemplate_starGenType_Templates_results
}

// MoqTemplate_starGenType_Templates_doFn defines the type of function needed
// when calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_Templates_doFn func()

// MoqTemplate_starGenType_Templates_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_Templates_doReturnFn func() []*template.Template

// MoqTemplate_starGenType_Templates_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_Templates_results struct {
	Params  MoqTemplate_starGenType_Templates_params
	Results []struct {
		Values *struct {
			Result1 []*template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Templates_doFn
		DoReturnFn MoqTemplate_starGenType_Templates_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_Templates_fnRecorder routes recorded function calls
// to the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_Templates_fnRecorder struct {
	Params    MoqTemplate_starGenType_Templates_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_Templates_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_Templates_anyParams isolates the any params
// functions of the Template_starGenType type
type MoqTemplate_starGenType_Templates_anyParams struct {
	Recorder *MoqTemplate_starGenType_Templates_fnRecorder
}

// MoqTemplate_starGenType_Option_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_Option_params struct{ Opt []string }

// MoqTemplate_starGenType_Option_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_Option_paramsKey struct {
	Params struct{}
	Hashes struct{ Opt hash.Hash }
}

// MoqTemplate_starGenType_Option_resultsByParams contains the results for a
// given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_Option_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_Option_paramsKey]*MoqTemplate_starGenType_Option_results
}

// MoqTemplate_starGenType_Option_doFn defines the type of function needed when
// calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_Option_doFn func(opt ...string)

// MoqTemplate_starGenType_Option_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_Option_doReturnFn func(opt ...string) *template.Template

// MoqTemplate_starGenType_Option_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_Option_results struct {
	Params  MoqTemplate_starGenType_Option_params
	Results []struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Option_doFn
		DoReturnFn MoqTemplate_starGenType_Option_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_Option_fnRecorder routes recorded function calls to
// the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_Option_fnRecorder struct {
	Params    MoqTemplate_starGenType_Option_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_Option_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_Option_anyParams isolates the any params functions
// of the Template_starGenType type
type MoqTemplate_starGenType_Option_anyParams struct {
	Recorder *MoqTemplate_starGenType_Option_fnRecorder
}

// MoqTemplate_starGenType_Execute_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_Execute_params struct {
	Wr   io.Writer
	Data interface{}
}

// MoqTemplate_starGenType_Execute_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_Execute_paramsKey struct {
	Params struct {
		Wr   io.Writer
		Data interface{}
	}
	Hashes struct {
		Wr   hash.Hash
		Data hash.Hash
	}
}

// MoqTemplate_starGenType_Execute_resultsByParams contains the results for a
// given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_Execute_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_Execute_paramsKey]*MoqTemplate_starGenType_Execute_results
}

// MoqTemplate_starGenType_Execute_doFn defines the type of function needed
// when calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_Execute_doFn func(wr io.Writer, data interface{})

// MoqTemplate_starGenType_Execute_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_Execute_doReturnFn func(wr io.Writer, data interface{}) error

// MoqTemplate_starGenType_Execute_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_Execute_results struct {
	Params  MoqTemplate_starGenType_Execute_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Execute_doFn
		DoReturnFn MoqTemplate_starGenType_Execute_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_Execute_fnRecorder routes recorded function calls to
// the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_Execute_fnRecorder struct {
	Params    MoqTemplate_starGenType_Execute_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_Execute_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_Execute_anyParams isolates the any params functions
// of the Template_starGenType type
type MoqTemplate_starGenType_Execute_anyParams struct {
	Recorder *MoqTemplate_starGenType_Execute_fnRecorder
}

// MoqTemplate_starGenType_ExecuteTemplate_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_ExecuteTemplate_params struct {
	Wr   io.Writer
	Name string
	Data interface{}
}

// MoqTemplate_starGenType_ExecuteTemplate_paramsKey holds the map key params
// of the Template_starGenType type
type MoqTemplate_starGenType_ExecuteTemplate_paramsKey struct {
	Params struct {
		Wr   io.Writer
		Name string
		Data interface{}
	}
	Hashes struct {
		Wr   hash.Hash
		Name hash.Hash
		Data hash.Hash
	}
}

// MoqTemplate_starGenType_ExecuteTemplate_resultsByParams contains the results
// for a given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_ExecuteTemplate_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_ExecuteTemplate_paramsKey]*MoqTemplate_starGenType_ExecuteTemplate_results
}

// MoqTemplate_starGenType_ExecuteTemplate_doFn defines the type of function
// needed when calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_ExecuteTemplate_doFn func(wr io.Writer, name string, data interface{})

// MoqTemplate_starGenType_ExecuteTemplate_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Template_starGenType
// type
type MoqTemplate_starGenType_ExecuteTemplate_doReturnFn func(wr io.Writer, name string, data interface{}) error

// MoqTemplate_starGenType_ExecuteTemplate_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_ExecuteTemplate_results struct {
	Params  MoqTemplate_starGenType_ExecuteTemplate_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_ExecuteTemplate_doFn
		DoReturnFn MoqTemplate_starGenType_ExecuteTemplate_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_ExecuteTemplate_fnRecorder routes recorded function
// calls to the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_ExecuteTemplate_fnRecorder struct {
	Params    MoqTemplate_starGenType_ExecuteTemplate_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_ExecuteTemplate_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_ExecuteTemplate_anyParams isolates the any params
// functions of the Template_starGenType type
type MoqTemplate_starGenType_ExecuteTemplate_anyParams struct {
	Recorder *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder
}

// MoqTemplate_starGenType_DefinedTemplates_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_DefinedTemplates_params struct{}

// MoqTemplate_starGenType_DefinedTemplates_paramsKey holds the map key params
// of the Template_starGenType type
type MoqTemplate_starGenType_DefinedTemplates_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTemplate_starGenType_DefinedTemplates_resultsByParams contains the
// results for a given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_DefinedTemplates_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_DefinedTemplates_paramsKey]*MoqTemplate_starGenType_DefinedTemplates_results
}

// MoqTemplate_starGenType_DefinedTemplates_doFn defines the type of function
// needed when calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_DefinedTemplates_doFn func()

// MoqTemplate_starGenType_DefinedTemplates_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Template_starGenType
// type
type MoqTemplate_starGenType_DefinedTemplates_doReturnFn func() string

// MoqTemplate_starGenType_DefinedTemplates_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_DefinedTemplates_results struct {
	Params  MoqTemplate_starGenType_DefinedTemplates_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_DefinedTemplates_doFn
		DoReturnFn MoqTemplate_starGenType_DefinedTemplates_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_DefinedTemplates_fnRecorder routes recorded function
// calls to the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_DefinedTemplates_fnRecorder struct {
	Params    MoqTemplate_starGenType_DefinedTemplates_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_DefinedTemplates_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_DefinedTemplates_anyParams isolates the any params
// functions of the Template_starGenType type
type MoqTemplate_starGenType_DefinedTemplates_anyParams struct {
	Recorder *MoqTemplate_starGenType_DefinedTemplates_fnRecorder
}

// MoqTemplate_starGenType_Parse_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_Parse_params struct{ Text string }

// MoqTemplate_starGenType_Parse_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_Parse_paramsKey struct {
	Params struct{ Text string }
	Hashes struct{ Text hash.Hash }
}

// MoqTemplate_starGenType_Parse_resultsByParams contains the results for a
// given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_Parse_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_Parse_paramsKey]*MoqTemplate_starGenType_Parse_results
}

// MoqTemplate_starGenType_Parse_doFn defines the type of function needed when
// calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_Parse_doFn func(text string)

// MoqTemplate_starGenType_Parse_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_Parse_doReturnFn func(text string) (*template.Template, error)

// MoqTemplate_starGenType_Parse_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_Parse_results struct {
	Params  MoqTemplate_starGenType_Parse_params
	Results []struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Parse_doFn
		DoReturnFn MoqTemplate_starGenType_Parse_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_Parse_fnRecorder routes recorded function calls to
// the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_Parse_fnRecorder struct {
	Params    MoqTemplate_starGenType_Parse_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_Parse_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_Parse_anyParams isolates the any params functions of
// the Template_starGenType type
type MoqTemplate_starGenType_Parse_anyParams struct {
	Recorder *MoqTemplate_starGenType_Parse_fnRecorder
}

// MoqTemplate_starGenType_AddParseTree_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_AddParseTree_params struct {
	Name string
	Tree *parse.Tree
}

// MoqTemplate_starGenType_AddParseTree_paramsKey holds the map key params of
// the Template_starGenType type
type MoqTemplate_starGenType_AddParseTree_paramsKey struct {
	Params struct {
		Name string
		Tree *parse.Tree
	}
	Hashes struct {
		Name hash.Hash
		Tree hash.Hash
	}
}

// MoqTemplate_starGenType_AddParseTree_resultsByParams contains the results
// for a given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_AddParseTree_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_AddParseTree_paramsKey]*MoqTemplate_starGenType_AddParseTree_results
}

// MoqTemplate_starGenType_AddParseTree_doFn defines the type of function
// needed when calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_AddParseTree_doFn func(name string, tree *parse.Tree)

// MoqTemplate_starGenType_AddParseTree_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_AddParseTree_doReturnFn func(name string, tree *parse.Tree) (*template.Template, error)

// MoqTemplate_starGenType_AddParseTree_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_AddParseTree_results struct {
	Params  MoqTemplate_starGenType_AddParseTree_params
	Results []struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_AddParseTree_doFn
		DoReturnFn MoqTemplate_starGenType_AddParseTree_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_AddParseTree_fnRecorder routes recorded function
// calls to the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_AddParseTree_fnRecorder struct {
	Params    MoqTemplate_starGenType_AddParseTree_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_AddParseTree_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_AddParseTree_anyParams isolates the any params
// functions of the Template_starGenType type
type MoqTemplate_starGenType_AddParseTree_anyParams struct {
	Recorder *MoqTemplate_starGenType_AddParseTree_fnRecorder
}

// MoqTemplate_starGenType_Clone_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_Clone_params struct{}

// MoqTemplate_starGenType_Clone_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_Clone_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTemplate_starGenType_Clone_resultsByParams contains the results for a
// given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_Clone_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_Clone_paramsKey]*MoqTemplate_starGenType_Clone_results
}

// MoqTemplate_starGenType_Clone_doFn defines the type of function needed when
// calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_Clone_doFn func()

// MoqTemplate_starGenType_Clone_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_Clone_doReturnFn func() (*template.Template, error)

// MoqTemplate_starGenType_Clone_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_Clone_results struct {
	Params  MoqTemplate_starGenType_Clone_params
	Results []struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Clone_doFn
		DoReturnFn MoqTemplate_starGenType_Clone_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_Clone_fnRecorder routes recorded function calls to
// the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_Clone_fnRecorder struct {
	Params    MoqTemplate_starGenType_Clone_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_Clone_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_Clone_anyParams isolates the any params functions of
// the Template_starGenType type
type MoqTemplate_starGenType_Clone_anyParams struct {
	Recorder *MoqTemplate_starGenType_Clone_fnRecorder
}

// MoqTemplate_starGenType_New_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_New_params struct{ Name string }

// MoqTemplate_starGenType_New_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_New_paramsKey struct {
	Params struct{ Name string }
	Hashes struct{ Name hash.Hash }
}

// MoqTemplate_starGenType_New_resultsByParams contains the results for a given
// set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_New_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_New_paramsKey]*MoqTemplate_starGenType_New_results
}

// MoqTemplate_starGenType_New_doFn defines the type of function needed when
// calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_New_doFn func(name string)

// MoqTemplate_starGenType_New_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_New_doReturnFn func(name string) *template.Template

// MoqTemplate_starGenType_New_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_New_results struct {
	Params  MoqTemplate_starGenType_New_params
	Results []struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_New_doFn
		DoReturnFn MoqTemplate_starGenType_New_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_New_fnRecorder routes recorded function calls to the
// MoqTemplate_starGenType moq
type MoqTemplate_starGenType_New_fnRecorder struct {
	Params    MoqTemplate_starGenType_New_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_New_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_New_anyParams isolates the any params functions of
// the Template_starGenType type
type MoqTemplate_starGenType_New_anyParams struct {
	Recorder *MoqTemplate_starGenType_New_fnRecorder
}

// MoqTemplate_starGenType_Name_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_Name_params struct{}

// MoqTemplate_starGenType_Name_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_Name_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTemplate_starGenType_Name_resultsByParams contains the results for a
// given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_Name_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_Name_paramsKey]*MoqTemplate_starGenType_Name_results
}

// MoqTemplate_starGenType_Name_doFn defines the type of function needed when
// calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_Name_doFn func()

// MoqTemplate_starGenType_Name_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_Name_doReturnFn func() string

// MoqTemplate_starGenType_Name_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_Name_results struct {
	Params  MoqTemplate_starGenType_Name_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Name_doFn
		DoReturnFn MoqTemplate_starGenType_Name_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_Name_fnRecorder routes recorded function calls to
// the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_Name_fnRecorder struct {
	Params    MoqTemplate_starGenType_Name_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_Name_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_Name_anyParams isolates the any params functions of
// the Template_starGenType type
type MoqTemplate_starGenType_Name_anyParams struct {
	Recorder *MoqTemplate_starGenType_Name_fnRecorder
}

// MoqTemplate_starGenType_Funcs_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_Funcs_params struct{ FuncMap template.FuncMap }

// MoqTemplate_starGenType_Funcs_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_Funcs_paramsKey struct {
	Params struct{}
	Hashes struct{ FuncMap hash.Hash }
}

// MoqTemplate_starGenType_Funcs_resultsByParams contains the results for a
// given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_Funcs_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_Funcs_paramsKey]*MoqTemplate_starGenType_Funcs_results
}

// MoqTemplate_starGenType_Funcs_doFn defines the type of function needed when
// calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_Funcs_doFn func(funcMap template.FuncMap)

// MoqTemplate_starGenType_Funcs_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_Funcs_doReturnFn func(funcMap template.FuncMap) *template.Template

// MoqTemplate_starGenType_Funcs_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_Funcs_results struct {
	Params  MoqTemplate_starGenType_Funcs_params
	Results []struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Funcs_doFn
		DoReturnFn MoqTemplate_starGenType_Funcs_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_Funcs_fnRecorder routes recorded function calls to
// the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_Funcs_fnRecorder struct {
	Params    MoqTemplate_starGenType_Funcs_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_Funcs_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_Funcs_anyParams isolates the any params functions of
// the Template_starGenType type
type MoqTemplate_starGenType_Funcs_anyParams struct {
	Recorder *MoqTemplate_starGenType_Funcs_fnRecorder
}

// MoqTemplate_starGenType_Delims_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_Delims_params struct{ Left, Right string }

// MoqTemplate_starGenType_Delims_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_Delims_paramsKey struct {
	Params struct{ Left, Right string }
	Hashes struct{ Left, Right hash.Hash }
}

// MoqTemplate_starGenType_Delims_resultsByParams contains the results for a
// given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_Delims_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_Delims_paramsKey]*MoqTemplate_starGenType_Delims_results
}

// MoqTemplate_starGenType_Delims_doFn defines the type of function needed when
// calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_Delims_doFn func(left, right string)

// MoqTemplate_starGenType_Delims_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_Delims_doReturnFn func(left, right string) *template.Template

// MoqTemplate_starGenType_Delims_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_Delims_results struct {
	Params  MoqTemplate_starGenType_Delims_params
	Results []struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Delims_doFn
		DoReturnFn MoqTemplate_starGenType_Delims_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_Delims_fnRecorder routes recorded function calls to
// the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_Delims_fnRecorder struct {
	Params    MoqTemplate_starGenType_Delims_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_Delims_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_Delims_anyParams isolates the any params functions
// of the Template_starGenType type
type MoqTemplate_starGenType_Delims_anyParams struct {
	Recorder *MoqTemplate_starGenType_Delims_fnRecorder
}

// MoqTemplate_starGenType_Lookup_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_Lookup_params struct{ Name string }

// MoqTemplate_starGenType_Lookup_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_Lookup_paramsKey struct {
	Params struct{ Name string }
	Hashes struct{ Name hash.Hash }
}

// MoqTemplate_starGenType_Lookup_resultsByParams contains the results for a
// given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_Lookup_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_Lookup_paramsKey]*MoqTemplate_starGenType_Lookup_results
}

// MoqTemplate_starGenType_Lookup_doFn defines the type of function needed when
// calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_Lookup_doFn func(name string)

// MoqTemplate_starGenType_Lookup_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_Lookup_doReturnFn func(name string) *template.Template

// MoqTemplate_starGenType_Lookup_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_Lookup_results struct {
	Params  MoqTemplate_starGenType_Lookup_params
	Results []struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Lookup_doFn
		DoReturnFn MoqTemplate_starGenType_Lookup_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_Lookup_fnRecorder routes recorded function calls to
// the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_Lookup_fnRecorder struct {
	Params    MoqTemplate_starGenType_Lookup_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_Lookup_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_Lookup_anyParams isolates the any params functions
// of the Template_starGenType type
type MoqTemplate_starGenType_Lookup_anyParams struct {
	Recorder *MoqTemplate_starGenType_Lookup_fnRecorder
}

// MoqTemplate_starGenType_ParseFiles_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_ParseFiles_params struct{ Filenames []string }

// MoqTemplate_starGenType_ParseFiles_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_ParseFiles_paramsKey struct {
	Params struct{}
	Hashes struct{ Filenames hash.Hash }
}

// MoqTemplate_starGenType_ParseFiles_resultsByParams contains the results for
// a given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_ParseFiles_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_ParseFiles_paramsKey]*MoqTemplate_starGenType_ParseFiles_results
}

// MoqTemplate_starGenType_ParseFiles_doFn defines the type of function needed
// when calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_ParseFiles_doFn func(filenames ...string)

// MoqTemplate_starGenType_ParseFiles_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_ParseFiles_doReturnFn func(filenames ...string) (*template.Template, error)

// MoqTemplate_starGenType_ParseFiles_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_ParseFiles_results struct {
	Params  MoqTemplate_starGenType_ParseFiles_params
	Results []struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_ParseFiles_doFn
		DoReturnFn MoqTemplate_starGenType_ParseFiles_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_ParseFiles_fnRecorder routes recorded function calls
// to the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_ParseFiles_fnRecorder struct {
	Params    MoqTemplate_starGenType_ParseFiles_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_ParseFiles_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_ParseFiles_anyParams isolates the any params
// functions of the Template_starGenType type
type MoqTemplate_starGenType_ParseFiles_anyParams struct {
	Recorder *MoqTemplate_starGenType_ParseFiles_fnRecorder
}

// MoqTemplate_starGenType_ParseGlob_params holds the params of the
// Template_starGenType type
type MoqTemplate_starGenType_ParseGlob_params struct{ Pattern string }

// MoqTemplate_starGenType_ParseGlob_paramsKey holds the map key params of the
// Template_starGenType type
type MoqTemplate_starGenType_ParseGlob_paramsKey struct {
	Params struct{ Pattern string }
	Hashes struct{ Pattern hash.Hash }
}

// MoqTemplate_starGenType_ParseGlob_resultsByParams contains the results for a
// given set of parameters for the Template_starGenType type
type MoqTemplate_starGenType_ParseGlob_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTemplate_starGenType_ParseGlob_paramsKey]*MoqTemplate_starGenType_ParseGlob_results
}

// MoqTemplate_starGenType_ParseGlob_doFn defines the type of function needed
// when calling AndDo for the Template_starGenType type
type MoqTemplate_starGenType_ParseGlob_doFn func(pattern string)

// MoqTemplate_starGenType_ParseGlob_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Template_starGenType type
type MoqTemplate_starGenType_ParseGlob_doReturnFn func(pattern string) (*template.Template, error)

// MoqTemplate_starGenType_ParseGlob_results holds the results of the
// Template_starGenType type
type MoqTemplate_starGenType_ParseGlob_results struct {
	Params  MoqTemplate_starGenType_ParseGlob_params
	Results []struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_ParseGlob_doFn
		DoReturnFn MoqTemplate_starGenType_ParseGlob_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTemplate_starGenType_ParseGlob_fnRecorder routes recorded function calls
// to the MoqTemplate_starGenType moq
type MoqTemplate_starGenType_ParseGlob_fnRecorder struct {
	Params    MoqTemplate_starGenType_ParseGlob_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTemplate_starGenType_ParseGlob_results
	Moq       *MoqTemplate_starGenType
}

// MoqTemplate_starGenType_ParseGlob_anyParams isolates the any params
// functions of the Template_starGenType type
type MoqTemplate_starGenType_ParseGlob_anyParams struct {
	Recorder *MoqTemplate_starGenType_ParseGlob_fnRecorder
}

// NewMoqTemplate_starGenType creates a new moq of the Template_starGenType
// type
func NewMoqTemplate_starGenType(scene *moq.Scene, config *moq.Config) *MoqTemplate_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqTemplate_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqTemplate_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Templates struct{}
				Option    struct {
					Opt moq.ParamIndexing
				}
				Execute struct {
					Wr   moq.ParamIndexing
					Data moq.ParamIndexing
				}
				ExecuteTemplate struct {
					Wr   moq.ParamIndexing
					Name moq.ParamIndexing
					Data moq.ParamIndexing
				}
				DefinedTemplates struct{}
				Parse            struct {
					Text moq.ParamIndexing
				}
				AddParseTree struct {
					Name moq.ParamIndexing
					Tree moq.ParamIndexing
				}
				Clone struct{}
				New   struct {
					Name moq.ParamIndexing
				}
				Name  struct{}
				Funcs struct {
					FuncMap moq.ParamIndexing
				}
				Delims struct {
					Left  moq.ParamIndexing
					Right moq.ParamIndexing
				}
				Lookup struct {
					Name moq.ParamIndexing
				}
				ParseFiles struct {
					Filenames moq.ParamIndexing
				}
				ParseGlob struct {
					Pattern moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			Templates struct{}
			Option    struct {
				Opt moq.ParamIndexing
			}
			Execute struct {
				Wr   moq.ParamIndexing
				Data moq.ParamIndexing
			}
			ExecuteTemplate struct {
				Wr   moq.ParamIndexing
				Name moq.ParamIndexing
				Data moq.ParamIndexing
			}
			DefinedTemplates struct{}
			Parse            struct {
				Text moq.ParamIndexing
			}
			AddParseTree struct {
				Name moq.ParamIndexing
				Tree moq.ParamIndexing
			}
			Clone struct{}
			New   struct {
				Name moq.ParamIndexing
			}
			Name  struct{}
			Funcs struct {
				FuncMap moq.ParamIndexing
			}
			Delims struct {
				Left  moq.ParamIndexing
				Right moq.ParamIndexing
			}
			Lookup struct {
				Name moq.ParamIndexing
			}
			ParseFiles struct {
				Filenames moq.ParamIndexing
			}
			ParseGlob struct {
				Pattern moq.ParamIndexing
			}
		}{
			Templates: struct{}{},
			Option: struct {
				Opt moq.ParamIndexing
			}{
				Opt: moq.ParamIndexByHash,
			},
			Execute: struct {
				Wr   moq.ParamIndexing
				Data moq.ParamIndexing
			}{
				Wr:   moq.ParamIndexByHash,
				Data: moq.ParamIndexByHash,
			},
			ExecuteTemplate: struct {
				Wr   moq.ParamIndexing
				Name moq.ParamIndexing
				Data moq.ParamIndexing
			}{
				Wr:   moq.ParamIndexByHash,
				Name: moq.ParamIndexByValue,
				Data: moq.ParamIndexByHash,
			},
			DefinedTemplates: struct{}{},
			Parse: struct {
				Text moq.ParamIndexing
			}{
				Text: moq.ParamIndexByValue,
			},
			AddParseTree: struct {
				Name moq.ParamIndexing
				Tree moq.ParamIndexing
			}{
				Name: moq.ParamIndexByValue,
				Tree: moq.ParamIndexByHash,
			},
			Clone: struct{}{},
			New: struct {
				Name moq.ParamIndexing
			}{
				Name: moq.ParamIndexByValue,
			},
			Name: struct{}{},
			Funcs: struct {
				FuncMap moq.ParamIndexing
			}{
				FuncMap: moq.ParamIndexByHash,
			},
			Delims: struct {
				Left  moq.ParamIndexing
				Right moq.ParamIndexing
			}{
				Left:  moq.ParamIndexByValue,
				Right: moq.ParamIndexByValue,
			},
			Lookup: struct {
				Name moq.ParamIndexing
			}{
				Name: moq.ParamIndexByValue,
			},
			ParseFiles: struct {
				Filenames moq.ParamIndexing
			}{
				Filenames: moq.ParamIndexByHash,
			},
			ParseGlob: struct {
				Pattern moq.ParamIndexing
			}{
				Pattern: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Template_starGenType type
func (m *MoqTemplate_starGenType) Mock() *MoqTemplate_starGenType_mock { return m.Moq }

func (m *MoqTemplate_starGenType_mock) Templates() (result1 []*template.Template) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_Templates_params{}
	var results *MoqTemplate_starGenType_Templates_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Templates {
		paramsKey := m.Moq.ParamsKey_Templates(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Templates(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Templates(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Templates(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTemplate_starGenType_mock) Option(opt ...string) (result1 *template.Template) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_Option_params{
		Opt: opt,
	}
	var results *MoqTemplate_starGenType_Option_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Option {
		paramsKey := m.Moq.ParamsKey_Option(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Option(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Option(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Option(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(opt...)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(opt...)
	}
	return
}

func (m *MoqTemplate_starGenType_mock) Execute(wr io.Writer, data interface{}) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_Execute_params{
		Wr:   wr,
		Data: data,
	}
	var results *MoqTemplate_starGenType_Execute_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Execute {
		paramsKey := m.Moq.ParamsKey_Execute(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Execute(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Execute(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Execute(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(wr, data)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(wr, data)
	}
	return
}

func (m *MoqTemplate_starGenType_mock) ExecuteTemplate(wr io.Writer, name string, data interface{}) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_ExecuteTemplate_params{
		Wr:   wr,
		Name: name,
		Data: data,
	}
	var results *MoqTemplate_starGenType_ExecuteTemplate_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ExecuteTemplate {
		paramsKey := m.Moq.ParamsKey_ExecuteTemplate(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ExecuteTemplate(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ExecuteTemplate(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ExecuteTemplate(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(wr, name, data)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(wr, name, data)
	}
	return
}

func (m *MoqTemplate_starGenType_mock) DefinedTemplates() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_DefinedTemplates_params{}
	var results *MoqTemplate_starGenType_DefinedTemplates_results
	for _, resultsByParams := range m.Moq.ResultsByParams_DefinedTemplates {
		paramsKey := m.Moq.ParamsKey_DefinedTemplates(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_DefinedTemplates(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_DefinedTemplates(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_DefinedTemplates(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTemplate_starGenType_mock) Parse(text string) (result1 *template.Template, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_Parse_params{
		Text: text,
	}
	var results *MoqTemplate_starGenType_Parse_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Parse {
		paramsKey := m.Moq.ParamsKey_Parse(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Parse(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Parse(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Parse(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(text)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(text)
	}
	return
}

func (m *MoqTemplate_starGenType_mock) AddParseTree(name string, tree *parse.Tree) (result1 *template.Template, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_AddParseTree_params{
		Name: name,
		Tree: tree,
	}
	var results *MoqTemplate_starGenType_AddParseTree_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AddParseTree {
		paramsKey := m.Moq.ParamsKey_AddParseTree(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AddParseTree(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AddParseTree(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AddParseTree(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(name, tree)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(name, tree)
	}
	return
}

func (m *MoqTemplate_starGenType_mock) Clone() (result1 *template.Template, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_Clone_params{}
	var results *MoqTemplate_starGenType_Clone_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Clone {
		paramsKey := m.Moq.ParamsKey_Clone(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Clone(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Clone(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Clone(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqTemplate_starGenType_mock) New(name string) (result1 *template.Template) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_New_params{
		Name: name,
	}
	var results *MoqTemplate_starGenType_New_results
	for _, resultsByParams := range m.Moq.ResultsByParams_New {
		paramsKey := m.Moq.ParamsKey_New(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_New(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_New(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_New(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(name)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(name)
	}
	return
}

func (m *MoqTemplate_starGenType_mock) Name() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_Name_params{}
	var results *MoqTemplate_starGenType_Name_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Name {
		paramsKey := m.Moq.ParamsKey_Name(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Name(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Name(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Name(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTemplate_starGenType_mock) Funcs(funcMap template.FuncMap) (result1 *template.Template) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_Funcs_params{
		FuncMap: funcMap,
	}
	var results *MoqTemplate_starGenType_Funcs_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Funcs {
		paramsKey := m.Moq.ParamsKey_Funcs(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Funcs(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Funcs(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Funcs(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(funcMap)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(funcMap)
	}
	return
}

func (m *MoqTemplate_starGenType_mock) Delims(left, right string) (result1 *template.Template) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_Delims_params{
		Left:  left,
		Right: right,
	}
	var results *MoqTemplate_starGenType_Delims_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Delims {
		paramsKey := m.Moq.ParamsKey_Delims(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Delims(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Delims(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Delims(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(left, right)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(left, right)
	}
	return
}

func (m *MoqTemplate_starGenType_mock) Lookup(name string) (result1 *template.Template) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_Lookup_params{
		Name: name,
	}
	var results *MoqTemplate_starGenType_Lookup_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Lookup {
		paramsKey := m.Moq.ParamsKey_Lookup(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Lookup(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Lookup(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Lookup(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(name)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(name)
	}
	return
}

func (m *MoqTemplate_starGenType_mock) ParseFiles(filenames ...string) (result1 *template.Template, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_ParseFiles_params{
		Filenames: filenames,
	}
	var results *MoqTemplate_starGenType_ParseFiles_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ParseFiles {
		paramsKey := m.Moq.ParamsKey_ParseFiles(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ParseFiles(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ParseFiles(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ParseFiles(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(filenames...)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(filenames...)
	}
	return
}

func (m *MoqTemplate_starGenType_mock) ParseGlob(pattern string) (result1 *template.Template, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTemplate_starGenType_ParseGlob_params{
		Pattern: pattern,
	}
	var results *MoqTemplate_starGenType_ParseGlob_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ParseGlob {
		paramsKey := m.Moq.ParamsKey_ParseGlob(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ParseGlob(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ParseGlob(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ParseGlob(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(pattern)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(pattern)
	}
	return
}

// OnCall returns the recorder implementation of the Template_starGenType type
func (m *MoqTemplate_starGenType) OnCall() *MoqTemplate_starGenType_recorder {
	return &MoqTemplate_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqTemplate_starGenType_recorder) Templates() *MoqTemplate_starGenType_Templates_fnRecorder {
	return &MoqTemplate_starGenType_Templates_fnRecorder{
		Params:   MoqTemplate_starGenType_Templates_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_Templates_fnRecorder) Any() *MoqTemplate_starGenType_Templates_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Templates(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_Templates_anyParams{Recorder: r}
}

func (r *MoqTemplate_starGenType_Templates_fnRecorder) Seq() *MoqTemplate_starGenType_Templates_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Templates(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_Templates_fnRecorder) NoSeq() *MoqTemplate_starGenType_Templates_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Templates(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_Templates_fnRecorder) ReturnResults(result1 []*template.Template) *MoqTemplate_starGenType_Templates_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []*template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Templates_doFn
		DoReturnFn MoqTemplate_starGenType_Templates_doReturnFn
	}{
		Values: &struct {
			Result1 []*template.Template
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_Templates_fnRecorder) AndDo(fn MoqTemplate_starGenType_Templates_doFn) *MoqTemplate_starGenType_Templates_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_Templates_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_Templates_doReturnFn) *MoqTemplate_starGenType_Templates_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []*template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Templates_doFn
		DoReturnFn MoqTemplate_starGenType_Templates_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_Templates_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_Templates_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Templates {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_Templates_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_Templates_paramsKey]*MoqTemplate_starGenType_Templates_results{},
		}
		r.Moq.ResultsByParams_Templates = append(r.Moq.ResultsByParams_Templates, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Templates) {
			copy(r.Moq.ResultsByParams_Templates[insertAt+1:], r.Moq.ResultsByParams_Templates[insertAt:0])
			r.Moq.ResultsByParams_Templates[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Templates(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_Templates_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_Templates_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_Templates_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []*template.Template
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_Templates_doFn
				DoReturnFn MoqTemplate_starGenType_Templates_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_Templates(params MoqTemplate_starGenType_Templates_params) string {
	return fmt.Sprintf("Templates()")
}

func (m *MoqTemplate_starGenType) ParamsKey_Templates(params MoqTemplate_starGenType_Templates_params, anyParams uint64) MoqTemplate_starGenType_Templates_paramsKey {
	m.Scene.T.Helper()
	return MoqTemplate_starGenType_Templates_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTemplate_starGenType_recorder) Option(opt ...string) *MoqTemplate_starGenType_Option_fnRecorder {
	return &MoqTemplate_starGenType_Option_fnRecorder{
		Params: MoqTemplate_starGenType_Option_params{
			Opt: opt,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_Option_fnRecorder) Any() *MoqTemplate_starGenType_Option_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Option(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_Option_anyParams{Recorder: r}
}

func (a *MoqTemplate_starGenType_Option_anyParams) Opt() *MoqTemplate_starGenType_Option_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTemplate_starGenType_Option_fnRecorder) Seq() *MoqTemplate_starGenType_Option_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Option(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_Option_fnRecorder) NoSeq() *MoqTemplate_starGenType_Option_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Option(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_Option_fnRecorder) ReturnResults(result1 *template.Template) *MoqTemplate_starGenType_Option_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Option_doFn
		DoReturnFn MoqTemplate_starGenType_Option_doReturnFn
	}{
		Values: &struct {
			Result1 *template.Template
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_Option_fnRecorder) AndDo(fn MoqTemplate_starGenType_Option_doFn) *MoqTemplate_starGenType_Option_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_Option_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_Option_doReturnFn) *MoqTemplate_starGenType_Option_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Option_doFn
		DoReturnFn MoqTemplate_starGenType_Option_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_Option_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_Option_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Option {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_Option_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_Option_paramsKey]*MoqTemplate_starGenType_Option_results{},
		}
		r.Moq.ResultsByParams_Option = append(r.Moq.ResultsByParams_Option, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Option) {
			copy(r.Moq.ResultsByParams_Option[insertAt+1:], r.Moq.ResultsByParams_Option[insertAt:0])
			r.Moq.ResultsByParams_Option[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Option(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_Option_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_Option_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_Option_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *template.Template
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_Option_doFn
				DoReturnFn MoqTemplate_starGenType_Option_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_Option(params MoqTemplate_starGenType_Option_params) string {
	return fmt.Sprintf("Option(%#v)", params.Opt)
}

func (m *MoqTemplate_starGenType) ParamsKey_Option(params MoqTemplate_starGenType_Option_params, anyParams uint64) MoqTemplate_starGenType_Option_paramsKey {
	m.Scene.T.Helper()
	var optUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Option.Opt == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The opt parameter of the Option function can't be indexed by value")
		}
		optUsedHash = hash.DeepHash(params.Opt)
	}
	return MoqTemplate_starGenType_Option_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Opt hash.Hash }{
			Opt: optUsedHash,
		},
	}
}

func (m *MoqTemplate_starGenType_recorder) Execute(wr io.Writer, data interface{}) *MoqTemplate_starGenType_Execute_fnRecorder {
	return &MoqTemplate_starGenType_Execute_fnRecorder{
		Params: MoqTemplate_starGenType_Execute_params{
			Wr:   wr,
			Data: data,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_Execute_fnRecorder) Any() *MoqTemplate_starGenType_Execute_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Execute(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_Execute_anyParams{Recorder: r}
}

func (a *MoqTemplate_starGenType_Execute_anyParams) Wr() *MoqTemplate_starGenType_Execute_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqTemplate_starGenType_Execute_anyParams) Data() *MoqTemplate_starGenType_Execute_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqTemplate_starGenType_Execute_fnRecorder) Seq() *MoqTemplate_starGenType_Execute_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Execute(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_Execute_fnRecorder) NoSeq() *MoqTemplate_starGenType_Execute_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Execute(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_Execute_fnRecorder) ReturnResults(result1 error) *MoqTemplate_starGenType_Execute_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Execute_doFn
		DoReturnFn MoqTemplate_starGenType_Execute_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_Execute_fnRecorder) AndDo(fn MoqTemplate_starGenType_Execute_doFn) *MoqTemplate_starGenType_Execute_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_Execute_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_Execute_doReturnFn) *MoqTemplate_starGenType_Execute_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Execute_doFn
		DoReturnFn MoqTemplate_starGenType_Execute_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_Execute_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_Execute_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Execute {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_Execute_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_Execute_paramsKey]*MoqTemplate_starGenType_Execute_results{},
		}
		r.Moq.ResultsByParams_Execute = append(r.Moq.ResultsByParams_Execute, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Execute) {
			copy(r.Moq.ResultsByParams_Execute[insertAt+1:], r.Moq.ResultsByParams_Execute[insertAt:0])
			r.Moq.ResultsByParams_Execute[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Execute(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_Execute_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_Execute_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_Execute_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_Execute_doFn
				DoReturnFn MoqTemplate_starGenType_Execute_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_Execute(params MoqTemplate_starGenType_Execute_params) string {
	return fmt.Sprintf("Execute(%#v, %#v)", params.Wr, params.Data)
}

func (m *MoqTemplate_starGenType) ParamsKey_Execute(params MoqTemplate_starGenType_Execute_params, anyParams uint64) MoqTemplate_starGenType_Execute_paramsKey {
	m.Scene.T.Helper()
	var wrUsed io.Writer
	var wrUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Execute.Wr == moq.ParamIndexByValue {
			wrUsed = params.Wr
		} else {
			wrUsedHash = hash.DeepHash(params.Wr)
		}
	}
	var dataUsed interface{}
	var dataUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Execute.Data == moq.ParamIndexByValue {
			dataUsed = params.Data
		} else {
			dataUsedHash = hash.DeepHash(params.Data)
		}
	}
	return MoqTemplate_starGenType_Execute_paramsKey{
		Params: struct {
			Wr   io.Writer
			Data interface{}
		}{
			Wr:   wrUsed,
			Data: dataUsed,
		},
		Hashes: struct {
			Wr   hash.Hash
			Data hash.Hash
		}{
			Wr:   wrUsedHash,
			Data: dataUsedHash,
		},
	}
}

func (m *MoqTemplate_starGenType_recorder) ExecuteTemplate(wr io.Writer, name string, data interface{}) *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder {
	return &MoqTemplate_starGenType_ExecuteTemplate_fnRecorder{
		Params: MoqTemplate_starGenType_ExecuteTemplate_params{
			Wr:   wr,
			Name: name,
			Data: data,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder) Any() *MoqTemplate_starGenType_ExecuteTemplate_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ExecuteTemplate(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_ExecuteTemplate_anyParams{Recorder: r}
}

func (a *MoqTemplate_starGenType_ExecuteTemplate_anyParams) Wr() *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqTemplate_starGenType_ExecuteTemplate_anyParams) Name() *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqTemplate_starGenType_ExecuteTemplate_anyParams) Data() *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder) Seq() *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ExecuteTemplate(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder) NoSeq() *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ExecuteTemplate(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder) ReturnResults(result1 error) *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_ExecuteTemplate_doFn
		DoReturnFn MoqTemplate_starGenType_ExecuteTemplate_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder) AndDo(fn MoqTemplate_starGenType_ExecuteTemplate_doFn) *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_ExecuteTemplate_doReturnFn) *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_ExecuteTemplate_doFn
		DoReturnFn MoqTemplate_starGenType_ExecuteTemplate_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_ExecuteTemplate_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ExecuteTemplate {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_ExecuteTemplate_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_ExecuteTemplate_paramsKey]*MoqTemplate_starGenType_ExecuteTemplate_results{},
		}
		r.Moq.ResultsByParams_ExecuteTemplate = append(r.Moq.ResultsByParams_ExecuteTemplate, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ExecuteTemplate) {
			copy(r.Moq.ResultsByParams_ExecuteTemplate[insertAt+1:], r.Moq.ResultsByParams_ExecuteTemplate[insertAt:0])
			r.Moq.ResultsByParams_ExecuteTemplate[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ExecuteTemplate(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_ExecuteTemplate_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_ExecuteTemplate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_ExecuteTemplate_doFn
				DoReturnFn MoqTemplate_starGenType_ExecuteTemplate_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_ExecuteTemplate(params MoqTemplate_starGenType_ExecuteTemplate_params) string {
	return fmt.Sprintf("ExecuteTemplate(%#v, %#v, %#v)", params.Wr, params.Name, params.Data)
}

func (m *MoqTemplate_starGenType) ParamsKey_ExecuteTemplate(params MoqTemplate_starGenType_ExecuteTemplate_params, anyParams uint64) MoqTemplate_starGenType_ExecuteTemplate_paramsKey {
	m.Scene.T.Helper()
	var wrUsed io.Writer
	var wrUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ExecuteTemplate.Wr == moq.ParamIndexByValue {
			wrUsed = params.Wr
		} else {
			wrUsedHash = hash.DeepHash(params.Wr)
		}
	}
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ExecuteTemplate.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	var dataUsed interface{}
	var dataUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.ExecuteTemplate.Data == moq.ParamIndexByValue {
			dataUsed = params.Data
		} else {
			dataUsedHash = hash.DeepHash(params.Data)
		}
	}
	return MoqTemplate_starGenType_ExecuteTemplate_paramsKey{
		Params: struct {
			Wr   io.Writer
			Name string
			Data interface{}
		}{
			Wr:   wrUsed,
			Name: nameUsed,
			Data: dataUsed,
		},
		Hashes: struct {
			Wr   hash.Hash
			Name hash.Hash
			Data hash.Hash
		}{
			Wr:   wrUsedHash,
			Name: nameUsedHash,
			Data: dataUsedHash,
		},
	}
}

func (m *MoqTemplate_starGenType_recorder) DefinedTemplates() *MoqTemplate_starGenType_DefinedTemplates_fnRecorder {
	return &MoqTemplate_starGenType_DefinedTemplates_fnRecorder{
		Params:   MoqTemplate_starGenType_DefinedTemplates_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_DefinedTemplates_fnRecorder) Any() *MoqTemplate_starGenType_DefinedTemplates_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_DefinedTemplates(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_DefinedTemplates_anyParams{Recorder: r}
}

func (r *MoqTemplate_starGenType_DefinedTemplates_fnRecorder) Seq() *MoqTemplate_starGenType_DefinedTemplates_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_DefinedTemplates(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_DefinedTemplates_fnRecorder) NoSeq() *MoqTemplate_starGenType_DefinedTemplates_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_DefinedTemplates(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_DefinedTemplates_fnRecorder) ReturnResults(result1 string) *MoqTemplate_starGenType_DefinedTemplates_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_DefinedTemplates_doFn
		DoReturnFn MoqTemplate_starGenType_DefinedTemplates_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_DefinedTemplates_fnRecorder) AndDo(fn MoqTemplate_starGenType_DefinedTemplates_doFn) *MoqTemplate_starGenType_DefinedTemplates_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_DefinedTemplates_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_DefinedTemplates_doReturnFn) *MoqTemplate_starGenType_DefinedTemplates_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_DefinedTemplates_doFn
		DoReturnFn MoqTemplate_starGenType_DefinedTemplates_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_DefinedTemplates_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_DefinedTemplates_resultsByParams
	for n, res := range r.Moq.ResultsByParams_DefinedTemplates {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_DefinedTemplates_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_DefinedTemplates_paramsKey]*MoqTemplate_starGenType_DefinedTemplates_results{},
		}
		r.Moq.ResultsByParams_DefinedTemplates = append(r.Moq.ResultsByParams_DefinedTemplates, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_DefinedTemplates) {
			copy(r.Moq.ResultsByParams_DefinedTemplates[insertAt+1:], r.Moq.ResultsByParams_DefinedTemplates[insertAt:0])
			r.Moq.ResultsByParams_DefinedTemplates[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_DefinedTemplates(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_DefinedTemplates_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_DefinedTemplates_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_DefinedTemplates_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_DefinedTemplates_doFn
				DoReturnFn MoqTemplate_starGenType_DefinedTemplates_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_DefinedTemplates(params MoqTemplate_starGenType_DefinedTemplates_params) string {
	return fmt.Sprintf("DefinedTemplates()")
}

func (m *MoqTemplate_starGenType) ParamsKey_DefinedTemplates(params MoqTemplate_starGenType_DefinedTemplates_params, anyParams uint64) MoqTemplate_starGenType_DefinedTemplates_paramsKey {
	m.Scene.T.Helper()
	return MoqTemplate_starGenType_DefinedTemplates_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTemplate_starGenType_recorder) Parse(text string) *MoqTemplate_starGenType_Parse_fnRecorder {
	return &MoqTemplate_starGenType_Parse_fnRecorder{
		Params: MoqTemplate_starGenType_Parse_params{
			Text: text,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_Parse_fnRecorder) Any() *MoqTemplate_starGenType_Parse_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parse(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_Parse_anyParams{Recorder: r}
}

func (a *MoqTemplate_starGenType_Parse_anyParams) Text() *MoqTemplate_starGenType_Parse_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTemplate_starGenType_Parse_fnRecorder) Seq() *MoqTemplate_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parse(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_Parse_fnRecorder) NoSeq() *MoqTemplate_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parse(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_Parse_fnRecorder) ReturnResults(result1 *template.Template, result2 error) *MoqTemplate_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Parse_doFn
		DoReturnFn MoqTemplate_starGenType_Parse_doReturnFn
	}{
		Values: &struct {
			Result1 *template.Template
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_Parse_fnRecorder) AndDo(fn MoqTemplate_starGenType_Parse_doFn) *MoqTemplate_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_Parse_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_Parse_doReturnFn) *MoqTemplate_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Parse_doFn
		DoReturnFn MoqTemplate_starGenType_Parse_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_Parse_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_Parse_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Parse {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_Parse_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_Parse_paramsKey]*MoqTemplate_starGenType_Parse_results{},
		}
		r.Moq.ResultsByParams_Parse = append(r.Moq.ResultsByParams_Parse, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Parse) {
			copy(r.Moq.ResultsByParams_Parse[insertAt+1:], r.Moq.ResultsByParams_Parse[insertAt:0])
			r.Moq.ResultsByParams_Parse[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Parse(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_Parse_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_Parse_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *template.Template
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_Parse_doFn
				DoReturnFn MoqTemplate_starGenType_Parse_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_Parse(params MoqTemplate_starGenType_Parse_params) string {
	return fmt.Sprintf("Parse(%#v)", params.Text)
}

func (m *MoqTemplate_starGenType) ParamsKey_Parse(params MoqTemplate_starGenType_Parse_params, anyParams uint64) MoqTemplate_starGenType_Parse_paramsKey {
	m.Scene.T.Helper()
	var textUsed string
	var textUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Parse.Text == moq.ParamIndexByValue {
			textUsed = params.Text
		} else {
			textUsedHash = hash.DeepHash(params.Text)
		}
	}
	return MoqTemplate_starGenType_Parse_paramsKey{
		Params: struct{ Text string }{
			Text: textUsed,
		},
		Hashes: struct{ Text hash.Hash }{
			Text: textUsedHash,
		},
	}
}

func (m *MoqTemplate_starGenType_recorder) AddParseTree(name string, tree *parse.Tree) *MoqTemplate_starGenType_AddParseTree_fnRecorder {
	return &MoqTemplate_starGenType_AddParseTree_fnRecorder{
		Params: MoqTemplate_starGenType_AddParseTree_params{
			Name: name,
			Tree: tree,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_AddParseTree_fnRecorder) Any() *MoqTemplate_starGenType_AddParseTree_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddParseTree(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_AddParseTree_anyParams{Recorder: r}
}

func (a *MoqTemplate_starGenType_AddParseTree_anyParams) Name() *MoqTemplate_starGenType_AddParseTree_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqTemplate_starGenType_AddParseTree_anyParams) Tree() *MoqTemplate_starGenType_AddParseTree_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqTemplate_starGenType_AddParseTree_fnRecorder) Seq() *MoqTemplate_starGenType_AddParseTree_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddParseTree(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_AddParseTree_fnRecorder) NoSeq() *MoqTemplate_starGenType_AddParseTree_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddParseTree(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_AddParseTree_fnRecorder) ReturnResults(result1 *template.Template, result2 error) *MoqTemplate_starGenType_AddParseTree_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_AddParseTree_doFn
		DoReturnFn MoqTemplate_starGenType_AddParseTree_doReturnFn
	}{
		Values: &struct {
			Result1 *template.Template
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_AddParseTree_fnRecorder) AndDo(fn MoqTemplate_starGenType_AddParseTree_doFn) *MoqTemplate_starGenType_AddParseTree_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_AddParseTree_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_AddParseTree_doReturnFn) *MoqTemplate_starGenType_AddParseTree_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_AddParseTree_doFn
		DoReturnFn MoqTemplate_starGenType_AddParseTree_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_AddParseTree_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_AddParseTree_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AddParseTree {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_AddParseTree_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_AddParseTree_paramsKey]*MoqTemplate_starGenType_AddParseTree_results{},
		}
		r.Moq.ResultsByParams_AddParseTree = append(r.Moq.ResultsByParams_AddParseTree, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AddParseTree) {
			copy(r.Moq.ResultsByParams_AddParseTree[insertAt+1:], r.Moq.ResultsByParams_AddParseTree[insertAt:0])
			r.Moq.ResultsByParams_AddParseTree[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AddParseTree(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_AddParseTree_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_AddParseTree_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_AddParseTree_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *template.Template
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_AddParseTree_doFn
				DoReturnFn MoqTemplate_starGenType_AddParseTree_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_AddParseTree(params MoqTemplate_starGenType_AddParseTree_params) string {
	return fmt.Sprintf("AddParseTree(%#v, %#v)", params.Name, params.Tree)
}

func (m *MoqTemplate_starGenType) ParamsKey_AddParseTree(params MoqTemplate_starGenType_AddParseTree_params, anyParams uint64) MoqTemplate_starGenType_AddParseTree_paramsKey {
	m.Scene.T.Helper()
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.AddParseTree.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	var treeUsed *parse.Tree
	var treeUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.AddParseTree.Tree == moq.ParamIndexByValue {
			treeUsed = params.Tree
		} else {
			treeUsedHash = hash.DeepHash(params.Tree)
		}
	}
	return MoqTemplate_starGenType_AddParseTree_paramsKey{
		Params: struct {
			Name string
			Tree *parse.Tree
		}{
			Name: nameUsed,
			Tree: treeUsed,
		},
		Hashes: struct {
			Name hash.Hash
			Tree hash.Hash
		}{
			Name: nameUsedHash,
			Tree: treeUsedHash,
		},
	}
}

func (m *MoqTemplate_starGenType_recorder) Clone() *MoqTemplate_starGenType_Clone_fnRecorder {
	return &MoqTemplate_starGenType_Clone_fnRecorder{
		Params:   MoqTemplate_starGenType_Clone_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_Clone_fnRecorder) Any() *MoqTemplate_starGenType_Clone_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Clone(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_Clone_anyParams{Recorder: r}
}

func (r *MoqTemplate_starGenType_Clone_fnRecorder) Seq() *MoqTemplate_starGenType_Clone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Clone(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_Clone_fnRecorder) NoSeq() *MoqTemplate_starGenType_Clone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Clone(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_Clone_fnRecorder) ReturnResults(result1 *template.Template, result2 error) *MoqTemplate_starGenType_Clone_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Clone_doFn
		DoReturnFn MoqTemplate_starGenType_Clone_doReturnFn
	}{
		Values: &struct {
			Result1 *template.Template
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_Clone_fnRecorder) AndDo(fn MoqTemplate_starGenType_Clone_doFn) *MoqTemplate_starGenType_Clone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_Clone_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_Clone_doReturnFn) *MoqTemplate_starGenType_Clone_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Clone_doFn
		DoReturnFn MoqTemplate_starGenType_Clone_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_Clone_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_Clone_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Clone {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_Clone_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_Clone_paramsKey]*MoqTemplate_starGenType_Clone_results{},
		}
		r.Moq.ResultsByParams_Clone = append(r.Moq.ResultsByParams_Clone, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Clone) {
			copy(r.Moq.ResultsByParams_Clone[insertAt+1:], r.Moq.ResultsByParams_Clone[insertAt:0])
			r.Moq.ResultsByParams_Clone[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Clone(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_Clone_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_Clone_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_Clone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *template.Template
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_Clone_doFn
				DoReturnFn MoqTemplate_starGenType_Clone_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_Clone(params MoqTemplate_starGenType_Clone_params) string {
	return fmt.Sprintf("Clone()")
}

func (m *MoqTemplate_starGenType) ParamsKey_Clone(params MoqTemplate_starGenType_Clone_params, anyParams uint64) MoqTemplate_starGenType_Clone_paramsKey {
	m.Scene.T.Helper()
	return MoqTemplate_starGenType_Clone_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTemplate_starGenType_recorder) New(name string) *MoqTemplate_starGenType_New_fnRecorder {
	return &MoqTemplate_starGenType_New_fnRecorder{
		Params: MoqTemplate_starGenType_New_params{
			Name: name,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_New_fnRecorder) Any() *MoqTemplate_starGenType_New_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_New(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_New_anyParams{Recorder: r}
}

func (a *MoqTemplate_starGenType_New_anyParams) Name() *MoqTemplate_starGenType_New_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTemplate_starGenType_New_fnRecorder) Seq() *MoqTemplate_starGenType_New_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_New(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_New_fnRecorder) NoSeq() *MoqTemplate_starGenType_New_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_New(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_New_fnRecorder) ReturnResults(result1 *template.Template) *MoqTemplate_starGenType_New_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_New_doFn
		DoReturnFn MoqTemplate_starGenType_New_doReturnFn
	}{
		Values: &struct {
			Result1 *template.Template
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_New_fnRecorder) AndDo(fn MoqTemplate_starGenType_New_doFn) *MoqTemplate_starGenType_New_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_New_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_New_doReturnFn) *MoqTemplate_starGenType_New_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_New_doFn
		DoReturnFn MoqTemplate_starGenType_New_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_New_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_New_resultsByParams
	for n, res := range r.Moq.ResultsByParams_New {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_New_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_New_paramsKey]*MoqTemplate_starGenType_New_results{},
		}
		r.Moq.ResultsByParams_New = append(r.Moq.ResultsByParams_New, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_New) {
			copy(r.Moq.ResultsByParams_New[insertAt+1:], r.Moq.ResultsByParams_New[insertAt:0])
			r.Moq.ResultsByParams_New[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_New(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_New_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_New_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_New_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *template.Template
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_New_doFn
				DoReturnFn MoqTemplate_starGenType_New_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_New(params MoqTemplate_starGenType_New_params) string {
	return fmt.Sprintf("New(%#v)", params.Name)
}

func (m *MoqTemplate_starGenType) ParamsKey_New(params MoqTemplate_starGenType_New_params, anyParams uint64) MoqTemplate_starGenType_New_paramsKey {
	m.Scene.T.Helper()
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.New.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	return MoqTemplate_starGenType_New_paramsKey{
		Params: struct{ Name string }{
			Name: nameUsed,
		},
		Hashes: struct{ Name hash.Hash }{
			Name: nameUsedHash,
		},
	}
}

func (m *MoqTemplate_starGenType_recorder) Name() *MoqTemplate_starGenType_Name_fnRecorder {
	return &MoqTemplate_starGenType_Name_fnRecorder{
		Params:   MoqTemplate_starGenType_Name_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_Name_fnRecorder) Any() *MoqTemplate_starGenType_Name_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_Name_anyParams{Recorder: r}
}

func (r *MoqTemplate_starGenType_Name_fnRecorder) Seq() *MoqTemplate_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_Name_fnRecorder) NoSeq() *MoqTemplate_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_Name_fnRecorder) ReturnResults(result1 string) *MoqTemplate_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Name_doFn
		DoReturnFn MoqTemplate_starGenType_Name_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_Name_fnRecorder) AndDo(fn MoqTemplate_starGenType_Name_doFn) *MoqTemplate_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_Name_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_Name_doReturnFn) *MoqTemplate_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Name_doFn
		DoReturnFn MoqTemplate_starGenType_Name_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_Name_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_Name_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Name {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_Name_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_Name_paramsKey]*MoqTemplate_starGenType_Name_results{},
		}
		r.Moq.ResultsByParams_Name = append(r.Moq.ResultsByParams_Name, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Name) {
			copy(r.Moq.ResultsByParams_Name[insertAt+1:], r.Moq.ResultsByParams_Name[insertAt:0])
			r.Moq.ResultsByParams_Name[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Name(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_Name_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_Name_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_Name_doFn
				DoReturnFn MoqTemplate_starGenType_Name_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_Name(params MoqTemplate_starGenType_Name_params) string {
	return fmt.Sprintf("Name()")
}

func (m *MoqTemplate_starGenType) ParamsKey_Name(params MoqTemplate_starGenType_Name_params, anyParams uint64) MoqTemplate_starGenType_Name_paramsKey {
	m.Scene.T.Helper()
	return MoqTemplate_starGenType_Name_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTemplate_starGenType_recorder) Funcs(funcMap template.FuncMap) *MoqTemplate_starGenType_Funcs_fnRecorder {
	return &MoqTemplate_starGenType_Funcs_fnRecorder{
		Params: MoqTemplate_starGenType_Funcs_params{
			FuncMap: funcMap,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_Funcs_fnRecorder) Any() *MoqTemplate_starGenType_Funcs_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Funcs(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_Funcs_anyParams{Recorder: r}
}

func (a *MoqTemplate_starGenType_Funcs_anyParams) FuncMap() *MoqTemplate_starGenType_Funcs_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTemplate_starGenType_Funcs_fnRecorder) Seq() *MoqTemplate_starGenType_Funcs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Funcs(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_Funcs_fnRecorder) NoSeq() *MoqTemplate_starGenType_Funcs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Funcs(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_Funcs_fnRecorder) ReturnResults(result1 *template.Template) *MoqTemplate_starGenType_Funcs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Funcs_doFn
		DoReturnFn MoqTemplate_starGenType_Funcs_doReturnFn
	}{
		Values: &struct {
			Result1 *template.Template
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_Funcs_fnRecorder) AndDo(fn MoqTemplate_starGenType_Funcs_doFn) *MoqTemplate_starGenType_Funcs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_Funcs_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_Funcs_doReturnFn) *MoqTemplate_starGenType_Funcs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Funcs_doFn
		DoReturnFn MoqTemplate_starGenType_Funcs_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_Funcs_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_Funcs_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Funcs {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_Funcs_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_Funcs_paramsKey]*MoqTemplate_starGenType_Funcs_results{},
		}
		r.Moq.ResultsByParams_Funcs = append(r.Moq.ResultsByParams_Funcs, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Funcs) {
			copy(r.Moq.ResultsByParams_Funcs[insertAt+1:], r.Moq.ResultsByParams_Funcs[insertAt:0])
			r.Moq.ResultsByParams_Funcs[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Funcs(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_Funcs_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_Funcs_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_Funcs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *template.Template
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_Funcs_doFn
				DoReturnFn MoqTemplate_starGenType_Funcs_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_Funcs(params MoqTemplate_starGenType_Funcs_params) string {
	return fmt.Sprintf("Funcs(%#v)", params.FuncMap)
}

func (m *MoqTemplate_starGenType) ParamsKey_Funcs(params MoqTemplate_starGenType_Funcs_params, anyParams uint64) MoqTemplate_starGenType_Funcs_paramsKey {
	m.Scene.T.Helper()
	var funcMapUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Funcs.FuncMap == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The funcMap parameter of the Funcs function can't be indexed by value")
		}
		funcMapUsedHash = hash.DeepHash(params.FuncMap)
	}
	return MoqTemplate_starGenType_Funcs_paramsKey{
		Params: struct{}{},
		Hashes: struct{ FuncMap hash.Hash }{
			FuncMap: funcMapUsedHash,
		},
	}
}

func (m *MoqTemplate_starGenType_recorder) Delims(left, right string) *MoqTemplate_starGenType_Delims_fnRecorder {
	return &MoqTemplate_starGenType_Delims_fnRecorder{
		Params: MoqTemplate_starGenType_Delims_params{
			Left:  left,
			Right: right,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_Delims_fnRecorder) Any() *MoqTemplate_starGenType_Delims_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Delims(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_Delims_anyParams{Recorder: r}
}

func (a *MoqTemplate_starGenType_Delims_anyParams) Left() *MoqTemplate_starGenType_Delims_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqTemplate_starGenType_Delims_anyParams) Right() *MoqTemplate_starGenType_Delims_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqTemplate_starGenType_Delims_fnRecorder) Seq() *MoqTemplate_starGenType_Delims_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Delims(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_Delims_fnRecorder) NoSeq() *MoqTemplate_starGenType_Delims_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Delims(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_Delims_fnRecorder) ReturnResults(result1 *template.Template) *MoqTemplate_starGenType_Delims_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Delims_doFn
		DoReturnFn MoqTemplate_starGenType_Delims_doReturnFn
	}{
		Values: &struct {
			Result1 *template.Template
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_Delims_fnRecorder) AndDo(fn MoqTemplate_starGenType_Delims_doFn) *MoqTemplate_starGenType_Delims_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_Delims_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_Delims_doReturnFn) *MoqTemplate_starGenType_Delims_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Delims_doFn
		DoReturnFn MoqTemplate_starGenType_Delims_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_Delims_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_Delims_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Delims {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_Delims_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_Delims_paramsKey]*MoqTemplate_starGenType_Delims_results{},
		}
		r.Moq.ResultsByParams_Delims = append(r.Moq.ResultsByParams_Delims, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Delims) {
			copy(r.Moq.ResultsByParams_Delims[insertAt+1:], r.Moq.ResultsByParams_Delims[insertAt:0])
			r.Moq.ResultsByParams_Delims[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Delims(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_Delims_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_Delims_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_Delims_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *template.Template
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_Delims_doFn
				DoReturnFn MoqTemplate_starGenType_Delims_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_Delims(params MoqTemplate_starGenType_Delims_params) string {
	return fmt.Sprintf("Delims(%#v, %#v)", params.Left, params.Right)
}

func (m *MoqTemplate_starGenType) ParamsKey_Delims(params MoqTemplate_starGenType_Delims_params, anyParams uint64) MoqTemplate_starGenType_Delims_paramsKey {
	m.Scene.T.Helper()
	var leftUsed string
	var leftUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Delims.Left == moq.ParamIndexByValue {
			leftUsed = params.Left
		} else {
			leftUsedHash = hash.DeepHash(params.Left)
		}
	}
	var rightUsed string
	var rightUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Delims.Right == moq.ParamIndexByValue {
			rightUsed = params.Right
		} else {
			rightUsedHash = hash.DeepHash(params.Right)
		}
	}
	return MoqTemplate_starGenType_Delims_paramsKey{
		Params: struct{ Left, Right string }{
			Left:  leftUsed,
			Right: rightUsed,
		},
		Hashes: struct{ Left, Right hash.Hash }{
			Left:  leftUsedHash,
			Right: rightUsedHash,
		},
	}
}

func (m *MoqTemplate_starGenType_recorder) Lookup(name string) *MoqTemplate_starGenType_Lookup_fnRecorder {
	return &MoqTemplate_starGenType_Lookup_fnRecorder{
		Params: MoqTemplate_starGenType_Lookup_params{
			Name: name,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_Lookup_fnRecorder) Any() *MoqTemplate_starGenType_Lookup_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Lookup(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_Lookup_anyParams{Recorder: r}
}

func (a *MoqTemplate_starGenType_Lookup_anyParams) Name() *MoqTemplate_starGenType_Lookup_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTemplate_starGenType_Lookup_fnRecorder) Seq() *MoqTemplate_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Lookup(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_Lookup_fnRecorder) NoSeq() *MoqTemplate_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Lookup(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_Lookup_fnRecorder) ReturnResults(result1 *template.Template) *MoqTemplate_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Lookup_doFn
		DoReturnFn MoqTemplate_starGenType_Lookup_doReturnFn
	}{
		Values: &struct {
			Result1 *template.Template
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_Lookup_fnRecorder) AndDo(fn MoqTemplate_starGenType_Lookup_doFn) *MoqTemplate_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_Lookup_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_Lookup_doReturnFn) *MoqTemplate_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_Lookup_doFn
		DoReturnFn MoqTemplate_starGenType_Lookup_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_Lookup_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_Lookup_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Lookup {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_Lookup_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_Lookup_paramsKey]*MoqTemplate_starGenType_Lookup_results{},
		}
		r.Moq.ResultsByParams_Lookup = append(r.Moq.ResultsByParams_Lookup, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Lookup) {
			copy(r.Moq.ResultsByParams_Lookup[insertAt+1:], r.Moq.ResultsByParams_Lookup[insertAt:0])
			r.Moq.ResultsByParams_Lookup[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Lookup(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_Lookup_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_Lookup_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_Lookup_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *template.Template
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_Lookup_doFn
				DoReturnFn MoqTemplate_starGenType_Lookup_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_Lookup(params MoqTemplate_starGenType_Lookup_params) string {
	return fmt.Sprintf("Lookup(%#v)", params.Name)
}

func (m *MoqTemplate_starGenType) ParamsKey_Lookup(params MoqTemplate_starGenType_Lookup_params, anyParams uint64) MoqTemplate_starGenType_Lookup_paramsKey {
	m.Scene.T.Helper()
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Lookup.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	return MoqTemplate_starGenType_Lookup_paramsKey{
		Params: struct{ Name string }{
			Name: nameUsed,
		},
		Hashes: struct{ Name hash.Hash }{
			Name: nameUsedHash,
		},
	}
}

func (m *MoqTemplate_starGenType_recorder) ParseFiles(filenames ...string) *MoqTemplate_starGenType_ParseFiles_fnRecorder {
	return &MoqTemplate_starGenType_ParseFiles_fnRecorder{
		Params: MoqTemplate_starGenType_ParseFiles_params{
			Filenames: filenames,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_ParseFiles_fnRecorder) Any() *MoqTemplate_starGenType_ParseFiles_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ParseFiles(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_ParseFiles_anyParams{Recorder: r}
}

func (a *MoqTemplate_starGenType_ParseFiles_anyParams) Filenames() *MoqTemplate_starGenType_ParseFiles_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTemplate_starGenType_ParseFiles_fnRecorder) Seq() *MoqTemplate_starGenType_ParseFiles_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ParseFiles(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_ParseFiles_fnRecorder) NoSeq() *MoqTemplate_starGenType_ParseFiles_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ParseFiles(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_ParseFiles_fnRecorder) ReturnResults(result1 *template.Template, result2 error) *MoqTemplate_starGenType_ParseFiles_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_ParseFiles_doFn
		DoReturnFn MoqTemplate_starGenType_ParseFiles_doReturnFn
	}{
		Values: &struct {
			Result1 *template.Template
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_ParseFiles_fnRecorder) AndDo(fn MoqTemplate_starGenType_ParseFiles_doFn) *MoqTemplate_starGenType_ParseFiles_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_ParseFiles_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_ParseFiles_doReturnFn) *MoqTemplate_starGenType_ParseFiles_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_ParseFiles_doFn
		DoReturnFn MoqTemplate_starGenType_ParseFiles_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_ParseFiles_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_ParseFiles_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ParseFiles {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_ParseFiles_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_ParseFiles_paramsKey]*MoqTemplate_starGenType_ParseFiles_results{},
		}
		r.Moq.ResultsByParams_ParseFiles = append(r.Moq.ResultsByParams_ParseFiles, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ParseFiles) {
			copy(r.Moq.ResultsByParams_ParseFiles[insertAt+1:], r.Moq.ResultsByParams_ParseFiles[insertAt:0])
			r.Moq.ResultsByParams_ParseFiles[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ParseFiles(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_ParseFiles_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_ParseFiles_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_ParseFiles_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *template.Template
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_ParseFiles_doFn
				DoReturnFn MoqTemplate_starGenType_ParseFiles_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_ParseFiles(params MoqTemplate_starGenType_ParseFiles_params) string {
	return fmt.Sprintf("ParseFiles(%#v)", params.Filenames)
}

func (m *MoqTemplate_starGenType) ParamsKey_ParseFiles(params MoqTemplate_starGenType_ParseFiles_params, anyParams uint64) MoqTemplate_starGenType_ParseFiles_paramsKey {
	m.Scene.T.Helper()
	var filenamesUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ParseFiles.Filenames == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The filenames parameter of the ParseFiles function can't be indexed by value")
		}
		filenamesUsedHash = hash.DeepHash(params.Filenames)
	}
	return MoqTemplate_starGenType_ParseFiles_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Filenames hash.Hash }{
			Filenames: filenamesUsedHash,
		},
	}
}

func (m *MoqTemplate_starGenType_recorder) ParseGlob(pattern string) *MoqTemplate_starGenType_ParseGlob_fnRecorder {
	return &MoqTemplate_starGenType_ParseGlob_fnRecorder{
		Params: MoqTemplate_starGenType_ParseGlob_params{
			Pattern: pattern,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTemplate_starGenType_ParseGlob_fnRecorder) Any() *MoqTemplate_starGenType_ParseGlob_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ParseGlob(r.Params))
		return nil
	}
	return &MoqTemplate_starGenType_ParseGlob_anyParams{Recorder: r}
}

func (a *MoqTemplate_starGenType_ParseGlob_anyParams) Pattern() *MoqTemplate_starGenType_ParseGlob_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTemplate_starGenType_ParseGlob_fnRecorder) Seq() *MoqTemplate_starGenType_ParseGlob_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ParseGlob(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTemplate_starGenType_ParseGlob_fnRecorder) NoSeq() *MoqTemplate_starGenType_ParseGlob_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ParseGlob(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTemplate_starGenType_ParseGlob_fnRecorder) ReturnResults(result1 *template.Template, result2 error) *MoqTemplate_starGenType_ParseGlob_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_ParseGlob_doFn
		DoReturnFn MoqTemplate_starGenType_ParseGlob_doReturnFn
	}{
		Values: &struct {
			Result1 *template.Template
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTemplate_starGenType_ParseGlob_fnRecorder) AndDo(fn MoqTemplate_starGenType_ParseGlob_doFn) *MoqTemplate_starGenType_ParseGlob_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTemplate_starGenType_ParseGlob_fnRecorder) DoReturnResults(fn MoqTemplate_starGenType_ParseGlob_doReturnFn) *MoqTemplate_starGenType_ParseGlob_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *template.Template
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTemplate_starGenType_ParseGlob_doFn
		DoReturnFn MoqTemplate_starGenType_ParseGlob_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTemplate_starGenType_ParseGlob_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTemplate_starGenType_ParseGlob_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ParseGlob {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTemplate_starGenType_ParseGlob_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTemplate_starGenType_ParseGlob_paramsKey]*MoqTemplate_starGenType_ParseGlob_results{},
		}
		r.Moq.ResultsByParams_ParseGlob = append(r.Moq.ResultsByParams_ParseGlob, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ParseGlob) {
			copy(r.Moq.ResultsByParams_ParseGlob[insertAt+1:], r.Moq.ResultsByParams_ParseGlob[insertAt:0])
			r.Moq.ResultsByParams_ParseGlob[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ParseGlob(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTemplate_starGenType_ParseGlob_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTemplate_starGenType_ParseGlob_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTemplate_starGenType_ParseGlob_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *template.Template
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqTemplate_starGenType_ParseGlob_doFn
				DoReturnFn MoqTemplate_starGenType_ParseGlob_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTemplate_starGenType) PrettyParams_ParseGlob(params MoqTemplate_starGenType_ParseGlob_params) string {
	return fmt.Sprintf("ParseGlob(%#v)", params.Pattern)
}

func (m *MoqTemplate_starGenType) ParamsKey_ParseGlob(params MoqTemplate_starGenType_ParseGlob_params, anyParams uint64) MoqTemplate_starGenType_ParseGlob_paramsKey {
	m.Scene.T.Helper()
	var patternUsed string
	var patternUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ParseGlob.Pattern == moq.ParamIndexByValue {
			patternUsed = params.Pattern
		} else {
			patternUsedHash = hash.DeepHash(params.Pattern)
		}
	}
	return MoqTemplate_starGenType_ParseGlob_paramsKey{
		Params: struct{ Pattern string }{
			Pattern: patternUsed,
		},
		Hashes: struct{ Pattern hash.Hash }{
			Pattern: patternUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqTemplate_starGenType) Reset() {
	m.ResultsByParams_Templates = nil
	m.ResultsByParams_Option = nil
	m.ResultsByParams_Execute = nil
	m.ResultsByParams_ExecuteTemplate = nil
	m.ResultsByParams_DefinedTemplates = nil
	m.ResultsByParams_Parse = nil
	m.ResultsByParams_AddParseTree = nil
	m.ResultsByParams_Clone = nil
	m.ResultsByParams_New = nil
	m.ResultsByParams_Name = nil
	m.ResultsByParams_Funcs = nil
	m.ResultsByParams_Delims = nil
	m.ResultsByParams_Lookup = nil
	m.ResultsByParams_ParseFiles = nil
	m.ResultsByParams_ParseGlob = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqTemplate_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Templates {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Templates(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Option {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Option(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Execute {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Execute(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ExecuteTemplate {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ExecuteTemplate(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_DefinedTemplates {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_DefinedTemplates(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Parse {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Parse(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AddParseTree {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AddParseTree(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Clone {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Clone(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_New {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_New(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Name {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Name(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Funcs {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Funcs(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Delims {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Delims(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Lookup {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Lookup(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ParseFiles {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ParseFiles(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ParseGlob {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ParseGlob(results.Params))
			}
		}
	}
}
