// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package os

import (
	"fmt"
	"math/bits"
	"os"
	"sync/atomic"
	"syscall"
	"time"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that os.File_starGenType is mocked
// completely
var _ File_starGenType = (*MoqFile_starGenType_mock)(nil)

// File_starGenType is the fabricated implementation type of this mock (emitted
// when mocking a collections of methods directly and not from an interface
// type)
type File_starGenType interface {
	Readdir(n int) ([]os.FileInfo, error)
	Readdirnames(n int) (names []string, err error)
	Name() string
	Read(b []byte) (n int, err error)
	ReadAt(b []byte, off int64) (n int, err error)
	Write(b []byte) (n int, err error)
	WriteAt(b []byte, off int64) (n int, err error)
	Seek(offset int64, whence int) (ret int64, err error)
	WriteString(s string) (n int, err error)
	Chmod(mode os.FileMode) error
	SetDeadline(t time.Time) error
	SetReadDeadline(t time.Time) error
	SetWriteDeadline(t time.Time) error
	SyscallConn() (syscall.RawConn, error)
	Chown(uid, gid int) error
	Truncate(size int64) error
	Sync() error
	Chdir() error
	Fd() uintptr
	Close() error
	Stat() (os.FileInfo, error)
}

// MoqFile_starGenType holds the state of a moq of the File_starGenType type
type MoqFile_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqFile_starGenType_mock

	ResultsByParams_Readdir          []MoqFile_starGenType_Readdir_resultsByParams
	ResultsByParams_Readdirnames     []MoqFile_starGenType_Readdirnames_resultsByParams
	ResultsByParams_Name             []MoqFile_starGenType_Name_resultsByParams
	ResultsByParams_Read             []MoqFile_starGenType_Read_resultsByParams
	ResultsByParams_ReadAt           []MoqFile_starGenType_ReadAt_resultsByParams
	ResultsByParams_Write            []MoqFile_starGenType_Write_resultsByParams
	ResultsByParams_WriteAt          []MoqFile_starGenType_WriteAt_resultsByParams
	ResultsByParams_Seek             []MoqFile_starGenType_Seek_resultsByParams
	ResultsByParams_WriteString      []MoqFile_starGenType_WriteString_resultsByParams
	ResultsByParams_Chmod            []MoqFile_starGenType_Chmod_resultsByParams
	ResultsByParams_SetDeadline      []MoqFile_starGenType_SetDeadline_resultsByParams
	ResultsByParams_SetReadDeadline  []MoqFile_starGenType_SetReadDeadline_resultsByParams
	ResultsByParams_SetWriteDeadline []MoqFile_starGenType_SetWriteDeadline_resultsByParams
	ResultsByParams_SyscallConn      []MoqFile_starGenType_SyscallConn_resultsByParams
	ResultsByParams_Chown            []MoqFile_starGenType_Chown_resultsByParams
	ResultsByParams_Truncate         []MoqFile_starGenType_Truncate_resultsByParams
	ResultsByParams_Sync             []MoqFile_starGenType_Sync_resultsByParams
	ResultsByParams_Chdir            []MoqFile_starGenType_Chdir_resultsByParams
	ResultsByParams_Fd               []MoqFile_starGenType_Fd_resultsByParams
	ResultsByParams_Close            []MoqFile_starGenType_Close_resultsByParams
	ResultsByParams_Stat             []MoqFile_starGenType_Stat_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Readdir struct {
				N moq.ParamIndexing
			}
			Readdirnames struct {
				N moq.ParamIndexing
			}
			Name struct{}
			Read struct {
				B moq.ParamIndexing
			}
			ReadAt struct {
				B   moq.ParamIndexing
				Off moq.ParamIndexing
			}
			Write struct {
				B moq.ParamIndexing
			}
			WriteAt struct {
				B   moq.ParamIndexing
				Off moq.ParamIndexing
			}
			Seek struct {
				Offset moq.ParamIndexing
				Whence moq.ParamIndexing
			}
			WriteString struct {
				S moq.ParamIndexing
			}
			Chmod struct {
				Mode moq.ParamIndexing
			}
			SetDeadline struct {
				T moq.ParamIndexing
			}
			SetReadDeadline struct {
				T moq.ParamIndexing
			}
			SetWriteDeadline struct {
				T moq.ParamIndexing
			}
			SyscallConn struct{}
			Chown       struct {
				Uid moq.ParamIndexing
				Gid moq.ParamIndexing
			}
			Truncate struct {
				Size moq.ParamIndexing
			}
			Sync  struct{}
			Chdir struct{}
			Fd    struct{}
			Close struct{}
			Stat  struct{}
		}
	}
}

// MoqFile_starGenType_mock isolates the mock interface of the File_starGenType
// type
type MoqFile_starGenType_mock struct {
	Moq *MoqFile_starGenType
}

// MoqFile_starGenType_recorder isolates the recorder interface of the
// File_starGenType type
type MoqFile_starGenType_recorder struct {
	Moq *MoqFile_starGenType
}

// MoqFile_starGenType_Readdir_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Readdir_params struct{ N int }

// MoqFile_starGenType_Readdir_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Readdir_paramsKey struct {
	Params struct{ N int }
	Hashes struct{ N hash.Hash }
}

// MoqFile_starGenType_Readdir_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Readdir_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Readdir_paramsKey]*MoqFile_starGenType_Readdir_results
}

// MoqFile_starGenType_Readdir_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Readdir_doFn func(n int)

// MoqFile_starGenType_Readdir_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Readdir_doReturnFn func(n int) ([]os.FileInfo, error)

// MoqFile_starGenType_Readdir_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_Readdir_results struct {
	Params  MoqFile_starGenType_Readdir_params
	Results []struct {
		Values *struct {
			Result1 []os.FileInfo
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Readdir_doFn
		DoReturnFn MoqFile_starGenType_Readdir_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Readdir_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Readdir_fnRecorder struct {
	Params    MoqFile_starGenType_Readdir_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Readdir_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Readdir_anyParams isolates the any params functions of
// the File_starGenType type
type MoqFile_starGenType_Readdir_anyParams struct {
	Recorder *MoqFile_starGenType_Readdir_fnRecorder
}

// MoqFile_starGenType_Readdirnames_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_Readdirnames_params struct{ N int }

// MoqFile_starGenType_Readdirnames_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Readdirnames_paramsKey struct {
	Params struct{ N int }
	Hashes struct{ N hash.Hash }
}

// MoqFile_starGenType_Readdirnames_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_Readdirnames_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Readdirnames_paramsKey]*MoqFile_starGenType_Readdirnames_results
}

// MoqFile_starGenType_Readdirnames_doFn defines the type of function needed
// when calling AndDo for the File_starGenType type
type MoqFile_starGenType_Readdirnames_doFn func(n int)

// MoqFile_starGenType_Readdirnames_doReturnFn defines the type of function
// needed when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Readdirnames_doReturnFn func(n int) (names []string, err error)

// MoqFile_starGenType_Readdirnames_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_Readdirnames_results struct {
	Params  MoqFile_starGenType_Readdirnames_params
	Results []struct {
		Values *struct {
			Names []string
			Err   error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Readdirnames_doFn
		DoReturnFn MoqFile_starGenType_Readdirnames_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Readdirnames_fnRecorder routes recorded function calls
// to the MoqFile_starGenType moq
type MoqFile_starGenType_Readdirnames_fnRecorder struct {
	Params    MoqFile_starGenType_Readdirnames_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Readdirnames_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Readdirnames_anyParams isolates the any params functions
// of the File_starGenType type
type MoqFile_starGenType_Readdirnames_anyParams struct {
	Recorder *MoqFile_starGenType_Readdirnames_fnRecorder
}

// MoqFile_starGenType_Name_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Name_params struct{}

// MoqFile_starGenType_Name_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Name_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFile_starGenType_Name_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Name_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Name_paramsKey]*MoqFile_starGenType_Name_results
}

// MoqFile_starGenType_Name_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Name_doFn func()

// MoqFile_starGenType_Name_doReturnFn defines the type of function needed when
// calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Name_doReturnFn func() string

// MoqFile_starGenType_Name_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Name_results struct {
	Params  MoqFile_starGenType_Name_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Name_doFn
		DoReturnFn MoqFile_starGenType_Name_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Name_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Name_fnRecorder struct {
	Params    MoqFile_starGenType_Name_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Name_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Name_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Name_anyParams struct {
	Recorder *MoqFile_starGenType_Name_fnRecorder
}

// MoqFile_starGenType_Read_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Read_params struct{ B []byte }

// MoqFile_starGenType_Read_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Read_paramsKey struct {
	Params struct{}
	Hashes struct{ B hash.Hash }
}

// MoqFile_starGenType_Read_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Read_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Read_paramsKey]*MoqFile_starGenType_Read_results
}

// MoqFile_starGenType_Read_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Read_doFn func(b []byte)

// MoqFile_starGenType_Read_doReturnFn defines the type of function needed when
// calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Read_doReturnFn func(b []byte) (n int, err error)

// MoqFile_starGenType_Read_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Read_results struct {
	Params  MoqFile_starGenType_Read_params
	Results []struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Read_doFn
		DoReturnFn MoqFile_starGenType_Read_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Read_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Read_fnRecorder struct {
	Params    MoqFile_starGenType_Read_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Read_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Read_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Read_anyParams struct {
	Recorder *MoqFile_starGenType_Read_fnRecorder
}

// MoqFile_starGenType_ReadAt_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_ReadAt_params struct {
	B   []byte
	Off int64
}

// MoqFile_starGenType_ReadAt_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_ReadAt_paramsKey struct {
	Params struct{ Off int64 }
	Hashes struct {
		B   hash.Hash
		Off hash.Hash
	}
}

// MoqFile_starGenType_ReadAt_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_ReadAt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_ReadAt_paramsKey]*MoqFile_starGenType_ReadAt_results
}

// MoqFile_starGenType_ReadAt_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_ReadAt_doFn func(b []byte, off int64)

// MoqFile_starGenType_ReadAt_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_ReadAt_doReturnFn func(b []byte, off int64) (n int, err error)

// MoqFile_starGenType_ReadAt_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_ReadAt_results struct {
	Params  MoqFile_starGenType_ReadAt_params
	Results []struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_ReadAt_doFn
		DoReturnFn MoqFile_starGenType_ReadAt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_ReadAt_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_ReadAt_fnRecorder struct {
	Params    MoqFile_starGenType_ReadAt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_ReadAt_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_ReadAt_anyParams isolates the any params functions of
// the File_starGenType type
type MoqFile_starGenType_ReadAt_anyParams struct {
	Recorder *MoqFile_starGenType_ReadAt_fnRecorder
}

// MoqFile_starGenType_Write_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Write_params struct{ B []byte }

// MoqFile_starGenType_Write_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Write_paramsKey struct {
	Params struct{}
	Hashes struct{ B hash.Hash }
}

// MoqFile_starGenType_Write_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Write_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Write_paramsKey]*MoqFile_starGenType_Write_results
}

// MoqFile_starGenType_Write_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Write_doFn func(b []byte)

// MoqFile_starGenType_Write_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Write_doReturnFn func(b []byte) (n int, err error)

// MoqFile_starGenType_Write_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Write_results struct {
	Params  MoqFile_starGenType_Write_params
	Results []struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Write_doFn
		DoReturnFn MoqFile_starGenType_Write_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Write_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Write_fnRecorder struct {
	Params    MoqFile_starGenType_Write_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Write_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Write_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Write_anyParams struct {
	Recorder *MoqFile_starGenType_Write_fnRecorder
}

// MoqFile_starGenType_WriteAt_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_WriteAt_params struct {
	B   []byte
	Off int64
}

// MoqFile_starGenType_WriteAt_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_WriteAt_paramsKey struct {
	Params struct{ Off int64 }
	Hashes struct {
		B   hash.Hash
		Off hash.Hash
	}
}

// MoqFile_starGenType_WriteAt_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_WriteAt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_WriteAt_paramsKey]*MoqFile_starGenType_WriteAt_results
}

// MoqFile_starGenType_WriteAt_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_WriteAt_doFn func(b []byte, off int64)

// MoqFile_starGenType_WriteAt_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_WriteAt_doReturnFn func(b []byte, off int64) (n int, err error)

// MoqFile_starGenType_WriteAt_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_WriteAt_results struct {
	Params  MoqFile_starGenType_WriteAt_params
	Results []struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_WriteAt_doFn
		DoReturnFn MoqFile_starGenType_WriteAt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_WriteAt_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_WriteAt_fnRecorder struct {
	Params    MoqFile_starGenType_WriteAt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_WriteAt_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_WriteAt_anyParams isolates the any params functions of
// the File_starGenType type
type MoqFile_starGenType_WriteAt_anyParams struct {
	Recorder *MoqFile_starGenType_WriteAt_fnRecorder
}

// MoqFile_starGenType_Seek_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Seek_params struct {
	Offset int64
	Whence int
}

// MoqFile_starGenType_Seek_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Seek_paramsKey struct {
	Params struct {
		Offset int64
		Whence int
	}
	Hashes struct {
		Offset hash.Hash
		Whence hash.Hash
	}
}

// MoqFile_starGenType_Seek_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Seek_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Seek_paramsKey]*MoqFile_starGenType_Seek_results
}

// MoqFile_starGenType_Seek_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Seek_doFn func(offset int64, whence int)

// MoqFile_starGenType_Seek_doReturnFn defines the type of function needed when
// calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Seek_doReturnFn func(offset int64, whence int) (ret int64, err error)

// MoqFile_starGenType_Seek_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Seek_results struct {
	Params  MoqFile_starGenType_Seek_params
	Results []struct {
		Values *struct {
			Ret int64
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Seek_doFn
		DoReturnFn MoqFile_starGenType_Seek_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Seek_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Seek_fnRecorder struct {
	Params    MoqFile_starGenType_Seek_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Seek_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Seek_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Seek_anyParams struct {
	Recorder *MoqFile_starGenType_Seek_fnRecorder
}

// MoqFile_starGenType_WriteString_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_WriteString_params struct{ S string }

// MoqFile_starGenType_WriteString_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_WriteString_paramsKey struct {
	Params struct{ S string }
	Hashes struct{ S hash.Hash }
}

// MoqFile_starGenType_WriteString_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_WriteString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_WriteString_paramsKey]*MoqFile_starGenType_WriteString_results
}

// MoqFile_starGenType_WriteString_doFn defines the type of function needed
// when calling AndDo for the File_starGenType type
type MoqFile_starGenType_WriteString_doFn func(s string)

// MoqFile_starGenType_WriteString_doReturnFn defines the type of function
// needed when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_WriteString_doReturnFn func(s string) (n int, err error)

// MoqFile_starGenType_WriteString_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_WriteString_results struct {
	Params  MoqFile_starGenType_WriteString_params
	Results []struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_WriteString_doFn
		DoReturnFn MoqFile_starGenType_WriteString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_WriteString_fnRecorder routes recorded function calls to
// the MoqFile_starGenType moq
type MoqFile_starGenType_WriteString_fnRecorder struct {
	Params    MoqFile_starGenType_WriteString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_WriteString_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_WriteString_anyParams isolates the any params functions
// of the File_starGenType type
type MoqFile_starGenType_WriteString_anyParams struct {
	Recorder *MoqFile_starGenType_WriteString_fnRecorder
}

// MoqFile_starGenType_Chmod_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Chmod_params struct{ Mode os.FileMode }

// MoqFile_starGenType_Chmod_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Chmod_paramsKey struct {
	Params struct{ Mode os.FileMode }
	Hashes struct{ Mode hash.Hash }
}

// MoqFile_starGenType_Chmod_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Chmod_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Chmod_paramsKey]*MoqFile_starGenType_Chmod_results
}

// MoqFile_starGenType_Chmod_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Chmod_doFn func(mode os.FileMode)

// MoqFile_starGenType_Chmod_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Chmod_doReturnFn func(mode os.FileMode) error

// MoqFile_starGenType_Chmod_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Chmod_results struct {
	Params  MoqFile_starGenType_Chmod_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Chmod_doFn
		DoReturnFn MoqFile_starGenType_Chmod_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Chmod_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Chmod_fnRecorder struct {
	Params    MoqFile_starGenType_Chmod_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Chmod_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Chmod_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Chmod_anyParams struct {
	Recorder *MoqFile_starGenType_Chmod_fnRecorder
}

// MoqFile_starGenType_SetDeadline_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_SetDeadline_params struct{ T time.Time }

// MoqFile_starGenType_SetDeadline_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_SetDeadline_paramsKey struct {
	Params struct{ T time.Time }
	Hashes struct{ T hash.Hash }
}

// MoqFile_starGenType_SetDeadline_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_SetDeadline_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_SetDeadline_paramsKey]*MoqFile_starGenType_SetDeadline_results
}

// MoqFile_starGenType_SetDeadline_doFn defines the type of function needed
// when calling AndDo for the File_starGenType type
type MoqFile_starGenType_SetDeadline_doFn func(t time.Time)

// MoqFile_starGenType_SetDeadline_doReturnFn defines the type of function
// needed when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_SetDeadline_doReturnFn func(t time.Time) error

// MoqFile_starGenType_SetDeadline_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_SetDeadline_results struct {
	Params  MoqFile_starGenType_SetDeadline_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetDeadline_doFn
		DoReturnFn MoqFile_starGenType_SetDeadline_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_SetDeadline_fnRecorder routes recorded function calls to
// the MoqFile_starGenType moq
type MoqFile_starGenType_SetDeadline_fnRecorder struct {
	Params    MoqFile_starGenType_SetDeadline_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_SetDeadline_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_SetDeadline_anyParams isolates the any params functions
// of the File_starGenType type
type MoqFile_starGenType_SetDeadline_anyParams struct {
	Recorder *MoqFile_starGenType_SetDeadline_fnRecorder
}

// MoqFile_starGenType_SetReadDeadline_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_SetReadDeadline_params struct{ T time.Time }

// MoqFile_starGenType_SetReadDeadline_paramsKey holds the map key params of
// the File_starGenType type
type MoqFile_starGenType_SetReadDeadline_paramsKey struct {
	Params struct{ T time.Time }
	Hashes struct{ T hash.Hash }
}

// MoqFile_starGenType_SetReadDeadline_resultsByParams contains the results for
// a given set of parameters for the File_starGenType type
type MoqFile_starGenType_SetReadDeadline_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_SetReadDeadline_paramsKey]*MoqFile_starGenType_SetReadDeadline_results
}

// MoqFile_starGenType_SetReadDeadline_doFn defines the type of function needed
// when calling AndDo for the File_starGenType type
type MoqFile_starGenType_SetReadDeadline_doFn func(t time.Time)

// MoqFile_starGenType_SetReadDeadline_doReturnFn defines the type of function
// needed when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_SetReadDeadline_doReturnFn func(t time.Time) error

// MoqFile_starGenType_SetReadDeadline_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_SetReadDeadline_results struct {
	Params  MoqFile_starGenType_SetReadDeadline_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetReadDeadline_doFn
		DoReturnFn MoqFile_starGenType_SetReadDeadline_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_SetReadDeadline_fnRecorder routes recorded function
// calls to the MoqFile_starGenType moq
type MoqFile_starGenType_SetReadDeadline_fnRecorder struct {
	Params    MoqFile_starGenType_SetReadDeadline_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_SetReadDeadline_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_SetReadDeadline_anyParams isolates the any params
// functions of the File_starGenType type
type MoqFile_starGenType_SetReadDeadline_anyParams struct {
	Recorder *MoqFile_starGenType_SetReadDeadline_fnRecorder
}

// MoqFile_starGenType_SetWriteDeadline_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_SetWriteDeadline_params struct{ T time.Time }

// MoqFile_starGenType_SetWriteDeadline_paramsKey holds the map key params of
// the File_starGenType type
type MoqFile_starGenType_SetWriteDeadline_paramsKey struct {
	Params struct{ T time.Time }
	Hashes struct{ T hash.Hash }
}

// MoqFile_starGenType_SetWriteDeadline_resultsByParams contains the results
// for a given set of parameters for the File_starGenType type
type MoqFile_starGenType_SetWriteDeadline_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_SetWriteDeadline_paramsKey]*MoqFile_starGenType_SetWriteDeadline_results
}

// MoqFile_starGenType_SetWriteDeadline_doFn defines the type of function
// needed when calling AndDo for the File_starGenType type
type MoqFile_starGenType_SetWriteDeadline_doFn func(t time.Time)

// MoqFile_starGenType_SetWriteDeadline_doReturnFn defines the type of function
// needed when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_SetWriteDeadline_doReturnFn func(t time.Time) error

// MoqFile_starGenType_SetWriteDeadline_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_SetWriteDeadline_results struct {
	Params  MoqFile_starGenType_SetWriteDeadline_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetWriteDeadline_doFn
		DoReturnFn MoqFile_starGenType_SetWriteDeadline_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_SetWriteDeadline_fnRecorder routes recorded function
// calls to the MoqFile_starGenType moq
type MoqFile_starGenType_SetWriteDeadline_fnRecorder struct {
	Params    MoqFile_starGenType_SetWriteDeadline_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_SetWriteDeadline_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_SetWriteDeadline_anyParams isolates the any params
// functions of the File_starGenType type
type MoqFile_starGenType_SetWriteDeadline_anyParams struct {
	Recorder *MoqFile_starGenType_SetWriteDeadline_fnRecorder
}

// MoqFile_starGenType_SyscallConn_params holds the params of the
// File_starGenType type
type MoqFile_starGenType_SyscallConn_params struct{}

// MoqFile_starGenType_SyscallConn_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_SyscallConn_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFile_starGenType_SyscallConn_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_SyscallConn_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_SyscallConn_paramsKey]*MoqFile_starGenType_SyscallConn_results
}

// MoqFile_starGenType_SyscallConn_doFn defines the type of function needed
// when calling AndDo for the File_starGenType type
type MoqFile_starGenType_SyscallConn_doFn func()

// MoqFile_starGenType_SyscallConn_doReturnFn defines the type of function
// needed when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_SyscallConn_doReturnFn func() (syscall.RawConn, error)

// MoqFile_starGenType_SyscallConn_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_SyscallConn_results struct {
	Params  MoqFile_starGenType_SyscallConn_params
	Results []struct {
		Values *struct {
			Result1 syscall.RawConn
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SyscallConn_doFn
		DoReturnFn MoqFile_starGenType_SyscallConn_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_SyscallConn_fnRecorder routes recorded function calls to
// the MoqFile_starGenType moq
type MoqFile_starGenType_SyscallConn_fnRecorder struct {
	Params    MoqFile_starGenType_SyscallConn_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_SyscallConn_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_SyscallConn_anyParams isolates the any params functions
// of the File_starGenType type
type MoqFile_starGenType_SyscallConn_anyParams struct {
	Recorder *MoqFile_starGenType_SyscallConn_fnRecorder
}

// MoqFile_starGenType_Chown_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Chown_params struct{ Uid, Gid int }

// MoqFile_starGenType_Chown_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Chown_paramsKey struct {
	Params struct{ Uid, Gid int }
	Hashes struct{ Uid, Gid hash.Hash }
}

// MoqFile_starGenType_Chown_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Chown_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Chown_paramsKey]*MoqFile_starGenType_Chown_results
}

// MoqFile_starGenType_Chown_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Chown_doFn func(uid, gid int)

// MoqFile_starGenType_Chown_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Chown_doReturnFn func(uid, gid int) error

// MoqFile_starGenType_Chown_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Chown_results struct {
	Params  MoqFile_starGenType_Chown_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Chown_doFn
		DoReturnFn MoqFile_starGenType_Chown_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Chown_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Chown_fnRecorder struct {
	Params    MoqFile_starGenType_Chown_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Chown_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Chown_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Chown_anyParams struct {
	Recorder *MoqFile_starGenType_Chown_fnRecorder
}

// MoqFile_starGenType_Truncate_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Truncate_params struct{ Size int64 }

// MoqFile_starGenType_Truncate_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Truncate_paramsKey struct {
	Params struct{ Size int64 }
	Hashes struct{ Size hash.Hash }
}

// MoqFile_starGenType_Truncate_resultsByParams contains the results for a
// given set of parameters for the File_starGenType type
type MoqFile_starGenType_Truncate_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Truncate_paramsKey]*MoqFile_starGenType_Truncate_results
}

// MoqFile_starGenType_Truncate_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Truncate_doFn func(size int64)

// MoqFile_starGenType_Truncate_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Truncate_doReturnFn func(size int64) error

// MoqFile_starGenType_Truncate_results holds the results of the
// File_starGenType type
type MoqFile_starGenType_Truncate_results struct {
	Params  MoqFile_starGenType_Truncate_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Truncate_doFn
		DoReturnFn MoqFile_starGenType_Truncate_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Truncate_fnRecorder routes recorded function calls to
// the MoqFile_starGenType moq
type MoqFile_starGenType_Truncate_fnRecorder struct {
	Params    MoqFile_starGenType_Truncate_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Truncate_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Truncate_anyParams isolates the any params functions of
// the File_starGenType type
type MoqFile_starGenType_Truncate_anyParams struct {
	Recorder *MoqFile_starGenType_Truncate_fnRecorder
}

// MoqFile_starGenType_Sync_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Sync_params struct{}

// MoqFile_starGenType_Sync_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Sync_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFile_starGenType_Sync_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Sync_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Sync_paramsKey]*MoqFile_starGenType_Sync_results
}

// MoqFile_starGenType_Sync_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Sync_doFn func()

// MoqFile_starGenType_Sync_doReturnFn defines the type of function needed when
// calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Sync_doReturnFn func() error

// MoqFile_starGenType_Sync_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Sync_results struct {
	Params  MoqFile_starGenType_Sync_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Sync_doFn
		DoReturnFn MoqFile_starGenType_Sync_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Sync_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Sync_fnRecorder struct {
	Params    MoqFile_starGenType_Sync_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Sync_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Sync_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Sync_anyParams struct {
	Recorder *MoqFile_starGenType_Sync_fnRecorder
}

// MoqFile_starGenType_Chdir_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Chdir_params struct{}

// MoqFile_starGenType_Chdir_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Chdir_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFile_starGenType_Chdir_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Chdir_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Chdir_paramsKey]*MoqFile_starGenType_Chdir_results
}

// MoqFile_starGenType_Chdir_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Chdir_doFn func()

// MoqFile_starGenType_Chdir_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Chdir_doReturnFn func() error

// MoqFile_starGenType_Chdir_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Chdir_results struct {
	Params  MoqFile_starGenType_Chdir_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Chdir_doFn
		DoReturnFn MoqFile_starGenType_Chdir_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Chdir_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Chdir_fnRecorder struct {
	Params    MoqFile_starGenType_Chdir_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Chdir_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Chdir_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Chdir_anyParams struct {
	Recorder *MoqFile_starGenType_Chdir_fnRecorder
}

// MoqFile_starGenType_Fd_params holds the params of the File_starGenType type
type MoqFile_starGenType_Fd_params struct{}

// MoqFile_starGenType_Fd_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Fd_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFile_starGenType_Fd_resultsByParams contains the results for a given set
// of parameters for the File_starGenType type
type MoqFile_starGenType_Fd_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Fd_paramsKey]*MoqFile_starGenType_Fd_results
}

// MoqFile_starGenType_Fd_doFn defines the type of function needed when calling
// AndDo for the File_starGenType type
type MoqFile_starGenType_Fd_doFn func()

// MoqFile_starGenType_Fd_doReturnFn defines the type of function needed when
// calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Fd_doReturnFn func() uintptr

// MoqFile_starGenType_Fd_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Fd_results struct {
	Params  MoqFile_starGenType_Fd_params
	Results []struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Fd_doFn
		DoReturnFn MoqFile_starGenType_Fd_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Fd_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Fd_fnRecorder struct {
	Params    MoqFile_starGenType_Fd_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Fd_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Fd_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Fd_anyParams struct {
	Recorder *MoqFile_starGenType_Fd_fnRecorder
}

// MoqFile_starGenType_Close_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Close_params struct{}

// MoqFile_starGenType_Close_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Close_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFile_starGenType_Close_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Close_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Close_paramsKey]*MoqFile_starGenType_Close_results
}

// MoqFile_starGenType_Close_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Close_doFn func()

// MoqFile_starGenType_Close_doReturnFn defines the type of function needed
// when calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Close_doReturnFn func() error

// MoqFile_starGenType_Close_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Close_results struct {
	Params  MoqFile_starGenType_Close_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Close_doFn
		DoReturnFn MoqFile_starGenType_Close_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Close_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Close_fnRecorder struct {
	Params    MoqFile_starGenType_Close_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Close_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Close_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Close_anyParams struct {
	Recorder *MoqFile_starGenType_Close_fnRecorder
}

// MoqFile_starGenType_Stat_params holds the params of the File_starGenType
// type
type MoqFile_starGenType_Stat_params struct{}

// MoqFile_starGenType_Stat_paramsKey holds the map key params of the
// File_starGenType type
type MoqFile_starGenType_Stat_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqFile_starGenType_Stat_resultsByParams contains the results for a given
// set of parameters for the File_starGenType type
type MoqFile_starGenType_Stat_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqFile_starGenType_Stat_paramsKey]*MoqFile_starGenType_Stat_results
}

// MoqFile_starGenType_Stat_doFn defines the type of function needed when
// calling AndDo for the File_starGenType type
type MoqFile_starGenType_Stat_doFn func()

// MoqFile_starGenType_Stat_doReturnFn defines the type of function needed when
// calling DoReturnResults for the File_starGenType type
type MoqFile_starGenType_Stat_doReturnFn func() (os.FileInfo, error)

// MoqFile_starGenType_Stat_results holds the results of the File_starGenType
// type
type MoqFile_starGenType_Stat_results struct {
	Params  MoqFile_starGenType_Stat_params
	Results []struct {
		Values *struct {
			Result1 os.FileInfo
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Stat_doFn
		DoReturnFn MoqFile_starGenType_Stat_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqFile_starGenType_Stat_fnRecorder routes recorded function calls to the
// MoqFile_starGenType moq
type MoqFile_starGenType_Stat_fnRecorder struct {
	Params    MoqFile_starGenType_Stat_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqFile_starGenType_Stat_results
	Moq       *MoqFile_starGenType
}

// MoqFile_starGenType_Stat_anyParams isolates the any params functions of the
// File_starGenType type
type MoqFile_starGenType_Stat_anyParams struct {
	Recorder *MoqFile_starGenType_Stat_fnRecorder
}

// NewMoqFile_starGenType creates a new moq of the File_starGenType type
func NewMoqFile_starGenType(scene *moq.Scene, config *moq.Config) *MoqFile_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqFile_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqFile_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Readdir struct {
					N moq.ParamIndexing
				}
				Readdirnames struct {
					N moq.ParamIndexing
				}
				Name struct{}
				Read struct {
					B moq.ParamIndexing
				}
				ReadAt struct {
					B   moq.ParamIndexing
					Off moq.ParamIndexing
				}
				Write struct {
					B moq.ParamIndexing
				}
				WriteAt struct {
					B   moq.ParamIndexing
					Off moq.ParamIndexing
				}
				Seek struct {
					Offset moq.ParamIndexing
					Whence moq.ParamIndexing
				}
				WriteString struct {
					S moq.ParamIndexing
				}
				Chmod struct {
					Mode moq.ParamIndexing
				}
				SetDeadline struct {
					T moq.ParamIndexing
				}
				SetReadDeadline struct {
					T moq.ParamIndexing
				}
				SetWriteDeadline struct {
					T moq.ParamIndexing
				}
				SyscallConn struct{}
				Chown       struct {
					Uid moq.ParamIndexing
					Gid moq.ParamIndexing
				}
				Truncate struct {
					Size moq.ParamIndexing
				}
				Sync  struct{}
				Chdir struct{}
				Fd    struct{}
				Close struct{}
				Stat  struct{}
			}
		}{ParameterIndexing: struct {
			Readdir struct {
				N moq.ParamIndexing
			}
			Readdirnames struct {
				N moq.ParamIndexing
			}
			Name struct{}
			Read struct {
				B moq.ParamIndexing
			}
			ReadAt struct {
				B   moq.ParamIndexing
				Off moq.ParamIndexing
			}
			Write struct {
				B moq.ParamIndexing
			}
			WriteAt struct {
				B   moq.ParamIndexing
				Off moq.ParamIndexing
			}
			Seek struct {
				Offset moq.ParamIndexing
				Whence moq.ParamIndexing
			}
			WriteString struct {
				S moq.ParamIndexing
			}
			Chmod struct {
				Mode moq.ParamIndexing
			}
			SetDeadline struct {
				T moq.ParamIndexing
			}
			SetReadDeadline struct {
				T moq.ParamIndexing
			}
			SetWriteDeadline struct {
				T moq.ParamIndexing
			}
			SyscallConn struct{}
			Chown       struct {
				Uid moq.ParamIndexing
				Gid moq.ParamIndexing
			}
			Truncate struct {
				Size moq.ParamIndexing
			}
			Sync  struct{}
			Chdir struct{}
			Fd    struct{}
			Close struct{}
			Stat  struct{}
		}{
			Readdir: struct {
				N moq.ParamIndexing
			}{
				N: moq.ParamIndexByValue,
			},
			Readdirnames: struct {
				N moq.ParamIndexing
			}{
				N: moq.ParamIndexByValue,
			},
			Name: struct{}{},
			Read: struct {
				B moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
			},
			ReadAt: struct {
				B   moq.ParamIndexing
				Off moq.ParamIndexing
			}{
				B:   moq.ParamIndexByHash,
				Off: moq.ParamIndexByValue,
			},
			Write: struct {
				B moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
			},
			WriteAt: struct {
				B   moq.ParamIndexing
				Off moq.ParamIndexing
			}{
				B:   moq.ParamIndexByHash,
				Off: moq.ParamIndexByValue,
			},
			Seek: struct {
				Offset moq.ParamIndexing
				Whence moq.ParamIndexing
			}{
				Offset: moq.ParamIndexByValue,
				Whence: moq.ParamIndexByValue,
			},
			WriteString: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			Chmod: struct {
				Mode moq.ParamIndexing
			}{
				Mode: moq.ParamIndexByValue,
			},
			SetDeadline: struct {
				T moq.ParamIndexing
			}{
				T: moq.ParamIndexByHash,
			},
			SetReadDeadline: struct {
				T moq.ParamIndexing
			}{
				T: moq.ParamIndexByHash,
			},
			SetWriteDeadline: struct {
				T moq.ParamIndexing
			}{
				T: moq.ParamIndexByHash,
			},
			SyscallConn: struct{}{},
			Chown: struct {
				Uid moq.ParamIndexing
				Gid moq.ParamIndexing
			}{
				Uid: moq.ParamIndexByValue,
				Gid: moq.ParamIndexByValue,
			},
			Truncate: struct {
				Size moq.ParamIndexing
			}{
				Size: moq.ParamIndexByValue,
			},
			Sync:  struct{}{},
			Chdir: struct{}{},
			Fd:    struct{}{},
			Close: struct{}{},
			Stat:  struct{}{},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the File_starGenType type
func (m *MoqFile_starGenType) Mock() *MoqFile_starGenType_mock { return m.Moq }

func (m *MoqFile_starGenType_mock) Readdir(n int) (result1 []os.FileInfo, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Readdir_params{
		N: n,
	}
	var results *MoqFile_starGenType_Readdir_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Readdir {
		paramsKey := m.Moq.ParamsKey_Readdir(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Readdir(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Readdir(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Readdir(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(n)
	}
	return
}

func (m *MoqFile_starGenType_mock) Readdirnames(n int) (names []string, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Readdirnames_params{
		N: n,
	}
	var results *MoqFile_starGenType_Readdirnames_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Readdirnames {
		paramsKey := m.Moq.ParamsKey_Readdirnames(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Readdirnames(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Readdirnames(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Readdirnames(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(n)
	}

	if result.Values != nil {
		names = result.Values.Names
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		names, err = result.DoReturnFn(n)
	}
	return
}

func (m *MoqFile_starGenType_mock) Name() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Name_params{}
	var results *MoqFile_starGenType_Name_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Name {
		paramsKey := m.Moq.ParamsKey_Name(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Name(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Name(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Name(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFile_starGenType_mock) Read(b []byte) (n int, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Read_params{
		B: b,
	}
	var results *MoqFile_starGenType_Read_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Read {
		paramsKey := m.Moq.ParamsKey_Read(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Read(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Read(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Read(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b)
	}

	if result.Values != nil {
		n = result.Values.N
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		n, err = result.DoReturnFn(b)
	}
	return
}

func (m *MoqFile_starGenType_mock) ReadAt(b []byte, off int64) (n int, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_ReadAt_params{
		B:   b,
		Off: off,
	}
	var results *MoqFile_starGenType_ReadAt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReadAt {
		paramsKey := m.Moq.ParamsKey_ReadAt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReadAt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReadAt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReadAt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b, off)
	}

	if result.Values != nil {
		n = result.Values.N
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		n, err = result.DoReturnFn(b, off)
	}
	return
}

func (m *MoqFile_starGenType_mock) Write(b []byte) (n int, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Write_params{
		B: b,
	}
	var results *MoqFile_starGenType_Write_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Write {
		paramsKey := m.Moq.ParamsKey_Write(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Write(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Write(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Write(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b)
	}

	if result.Values != nil {
		n = result.Values.N
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		n, err = result.DoReturnFn(b)
	}
	return
}

func (m *MoqFile_starGenType_mock) WriteAt(b []byte, off int64) (n int, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_WriteAt_params{
		B:   b,
		Off: off,
	}
	var results *MoqFile_starGenType_WriteAt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_WriteAt {
		paramsKey := m.Moq.ParamsKey_WriteAt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_WriteAt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_WriteAt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_WriteAt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b, off)
	}

	if result.Values != nil {
		n = result.Values.N
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		n, err = result.DoReturnFn(b, off)
	}
	return
}

func (m *MoqFile_starGenType_mock) Seek(offset int64, whence int) (ret int64, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Seek_params{
		Offset: offset,
		Whence: whence,
	}
	var results *MoqFile_starGenType_Seek_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Seek {
		paramsKey := m.Moq.ParamsKey_Seek(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Seek(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Seek(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Seek(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(offset, whence)
	}

	if result.Values != nil {
		ret = result.Values.Ret
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		ret, err = result.DoReturnFn(offset, whence)
	}
	return
}

func (m *MoqFile_starGenType_mock) WriteString(s string) (n int, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_WriteString_params{
		S: s,
	}
	var results *MoqFile_starGenType_WriteString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_WriteString {
		paramsKey := m.Moq.ParamsKey_WriteString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_WriteString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_WriteString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_WriteString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		n = result.Values.N
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		n, err = result.DoReturnFn(s)
	}
	return
}

func (m *MoqFile_starGenType_mock) Chmod(mode os.FileMode) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Chmod_params{
		Mode: mode,
	}
	var results *MoqFile_starGenType_Chmod_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Chmod {
		paramsKey := m.Moq.ParamsKey_Chmod(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Chmod(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Chmod(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Chmod(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(mode)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(mode)
	}
	return
}

func (m *MoqFile_starGenType_mock) SetDeadline(t time.Time) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_SetDeadline_params{
		T: t,
	}
	var results *MoqFile_starGenType_SetDeadline_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetDeadline {
		paramsKey := m.Moq.ParamsKey_SetDeadline(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetDeadline(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetDeadline(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetDeadline(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(t)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(t)
	}
	return
}

func (m *MoqFile_starGenType_mock) SetReadDeadline(t time.Time) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_SetReadDeadline_params{
		T: t,
	}
	var results *MoqFile_starGenType_SetReadDeadline_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetReadDeadline {
		paramsKey := m.Moq.ParamsKey_SetReadDeadline(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetReadDeadline(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetReadDeadline(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetReadDeadline(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(t)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(t)
	}
	return
}

func (m *MoqFile_starGenType_mock) SetWriteDeadline(t time.Time) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_SetWriteDeadline_params{
		T: t,
	}
	var results *MoqFile_starGenType_SetWriteDeadline_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetWriteDeadline {
		paramsKey := m.Moq.ParamsKey_SetWriteDeadline(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetWriteDeadline(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetWriteDeadline(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetWriteDeadline(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(t)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(t)
	}
	return
}

func (m *MoqFile_starGenType_mock) SyscallConn() (result1 syscall.RawConn, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_SyscallConn_params{}
	var results *MoqFile_starGenType_SyscallConn_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SyscallConn {
		paramsKey := m.Moq.ParamsKey_SyscallConn(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SyscallConn(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SyscallConn(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SyscallConn(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqFile_starGenType_mock) Chown(uid, gid int) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Chown_params{
		Uid: uid,
		Gid: gid,
	}
	var results *MoqFile_starGenType_Chown_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Chown {
		paramsKey := m.Moq.ParamsKey_Chown(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Chown(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Chown(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Chown(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(uid, gid)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(uid, gid)
	}
	return
}

func (m *MoqFile_starGenType_mock) Truncate(size int64) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Truncate_params{
		Size: size,
	}
	var results *MoqFile_starGenType_Truncate_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Truncate {
		paramsKey := m.Moq.ParamsKey_Truncate(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Truncate(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Truncate(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Truncate(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(size)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(size)
	}
	return
}

func (m *MoqFile_starGenType_mock) Sync() (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Sync_params{}
	var results *MoqFile_starGenType_Sync_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Sync {
		paramsKey := m.Moq.ParamsKey_Sync(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Sync(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Sync(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Sync(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFile_starGenType_mock) Chdir() (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Chdir_params{}
	var results *MoqFile_starGenType_Chdir_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Chdir {
		paramsKey := m.Moq.ParamsKey_Chdir(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Chdir(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Chdir(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Chdir(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFile_starGenType_mock) Fd() (result1 uintptr) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Fd_params{}
	var results *MoqFile_starGenType_Fd_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Fd {
		paramsKey := m.Moq.ParamsKey_Fd(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Fd(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Fd(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Fd(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFile_starGenType_mock) Close() (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Close_params{}
	var results *MoqFile_starGenType_Close_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Close {
		paramsKey := m.Moq.ParamsKey_Close(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Close(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Close(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Close(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqFile_starGenType_mock) Stat() (result1 os.FileInfo, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqFile_starGenType_Stat_params{}
	var results *MoqFile_starGenType_Stat_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Stat {
		paramsKey := m.Moq.ParamsKey_Stat(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Stat(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Stat(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Stat(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

// OnCall returns the recorder implementation of the File_starGenType type
func (m *MoqFile_starGenType) OnCall() *MoqFile_starGenType_recorder {
	return &MoqFile_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqFile_starGenType_recorder) Readdir(n int) *MoqFile_starGenType_Readdir_fnRecorder {
	return &MoqFile_starGenType_Readdir_fnRecorder{
		Params: MoqFile_starGenType_Readdir_params{
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Readdir_fnRecorder) Any() *MoqFile_starGenType_Readdir_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Readdir(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Readdir_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Readdir_anyParams) N() *MoqFile_starGenType_Readdir_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_Readdir_fnRecorder) Seq() *MoqFile_starGenType_Readdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Readdir(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Readdir_fnRecorder) NoSeq() *MoqFile_starGenType_Readdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Readdir(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Readdir_fnRecorder) ReturnResults(result1 []os.FileInfo, result2 error) *MoqFile_starGenType_Readdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []os.FileInfo
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Readdir_doFn
		DoReturnFn MoqFile_starGenType_Readdir_doReturnFn
	}{
		Values: &struct {
			Result1 []os.FileInfo
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Readdir_fnRecorder) AndDo(fn MoqFile_starGenType_Readdir_doFn) *MoqFile_starGenType_Readdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Readdir_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Readdir_doReturnFn) *MoqFile_starGenType_Readdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []os.FileInfo
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Readdir_doFn
		DoReturnFn MoqFile_starGenType_Readdir_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Readdir_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Readdir_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Readdir {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Readdir_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Readdir_paramsKey]*MoqFile_starGenType_Readdir_results{},
		}
		r.Moq.ResultsByParams_Readdir = append(r.Moq.ResultsByParams_Readdir, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Readdir) {
			copy(r.Moq.ResultsByParams_Readdir[insertAt+1:], r.Moq.ResultsByParams_Readdir[insertAt:0])
			r.Moq.ResultsByParams_Readdir[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Readdir(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Readdir_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Readdir_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Readdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []os.FileInfo
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Readdir_doFn
				DoReturnFn MoqFile_starGenType_Readdir_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Readdir(params MoqFile_starGenType_Readdir_params) string {
	return fmt.Sprintf("Readdir(%#v)", params.N)
}

func (m *MoqFile_starGenType) ParamsKey_Readdir(params MoqFile_starGenType_Readdir_params, anyParams uint64) MoqFile_starGenType_Readdir_paramsKey {
	m.Scene.T.Helper()
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Readdir.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqFile_starGenType_Readdir_paramsKey{
		Params: struct{ N int }{
			N: nUsed,
		},
		Hashes: struct{ N hash.Hash }{
			N: nUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) Readdirnames(n int) *MoqFile_starGenType_Readdirnames_fnRecorder {
	return &MoqFile_starGenType_Readdirnames_fnRecorder{
		Params: MoqFile_starGenType_Readdirnames_params{
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Readdirnames_fnRecorder) Any() *MoqFile_starGenType_Readdirnames_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Readdirnames(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Readdirnames_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Readdirnames_anyParams) N() *MoqFile_starGenType_Readdirnames_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_Readdirnames_fnRecorder) Seq() *MoqFile_starGenType_Readdirnames_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Readdirnames(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Readdirnames_fnRecorder) NoSeq() *MoqFile_starGenType_Readdirnames_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Readdirnames(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Readdirnames_fnRecorder) ReturnResults(names []string, err error) *MoqFile_starGenType_Readdirnames_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Names []string
			Err   error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Readdirnames_doFn
		DoReturnFn MoqFile_starGenType_Readdirnames_doReturnFn
	}{
		Values: &struct {
			Names []string
			Err   error
		}{
			Names: names,
			Err:   err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Readdirnames_fnRecorder) AndDo(fn MoqFile_starGenType_Readdirnames_doFn) *MoqFile_starGenType_Readdirnames_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Readdirnames_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Readdirnames_doReturnFn) *MoqFile_starGenType_Readdirnames_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Names []string
			Err   error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Readdirnames_doFn
		DoReturnFn MoqFile_starGenType_Readdirnames_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Readdirnames_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Readdirnames_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Readdirnames {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Readdirnames_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Readdirnames_paramsKey]*MoqFile_starGenType_Readdirnames_results{},
		}
		r.Moq.ResultsByParams_Readdirnames = append(r.Moq.ResultsByParams_Readdirnames, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Readdirnames) {
			copy(r.Moq.ResultsByParams_Readdirnames[insertAt+1:], r.Moq.ResultsByParams_Readdirnames[insertAt:0])
			r.Moq.ResultsByParams_Readdirnames[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Readdirnames(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Readdirnames_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Readdirnames_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Readdirnames_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Names []string
					Err   error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Readdirnames_doFn
				DoReturnFn MoqFile_starGenType_Readdirnames_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Readdirnames(params MoqFile_starGenType_Readdirnames_params) string {
	return fmt.Sprintf("Readdirnames(%#v)", params.N)
}

func (m *MoqFile_starGenType) ParamsKey_Readdirnames(params MoqFile_starGenType_Readdirnames_params, anyParams uint64) MoqFile_starGenType_Readdirnames_paramsKey {
	m.Scene.T.Helper()
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Readdirnames.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqFile_starGenType_Readdirnames_paramsKey{
		Params: struct{ N int }{
			N: nUsed,
		},
		Hashes: struct{ N hash.Hash }{
			N: nUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) Name() *MoqFile_starGenType_Name_fnRecorder {
	return &MoqFile_starGenType_Name_fnRecorder{
		Params:   MoqFile_starGenType_Name_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Name_fnRecorder) Any() *MoqFile_starGenType_Name_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Name_anyParams{Recorder: r}
}

func (r *MoqFile_starGenType_Name_fnRecorder) Seq() *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Name_fnRecorder) NoSeq() *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Name_fnRecorder) ReturnResults(result1 string) *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Name_doFn
		DoReturnFn MoqFile_starGenType_Name_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Name_fnRecorder) AndDo(fn MoqFile_starGenType_Name_doFn) *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Name_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Name_doReturnFn) *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Name_doFn
		DoReturnFn MoqFile_starGenType_Name_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Name_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Name_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Name {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Name_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Name_paramsKey]*MoqFile_starGenType_Name_results{},
		}
		r.Moq.ResultsByParams_Name = append(r.Moq.ResultsByParams_Name, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Name) {
			copy(r.Moq.ResultsByParams_Name[insertAt+1:], r.Moq.ResultsByParams_Name[insertAt:0])
			r.Moq.ResultsByParams_Name[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Name(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Name_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Name_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Name_doFn
				DoReturnFn MoqFile_starGenType_Name_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Name(params MoqFile_starGenType_Name_params) string {
	return fmt.Sprintf("Name()")
}

func (m *MoqFile_starGenType) ParamsKey_Name(params MoqFile_starGenType_Name_params, anyParams uint64) MoqFile_starGenType_Name_paramsKey {
	m.Scene.T.Helper()
	return MoqFile_starGenType_Name_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFile_starGenType_recorder) Read(b []byte) *MoqFile_starGenType_Read_fnRecorder {
	return &MoqFile_starGenType_Read_fnRecorder{
		Params: MoqFile_starGenType_Read_params{
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Read_fnRecorder) Any() *MoqFile_starGenType_Read_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Read(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Read_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Read_anyParams) B() *MoqFile_starGenType_Read_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_Read_fnRecorder) Seq() *MoqFile_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Read(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Read_fnRecorder) NoSeq() *MoqFile_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Read(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Read_fnRecorder) ReturnResults(n int, err error) *MoqFile_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Read_doFn
		DoReturnFn MoqFile_starGenType_Read_doReturnFn
	}{
		Values: &struct {
			N   int
			Err error
		}{
			N:   n,
			Err: err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Read_fnRecorder) AndDo(fn MoqFile_starGenType_Read_doFn) *MoqFile_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Read_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Read_doReturnFn) *MoqFile_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Read_doFn
		DoReturnFn MoqFile_starGenType_Read_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Read_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Read_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Read {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Read_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Read_paramsKey]*MoqFile_starGenType_Read_results{},
		}
		r.Moq.ResultsByParams_Read = append(r.Moq.ResultsByParams_Read, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Read) {
			copy(r.Moq.ResultsByParams_Read[insertAt+1:], r.Moq.ResultsByParams_Read[insertAt:0])
			r.Moq.ResultsByParams_Read[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Read(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Read_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Read_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Read_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					N   int
					Err error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Read_doFn
				DoReturnFn MoqFile_starGenType_Read_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Read(params MoqFile_starGenType_Read_params) string {
	return fmt.Sprintf("Read(%#v)", params.B)
}

func (m *MoqFile_starGenType) ParamsKey_Read(params MoqFile_starGenType_Read_params, anyParams uint64) MoqFile_starGenType_Read_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Read.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the Read function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	return MoqFile_starGenType_Read_paramsKey{
		Params: struct{}{},
		Hashes: struct{ B hash.Hash }{
			B: bUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) ReadAt(b []byte, off int64) *MoqFile_starGenType_ReadAt_fnRecorder {
	return &MoqFile_starGenType_ReadAt_fnRecorder{
		Params: MoqFile_starGenType_ReadAt_params{
			B:   b,
			Off: off,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_ReadAt_fnRecorder) Any() *MoqFile_starGenType_ReadAt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadAt(r.Params))
		return nil
	}
	return &MoqFile_starGenType_ReadAt_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_ReadAt_anyParams) B() *MoqFile_starGenType_ReadAt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFile_starGenType_ReadAt_anyParams) Off() *MoqFile_starGenType_ReadAt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFile_starGenType_ReadAt_fnRecorder) Seq() *MoqFile_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadAt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_ReadAt_fnRecorder) NoSeq() *MoqFile_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadAt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_ReadAt_fnRecorder) ReturnResults(n int, err error) *MoqFile_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_ReadAt_doFn
		DoReturnFn MoqFile_starGenType_ReadAt_doReturnFn
	}{
		Values: &struct {
			N   int
			Err error
		}{
			N:   n,
			Err: err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_ReadAt_fnRecorder) AndDo(fn MoqFile_starGenType_ReadAt_doFn) *MoqFile_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_ReadAt_fnRecorder) DoReturnResults(fn MoqFile_starGenType_ReadAt_doReturnFn) *MoqFile_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_ReadAt_doFn
		DoReturnFn MoqFile_starGenType_ReadAt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_ReadAt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_ReadAt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReadAt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_ReadAt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_ReadAt_paramsKey]*MoqFile_starGenType_ReadAt_results{},
		}
		r.Moq.ResultsByParams_ReadAt = append(r.Moq.ResultsByParams_ReadAt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReadAt) {
			copy(r.Moq.ResultsByParams_ReadAt[insertAt+1:], r.Moq.ResultsByParams_ReadAt[insertAt:0])
			r.Moq.ResultsByParams_ReadAt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReadAt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_ReadAt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_ReadAt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_ReadAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					N   int
					Err error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_ReadAt_doFn
				DoReturnFn MoqFile_starGenType_ReadAt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_ReadAt(params MoqFile_starGenType_ReadAt_params) string {
	return fmt.Sprintf("ReadAt(%#v, %#v)", params.B, params.Off)
}

func (m *MoqFile_starGenType) ParamsKey_ReadAt(params MoqFile_starGenType_ReadAt_params, anyParams uint64) MoqFile_starGenType_ReadAt_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ReadAt.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the ReadAt function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	var offUsed int64
	var offUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ReadAt.Off == moq.ParamIndexByValue {
			offUsed = params.Off
		} else {
			offUsedHash = hash.DeepHash(params.Off)
		}
	}
	return MoqFile_starGenType_ReadAt_paramsKey{
		Params: struct{ Off int64 }{
			Off: offUsed,
		},
		Hashes: struct {
			B   hash.Hash
			Off hash.Hash
		}{
			B:   bUsedHash,
			Off: offUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) Write(b []byte) *MoqFile_starGenType_Write_fnRecorder {
	return &MoqFile_starGenType_Write_fnRecorder{
		Params: MoqFile_starGenType_Write_params{
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Write_fnRecorder) Any() *MoqFile_starGenType_Write_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Write(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Write_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Write_anyParams) B() *MoqFile_starGenType_Write_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_Write_fnRecorder) Seq() *MoqFile_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Write(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Write_fnRecorder) NoSeq() *MoqFile_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Write(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Write_fnRecorder) ReturnResults(n int, err error) *MoqFile_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Write_doFn
		DoReturnFn MoqFile_starGenType_Write_doReturnFn
	}{
		Values: &struct {
			N   int
			Err error
		}{
			N:   n,
			Err: err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Write_fnRecorder) AndDo(fn MoqFile_starGenType_Write_doFn) *MoqFile_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Write_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Write_doReturnFn) *MoqFile_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Write_doFn
		DoReturnFn MoqFile_starGenType_Write_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Write_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Write_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Write {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Write_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Write_paramsKey]*MoqFile_starGenType_Write_results{},
		}
		r.Moq.ResultsByParams_Write = append(r.Moq.ResultsByParams_Write, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Write) {
			copy(r.Moq.ResultsByParams_Write[insertAt+1:], r.Moq.ResultsByParams_Write[insertAt:0])
			r.Moq.ResultsByParams_Write[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Write(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Write_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Write_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Write_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					N   int
					Err error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Write_doFn
				DoReturnFn MoqFile_starGenType_Write_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Write(params MoqFile_starGenType_Write_params) string {
	return fmt.Sprintf("Write(%#v)", params.B)
}

func (m *MoqFile_starGenType) ParamsKey_Write(params MoqFile_starGenType_Write_params, anyParams uint64) MoqFile_starGenType_Write_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Write.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the Write function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	return MoqFile_starGenType_Write_paramsKey{
		Params: struct{}{},
		Hashes: struct{ B hash.Hash }{
			B: bUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) WriteAt(b []byte, off int64) *MoqFile_starGenType_WriteAt_fnRecorder {
	return &MoqFile_starGenType_WriteAt_fnRecorder{
		Params: MoqFile_starGenType_WriteAt_params{
			B:   b,
			Off: off,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_WriteAt_fnRecorder) Any() *MoqFile_starGenType_WriteAt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteAt(r.Params))
		return nil
	}
	return &MoqFile_starGenType_WriteAt_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_WriteAt_anyParams) B() *MoqFile_starGenType_WriteAt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFile_starGenType_WriteAt_anyParams) Off() *MoqFile_starGenType_WriteAt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFile_starGenType_WriteAt_fnRecorder) Seq() *MoqFile_starGenType_WriteAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteAt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_WriteAt_fnRecorder) NoSeq() *MoqFile_starGenType_WriteAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteAt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_WriteAt_fnRecorder) ReturnResults(n int, err error) *MoqFile_starGenType_WriteAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_WriteAt_doFn
		DoReturnFn MoqFile_starGenType_WriteAt_doReturnFn
	}{
		Values: &struct {
			N   int
			Err error
		}{
			N:   n,
			Err: err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_WriteAt_fnRecorder) AndDo(fn MoqFile_starGenType_WriteAt_doFn) *MoqFile_starGenType_WriteAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_WriteAt_fnRecorder) DoReturnResults(fn MoqFile_starGenType_WriteAt_doReturnFn) *MoqFile_starGenType_WriteAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_WriteAt_doFn
		DoReturnFn MoqFile_starGenType_WriteAt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_WriteAt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_WriteAt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_WriteAt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_WriteAt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_WriteAt_paramsKey]*MoqFile_starGenType_WriteAt_results{},
		}
		r.Moq.ResultsByParams_WriteAt = append(r.Moq.ResultsByParams_WriteAt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_WriteAt) {
			copy(r.Moq.ResultsByParams_WriteAt[insertAt+1:], r.Moq.ResultsByParams_WriteAt[insertAt:0])
			r.Moq.ResultsByParams_WriteAt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_WriteAt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_WriteAt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_WriteAt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_WriteAt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					N   int
					Err error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_WriteAt_doFn
				DoReturnFn MoqFile_starGenType_WriteAt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_WriteAt(params MoqFile_starGenType_WriteAt_params) string {
	return fmt.Sprintf("WriteAt(%#v, %#v)", params.B, params.Off)
}

func (m *MoqFile_starGenType) ParamsKey_WriteAt(params MoqFile_starGenType_WriteAt_params, anyParams uint64) MoqFile_starGenType_WriteAt_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.WriteAt.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the WriteAt function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	var offUsed int64
	var offUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.WriteAt.Off == moq.ParamIndexByValue {
			offUsed = params.Off
		} else {
			offUsedHash = hash.DeepHash(params.Off)
		}
	}
	return MoqFile_starGenType_WriteAt_paramsKey{
		Params: struct{ Off int64 }{
			Off: offUsed,
		},
		Hashes: struct {
			B   hash.Hash
			Off hash.Hash
		}{
			B:   bUsedHash,
			Off: offUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) Seek(offset int64, whence int) *MoqFile_starGenType_Seek_fnRecorder {
	return &MoqFile_starGenType_Seek_fnRecorder{
		Params: MoqFile_starGenType_Seek_params{
			Offset: offset,
			Whence: whence,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Seek_fnRecorder) Any() *MoqFile_starGenType_Seek_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Seek(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Seek_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Seek_anyParams) Offset() *MoqFile_starGenType_Seek_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFile_starGenType_Seek_anyParams) Whence() *MoqFile_starGenType_Seek_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFile_starGenType_Seek_fnRecorder) Seq() *MoqFile_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Seek(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Seek_fnRecorder) NoSeq() *MoqFile_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Seek(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Seek_fnRecorder) ReturnResults(ret int64, err error) *MoqFile_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Ret int64
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Seek_doFn
		DoReturnFn MoqFile_starGenType_Seek_doReturnFn
	}{
		Values: &struct {
			Ret int64
			Err error
		}{
			Ret: ret,
			Err: err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Seek_fnRecorder) AndDo(fn MoqFile_starGenType_Seek_doFn) *MoqFile_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Seek_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Seek_doReturnFn) *MoqFile_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Ret int64
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Seek_doFn
		DoReturnFn MoqFile_starGenType_Seek_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Seek_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Seek_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Seek {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Seek_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Seek_paramsKey]*MoqFile_starGenType_Seek_results{},
		}
		r.Moq.ResultsByParams_Seek = append(r.Moq.ResultsByParams_Seek, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Seek) {
			copy(r.Moq.ResultsByParams_Seek[insertAt+1:], r.Moq.ResultsByParams_Seek[insertAt:0])
			r.Moq.ResultsByParams_Seek[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Seek(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Seek_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Seek_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Seek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Ret int64
					Err error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Seek_doFn
				DoReturnFn MoqFile_starGenType_Seek_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Seek(params MoqFile_starGenType_Seek_params) string {
	return fmt.Sprintf("Seek(%#v, %#v)", params.Offset, params.Whence)
}

func (m *MoqFile_starGenType) ParamsKey_Seek(params MoqFile_starGenType_Seek_params, anyParams uint64) MoqFile_starGenType_Seek_paramsKey {
	m.Scene.T.Helper()
	var offsetUsed int64
	var offsetUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Seek.Offset == moq.ParamIndexByValue {
			offsetUsed = params.Offset
		} else {
			offsetUsedHash = hash.DeepHash(params.Offset)
		}
	}
	var whenceUsed int
	var whenceUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Seek.Whence == moq.ParamIndexByValue {
			whenceUsed = params.Whence
		} else {
			whenceUsedHash = hash.DeepHash(params.Whence)
		}
	}
	return MoqFile_starGenType_Seek_paramsKey{
		Params: struct {
			Offset int64
			Whence int
		}{
			Offset: offsetUsed,
			Whence: whenceUsed,
		},
		Hashes: struct {
			Offset hash.Hash
			Whence hash.Hash
		}{
			Offset: offsetUsedHash,
			Whence: whenceUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) WriteString(s string) *MoqFile_starGenType_WriteString_fnRecorder {
	return &MoqFile_starGenType_WriteString_fnRecorder{
		Params: MoqFile_starGenType_WriteString_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_WriteString_fnRecorder) Any() *MoqFile_starGenType_WriteString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteString(r.Params))
		return nil
	}
	return &MoqFile_starGenType_WriteString_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_WriteString_anyParams) S() *MoqFile_starGenType_WriteString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_WriteString_fnRecorder) Seq() *MoqFile_starGenType_WriteString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_WriteString_fnRecorder) NoSeq() *MoqFile_starGenType_WriteString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WriteString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_WriteString_fnRecorder) ReturnResults(n int, err error) *MoqFile_starGenType_WriteString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_WriteString_doFn
		DoReturnFn MoqFile_starGenType_WriteString_doReturnFn
	}{
		Values: &struct {
			N   int
			Err error
		}{
			N:   n,
			Err: err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_WriteString_fnRecorder) AndDo(fn MoqFile_starGenType_WriteString_doFn) *MoqFile_starGenType_WriteString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_WriteString_fnRecorder) DoReturnResults(fn MoqFile_starGenType_WriteString_doReturnFn) *MoqFile_starGenType_WriteString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			N   int
			Err error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_WriteString_doFn
		DoReturnFn MoqFile_starGenType_WriteString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_WriteString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_WriteString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_WriteString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_WriteString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_WriteString_paramsKey]*MoqFile_starGenType_WriteString_results{},
		}
		r.Moq.ResultsByParams_WriteString = append(r.Moq.ResultsByParams_WriteString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_WriteString) {
			copy(r.Moq.ResultsByParams_WriteString[insertAt+1:], r.Moq.ResultsByParams_WriteString[insertAt:0])
			r.Moq.ResultsByParams_WriteString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_WriteString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_WriteString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_WriteString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_WriteString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					N   int
					Err error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_WriteString_doFn
				DoReturnFn MoqFile_starGenType_WriteString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_WriteString(params MoqFile_starGenType_WriteString_params) string {
	return fmt.Sprintf("WriteString(%#v)", params.S)
}

func (m *MoqFile_starGenType) ParamsKey_WriteString(params MoqFile_starGenType_WriteString_params, anyParams uint64) MoqFile_starGenType_WriteString_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.WriteString.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqFile_starGenType_WriteString_paramsKey{
		Params: struct{ S string }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) Chmod(mode os.FileMode) *MoqFile_starGenType_Chmod_fnRecorder {
	return &MoqFile_starGenType_Chmod_fnRecorder{
		Params: MoqFile_starGenType_Chmod_params{
			Mode: mode,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Chmod_fnRecorder) Any() *MoqFile_starGenType_Chmod_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Chmod(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Chmod_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Chmod_anyParams) Mode() *MoqFile_starGenType_Chmod_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_Chmod_fnRecorder) Seq() *MoqFile_starGenType_Chmod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Chmod(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Chmod_fnRecorder) NoSeq() *MoqFile_starGenType_Chmod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Chmod(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Chmod_fnRecorder) ReturnResults(result1 error) *MoqFile_starGenType_Chmod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Chmod_doFn
		DoReturnFn MoqFile_starGenType_Chmod_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Chmod_fnRecorder) AndDo(fn MoqFile_starGenType_Chmod_doFn) *MoqFile_starGenType_Chmod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Chmod_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Chmod_doReturnFn) *MoqFile_starGenType_Chmod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Chmod_doFn
		DoReturnFn MoqFile_starGenType_Chmod_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Chmod_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Chmod_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Chmod {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Chmod_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Chmod_paramsKey]*MoqFile_starGenType_Chmod_results{},
		}
		r.Moq.ResultsByParams_Chmod = append(r.Moq.ResultsByParams_Chmod, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Chmod) {
			copy(r.Moq.ResultsByParams_Chmod[insertAt+1:], r.Moq.ResultsByParams_Chmod[insertAt:0])
			r.Moq.ResultsByParams_Chmod[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Chmod(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Chmod_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Chmod_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Chmod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Chmod_doFn
				DoReturnFn MoqFile_starGenType_Chmod_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Chmod(params MoqFile_starGenType_Chmod_params) string {
	return fmt.Sprintf("Chmod(%#v)", params.Mode)
}

func (m *MoqFile_starGenType) ParamsKey_Chmod(params MoqFile_starGenType_Chmod_params, anyParams uint64) MoqFile_starGenType_Chmod_paramsKey {
	m.Scene.T.Helper()
	var modeUsed os.FileMode
	var modeUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Chmod.Mode == moq.ParamIndexByValue {
			modeUsed = params.Mode
		} else {
			modeUsedHash = hash.DeepHash(params.Mode)
		}
	}
	return MoqFile_starGenType_Chmod_paramsKey{
		Params: struct{ Mode os.FileMode }{
			Mode: modeUsed,
		},
		Hashes: struct{ Mode hash.Hash }{
			Mode: modeUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) SetDeadline(t time.Time) *MoqFile_starGenType_SetDeadline_fnRecorder {
	return &MoqFile_starGenType_SetDeadline_fnRecorder{
		Params: MoqFile_starGenType_SetDeadline_params{
			T: t,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_SetDeadline_fnRecorder) Any() *MoqFile_starGenType_SetDeadline_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetDeadline(r.Params))
		return nil
	}
	return &MoqFile_starGenType_SetDeadline_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_SetDeadline_anyParams) T() *MoqFile_starGenType_SetDeadline_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_SetDeadline_fnRecorder) Seq() *MoqFile_starGenType_SetDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetDeadline(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_SetDeadline_fnRecorder) NoSeq() *MoqFile_starGenType_SetDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetDeadline(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_SetDeadline_fnRecorder) ReturnResults(result1 error) *MoqFile_starGenType_SetDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetDeadline_doFn
		DoReturnFn MoqFile_starGenType_SetDeadline_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_SetDeadline_fnRecorder) AndDo(fn MoqFile_starGenType_SetDeadline_doFn) *MoqFile_starGenType_SetDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_SetDeadline_fnRecorder) DoReturnResults(fn MoqFile_starGenType_SetDeadline_doReturnFn) *MoqFile_starGenType_SetDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetDeadline_doFn
		DoReturnFn MoqFile_starGenType_SetDeadline_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_SetDeadline_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_SetDeadline_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetDeadline {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_SetDeadline_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_SetDeadline_paramsKey]*MoqFile_starGenType_SetDeadline_results{},
		}
		r.Moq.ResultsByParams_SetDeadline = append(r.Moq.ResultsByParams_SetDeadline, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetDeadline) {
			copy(r.Moq.ResultsByParams_SetDeadline[insertAt+1:], r.Moq.ResultsByParams_SetDeadline[insertAt:0])
			r.Moq.ResultsByParams_SetDeadline[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetDeadline(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_SetDeadline_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_SetDeadline_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_SetDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_SetDeadline_doFn
				DoReturnFn MoqFile_starGenType_SetDeadline_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_SetDeadline(params MoqFile_starGenType_SetDeadline_params) string {
	return fmt.Sprintf("SetDeadline(%#v)", params.T)
}

func (m *MoqFile_starGenType) ParamsKey_SetDeadline(params MoqFile_starGenType_SetDeadline_params, anyParams uint64) MoqFile_starGenType_SetDeadline_paramsKey {
	m.Scene.T.Helper()
	var tUsed time.Time
	var tUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetDeadline.T == moq.ParamIndexByValue {
			tUsed = params.T
		} else {
			tUsedHash = hash.DeepHash(params.T)
		}
	}
	return MoqFile_starGenType_SetDeadline_paramsKey{
		Params: struct{ T time.Time }{
			T: tUsed,
		},
		Hashes: struct{ T hash.Hash }{
			T: tUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) SetReadDeadline(t time.Time) *MoqFile_starGenType_SetReadDeadline_fnRecorder {
	return &MoqFile_starGenType_SetReadDeadline_fnRecorder{
		Params: MoqFile_starGenType_SetReadDeadline_params{
			T: t,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_SetReadDeadline_fnRecorder) Any() *MoqFile_starGenType_SetReadDeadline_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetReadDeadline(r.Params))
		return nil
	}
	return &MoqFile_starGenType_SetReadDeadline_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_SetReadDeadline_anyParams) T() *MoqFile_starGenType_SetReadDeadline_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_SetReadDeadline_fnRecorder) Seq() *MoqFile_starGenType_SetReadDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetReadDeadline(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_SetReadDeadline_fnRecorder) NoSeq() *MoqFile_starGenType_SetReadDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetReadDeadline(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_SetReadDeadline_fnRecorder) ReturnResults(result1 error) *MoqFile_starGenType_SetReadDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetReadDeadline_doFn
		DoReturnFn MoqFile_starGenType_SetReadDeadline_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_SetReadDeadline_fnRecorder) AndDo(fn MoqFile_starGenType_SetReadDeadline_doFn) *MoqFile_starGenType_SetReadDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_SetReadDeadline_fnRecorder) DoReturnResults(fn MoqFile_starGenType_SetReadDeadline_doReturnFn) *MoqFile_starGenType_SetReadDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetReadDeadline_doFn
		DoReturnFn MoqFile_starGenType_SetReadDeadline_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_SetReadDeadline_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_SetReadDeadline_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetReadDeadline {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_SetReadDeadline_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_SetReadDeadline_paramsKey]*MoqFile_starGenType_SetReadDeadline_results{},
		}
		r.Moq.ResultsByParams_SetReadDeadline = append(r.Moq.ResultsByParams_SetReadDeadline, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetReadDeadline) {
			copy(r.Moq.ResultsByParams_SetReadDeadline[insertAt+1:], r.Moq.ResultsByParams_SetReadDeadline[insertAt:0])
			r.Moq.ResultsByParams_SetReadDeadline[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetReadDeadline(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_SetReadDeadline_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_SetReadDeadline_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_SetReadDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_SetReadDeadline_doFn
				DoReturnFn MoqFile_starGenType_SetReadDeadline_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_SetReadDeadline(params MoqFile_starGenType_SetReadDeadline_params) string {
	return fmt.Sprintf("SetReadDeadline(%#v)", params.T)
}

func (m *MoqFile_starGenType) ParamsKey_SetReadDeadline(params MoqFile_starGenType_SetReadDeadline_params, anyParams uint64) MoqFile_starGenType_SetReadDeadline_paramsKey {
	m.Scene.T.Helper()
	var tUsed time.Time
	var tUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetReadDeadline.T == moq.ParamIndexByValue {
			tUsed = params.T
		} else {
			tUsedHash = hash.DeepHash(params.T)
		}
	}
	return MoqFile_starGenType_SetReadDeadline_paramsKey{
		Params: struct{ T time.Time }{
			T: tUsed,
		},
		Hashes: struct{ T hash.Hash }{
			T: tUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) SetWriteDeadline(t time.Time) *MoqFile_starGenType_SetWriteDeadline_fnRecorder {
	return &MoqFile_starGenType_SetWriteDeadline_fnRecorder{
		Params: MoqFile_starGenType_SetWriteDeadline_params{
			T: t,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_SetWriteDeadline_fnRecorder) Any() *MoqFile_starGenType_SetWriteDeadline_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetWriteDeadline(r.Params))
		return nil
	}
	return &MoqFile_starGenType_SetWriteDeadline_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_SetWriteDeadline_anyParams) T() *MoqFile_starGenType_SetWriteDeadline_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_SetWriteDeadline_fnRecorder) Seq() *MoqFile_starGenType_SetWriteDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetWriteDeadline(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_SetWriteDeadline_fnRecorder) NoSeq() *MoqFile_starGenType_SetWriteDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetWriteDeadline(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_SetWriteDeadline_fnRecorder) ReturnResults(result1 error) *MoqFile_starGenType_SetWriteDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetWriteDeadline_doFn
		DoReturnFn MoqFile_starGenType_SetWriteDeadline_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_SetWriteDeadline_fnRecorder) AndDo(fn MoqFile_starGenType_SetWriteDeadline_doFn) *MoqFile_starGenType_SetWriteDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_SetWriteDeadline_fnRecorder) DoReturnResults(fn MoqFile_starGenType_SetWriteDeadline_doReturnFn) *MoqFile_starGenType_SetWriteDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SetWriteDeadline_doFn
		DoReturnFn MoqFile_starGenType_SetWriteDeadline_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_SetWriteDeadline_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_SetWriteDeadline_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetWriteDeadline {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_SetWriteDeadline_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_SetWriteDeadline_paramsKey]*MoqFile_starGenType_SetWriteDeadline_results{},
		}
		r.Moq.ResultsByParams_SetWriteDeadline = append(r.Moq.ResultsByParams_SetWriteDeadline, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetWriteDeadline) {
			copy(r.Moq.ResultsByParams_SetWriteDeadline[insertAt+1:], r.Moq.ResultsByParams_SetWriteDeadline[insertAt:0])
			r.Moq.ResultsByParams_SetWriteDeadline[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetWriteDeadline(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_SetWriteDeadline_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_SetWriteDeadline_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_SetWriteDeadline_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_SetWriteDeadline_doFn
				DoReturnFn MoqFile_starGenType_SetWriteDeadline_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_SetWriteDeadline(params MoqFile_starGenType_SetWriteDeadline_params) string {
	return fmt.Sprintf("SetWriteDeadline(%#v)", params.T)
}

func (m *MoqFile_starGenType) ParamsKey_SetWriteDeadline(params MoqFile_starGenType_SetWriteDeadline_params, anyParams uint64) MoqFile_starGenType_SetWriteDeadline_paramsKey {
	m.Scene.T.Helper()
	var tUsed time.Time
	var tUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetWriteDeadline.T == moq.ParamIndexByValue {
			tUsed = params.T
		} else {
			tUsedHash = hash.DeepHash(params.T)
		}
	}
	return MoqFile_starGenType_SetWriteDeadline_paramsKey{
		Params: struct{ T time.Time }{
			T: tUsed,
		},
		Hashes: struct{ T hash.Hash }{
			T: tUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) SyscallConn() *MoqFile_starGenType_SyscallConn_fnRecorder {
	return &MoqFile_starGenType_SyscallConn_fnRecorder{
		Params:   MoqFile_starGenType_SyscallConn_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_SyscallConn_fnRecorder) Any() *MoqFile_starGenType_SyscallConn_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SyscallConn(r.Params))
		return nil
	}
	return &MoqFile_starGenType_SyscallConn_anyParams{Recorder: r}
}

func (r *MoqFile_starGenType_SyscallConn_fnRecorder) Seq() *MoqFile_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SyscallConn(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_SyscallConn_fnRecorder) NoSeq() *MoqFile_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SyscallConn(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_SyscallConn_fnRecorder) ReturnResults(result1 syscall.RawConn, result2 error) *MoqFile_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 syscall.RawConn
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SyscallConn_doFn
		DoReturnFn MoqFile_starGenType_SyscallConn_doReturnFn
	}{
		Values: &struct {
			Result1 syscall.RawConn
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_SyscallConn_fnRecorder) AndDo(fn MoqFile_starGenType_SyscallConn_doFn) *MoqFile_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_SyscallConn_fnRecorder) DoReturnResults(fn MoqFile_starGenType_SyscallConn_doReturnFn) *MoqFile_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 syscall.RawConn
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_SyscallConn_doFn
		DoReturnFn MoqFile_starGenType_SyscallConn_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_SyscallConn_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_SyscallConn_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SyscallConn {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_SyscallConn_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_SyscallConn_paramsKey]*MoqFile_starGenType_SyscallConn_results{},
		}
		r.Moq.ResultsByParams_SyscallConn = append(r.Moq.ResultsByParams_SyscallConn, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SyscallConn) {
			copy(r.Moq.ResultsByParams_SyscallConn[insertAt+1:], r.Moq.ResultsByParams_SyscallConn[insertAt:0])
			r.Moq.ResultsByParams_SyscallConn[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SyscallConn(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_SyscallConn_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_SyscallConn_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 syscall.RawConn
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_SyscallConn_doFn
				DoReturnFn MoqFile_starGenType_SyscallConn_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_SyscallConn(params MoqFile_starGenType_SyscallConn_params) string {
	return fmt.Sprintf("SyscallConn()")
}

func (m *MoqFile_starGenType) ParamsKey_SyscallConn(params MoqFile_starGenType_SyscallConn_params, anyParams uint64) MoqFile_starGenType_SyscallConn_paramsKey {
	m.Scene.T.Helper()
	return MoqFile_starGenType_SyscallConn_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFile_starGenType_recorder) Chown(uid, gid int) *MoqFile_starGenType_Chown_fnRecorder {
	return &MoqFile_starGenType_Chown_fnRecorder{
		Params: MoqFile_starGenType_Chown_params{
			Uid: uid,
			Gid: gid,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Chown_fnRecorder) Any() *MoqFile_starGenType_Chown_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Chown(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Chown_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Chown_anyParams) Uid() *MoqFile_starGenType_Chown_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqFile_starGenType_Chown_anyParams) Gid() *MoqFile_starGenType_Chown_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqFile_starGenType_Chown_fnRecorder) Seq() *MoqFile_starGenType_Chown_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Chown(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Chown_fnRecorder) NoSeq() *MoqFile_starGenType_Chown_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Chown(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Chown_fnRecorder) ReturnResults(result1 error) *MoqFile_starGenType_Chown_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Chown_doFn
		DoReturnFn MoqFile_starGenType_Chown_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Chown_fnRecorder) AndDo(fn MoqFile_starGenType_Chown_doFn) *MoqFile_starGenType_Chown_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Chown_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Chown_doReturnFn) *MoqFile_starGenType_Chown_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Chown_doFn
		DoReturnFn MoqFile_starGenType_Chown_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Chown_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Chown_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Chown {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Chown_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Chown_paramsKey]*MoqFile_starGenType_Chown_results{},
		}
		r.Moq.ResultsByParams_Chown = append(r.Moq.ResultsByParams_Chown, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Chown) {
			copy(r.Moq.ResultsByParams_Chown[insertAt+1:], r.Moq.ResultsByParams_Chown[insertAt:0])
			r.Moq.ResultsByParams_Chown[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Chown(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Chown_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Chown_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Chown_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Chown_doFn
				DoReturnFn MoqFile_starGenType_Chown_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Chown(params MoqFile_starGenType_Chown_params) string {
	return fmt.Sprintf("Chown(%#v, %#v)", params.Uid, params.Gid)
}

func (m *MoqFile_starGenType) ParamsKey_Chown(params MoqFile_starGenType_Chown_params, anyParams uint64) MoqFile_starGenType_Chown_paramsKey {
	m.Scene.T.Helper()
	var uidUsed int
	var uidUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Chown.Uid == moq.ParamIndexByValue {
			uidUsed = params.Uid
		} else {
			uidUsedHash = hash.DeepHash(params.Uid)
		}
	}
	var gidUsed int
	var gidUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Chown.Gid == moq.ParamIndexByValue {
			gidUsed = params.Gid
		} else {
			gidUsedHash = hash.DeepHash(params.Gid)
		}
	}
	return MoqFile_starGenType_Chown_paramsKey{
		Params: struct{ Uid, Gid int }{
			Uid: uidUsed,
			Gid: gidUsed,
		},
		Hashes: struct{ Uid, Gid hash.Hash }{
			Uid: uidUsedHash,
			Gid: gidUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) Truncate(size int64) *MoqFile_starGenType_Truncate_fnRecorder {
	return &MoqFile_starGenType_Truncate_fnRecorder{
		Params: MoqFile_starGenType_Truncate_params{
			Size: size,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Truncate_fnRecorder) Any() *MoqFile_starGenType_Truncate_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Truncate(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Truncate_anyParams{Recorder: r}
}

func (a *MoqFile_starGenType_Truncate_anyParams) Size() *MoqFile_starGenType_Truncate_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqFile_starGenType_Truncate_fnRecorder) Seq() *MoqFile_starGenType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Truncate(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Truncate_fnRecorder) NoSeq() *MoqFile_starGenType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Truncate(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Truncate_fnRecorder) ReturnResults(result1 error) *MoqFile_starGenType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Truncate_doFn
		DoReturnFn MoqFile_starGenType_Truncate_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Truncate_fnRecorder) AndDo(fn MoqFile_starGenType_Truncate_doFn) *MoqFile_starGenType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Truncate_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Truncate_doReturnFn) *MoqFile_starGenType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Truncate_doFn
		DoReturnFn MoqFile_starGenType_Truncate_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Truncate_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Truncate_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Truncate {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Truncate_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Truncate_paramsKey]*MoqFile_starGenType_Truncate_results{},
		}
		r.Moq.ResultsByParams_Truncate = append(r.Moq.ResultsByParams_Truncate, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Truncate) {
			copy(r.Moq.ResultsByParams_Truncate[insertAt+1:], r.Moq.ResultsByParams_Truncate[insertAt:0])
			r.Moq.ResultsByParams_Truncate[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Truncate(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Truncate_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Truncate_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Truncate_doFn
				DoReturnFn MoqFile_starGenType_Truncate_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Truncate(params MoqFile_starGenType_Truncate_params) string {
	return fmt.Sprintf("Truncate(%#v)", params.Size)
}

func (m *MoqFile_starGenType) ParamsKey_Truncate(params MoqFile_starGenType_Truncate_params, anyParams uint64) MoqFile_starGenType_Truncate_paramsKey {
	m.Scene.T.Helper()
	var sizeUsed int64
	var sizeUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Truncate.Size == moq.ParamIndexByValue {
			sizeUsed = params.Size
		} else {
			sizeUsedHash = hash.DeepHash(params.Size)
		}
	}
	return MoqFile_starGenType_Truncate_paramsKey{
		Params: struct{ Size int64 }{
			Size: sizeUsed,
		},
		Hashes: struct{ Size hash.Hash }{
			Size: sizeUsedHash,
		},
	}
}

func (m *MoqFile_starGenType_recorder) Sync() *MoqFile_starGenType_Sync_fnRecorder {
	return &MoqFile_starGenType_Sync_fnRecorder{
		Params:   MoqFile_starGenType_Sync_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Sync_fnRecorder) Any() *MoqFile_starGenType_Sync_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sync(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Sync_anyParams{Recorder: r}
}

func (r *MoqFile_starGenType_Sync_fnRecorder) Seq() *MoqFile_starGenType_Sync_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sync(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Sync_fnRecorder) NoSeq() *MoqFile_starGenType_Sync_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sync(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Sync_fnRecorder) ReturnResults(result1 error) *MoqFile_starGenType_Sync_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Sync_doFn
		DoReturnFn MoqFile_starGenType_Sync_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Sync_fnRecorder) AndDo(fn MoqFile_starGenType_Sync_doFn) *MoqFile_starGenType_Sync_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Sync_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Sync_doReturnFn) *MoqFile_starGenType_Sync_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Sync_doFn
		DoReturnFn MoqFile_starGenType_Sync_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Sync_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Sync_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Sync {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Sync_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Sync_paramsKey]*MoqFile_starGenType_Sync_results{},
		}
		r.Moq.ResultsByParams_Sync = append(r.Moq.ResultsByParams_Sync, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Sync) {
			copy(r.Moq.ResultsByParams_Sync[insertAt+1:], r.Moq.ResultsByParams_Sync[insertAt:0])
			r.Moq.ResultsByParams_Sync[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Sync(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Sync_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Sync_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Sync_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Sync_doFn
				DoReturnFn MoqFile_starGenType_Sync_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Sync(params MoqFile_starGenType_Sync_params) string {
	return fmt.Sprintf("Sync()")
}

func (m *MoqFile_starGenType) ParamsKey_Sync(params MoqFile_starGenType_Sync_params, anyParams uint64) MoqFile_starGenType_Sync_paramsKey {
	m.Scene.T.Helper()
	return MoqFile_starGenType_Sync_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFile_starGenType_recorder) Chdir() *MoqFile_starGenType_Chdir_fnRecorder {
	return &MoqFile_starGenType_Chdir_fnRecorder{
		Params:   MoqFile_starGenType_Chdir_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Chdir_fnRecorder) Any() *MoqFile_starGenType_Chdir_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Chdir(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Chdir_anyParams{Recorder: r}
}

func (r *MoqFile_starGenType_Chdir_fnRecorder) Seq() *MoqFile_starGenType_Chdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Chdir(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Chdir_fnRecorder) NoSeq() *MoqFile_starGenType_Chdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Chdir(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Chdir_fnRecorder) ReturnResults(result1 error) *MoqFile_starGenType_Chdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Chdir_doFn
		DoReturnFn MoqFile_starGenType_Chdir_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Chdir_fnRecorder) AndDo(fn MoqFile_starGenType_Chdir_doFn) *MoqFile_starGenType_Chdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Chdir_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Chdir_doReturnFn) *MoqFile_starGenType_Chdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Chdir_doFn
		DoReturnFn MoqFile_starGenType_Chdir_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Chdir_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Chdir_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Chdir {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Chdir_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Chdir_paramsKey]*MoqFile_starGenType_Chdir_results{},
		}
		r.Moq.ResultsByParams_Chdir = append(r.Moq.ResultsByParams_Chdir, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Chdir) {
			copy(r.Moq.ResultsByParams_Chdir[insertAt+1:], r.Moq.ResultsByParams_Chdir[insertAt:0])
			r.Moq.ResultsByParams_Chdir[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Chdir(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Chdir_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Chdir_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Chdir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Chdir_doFn
				DoReturnFn MoqFile_starGenType_Chdir_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Chdir(params MoqFile_starGenType_Chdir_params) string {
	return fmt.Sprintf("Chdir()")
}

func (m *MoqFile_starGenType) ParamsKey_Chdir(params MoqFile_starGenType_Chdir_params, anyParams uint64) MoqFile_starGenType_Chdir_paramsKey {
	m.Scene.T.Helper()
	return MoqFile_starGenType_Chdir_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFile_starGenType_recorder) Fd() *MoqFile_starGenType_Fd_fnRecorder {
	return &MoqFile_starGenType_Fd_fnRecorder{
		Params:   MoqFile_starGenType_Fd_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Fd_fnRecorder) Any() *MoqFile_starGenType_Fd_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fd(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Fd_anyParams{Recorder: r}
}

func (r *MoqFile_starGenType_Fd_fnRecorder) Seq() *MoqFile_starGenType_Fd_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fd(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Fd_fnRecorder) NoSeq() *MoqFile_starGenType_Fd_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Fd(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Fd_fnRecorder) ReturnResults(result1 uintptr) *MoqFile_starGenType_Fd_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Fd_doFn
		DoReturnFn MoqFile_starGenType_Fd_doReturnFn
	}{
		Values: &struct {
			Result1 uintptr
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Fd_fnRecorder) AndDo(fn MoqFile_starGenType_Fd_doFn) *MoqFile_starGenType_Fd_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Fd_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Fd_doReturnFn) *MoqFile_starGenType_Fd_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Fd_doFn
		DoReturnFn MoqFile_starGenType_Fd_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Fd_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Fd_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Fd {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Fd_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Fd_paramsKey]*MoqFile_starGenType_Fd_results{},
		}
		r.Moq.ResultsByParams_Fd = append(r.Moq.ResultsByParams_Fd, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Fd) {
			copy(r.Moq.ResultsByParams_Fd[insertAt+1:], r.Moq.ResultsByParams_Fd[insertAt:0])
			r.Moq.ResultsByParams_Fd[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Fd(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Fd_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Fd_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Fd_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 uintptr
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Fd_doFn
				DoReturnFn MoqFile_starGenType_Fd_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Fd(params MoqFile_starGenType_Fd_params) string {
	return fmt.Sprintf("Fd()")
}

func (m *MoqFile_starGenType) ParamsKey_Fd(params MoqFile_starGenType_Fd_params, anyParams uint64) MoqFile_starGenType_Fd_paramsKey {
	m.Scene.T.Helper()
	return MoqFile_starGenType_Fd_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFile_starGenType_recorder) Close() *MoqFile_starGenType_Close_fnRecorder {
	return &MoqFile_starGenType_Close_fnRecorder{
		Params:   MoqFile_starGenType_Close_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Close_fnRecorder) Any() *MoqFile_starGenType_Close_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Close(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Close_anyParams{Recorder: r}
}

func (r *MoqFile_starGenType_Close_fnRecorder) Seq() *MoqFile_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Close(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Close_fnRecorder) NoSeq() *MoqFile_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Close(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Close_fnRecorder) ReturnResults(result1 error) *MoqFile_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Close_doFn
		DoReturnFn MoqFile_starGenType_Close_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Close_fnRecorder) AndDo(fn MoqFile_starGenType_Close_doFn) *MoqFile_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Close_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Close_doReturnFn) *MoqFile_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Close_doFn
		DoReturnFn MoqFile_starGenType_Close_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Close_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Close_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Close {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Close_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Close_paramsKey]*MoqFile_starGenType_Close_results{},
		}
		r.Moq.ResultsByParams_Close = append(r.Moq.ResultsByParams_Close, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Close) {
			copy(r.Moq.ResultsByParams_Close[insertAt+1:], r.Moq.ResultsByParams_Close[insertAt:0])
			r.Moq.ResultsByParams_Close[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Close(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Close_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Close_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Close_doFn
				DoReturnFn MoqFile_starGenType_Close_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Close(params MoqFile_starGenType_Close_params) string {
	return fmt.Sprintf("Close()")
}

func (m *MoqFile_starGenType) ParamsKey_Close(params MoqFile_starGenType_Close_params, anyParams uint64) MoqFile_starGenType_Close_paramsKey {
	m.Scene.T.Helper()
	return MoqFile_starGenType_Close_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqFile_starGenType_recorder) Stat() *MoqFile_starGenType_Stat_fnRecorder {
	return &MoqFile_starGenType_Stat_fnRecorder{
		Params:   MoqFile_starGenType_Stat_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqFile_starGenType_Stat_fnRecorder) Any() *MoqFile_starGenType_Stat_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Stat(r.Params))
		return nil
	}
	return &MoqFile_starGenType_Stat_anyParams{Recorder: r}
}

func (r *MoqFile_starGenType_Stat_fnRecorder) Seq() *MoqFile_starGenType_Stat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Stat(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqFile_starGenType_Stat_fnRecorder) NoSeq() *MoqFile_starGenType_Stat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Stat(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqFile_starGenType_Stat_fnRecorder) ReturnResults(result1 os.FileInfo, result2 error) *MoqFile_starGenType_Stat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 os.FileInfo
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Stat_doFn
		DoReturnFn MoqFile_starGenType_Stat_doReturnFn
	}{
		Values: &struct {
			Result1 os.FileInfo
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqFile_starGenType_Stat_fnRecorder) AndDo(fn MoqFile_starGenType_Stat_doFn) *MoqFile_starGenType_Stat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqFile_starGenType_Stat_fnRecorder) DoReturnResults(fn MoqFile_starGenType_Stat_doReturnFn) *MoqFile_starGenType_Stat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 os.FileInfo
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqFile_starGenType_Stat_doFn
		DoReturnFn MoqFile_starGenType_Stat_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqFile_starGenType_Stat_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqFile_starGenType_Stat_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Stat {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqFile_starGenType_Stat_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqFile_starGenType_Stat_paramsKey]*MoqFile_starGenType_Stat_results{},
		}
		r.Moq.ResultsByParams_Stat = append(r.Moq.ResultsByParams_Stat, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Stat) {
			copy(r.Moq.ResultsByParams_Stat[insertAt+1:], r.Moq.ResultsByParams_Stat[insertAt:0])
			r.Moq.ResultsByParams_Stat[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Stat(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqFile_starGenType_Stat_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqFile_starGenType_Stat_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqFile_starGenType_Stat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 os.FileInfo
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqFile_starGenType_Stat_doFn
				DoReturnFn MoqFile_starGenType_Stat_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqFile_starGenType) PrettyParams_Stat(params MoqFile_starGenType_Stat_params) string {
	return fmt.Sprintf("Stat()")
}

func (m *MoqFile_starGenType) ParamsKey_Stat(params MoqFile_starGenType_Stat_params, anyParams uint64) MoqFile_starGenType_Stat_paramsKey {
	m.Scene.T.Helper()
	return MoqFile_starGenType_Stat_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqFile_starGenType) Reset() {
	m.ResultsByParams_Readdir = nil
	m.ResultsByParams_Readdirnames = nil
	m.ResultsByParams_Name = nil
	m.ResultsByParams_Read = nil
	m.ResultsByParams_ReadAt = nil
	m.ResultsByParams_Write = nil
	m.ResultsByParams_WriteAt = nil
	m.ResultsByParams_Seek = nil
	m.ResultsByParams_WriteString = nil
	m.ResultsByParams_Chmod = nil
	m.ResultsByParams_SetDeadline = nil
	m.ResultsByParams_SetReadDeadline = nil
	m.ResultsByParams_SetWriteDeadline = nil
	m.ResultsByParams_SyscallConn = nil
	m.ResultsByParams_Chown = nil
	m.ResultsByParams_Truncate = nil
	m.ResultsByParams_Sync = nil
	m.ResultsByParams_Chdir = nil
	m.ResultsByParams_Fd = nil
	m.ResultsByParams_Close = nil
	m.ResultsByParams_Stat = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqFile_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Readdir {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Readdir(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Readdirnames {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Readdirnames(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Name {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Name(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Read {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Read(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReadAt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReadAt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Write {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Write(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_WriteAt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_WriteAt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Seek {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Seek(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_WriteString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_WriteString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Chmod {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Chmod(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetDeadline {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetDeadline(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetReadDeadline {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetReadDeadline(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetWriteDeadline {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetWriteDeadline(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SyscallConn {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SyscallConn(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Chown {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Chown(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Truncate {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Truncate(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Sync {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Sync(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Chdir {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Chdir(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Fd {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Fd(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Close {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Close(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Stat {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Stat(results.Params))
			}
		}
	}
}
