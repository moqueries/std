// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package smtp

import (
	"crypto/tls"
	"fmt"
	"io"
	"math/bits"
	"net/smtp"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that smtp.Client_starGenType is mocked
// completely
var _ Client_starGenType = (*MoqClient_starGenType_mock)(nil)

// Client_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Client_starGenType interface {
	Close() error
	Hello(localName string) error
	StartTLS(config *tls.Config) error
	TLSConnectionState() (state tls.ConnectionState, ok bool)
	Verify(addr string) error
	Auth(a smtp.Auth) error
	Mail(from string) error
	Rcpt(to string) error
	Data() (io.WriteCloser, error)
	Extension(ext string) (bool, string)
	Reset() error
	Noop() error
	Quit() error
}

// MoqClient_starGenType holds the state of a moq of the Client_starGenType
// type
type MoqClient_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqClient_starGenType_mock

	ResultsByParams_Close              []MoqClient_starGenType_Close_resultsByParams
	ResultsByParams_Hello              []MoqClient_starGenType_Hello_resultsByParams
	ResultsByParams_StartTLS           []MoqClient_starGenType_StartTLS_resultsByParams
	ResultsByParams_TLSConnectionState []MoqClient_starGenType_TLSConnectionState_resultsByParams
	ResultsByParams_Verify             []MoqClient_starGenType_Verify_resultsByParams
	ResultsByParams_Auth               []MoqClient_starGenType_Auth_resultsByParams
	ResultsByParams_Mail               []MoqClient_starGenType_Mail_resultsByParams
	ResultsByParams_Rcpt               []MoqClient_starGenType_Rcpt_resultsByParams
	ResultsByParams_Data               []MoqClient_starGenType_Data_resultsByParams
	ResultsByParams_Extension          []MoqClient_starGenType_Extension_resultsByParams
	ResultsByParams_Reset              []MoqClient_starGenType_Reset_resultsByParams
	ResultsByParams_Noop               []MoqClient_starGenType_Noop_resultsByParams
	ResultsByParams_Quit               []MoqClient_starGenType_Quit_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Close struct{}
			Hello struct {
				LocalName moq.ParamIndexing
			}
			StartTLS struct {
				Config moq.ParamIndexing
			}
			TLSConnectionState struct{}
			Verify             struct {
				Addr moq.ParamIndexing
			}
			Auth struct {
				A moq.ParamIndexing
			}
			Mail struct {
				From moq.ParamIndexing
			}
			Rcpt struct {
				To moq.ParamIndexing
			}
			Data      struct{}
			Extension struct {
				Ext moq.ParamIndexing
			}
			Reset struct{}
			Noop  struct{}
			Quit  struct{}
		}
	}
}

// MoqClient_starGenType_mock isolates the mock interface of the
// Client_starGenType type
type MoqClient_starGenType_mock struct {
	Moq *MoqClient_starGenType
}

// MoqClient_starGenType_recorder isolates the recorder interface of the
// Client_starGenType type
type MoqClient_starGenType_recorder struct {
	Moq *MoqClient_starGenType
}

// MoqClient_starGenType_Close_params holds the params of the
// Client_starGenType type
type MoqClient_starGenType_Close_params struct{}

// MoqClient_starGenType_Close_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_Close_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqClient_starGenType_Close_resultsByParams contains the results for a given
// set of parameters for the Client_starGenType type
type MoqClient_starGenType_Close_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_Close_paramsKey]*MoqClient_starGenType_Close_results
}

// MoqClient_starGenType_Close_doFn defines the type of function needed when
// calling AndDo for the Client_starGenType type
type MoqClient_starGenType_Close_doFn func()

// MoqClient_starGenType_Close_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_Close_doReturnFn func() error

// MoqClient_starGenType_Close_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_Close_results struct {
	Params  MoqClient_starGenType_Close_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Close_doFn
		DoReturnFn MoqClient_starGenType_Close_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_Close_fnRecorder routes recorded function calls to the
// MoqClient_starGenType moq
type MoqClient_starGenType_Close_fnRecorder struct {
	Params    MoqClient_starGenType_Close_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_Close_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_Close_anyParams isolates the any params functions of
// the Client_starGenType type
type MoqClient_starGenType_Close_anyParams struct {
	Recorder *MoqClient_starGenType_Close_fnRecorder
}

// MoqClient_starGenType_Hello_params holds the params of the
// Client_starGenType type
type MoqClient_starGenType_Hello_params struct{ LocalName string }

// MoqClient_starGenType_Hello_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_Hello_paramsKey struct {
	Params struct{ LocalName string }
	Hashes struct{ LocalName hash.Hash }
}

// MoqClient_starGenType_Hello_resultsByParams contains the results for a given
// set of parameters for the Client_starGenType type
type MoqClient_starGenType_Hello_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_Hello_paramsKey]*MoqClient_starGenType_Hello_results
}

// MoqClient_starGenType_Hello_doFn defines the type of function needed when
// calling AndDo for the Client_starGenType type
type MoqClient_starGenType_Hello_doFn func(localName string)

// MoqClient_starGenType_Hello_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_Hello_doReturnFn func(localName string) error

// MoqClient_starGenType_Hello_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_Hello_results struct {
	Params  MoqClient_starGenType_Hello_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Hello_doFn
		DoReturnFn MoqClient_starGenType_Hello_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_Hello_fnRecorder routes recorded function calls to the
// MoqClient_starGenType moq
type MoqClient_starGenType_Hello_fnRecorder struct {
	Params    MoqClient_starGenType_Hello_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_Hello_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_Hello_anyParams isolates the any params functions of
// the Client_starGenType type
type MoqClient_starGenType_Hello_anyParams struct {
	Recorder *MoqClient_starGenType_Hello_fnRecorder
}

// MoqClient_starGenType_StartTLS_params holds the params of the
// Client_starGenType type
type MoqClient_starGenType_StartTLS_params struct{ Config *tls.Config }

// MoqClient_starGenType_StartTLS_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_StartTLS_paramsKey struct {
	Params struct{ Config *tls.Config }
	Hashes struct{ Config hash.Hash }
}

// MoqClient_starGenType_StartTLS_resultsByParams contains the results for a
// given set of parameters for the Client_starGenType type
type MoqClient_starGenType_StartTLS_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_StartTLS_paramsKey]*MoqClient_starGenType_StartTLS_results
}

// MoqClient_starGenType_StartTLS_doFn defines the type of function needed when
// calling AndDo for the Client_starGenType type
type MoqClient_starGenType_StartTLS_doFn func(config *tls.Config)

// MoqClient_starGenType_StartTLS_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_StartTLS_doReturnFn func(config *tls.Config) error

// MoqClient_starGenType_StartTLS_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_StartTLS_results struct {
	Params  MoqClient_starGenType_StartTLS_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_StartTLS_doFn
		DoReturnFn MoqClient_starGenType_StartTLS_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_StartTLS_fnRecorder routes recorded function calls to
// the MoqClient_starGenType moq
type MoqClient_starGenType_StartTLS_fnRecorder struct {
	Params    MoqClient_starGenType_StartTLS_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_StartTLS_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_StartTLS_anyParams isolates the any params functions
// of the Client_starGenType type
type MoqClient_starGenType_StartTLS_anyParams struct {
	Recorder *MoqClient_starGenType_StartTLS_fnRecorder
}

// MoqClient_starGenType_TLSConnectionState_params holds the params of the
// Client_starGenType type
type MoqClient_starGenType_TLSConnectionState_params struct{}

// MoqClient_starGenType_TLSConnectionState_paramsKey holds the map key params
// of the Client_starGenType type
type MoqClient_starGenType_TLSConnectionState_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqClient_starGenType_TLSConnectionState_resultsByParams contains the
// results for a given set of parameters for the Client_starGenType type
type MoqClient_starGenType_TLSConnectionState_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_TLSConnectionState_paramsKey]*MoqClient_starGenType_TLSConnectionState_results
}

// MoqClient_starGenType_TLSConnectionState_doFn defines the type of function
// needed when calling AndDo for the Client_starGenType type
type MoqClient_starGenType_TLSConnectionState_doFn func()

// MoqClient_starGenType_TLSConnectionState_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_TLSConnectionState_doReturnFn func() (state tls.ConnectionState, ok bool)

// MoqClient_starGenType_TLSConnectionState_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_TLSConnectionState_results struct {
	Params  MoqClient_starGenType_TLSConnectionState_params
	Results []struct {
		Values *struct {
			State tls.ConnectionState
			Ok    bool
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_TLSConnectionState_doFn
		DoReturnFn MoqClient_starGenType_TLSConnectionState_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_TLSConnectionState_fnRecorder routes recorded function
// calls to the MoqClient_starGenType moq
type MoqClient_starGenType_TLSConnectionState_fnRecorder struct {
	Params    MoqClient_starGenType_TLSConnectionState_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_TLSConnectionState_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_TLSConnectionState_anyParams isolates the any params
// functions of the Client_starGenType type
type MoqClient_starGenType_TLSConnectionState_anyParams struct {
	Recorder *MoqClient_starGenType_TLSConnectionState_fnRecorder
}

// MoqClient_starGenType_Verify_params holds the params of the
// Client_starGenType type
type MoqClient_starGenType_Verify_params struct{ Addr string }

// MoqClient_starGenType_Verify_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_Verify_paramsKey struct {
	Params struct{ Addr string }
	Hashes struct{ Addr hash.Hash }
}

// MoqClient_starGenType_Verify_resultsByParams contains the results for a
// given set of parameters for the Client_starGenType type
type MoqClient_starGenType_Verify_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_Verify_paramsKey]*MoqClient_starGenType_Verify_results
}

// MoqClient_starGenType_Verify_doFn defines the type of function needed when
// calling AndDo for the Client_starGenType type
type MoqClient_starGenType_Verify_doFn func(addr string)

// MoqClient_starGenType_Verify_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_Verify_doReturnFn func(addr string) error

// MoqClient_starGenType_Verify_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_Verify_results struct {
	Params  MoqClient_starGenType_Verify_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Verify_doFn
		DoReturnFn MoqClient_starGenType_Verify_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_Verify_fnRecorder routes recorded function calls to
// the MoqClient_starGenType moq
type MoqClient_starGenType_Verify_fnRecorder struct {
	Params    MoqClient_starGenType_Verify_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_Verify_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_Verify_anyParams isolates the any params functions of
// the Client_starGenType type
type MoqClient_starGenType_Verify_anyParams struct {
	Recorder *MoqClient_starGenType_Verify_fnRecorder
}

// MoqClient_starGenType_Auth_params holds the params of the Client_starGenType
// type
type MoqClient_starGenType_Auth_params struct{ A smtp.Auth }

// MoqClient_starGenType_Auth_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_Auth_paramsKey struct {
	Params struct{ A smtp.Auth }
	Hashes struct{ A hash.Hash }
}

// MoqClient_starGenType_Auth_resultsByParams contains the results for a given
// set of parameters for the Client_starGenType type
type MoqClient_starGenType_Auth_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_Auth_paramsKey]*MoqClient_starGenType_Auth_results
}

// MoqClient_starGenType_Auth_doFn defines the type of function needed when
// calling AndDo for the Client_starGenType type
type MoqClient_starGenType_Auth_doFn func(a smtp.Auth)

// MoqClient_starGenType_Auth_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_Auth_doReturnFn func(a smtp.Auth) error

// MoqClient_starGenType_Auth_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_Auth_results struct {
	Params  MoqClient_starGenType_Auth_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Auth_doFn
		DoReturnFn MoqClient_starGenType_Auth_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_Auth_fnRecorder routes recorded function calls to the
// MoqClient_starGenType moq
type MoqClient_starGenType_Auth_fnRecorder struct {
	Params    MoqClient_starGenType_Auth_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_Auth_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_Auth_anyParams isolates the any params functions of
// the Client_starGenType type
type MoqClient_starGenType_Auth_anyParams struct {
	Recorder *MoqClient_starGenType_Auth_fnRecorder
}

// MoqClient_starGenType_Mail_params holds the params of the Client_starGenType
// type
type MoqClient_starGenType_Mail_params struct{ From string }

// MoqClient_starGenType_Mail_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_Mail_paramsKey struct {
	Params struct{ From string }
	Hashes struct{ From hash.Hash }
}

// MoqClient_starGenType_Mail_resultsByParams contains the results for a given
// set of parameters for the Client_starGenType type
type MoqClient_starGenType_Mail_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_Mail_paramsKey]*MoqClient_starGenType_Mail_results
}

// MoqClient_starGenType_Mail_doFn defines the type of function needed when
// calling AndDo for the Client_starGenType type
type MoqClient_starGenType_Mail_doFn func(from string)

// MoqClient_starGenType_Mail_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_Mail_doReturnFn func(from string) error

// MoqClient_starGenType_Mail_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_Mail_results struct {
	Params  MoqClient_starGenType_Mail_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Mail_doFn
		DoReturnFn MoqClient_starGenType_Mail_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_Mail_fnRecorder routes recorded function calls to the
// MoqClient_starGenType moq
type MoqClient_starGenType_Mail_fnRecorder struct {
	Params    MoqClient_starGenType_Mail_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_Mail_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_Mail_anyParams isolates the any params functions of
// the Client_starGenType type
type MoqClient_starGenType_Mail_anyParams struct {
	Recorder *MoqClient_starGenType_Mail_fnRecorder
}

// MoqClient_starGenType_Rcpt_params holds the params of the Client_starGenType
// type
type MoqClient_starGenType_Rcpt_params struct{ To string }

// MoqClient_starGenType_Rcpt_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_Rcpt_paramsKey struct {
	Params struct{ To string }
	Hashes struct{ To hash.Hash }
}

// MoqClient_starGenType_Rcpt_resultsByParams contains the results for a given
// set of parameters for the Client_starGenType type
type MoqClient_starGenType_Rcpt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_Rcpt_paramsKey]*MoqClient_starGenType_Rcpt_results
}

// MoqClient_starGenType_Rcpt_doFn defines the type of function needed when
// calling AndDo for the Client_starGenType type
type MoqClient_starGenType_Rcpt_doFn func(to string)

// MoqClient_starGenType_Rcpt_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_Rcpt_doReturnFn func(to string) error

// MoqClient_starGenType_Rcpt_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_Rcpt_results struct {
	Params  MoqClient_starGenType_Rcpt_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Rcpt_doFn
		DoReturnFn MoqClient_starGenType_Rcpt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_Rcpt_fnRecorder routes recorded function calls to the
// MoqClient_starGenType moq
type MoqClient_starGenType_Rcpt_fnRecorder struct {
	Params    MoqClient_starGenType_Rcpt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_Rcpt_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_Rcpt_anyParams isolates the any params functions of
// the Client_starGenType type
type MoqClient_starGenType_Rcpt_anyParams struct {
	Recorder *MoqClient_starGenType_Rcpt_fnRecorder
}

// MoqClient_starGenType_Data_params holds the params of the Client_starGenType
// type
type MoqClient_starGenType_Data_params struct{}

// MoqClient_starGenType_Data_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_Data_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqClient_starGenType_Data_resultsByParams contains the results for a given
// set of parameters for the Client_starGenType type
type MoqClient_starGenType_Data_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_Data_paramsKey]*MoqClient_starGenType_Data_results
}

// MoqClient_starGenType_Data_doFn defines the type of function needed when
// calling AndDo for the Client_starGenType type
type MoqClient_starGenType_Data_doFn func()

// MoqClient_starGenType_Data_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_Data_doReturnFn func() (io.WriteCloser, error)

// MoqClient_starGenType_Data_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_Data_results struct {
	Params  MoqClient_starGenType_Data_params
	Results []struct {
		Values *struct {
			Result1 io.WriteCloser
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Data_doFn
		DoReturnFn MoqClient_starGenType_Data_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_Data_fnRecorder routes recorded function calls to the
// MoqClient_starGenType moq
type MoqClient_starGenType_Data_fnRecorder struct {
	Params    MoqClient_starGenType_Data_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_Data_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_Data_anyParams isolates the any params functions of
// the Client_starGenType type
type MoqClient_starGenType_Data_anyParams struct {
	Recorder *MoqClient_starGenType_Data_fnRecorder
}

// MoqClient_starGenType_Extension_params holds the params of the
// Client_starGenType type
type MoqClient_starGenType_Extension_params struct{ Ext string }

// MoqClient_starGenType_Extension_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_Extension_paramsKey struct {
	Params struct{ Ext string }
	Hashes struct{ Ext hash.Hash }
}

// MoqClient_starGenType_Extension_resultsByParams contains the results for a
// given set of parameters for the Client_starGenType type
type MoqClient_starGenType_Extension_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_Extension_paramsKey]*MoqClient_starGenType_Extension_results
}

// MoqClient_starGenType_Extension_doFn defines the type of function needed
// when calling AndDo for the Client_starGenType type
type MoqClient_starGenType_Extension_doFn func(ext string)

// MoqClient_starGenType_Extension_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_Extension_doReturnFn func(ext string) (bool, string)

// MoqClient_starGenType_Extension_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_Extension_results struct {
	Params  MoqClient_starGenType_Extension_params
	Results []struct {
		Values *struct {
			Result1 bool
			Result2 string
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Extension_doFn
		DoReturnFn MoqClient_starGenType_Extension_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_Extension_fnRecorder routes recorded function calls to
// the MoqClient_starGenType moq
type MoqClient_starGenType_Extension_fnRecorder struct {
	Params    MoqClient_starGenType_Extension_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_Extension_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_Extension_anyParams isolates the any params functions
// of the Client_starGenType type
type MoqClient_starGenType_Extension_anyParams struct {
	Recorder *MoqClient_starGenType_Extension_fnRecorder
}

// MoqClient_starGenType_Reset_params holds the params of the
// Client_starGenType type
type MoqClient_starGenType_Reset_params struct{}

// MoqClient_starGenType_Reset_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_Reset_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqClient_starGenType_Reset_resultsByParams contains the results for a given
// set of parameters for the Client_starGenType type
type MoqClient_starGenType_Reset_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_Reset_paramsKey]*MoqClient_starGenType_Reset_results
}

// MoqClient_starGenType_Reset_doFn defines the type of function needed when
// calling AndDo for the Client_starGenType type
type MoqClient_starGenType_Reset_doFn func()

// MoqClient_starGenType_Reset_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_Reset_doReturnFn func() error

// MoqClient_starGenType_Reset_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_Reset_results struct {
	Params  MoqClient_starGenType_Reset_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Reset_doFn
		DoReturnFn MoqClient_starGenType_Reset_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_Reset_fnRecorder routes recorded function calls to the
// MoqClient_starGenType moq
type MoqClient_starGenType_Reset_fnRecorder struct {
	Params    MoqClient_starGenType_Reset_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_Reset_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_Reset_anyParams isolates the any params functions of
// the Client_starGenType type
type MoqClient_starGenType_Reset_anyParams struct {
	Recorder *MoqClient_starGenType_Reset_fnRecorder
}

// MoqClient_starGenType_Noop_params holds the params of the Client_starGenType
// type
type MoqClient_starGenType_Noop_params struct{}

// MoqClient_starGenType_Noop_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_Noop_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqClient_starGenType_Noop_resultsByParams contains the results for a given
// set of parameters for the Client_starGenType type
type MoqClient_starGenType_Noop_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_Noop_paramsKey]*MoqClient_starGenType_Noop_results
}

// MoqClient_starGenType_Noop_doFn defines the type of function needed when
// calling AndDo for the Client_starGenType type
type MoqClient_starGenType_Noop_doFn func()

// MoqClient_starGenType_Noop_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_Noop_doReturnFn func() error

// MoqClient_starGenType_Noop_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_Noop_results struct {
	Params  MoqClient_starGenType_Noop_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Noop_doFn
		DoReturnFn MoqClient_starGenType_Noop_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_Noop_fnRecorder routes recorded function calls to the
// MoqClient_starGenType moq
type MoqClient_starGenType_Noop_fnRecorder struct {
	Params    MoqClient_starGenType_Noop_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_Noop_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_Noop_anyParams isolates the any params functions of
// the Client_starGenType type
type MoqClient_starGenType_Noop_anyParams struct {
	Recorder *MoqClient_starGenType_Noop_fnRecorder
}

// MoqClient_starGenType_Quit_params holds the params of the Client_starGenType
// type
type MoqClient_starGenType_Quit_params struct{}

// MoqClient_starGenType_Quit_paramsKey holds the map key params of the
// Client_starGenType type
type MoqClient_starGenType_Quit_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqClient_starGenType_Quit_resultsByParams contains the results for a given
// set of parameters for the Client_starGenType type
type MoqClient_starGenType_Quit_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqClient_starGenType_Quit_paramsKey]*MoqClient_starGenType_Quit_results
}

// MoqClient_starGenType_Quit_doFn defines the type of function needed when
// calling AndDo for the Client_starGenType type
type MoqClient_starGenType_Quit_doFn func()

// MoqClient_starGenType_Quit_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Client_starGenType type
type MoqClient_starGenType_Quit_doReturnFn func() error

// MoqClient_starGenType_Quit_results holds the results of the
// Client_starGenType type
type MoqClient_starGenType_Quit_results struct {
	Params  MoqClient_starGenType_Quit_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Quit_doFn
		DoReturnFn MoqClient_starGenType_Quit_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqClient_starGenType_Quit_fnRecorder routes recorded function calls to the
// MoqClient_starGenType moq
type MoqClient_starGenType_Quit_fnRecorder struct {
	Params    MoqClient_starGenType_Quit_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqClient_starGenType_Quit_results
	Moq       *MoqClient_starGenType
}

// MoqClient_starGenType_Quit_anyParams isolates the any params functions of
// the Client_starGenType type
type MoqClient_starGenType_Quit_anyParams struct {
	Recorder *MoqClient_starGenType_Quit_fnRecorder
}

// NewMoqClient_starGenType creates a new moq of the Client_starGenType type
func NewMoqClient_starGenType(scene *moq.Scene, config *moq.Config) *MoqClient_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqClient_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqClient_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Close struct{}
				Hello struct {
					LocalName moq.ParamIndexing
				}
				StartTLS struct {
					Config moq.ParamIndexing
				}
				TLSConnectionState struct{}
				Verify             struct {
					Addr moq.ParamIndexing
				}
				Auth struct {
					A moq.ParamIndexing
				}
				Mail struct {
					From moq.ParamIndexing
				}
				Rcpt struct {
					To moq.ParamIndexing
				}
				Data      struct{}
				Extension struct {
					Ext moq.ParamIndexing
				}
				Reset struct{}
				Noop  struct{}
				Quit  struct{}
			}
		}{ParameterIndexing: struct {
			Close struct{}
			Hello struct {
				LocalName moq.ParamIndexing
			}
			StartTLS struct {
				Config moq.ParamIndexing
			}
			TLSConnectionState struct{}
			Verify             struct {
				Addr moq.ParamIndexing
			}
			Auth struct {
				A moq.ParamIndexing
			}
			Mail struct {
				From moq.ParamIndexing
			}
			Rcpt struct {
				To moq.ParamIndexing
			}
			Data      struct{}
			Extension struct {
				Ext moq.ParamIndexing
			}
			Reset struct{}
			Noop  struct{}
			Quit  struct{}
		}{
			Close: struct{}{},
			Hello: struct {
				LocalName moq.ParamIndexing
			}{
				LocalName: moq.ParamIndexByValue,
			},
			StartTLS: struct {
				Config moq.ParamIndexing
			}{
				Config: moq.ParamIndexByHash,
			},
			TLSConnectionState: struct{}{},
			Verify: struct {
				Addr moq.ParamIndexing
			}{
				Addr: moq.ParamIndexByValue,
			},
			Auth: struct {
				A moq.ParamIndexing
			}{
				A: moq.ParamIndexByHash,
			},
			Mail: struct {
				From moq.ParamIndexing
			}{
				From: moq.ParamIndexByValue,
			},
			Rcpt: struct {
				To moq.ParamIndexing
			}{
				To: moq.ParamIndexByValue,
			},
			Data: struct{}{},
			Extension: struct {
				Ext moq.ParamIndexing
			}{
				Ext: moq.ParamIndexByValue,
			},
			Reset: struct{}{},
			Noop:  struct{}{},
			Quit:  struct{}{},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Client_starGenType type
func (m *MoqClient_starGenType) Mock() *MoqClient_starGenType_mock { return m.Moq }

func (m *MoqClient_starGenType_mock) Close() (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_Close_params{}
	var results *MoqClient_starGenType_Close_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Close {
		paramsKey := m.Moq.ParamsKey_Close(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Close(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Close(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Close(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqClient_starGenType_mock) Hello(localName string) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_Hello_params{
		LocalName: localName,
	}
	var results *MoqClient_starGenType_Hello_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Hello {
		paramsKey := m.Moq.ParamsKey_Hello(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Hello(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Hello(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Hello(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(localName)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(localName)
	}
	return
}

func (m *MoqClient_starGenType_mock) StartTLS(config *tls.Config) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_StartTLS_params{
		Config: config,
	}
	var results *MoqClient_starGenType_StartTLS_results
	for _, resultsByParams := range m.Moq.ResultsByParams_StartTLS {
		paramsKey := m.Moq.ParamsKey_StartTLS(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_StartTLS(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_StartTLS(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_StartTLS(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(config)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(config)
	}
	return
}

func (m *MoqClient_starGenType_mock) TLSConnectionState() (state tls.ConnectionState, ok bool) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_TLSConnectionState_params{}
	var results *MoqClient_starGenType_TLSConnectionState_results
	for _, resultsByParams := range m.Moq.ResultsByParams_TLSConnectionState {
		paramsKey := m.Moq.ParamsKey_TLSConnectionState(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_TLSConnectionState(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_TLSConnectionState(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_TLSConnectionState(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		state = result.Values.State
		ok = result.Values.Ok
	}
	if result.DoReturnFn != nil {
		state, ok = result.DoReturnFn()
	}
	return
}

func (m *MoqClient_starGenType_mock) Verify(addr string) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_Verify_params{
		Addr: addr,
	}
	var results *MoqClient_starGenType_Verify_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Verify {
		paramsKey := m.Moq.ParamsKey_Verify(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Verify(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Verify(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Verify(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(addr)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(addr)
	}
	return
}

func (m *MoqClient_starGenType_mock) Auth(a smtp.Auth) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_Auth_params{
		A: a,
	}
	var results *MoqClient_starGenType_Auth_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Auth {
		paramsKey := m.Moq.ParamsKey_Auth(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Auth(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Auth(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Auth(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(a)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(a)
	}
	return
}

func (m *MoqClient_starGenType_mock) Mail(from string) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_Mail_params{
		From: from,
	}
	var results *MoqClient_starGenType_Mail_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Mail {
		paramsKey := m.Moq.ParamsKey_Mail(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Mail(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Mail(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Mail(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(from)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(from)
	}
	return
}

func (m *MoqClient_starGenType_mock) Rcpt(to string) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_Rcpt_params{
		To: to,
	}
	var results *MoqClient_starGenType_Rcpt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Rcpt {
		paramsKey := m.Moq.ParamsKey_Rcpt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Rcpt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Rcpt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Rcpt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(to)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(to)
	}
	return
}

func (m *MoqClient_starGenType_mock) Data() (result1 io.WriteCloser, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_Data_params{}
	var results *MoqClient_starGenType_Data_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Data {
		paramsKey := m.Moq.ParamsKey_Data(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Data(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Data(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Data(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqClient_starGenType_mock) Extension(ext string) (result1 bool, result2 string) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_Extension_params{
		Ext: ext,
	}
	var results *MoqClient_starGenType_Extension_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Extension {
		paramsKey := m.Moq.ParamsKey_Extension(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Extension(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Extension(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Extension(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ext)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(ext)
	}
	return
}

func (m *MoqClient_starGenType_mock) Reset() (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_Reset_params{}
	var results *MoqClient_starGenType_Reset_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Reset {
		paramsKey := m.Moq.ParamsKey_Reset(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Reset(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Reset(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Reset(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqClient_starGenType_mock) Noop() (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_Noop_params{}
	var results *MoqClient_starGenType_Noop_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Noop {
		paramsKey := m.Moq.ParamsKey_Noop(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Noop(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Noop(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Noop(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqClient_starGenType_mock) Quit() (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqClient_starGenType_Quit_params{}
	var results *MoqClient_starGenType_Quit_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Quit {
		paramsKey := m.Moq.ParamsKey_Quit(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Quit(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Quit(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Quit(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

// OnCall returns the recorder implementation of the Client_starGenType type
func (m *MoqClient_starGenType) OnCall() *MoqClient_starGenType_recorder {
	return &MoqClient_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqClient_starGenType_recorder) Close() *MoqClient_starGenType_Close_fnRecorder {
	return &MoqClient_starGenType_Close_fnRecorder{
		Params:   MoqClient_starGenType_Close_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_Close_fnRecorder) Any() *MoqClient_starGenType_Close_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Close(r.Params))
		return nil
	}
	return &MoqClient_starGenType_Close_anyParams{Recorder: r}
}

func (r *MoqClient_starGenType_Close_fnRecorder) Seq() *MoqClient_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Close(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_Close_fnRecorder) NoSeq() *MoqClient_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Close(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_Close_fnRecorder) ReturnResults(result1 error) *MoqClient_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Close_doFn
		DoReturnFn MoqClient_starGenType_Close_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_Close_fnRecorder) AndDo(fn MoqClient_starGenType_Close_doFn) *MoqClient_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_Close_fnRecorder) DoReturnResults(fn MoqClient_starGenType_Close_doReturnFn) *MoqClient_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Close_doFn
		DoReturnFn MoqClient_starGenType_Close_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_Close_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_Close_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Close {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_Close_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_Close_paramsKey]*MoqClient_starGenType_Close_results{},
		}
		r.Moq.ResultsByParams_Close = append(r.Moq.ResultsByParams_Close, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Close) {
			copy(r.Moq.ResultsByParams_Close[insertAt+1:], r.Moq.ResultsByParams_Close[insertAt:0])
			r.Moq.ResultsByParams_Close[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Close(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_Close_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_Close_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_Close_doFn
				DoReturnFn MoqClient_starGenType_Close_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_Close(params MoqClient_starGenType_Close_params) string {
	return fmt.Sprintf("Close()")
}

func (m *MoqClient_starGenType) ParamsKey_Close(params MoqClient_starGenType_Close_params, anyParams uint64) MoqClient_starGenType_Close_paramsKey {
	m.Scene.T.Helper()
	return MoqClient_starGenType_Close_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqClient_starGenType_recorder) Hello(localName string) *MoqClient_starGenType_Hello_fnRecorder {
	return &MoqClient_starGenType_Hello_fnRecorder{
		Params: MoqClient_starGenType_Hello_params{
			LocalName: localName,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_Hello_fnRecorder) Any() *MoqClient_starGenType_Hello_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Hello(r.Params))
		return nil
	}
	return &MoqClient_starGenType_Hello_anyParams{Recorder: r}
}

func (a *MoqClient_starGenType_Hello_anyParams) LocalName() *MoqClient_starGenType_Hello_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqClient_starGenType_Hello_fnRecorder) Seq() *MoqClient_starGenType_Hello_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Hello(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_Hello_fnRecorder) NoSeq() *MoqClient_starGenType_Hello_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Hello(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_Hello_fnRecorder) ReturnResults(result1 error) *MoqClient_starGenType_Hello_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Hello_doFn
		DoReturnFn MoqClient_starGenType_Hello_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_Hello_fnRecorder) AndDo(fn MoqClient_starGenType_Hello_doFn) *MoqClient_starGenType_Hello_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_Hello_fnRecorder) DoReturnResults(fn MoqClient_starGenType_Hello_doReturnFn) *MoqClient_starGenType_Hello_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Hello_doFn
		DoReturnFn MoqClient_starGenType_Hello_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_Hello_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_Hello_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Hello {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_Hello_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_Hello_paramsKey]*MoqClient_starGenType_Hello_results{},
		}
		r.Moq.ResultsByParams_Hello = append(r.Moq.ResultsByParams_Hello, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Hello) {
			copy(r.Moq.ResultsByParams_Hello[insertAt+1:], r.Moq.ResultsByParams_Hello[insertAt:0])
			r.Moq.ResultsByParams_Hello[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Hello(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_Hello_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_Hello_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_Hello_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_Hello_doFn
				DoReturnFn MoqClient_starGenType_Hello_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_Hello(params MoqClient_starGenType_Hello_params) string {
	return fmt.Sprintf("Hello(%#v)", params.LocalName)
}

func (m *MoqClient_starGenType) ParamsKey_Hello(params MoqClient_starGenType_Hello_params, anyParams uint64) MoqClient_starGenType_Hello_paramsKey {
	m.Scene.T.Helper()
	var localNameUsed string
	var localNameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Hello.LocalName == moq.ParamIndexByValue {
			localNameUsed = params.LocalName
		} else {
			localNameUsedHash = hash.DeepHash(params.LocalName)
		}
	}
	return MoqClient_starGenType_Hello_paramsKey{
		Params: struct{ LocalName string }{
			LocalName: localNameUsed,
		},
		Hashes: struct{ LocalName hash.Hash }{
			LocalName: localNameUsedHash,
		},
	}
}

func (m *MoqClient_starGenType_recorder) StartTLS(config *tls.Config) *MoqClient_starGenType_StartTLS_fnRecorder {
	return &MoqClient_starGenType_StartTLS_fnRecorder{
		Params: MoqClient_starGenType_StartTLS_params{
			Config: config,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_StartTLS_fnRecorder) Any() *MoqClient_starGenType_StartTLS_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StartTLS(r.Params))
		return nil
	}
	return &MoqClient_starGenType_StartTLS_anyParams{Recorder: r}
}

func (a *MoqClient_starGenType_StartTLS_anyParams) Config() *MoqClient_starGenType_StartTLS_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqClient_starGenType_StartTLS_fnRecorder) Seq() *MoqClient_starGenType_StartTLS_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StartTLS(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_StartTLS_fnRecorder) NoSeq() *MoqClient_starGenType_StartTLS_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StartTLS(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_StartTLS_fnRecorder) ReturnResults(result1 error) *MoqClient_starGenType_StartTLS_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_StartTLS_doFn
		DoReturnFn MoqClient_starGenType_StartTLS_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_StartTLS_fnRecorder) AndDo(fn MoqClient_starGenType_StartTLS_doFn) *MoqClient_starGenType_StartTLS_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_StartTLS_fnRecorder) DoReturnResults(fn MoqClient_starGenType_StartTLS_doReturnFn) *MoqClient_starGenType_StartTLS_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_StartTLS_doFn
		DoReturnFn MoqClient_starGenType_StartTLS_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_StartTLS_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_StartTLS_resultsByParams
	for n, res := range r.Moq.ResultsByParams_StartTLS {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_StartTLS_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_StartTLS_paramsKey]*MoqClient_starGenType_StartTLS_results{},
		}
		r.Moq.ResultsByParams_StartTLS = append(r.Moq.ResultsByParams_StartTLS, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_StartTLS) {
			copy(r.Moq.ResultsByParams_StartTLS[insertAt+1:], r.Moq.ResultsByParams_StartTLS[insertAt:0])
			r.Moq.ResultsByParams_StartTLS[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_StartTLS(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_StartTLS_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_StartTLS_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_StartTLS_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_StartTLS_doFn
				DoReturnFn MoqClient_starGenType_StartTLS_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_StartTLS(params MoqClient_starGenType_StartTLS_params) string {
	return fmt.Sprintf("StartTLS(%#v)", params.Config)
}

func (m *MoqClient_starGenType) ParamsKey_StartTLS(params MoqClient_starGenType_StartTLS_params, anyParams uint64) MoqClient_starGenType_StartTLS_paramsKey {
	m.Scene.T.Helper()
	var configUsed *tls.Config
	var configUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.StartTLS.Config == moq.ParamIndexByValue {
			configUsed = params.Config
		} else {
			configUsedHash = hash.DeepHash(params.Config)
		}
	}
	return MoqClient_starGenType_StartTLS_paramsKey{
		Params: struct{ Config *tls.Config }{
			Config: configUsed,
		},
		Hashes: struct{ Config hash.Hash }{
			Config: configUsedHash,
		},
	}
}

func (m *MoqClient_starGenType_recorder) TLSConnectionState() *MoqClient_starGenType_TLSConnectionState_fnRecorder {
	return &MoqClient_starGenType_TLSConnectionState_fnRecorder{
		Params:   MoqClient_starGenType_TLSConnectionState_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_TLSConnectionState_fnRecorder) Any() *MoqClient_starGenType_TLSConnectionState_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TLSConnectionState(r.Params))
		return nil
	}
	return &MoqClient_starGenType_TLSConnectionState_anyParams{Recorder: r}
}

func (r *MoqClient_starGenType_TLSConnectionState_fnRecorder) Seq() *MoqClient_starGenType_TLSConnectionState_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TLSConnectionState(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_TLSConnectionState_fnRecorder) NoSeq() *MoqClient_starGenType_TLSConnectionState_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TLSConnectionState(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_TLSConnectionState_fnRecorder) ReturnResults(state tls.ConnectionState, ok bool) *MoqClient_starGenType_TLSConnectionState_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			State tls.ConnectionState
			Ok    bool
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_TLSConnectionState_doFn
		DoReturnFn MoqClient_starGenType_TLSConnectionState_doReturnFn
	}{
		Values: &struct {
			State tls.ConnectionState
			Ok    bool
		}{
			State: state,
			Ok:    ok,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_TLSConnectionState_fnRecorder) AndDo(fn MoqClient_starGenType_TLSConnectionState_doFn) *MoqClient_starGenType_TLSConnectionState_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_TLSConnectionState_fnRecorder) DoReturnResults(fn MoqClient_starGenType_TLSConnectionState_doReturnFn) *MoqClient_starGenType_TLSConnectionState_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			State tls.ConnectionState
			Ok    bool
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_TLSConnectionState_doFn
		DoReturnFn MoqClient_starGenType_TLSConnectionState_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_TLSConnectionState_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_TLSConnectionState_resultsByParams
	for n, res := range r.Moq.ResultsByParams_TLSConnectionState {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_TLSConnectionState_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_TLSConnectionState_paramsKey]*MoqClient_starGenType_TLSConnectionState_results{},
		}
		r.Moq.ResultsByParams_TLSConnectionState = append(r.Moq.ResultsByParams_TLSConnectionState, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_TLSConnectionState) {
			copy(r.Moq.ResultsByParams_TLSConnectionState[insertAt+1:], r.Moq.ResultsByParams_TLSConnectionState[insertAt:0])
			r.Moq.ResultsByParams_TLSConnectionState[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_TLSConnectionState(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_TLSConnectionState_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_TLSConnectionState_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_TLSConnectionState_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					State tls.ConnectionState
					Ok    bool
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_TLSConnectionState_doFn
				DoReturnFn MoqClient_starGenType_TLSConnectionState_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_TLSConnectionState(params MoqClient_starGenType_TLSConnectionState_params) string {
	return fmt.Sprintf("TLSConnectionState()")
}

func (m *MoqClient_starGenType) ParamsKey_TLSConnectionState(params MoqClient_starGenType_TLSConnectionState_params, anyParams uint64) MoqClient_starGenType_TLSConnectionState_paramsKey {
	m.Scene.T.Helper()
	return MoqClient_starGenType_TLSConnectionState_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqClient_starGenType_recorder) Verify(addr string) *MoqClient_starGenType_Verify_fnRecorder {
	return &MoqClient_starGenType_Verify_fnRecorder{
		Params: MoqClient_starGenType_Verify_params{
			Addr: addr,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_Verify_fnRecorder) Any() *MoqClient_starGenType_Verify_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Verify(r.Params))
		return nil
	}
	return &MoqClient_starGenType_Verify_anyParams{Recorder: r}
}

func (a *MoqClient_starGenType_Verify_anyParams) Addr() *MoqClient_starGenType_Verify_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqClient_starGenType_Verify_fnRecorder) Seq() *MoqClient_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Verify(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_Verify_fnRecorder) NoSeq() *MoqClient_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Verify(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_Verify_fnRecorder) ReturnResults(result1 error) *MoqClient_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Verify_doFn
		DoReturnFn MoqClient_starGenType_Verify_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_Verify_fnRecorder) AndDo(fn MoqClient_starGenType_Verify_doFn) *MoqClient_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_Verify_fnRecorder) DoReturnResults(fn MoqClient_starGenType_Verify_doReturnFn) *MoqClient_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Verify_doFn
		DoReturnFn MoqClient_starGenType_Verify_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_Verify_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_Verify_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Verify {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_Verify_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_Verify_paramsKey]*MoqClient_starGenType_Verify_results{},
		}
		r.Moq.ResultsByParams_Verify = append(r.Moq.ResultsByParams_Verify, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Verify) {
			copy(r.Moq.ResultsByParams_Verify[insertAt+1:], r.Moq.ResultsByParams_Verify[insertAt:0])
			r.Moq.ResultsByParams_Verify[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Verify(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_Verify_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_Verify_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_Verify_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_Verify_doFn
				DoReturnFn MoqClient_starGenType_Verify_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_Verify(params MoqClient_starGenType_Verify_params) string {
	return fmt.Sprintf("Verify(%#v)", params.Addr)
}

func (m *MoqClient_starGenType) ParamsKey_Verify(params MoqClient_starGenType_Verify_params, anyParams uint64) MoqClient_starGenType_Verify_paramsKey {
	m.Scene.T.Helper()
	var addrUsed string
	var addrUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Verify.Addr == moq.ParamIndexByValue {
			addrUsed = params.Addr
		} else {
			addrUsedHash = hash.DeepHash(params.Addr)
		}
	}
	return MoqClient_starGenType_Verify_paramsKey{
		Params: struct{ Addr string }{
			Addr: addrUsed,
		},
		Hashes: struct{ Addr hash.Hash }{
			Addr: addrUsedHash,
		},
	}
}

func (m *MoqClient_starGenType_recorder) Auth(a smtp.Auth) *MoqClient_starGenType_Auth_fnRecorder {
	return &MoqClient_starGenType_Auth_fnRecorder{
		Params: MoqClient_starGenType_Auth_params{
			A: a,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_Auth_fnRecorder) Any() *MoqClient_starGenType_Auth_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Auth(r.Params))
		return nil
	}
	return &MoqClient_starGenType_Auth_anyParams{Recorder: r}
}

func (a *MoqClient_starGenType_Auth_anyParams) A() *MoqClient_starGenType_Auth_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqClient_starGenType_Auth_fnRecorder) Seq() *MoqClient_starGenType_Auth_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Auth(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_Auth_fnRecorder) NoSeq() *MoqClient_starGenType_Auth_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Auth(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_Auth_fnRecorder) ReturnResults(result1 error) *MoqClient_starGenType_Auth_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Auth_doFn
		DoReturnFn MoqClient_starGenType_Auth_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_Auth_fnRecorder) AndDo(fn MoqClient_starGenType_Auth_doFn) *MoqClient_starGenType_Auth_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_Auth_fnRecorder) DoReturnResults(fn MoqClient_starGenType_Auth_doReturnFn) *MoqClient_starGenType_Auth_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Auth_doFn
		DoReturnFn MoqClient_starGenType_Auth_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_Auth_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_Auth_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Auth {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_Auth_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_Auth_paramsKey]*MoqClient_starGenType_Auth_results{},
		}
		r.Moq.ResultsByParams_Auth = append(r.Moq.ResultsByParams_Auth, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Auth) {
			copy(r.Moq.ResultsByParams_Auth[insertAt+1:], r.Moq.ResultsByParams_Auth[insertAt:0])
			r.Moq.ResultsByParams_Auth[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Auth(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_Auth_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_Auth_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_Auth_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_Auth_doFn
				DoReturnFn MoqClient_starGenType_Auth_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_Auth(params MoqClient_starGenType_Auth_params) string {
	return fmt.Sprintf("Auth(%#v)", params.A)
}

func (m *MoqClient_starGenType) ParamsKey_Auth(params MoqClient_starGenType_Auth_params, anyParams uint64) MoqClient_starGenType_Auth_paramsKey {
	m.Scene.T.Helper()
	var aUsed smtp.Auth
	var aUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Auth.A == moq.ParamIndexByValue {
			aUsed = params.A
		} else {
			aUsedHash = hash.DeepHash(params.A)
		}
	}
	return MoqClient_starGenType_Auth_paramsKey{
		Params: struct{ A smtp.Auth }{
			A: aUsed,
		},
		Hashes: struct{ A hash.Hash }{
			A: aUsedHash,
		},
	}
}

func (m *MoqClient_starGenType_recorder) Mail(from string) *MoqClient_starGenType_Mail_fnRecorder {
	return &MoqClient_starGenType_Mail_fnRecorder{
		Params: MoqClient_starGenType_Mail_params{
			From: from,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_Mail_fnRecorder) Any() *MoqClient_starGenType_Mail_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mail(r.Params))
		return nil
	}
	return &MoqClient_starGenType_Mail_anyParams{Recorder: r}
}

func (a *MoqClient_starGenType_Mail_anyParams) From() *MoqClient_starGenType_Mail_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqClient_starGenType_Mail_fnRecorder) Seq() *MoqClient_starGenType_Mail_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mail(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_Mail_fnRecorder) NoSeq() *MoqClient_starGenType_Mail_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Mail(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_Mail_fnRecorder) ReturnResults(result1 error) *MoqClient_starGenType_Mail_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Mail_doFn
		DoReturnFn MoqClient_starGenType_Mail_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_Mail_fnRecorder) AndDo(fn MoqClient_starGenType_Mail_doFn) *MoqClient_starGenType_Mail_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_Mail_fnRecorder) DoReturnResults(fn MoqClient_starGenType_Mail_doReturnFn) *MoqClient_starGenType_Mail_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Mail_doFn
		DoReturnFn MoqClient_starGenType_Mail_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_Mail_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_Mail_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Mail {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_Mail_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_Mail_paramsKey]*MoqClient_starGenType_Mail_results{},
		}
		r.Moq.ResultsByParams_Mail = append(r.Moq.ResultsByParams_Mail, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Mail) {
			copy(r.Moq.ResultsByParams_Mail[insertAt+1:], r.Moq.ResultsByParams_Mail[insertAt:0])
			r.Moq.ResultsByParams_Mail[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Mail(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_Mail_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_Mail_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_Mail_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_Mail_doFn
				DoReturnFn MoqClient_starGenType_Mail_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_Mail(params MoqClient_starGenType_Mail_params) string {
	return fmt.Sprintf("Mail(%#v)", params.From)
}

func (m *MoqClient_starGenType) ParamsKey_Mail(params MoqClient_starGenType_Mail_params, anyParams uint64) MoqClient_starGenType_Mail_paramsKey {
	m.Scene.T.Helper()
	var fromUsed string
	var fromUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Mail.From == moq.ParamIndexByValue {
			fromUsed = params.From
		} else {
			fromUsedHash = hash.DeepHash(params.From)
		}
	}
	return MoqClient_starGenType_Mail_paramsKey{
		Params: struct{ From string }{
			From: fromUsed,
		},
		Hashes: struct{ From hash.Hash }{
			From: fromUsedHash,
		},
	}
}

func (m *MoqClient_starGenType_recorder) Rcpt(to string) *MoqClient_starGenType_Rcpt_fnRecorder {
	return &MoqClient_starGenType_Rcpt_fnRecorder{
		Params: MoqClient_starGenType_Rcpt_params{
			To: to,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_Rcpt_fnRecorder) Any() *MoqClient_starGenType_Rcpt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rcpt(r.Params))
		return nil
	}
	return &MoqClient_starGenType_Rcpt_anyParams{Recorder: r}
}

func (a *MoqClient_starGenType_Rcpt_anyParams) To() *MoqClient_starGenType_Rcpt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqClient_starGenType_Rcpt_fnRecorder) Seq() *MoqClient_starGenType_Rcpt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rcpt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_Rcpt_fnRecorder) NoSeq() *MoqClient_starGenType_Rcpt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Rcpt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_Rcpt_fnRecorder) ReturnResults(result1 error) *MoqClient_starGenType_Rcpt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Rcpt_doFn
		DoReturnFn MoqClient_starGenType_Rcpt_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_Rcpt_fnRecorder) AndDo(fn MoqClient_starGenType_Rcpt_doFn) *MoqClient_starGenType_Rcpt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_Rcpt_fnRecorder) DoReturnResults(fn MoqClient_starGenType_Rcpt_doReturnFn) *MoqClient_starGenType_Rcpt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Rcpt_doFn
		DoReturnFn MoqClient_starGenType_Rcpt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_Rcpt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_Rcpt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Rcpt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_Rcpt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_Rcpt_paramsKey]*MoqClient_starGenType_Rcpt_results{},
		}
		r.Moq.ResultsByParams_Rcpt = append(r.Moq.ResultsByParams_Rcpt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Rcpt) {
			copy(r.Moq.ResultsByParams_Rcpt[insertAt+1:], r.Moq.ResultsByParams_Rcpt[insertAt:0])
			r.Moq.ResultsByParams_Rcpt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Rcpt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_Rcpt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_Rcpt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_Rcpt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_Rcpt_doFn
				DoReturnFn MoqClient_starGenType_Rcpt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_Rcpt(params MoqClient_starGenType_Rcpt_params) string {
	return fmt.Sprintf("Rcpt(%#v)", params.To)
}

func (m *MoqClient_starGenType) ParamsKey_Rcpt(params MoqClient_starGenType_Rcpt_params, anyParams uint64) MoqClient_starGenType_Rcpt_paramsKey {
	m.Scene.T.Helper()
	var toUsed string
	var toUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Rcpt.To == moq.ParamIndexByValue {
			toUsed = params.To
		} else {
			toUsedHash = hash.DeepHash(params.To)
		}
	}
	return MoqClient_starGenType_Rcpt_paramsKey{
		Params: struct{ To string }{
			To: toUsed,
		},
		Hashes: struct{ To hash.Hash }{
			To: toUsedHash,
		},
	}
}

func (m *MoqClient_starGenType_recorder) Data() *MoqClient_starGenType_Data_fnRecorder {
	return &MoqClient_starGenType_Data_fnRecorder{
		Params:   MoqClient_starGenType_Data_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_Data_fnRecorder) Any() *MoqClient_starGenType_Data_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Data(r.Params))
		return nil
	}
	return &MoqClient_starGenType_Data_anyParams{Recorder: r}
}

func (r *MoqClient_starGenType_Data_fnRecorder) Seq() *MoqClient_starGenType_Data_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Data(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_Data_fnRecorder) NoSeq() *MoqClient_starGenType_Data_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Data(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_Data_fnRecorder) ReturnResults(result1 io.WriteCloser, result2 error) *MoqClient_starGenType_Data_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 io.WriteCloser
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Data_doFn
		DoReturnFn MoqClient_starGenType_Data_doReturnFn
	}{
		Values: &struct {
			Result1 io.WriteCloser
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_Data_fnRecorder) AndDo(fn MoqClient_starGenType_Data_doFn) *MoqClient_starGenType_Data_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_Data_fnRecorder) DoReturnResults(fn MoqClient_starGenType_Data_doReturnFn) *MoqClient_starGenType_Data_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 io.WriteCloser
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Data_doFn
		DoReturnFn MoqClient_starGenType_Data_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_Data_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_Data_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Data {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_Data_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_Data_paramsKey]*MoqClient_starGenType_Data_results{},
		}
		r.Moq.ResultsByParams_Data = append(r.Moq.ResultsByParams_Data, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Data) {
			copy(r.Moq.ResultsByParams_Data[insertAt+1:], r.Moq.ResultsByParams_Data[insertAt:0])
			r.Moq.ResultsByParams_Data[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Data(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_Data_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_Data_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_Data_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 io.WriteCloser
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_Data_doFn
				DoReturnFn MoqClient_starGenType_Data_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_Data(params MoqClient_starGenType_Data_params) string {
	return fmt.Sprintf("Data()")
}

func (m *MoqClient_starGenType) ParamsKey_Data(params MoqClient_starGenType_Data_params, anyParams uint64) MoqClient_starGenType_Data_paramsKey {
	m.Scene.T.Helper()
	return MoqClient_starGenType_Data_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqClient_starGenType_recorder) Extension(ext string) *MoqClient_starGenType_Extension_fnRecorder {
	return &MoqClient_starGenType_Extension_fnRecorder{
		Params: MoqClient_starGenType_Extension_params{
			Ext: ext,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_Extension_fnRecorder) Any() *MoqClient_starGenType_Extension_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Extension(r.Params))
		return nil
	}
	return &MoqClient_starGenType_Extension_anyParams{Recorder: r}
}

func (a *MoqClient_starGenType_Extension_anyParams) Ext() *MoqClient_starGenType_Extension_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqClient_starGenType_Extension_fnRecorder) Seq() *MoqClient_starGenType_Extension_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Extension(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_Extension_fnRecorder) NoSeq() *MoqClient_starGenType_Extension_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Extension(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_Extension_fnRecorder) ReturnResults(result1 bool, result2 string) *MoqClient_starGenType_Extension_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
			Result2 string
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Extension_doFn
		DoReturnFn MoqClient_starGenType_Extension_doReturnFn
	}{
		Values: &struct {
			Result1 bool
			Result2 string
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_Extension_fnRecorder) AndDo(fn MoqClient_starGenType_Extension_doFn) *MoqClient_starGenType_Extension_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_Extension_fnRecorder) DoReturnResults(fn MoqClient_starGenType_Extension_doReturnFn) *MoqClient_starGenType_Extension_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
			Result2 string
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Extension_doFn
		DoReturnFn MoqClient_starGenType_Extension_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_Extension_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_Extension_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Extension {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_Extension_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_Extension_paramsKey]*MoqClient_starGenType_Extension_results{},
		}
		r.Moq.ResultsByParams_Extension = append(r.Moq.ResultsByParams_Extension, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Extension) {
			copy(r.Moq.ResultsByParams_Extension[insertAt+1:], r.Moq.ResultsByParams_Extension[insertAt:0])
			r.Moq.ResultsByParams_Extension[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Extension(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_Extension_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_Extension_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_Extension_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
					Result2 string
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_Extension_doFn
				DoReturnFn MoqClient_starGenType_Extension_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_Extension(params MoqClient_starGenType_Extension_params) string {
	return fmt.Sprintf("Extension(%#v)", params.Ext)
}

func (m *MoqClient_starGenType) ParamsKey_Extension(params MoqClient_starGenType_Extension_params, anyParams uint64) MoqClient_starGenType_Extension_paramsKey {
	m.Scene.T.Helper()
	var extUsed string
	var extUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Extension.Ext == moq.ParamIndexByValue {
			extUsed = params.Ext
		} else {
			extUsedHash = hash.DeepHash(params.Ext)
		}
	}
	return MoqClient_starGenType_Extension_paramsKey{
		Params: struct{ Ext string }{
			Ext: extUsed,
		},
		Hashes: struct{ Ext hash.Hash }{
			Ext: extUsedHash,
		},
	}
}

func (m *MoqClient_starGenType_recorder) Reset() *MoqClient_starGenType_Reset_fnRecorder {
	return &MoqClient_starGenType_Reset_fnRecorder{
		Params:   MoqClient_starGenType_Reset_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_Reset_fnRecorder) Any() *MoqClient_starGenType_Reset_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Reset(r.Params))
		return nil
	}
	return &MoqClient_starGenType_Reset_anyParams{Recorder: r}
}

func (r *MoqClient_starGenType_Reset_fnRecorder) Seq() *MoqClient_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Reset(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_Reset_fnRecorder) NoSeq() *MoqClient_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Reset(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_Reset_fnRecorder) ReturnResults(result1 error) *MoqClient_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Reset_doFn
		DoReturnFn MoqClient_starGenType_Reset_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_Reset_fnRecorder) AndDo(fn MoqClient_starGenType_Reset_doFn) *MoqClient_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_Reset_fnRecorder) DoReturnResults(fn MoqClient_starGenType_Reset_doReturnFn) *MoqClient_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Reset_doFn
		DoReturnFn MoqClient_starGenType_Reset_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_Reset_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_Reset_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Reset {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_Reset_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_Reset_paramsKey]*MoqClient_starGenType_Reset_results{},
		}
		r.Moq.ResultsByParams_Reset = append(r.Moq.ResultsByParams_Reset, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Reset) {
			copy(r.Moq.ResultsByParams_Reset[insertAt+1:], r.Moq.ResultsByParams_Reset[insertAt:0])
			r.Moq.ResultsByParams_Reset[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Reset(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_Reset_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_Reset_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_Reset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_Reset_doFn
				DoReturnFn MoqClient_starGenType_Reset_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_Reset(params MoqClient_starGenType_Reset_params) string {
	return fmt.Sprintf("Reset()")
}

func (m *MoqClient_starGenType) ParamsKey_Reset(params MoqClient_starGenType_Reset_params, anyParams uint64) MoqClient_starGenType_Reset_paramsKey {
	m.Scene.T.Helper()
	return MoqClient_starGenType_Reset_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqClient_starGenType_recorder) Noop() *MoqClient_starGenType_Noop_fnRecorder {
	return &MoqClient_starGenType_Noop_fnRecorder{
		Params:   MoqClient_starGenType_Noop_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_Noop_fnRecorder) Any() *MoqClient_starGenType_Noop_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Noop(r.Params))
		return nil
	}
	return &MoqClient_starGenType_Noop_anyParams{Recorder: r}
}

func (r *MoqClient_starGenType_Noop_fnRecorder) Seq() *MoqClient_starGenType_Noop_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Noop(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_Noop_fnRecorder) NoSeq() *MoqClient_starGenType_Noop_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Noop(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_Noop_fnRecorder) ReturnResults(result1 error) *MoqClient_starGenType_Noop_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Noop_doFn
		DoReturnFn MoqClient_starGenType_Noop_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_Noop_fnRecorder) AndDo(fn MoqClient_starGenType_Noop_doFn) *MoqClient_starGenType_Noop_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_Noop_fnRecorder) DoReturnResults(fn MoqClient_starGenType_Noop_doReturnFn) *MoqClient_starGenType_Noop_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Noop_doFn
		DoReturnFn MoqClient_starGenType_Noop_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_Noop_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_Noop_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Noop {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_Noop_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_Noop_paramsKey]*MoqClient_starGenType_Noop_results{},
		}
		r.Moq.ResultsByParams_Noop = append(r.Moq.ResultsByParams_Noop, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Noop) {
			copy(r.Moq.ResultsByParams_Noop[insertAt+1:], r.Moq.ResultsByParams_Noop[insertAt:0])
			r.Moq.ResultsByParams_Noop[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Noop(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_Noop_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_Noop_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_Noop_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_Noop_doFn
				DoReturnFn MoqClient_starGenType_Noop_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_Noop(params MoqClient_starGenType_Noop_params) string {
	return fmt.Sprintf("Noop()")
}

func (m *MoqClient_starGenType) ParamsKey_Noop(params MoqClient_starGenType_Noop_params, anyParams uint64) MoqClient_starGenType_Noop_paramsKey {
	m.Scene.T.Helper()
	return MoqClient_starGenType_Noop_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqClient_starGenType_recorder) Quit() *MoqClient_starGenType_Quit_fnRecorder {
	return &MoqClient_starGenType_Quit_fnRecorder{
		Params:   MoqClient_starGenType_Quit_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqClient_starGenType_Quit_fnRecorder) Any() *MoqClient_starGenType_Quit_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quit(r.Params))
		return nil
	}
	return &MoqClient_starGenType_Quit_anyParams{Recorder: r}
}

func (r *MoqClient_starGenType_Quit_fnRecorder) Seq() *MoqClient_starGenType_Quit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quit(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqClient_starGenType_Quit_fnRecorder) NoSeq() *MoqClient_starGenType_Quit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Quit(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqClient_starGenType_Quit_fnRecorder) ReturnResults(result1 error) *MoqClient_starGenType_Quit_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Quit_doFn
		DoReturnFn MoqClient_starGenType_Quit_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqClient_starGenType_Quit_fnRecorder) AndDo(fn MoqClient_starGenType_Quit_doFn) *MoqClient_starGenType_Quit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqClient_starGenType_Quit_fnRecorder) DoReturnResults(fn MoqClient_starGenType_Quit_doReturnFn) *MoqClient_starGenType_Quit_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqClient_starGenType_Quit_doFn
		DoReturnFn MoqClient_starGenType_Quit_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqClient_starGenType_Quit_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqClient_starGenType_Quit_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Quit {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqClient_starGenType_Quit_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqClient_starGenType_Quit_paramsKey]*MoqClient_starGenType_Quit_results{},
		}
		r.Moq.ResultsByParams_Quit = append(r.Moq.ResultsByParams_Quit, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Quit) {
			copy(r.Moq.ResultsByParams_Quit[insertAt+1:], r.Moq.ResultsByParams_Quit[insertAt:0])
			r.Moq.ResultsByParams_Quit[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Quit(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqClient_starGenType_Quit_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqClient_starGenType_Quit_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqClient_starGenType_Quit_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqClient_starGenType_Quit_doFn
				DoReturnFn MoqClient_starGenType_Quit_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqClient_starGenType) PrettyParams_Quit(params MoqClient_starGenType_Quit_params) string {
	return fmt.Sprintf("Quit()")
}

func (m *MoqClient_starGenType) ParamsKey_Quit(params MoqClient_starGenType_Quit_params, anyParams uint64) MoqClient_starGenType_Quit_paramsKey {
	m.Scene.T.Helper()
	return MoqClient_starGenType_Quit_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqClient_starGenType) Reset() {
	m.ResultsByParams_Close = nil
	m.ResultsByParams_Hello = nil
	m.ResultsByParams_StartTLS = nil
	m.ResultsByParams_TLSConnectionState = nil
	m.ResultsByParams_Verify = nil
	m.ResultsByParams_Auth = nil
	m.ResultsByParams_Mail = nil
	m.ResultsByParams_Rcpt = nil
	m.ResultsByParams_Data = nil
	m.ResultsByParams_Extension = nil
	m.ResultsByParams_Reset = nil
	m.ResultsByParams_Noop = nil
	m.ResultsByParams_Quit = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqClient_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Close {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Close(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Hello {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Hello(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_StartTLS {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_StartTLS(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_TLSConnectionState {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_TLSConnectionState(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Verify {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Verify(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Auth {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Auth(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Mail {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Mail(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Rcpt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Rcpt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Data {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Data(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Extension {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Extension(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Reset {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Reset(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Noop {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Noop(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Quit {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Quit(results.Params))
			}
		}
	}
}
