// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package rpc

import (
	"fmt"
	"io"
	"math/bits"
	"net"
	"net/http"
	"net/rpc"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that rpc.Server_starGenType is mocked
// completely
var _ Server_starGenType = (*MoqServer_starGenType_mock)(nil)

// Server_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Server_starGenType interface {
	Register(rcvr interface{}) error
	RegisterName(name string, rcvr interface{}) error
	ServeConn(conn io.ReadWriteCloser)
	ServeCodec(codec rpc.ServerCodec)
	ServeRequest(codec rpc.ServerCodec) error
	Accept(lis net.Listener)
	ServeHTTP(w http.ResponseWriter, req *http.Request)
	HandleHTTP(rpcPath, debugPath string)
}

// MoqServer_starGenType holds the state of a moq of the Server_starGenType
// type
type MoqServer_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqServer_starGenType_mock

	ResultsByParams_Register     []MoqServer_starGenType_Register_resultsByParams
	ResultsByParams_RegisterName []MoqServer_starGenType_RegisterName_resultsByParams
	ResultsByParams_ServeConn    []MoqServer_starGenType_ServeConn_resultsByParams
	ResultsByParams_ServeCodec   []MoqServer_starGenType_ServeCodec_resultsByParams
	ResultsByParams_ServeRequest []MoqServer_starGenType_ServeRequest_resultsByParams
	ResultsByParams_Accept       []MoqServer_starGenType_Accept_resultsByParams
	ResultsByParams_ServeHTTP    []MoqServer_starGenType_ServeHTTP_resultsByParams
	ResultsByParams_HandleHTTP   []MoqServer_starGenType_HandleHTTP_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Register struct {
				Rcvr moq.ParamIndexing
			}
			RegisterName struct {
				Name moq.ParamIndexing
				Rcvr moq.ParamIndexing
			}
			ServeConn struct {
				Conn moq.ParamIndexing
			}
			ServeCodec struct {
				Codec moq.ParamIndexing
			}
			ServeRequest struct {
				Codec moq.ParamIndexing
			}
			Accept struct {
				Lis moq.ParamIndexing
			}
			ServeHTTP struct {
				W   moq.ParamIndexing
				Req moq.ParamIndexing
			}
			HandleHTTP struct {
				RpcPath   moq.ParamIndexing
				DebugPath moq.ParamIndexing
			}
		}
	}
	// MoqServer_starGenType_mock isolates the mock interface of the
}

// Server_starGenType type
type MoqServer_starGenType_mock struct {
	Moq *MoqServer_starGenType
}

// MoqServer_starGenType_recorder isolates the recorder interface of the
// Server_starGenType type
type MoqServer_starGenType_recorder struct {
	Moq *MoqServer_starGenType
}

// MoqServer_starGenType_Register_params holds the params of the
// Server_starGenType type
type MoqServer_starGenType_Register_params struct{ Rcvr interface{} }

// MoqServer_starGenType_Register_paramsKey holds the map key params of the
// Server_starGenType type
type MoqServer_starGenType_Register_paramsKey struct {
	Params struct{ Rcvr interface{} }
	Hashes struct{ Rcvr hash.Hash }
}

// MoqServer_starGenType_Register_resultsByParams contains the results for a
// given set of parameters for the Server_starGenType type
type MoqServer_starGenType_Register_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqServer_starGenType_Register_paramsKey]*MoqServer_starGenType_Register_results
}

// MoqServer_starGenType_Register_doFn defines the type of function needed when
// calling AndDo for the Server_starGenType type
type MoqServer_starGenType_Register_doFn func(rcvr interface{})

// MoqServer_starGenType_Register_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Server_starGenType type
type MoqServer_starGenType_Register_doReturnFn func(rcvr interface{}) error

// MoqServer_starGenType_Register_results holds the results of the
// Server_starGenType type
type MoqServer_starGenType_Register_results struct {
	Params  MoqServer_starGenType_Register_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqServer_starGenType_Register_doFn
		DoReturnFn MoqServer_starGenType_Register_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqServer_starGenType_Register_fnRecorder routes recorded function calls to
// the MoqServer_starGenType moq
type MoqServer_starGenType_Register_fnRecorder struct {
	Params    MoqServer_starGenType_Register_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqServer_starGenType_Register_results
	Moq       *MoqServer_starGenType
}

// MoqServer_starGenType_Register_anyParams isolates the any params functions
// of the Server_starGenType type
type MoqServer_starGenType_Register_anyParams struct {
	Recorder *MoqServer_starGenType_Register_fnRecorder
}

// MoqServer_starGenType_RegisterName_params holds the params of the
// Server_starGenType type
type MoqServer_starGenType_RegisterName_params struct {
	Name string
	Rcvr interface{}
}

// MoqServer_starGenType_RegisterName_paramsKey holds the map key params of the
// Server_starGenType type
type MoqServer_starGenType_RegisterName_paramsKey struct {
	Params struct {
		Name string
		Rcvr interface{}
	}
	Hashes struct {
		Name hash.Hash
		Rcvr hash.Hash
	}
}

// MoqServer_starGenType_RegisterName_resultsByParams contains the results for
// a given set of parameters for the Server_starGenType type
type MoqServer_starGenType_RegisterName_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqServer_starGenType_RegisterName_paramsKey]*MoqServer_starGenType_RegisterName_results
}

// MoqServer_starGenType_RegisterName_doFn defines the type of function needed
// when calling AndDo for the Server_starGenType type
type MoqServer_starGenType_RegisterName_doFn func(name string, rcvr interface{})

// MoqServer_starGenType_RegisterName_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Server_starGenType type
type MoqServer_starGenType_RegisterName_doReturnFn func(name string, rcvr interface{}) error

// MoqServer_starGenType_RegisterName_results holds the results of the
// Server_starGenType type
type MoqServer_starGenType_RegisterName_results struct {
	Params  MoqServer_starGenType_RegisterName_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqServer_starGenType_RegisterName_doFn
		DoReturnFn MoqServer_starGenType_RegisterName_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqServer_starGenType_RegisterName_fnRecorder routes recorded function calls
// to the MoqServer_starGenType moq
type MoqServer_starGenType_RegisterName_fnRecorder struct {
	Params    MoqServer_starGenType_RegisterName_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqServer_starGenType_RegisterName_results
	Moq       *MoqServer_starGenType
}

// MoqServer_starGenType_RegisterName_anyParams isolates the any params
// functions of the Server_starGenType type
type MoqServer_starGenType_RegisterName_anyParams struct {
	Recorder *MoqServer_starGenType_RegisterName_fnRecorder
}

// MoqServer_starGenType_ServeConn_params holds the params of the
// Server_starGenType type
type MoqServer_starGenType_ServeConn_params struct{ Conn io.ReadWriteCloser }

// MoqServer_starGenType_ServeConn_paramsKey holds the map key params of the
// Server_starGenType type
type MoqServer_starGenType_ServeConn_paramsKey struct {
	Params struct{ Conn io.ReadWriteCloser }
	Hashes struct{ Conn hash.Hash }
}

// MoqServer_starGenType_ServeConn_resultsByParams contains the results for a
// given set of parameters for the Server_starGenType type
type MoqServer_starGenType_ServeConn_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqServer_starGenType_ServeConn_paramsKey]*MoqServer_starGenType_ServeConn_results
}

// MoqServer_starGenType_ServeConn_doFn defines the type of function needed
// when calling AndDo for the Server_starGenType type
type MoqServer_starGenType_ServeConn_doFn func(conn io.ReadWriteCloser)

// MoqServer_starGenType_ServeConn_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Server_starGenType type
type MoqServer_starGenType_ServeConn_doReturnFn func(conn io.ReadWriteCloser)

// MoqServer_starGenType_ServeConn_results holds the results of the
// Server_starGenType type
type MoqServer_starGenType_ServeConn_results struct {
	Params  MoqServer_starGenType_ServeConn_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeConn_doFn
		DoReturnFn MoqServer_starGenType_ServeConn_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqServer_starGenType_ServeConn_fnRecorder routes recorded function calls to
// the MoqServer_starGenType moq
type MoqServer_starGenType_ServeConn_fnRecorder struct {
	Params    MoqServer_starGenType_ServeConn_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqServer_starGenType_ServeConn_results
	Moq       *MoqServer_starGenType
}

// MoqServer_starGenType_ServeConn_anyParams isolates the any params functions
// of the Server_starGenType type
type MoqServer_starGenType_ServeConn_anyParams struct {
	Recorder *MoqServer_starGenType_ServeConn_fnRecorder
}

// MoqServer_starGenType_ServeCodec_params holds the params of the
// Server_starGenType type
type MoqServer_starGenType_ServeCodec_params struct{ Codec rpc.ServerCodec }

// MoqServer_starGenType_ServeCodec_paramsKey holds the map key params of the
// Server_starGenType type
type MoqServer_starGenType_ServeCodec_paramsKey struct {
	Params struct{ Codec rpc.ServerCodec }
	Hashes struct{ Codec hash.Hash }
}

// MoqServer_starGenType_ServeCodec_resultsByParams contains the results for a
// given set of parameters for the Server_starGenType type
type MoqServer_starGenType_ServeCodec_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqServer_starGenType_ServeCodec_paramsKey]*MoqServer_starGenType_ServeCodec_results
}

// MoqServer_starGenType_ServeCodec_doFn defines the type of function needed
// when calling AndDo for the Server_starGenType type
type MoqServer_starGenType_ServeCodec_doFn func(codec rpc.ServerCodec)

// MoqServer_starGenType_ServeCodec_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Server_starGenType type
type MoqServer_starGenType_ServeCodec_doReturnFn func(codec rpc.ServerCodec)

// MoqServer_starGenType_ServeCodec_results holds the results of the
// Server_starGenType type
type MoqServer_starGenType_ServeCodec_results struct {
	Params  MoqServer_starGenType_ServeCodec_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeCodec_doFn
		DoReturnFn MoqServer_starGenType_ServeCodec_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqServer_starGenType_ServeCodec_fnRecorder routes recorded function calls
// to the MoqServer_starGenType moq
type MoqServer_starGenType_ServeCodec_fnRecorder struct {
	Params    MoqServer_starGenType_ServeCodec_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqServer_starGenType_ServeCodec_results
	Moq       *MoqServer_starGenType
}

// MoqServer_starGenType_ServeCodec_anyParams isolates the any params functions
// of the Server_starGenType type
type MoqServer_starGenType_ServeCodec_anyParams struct {
	Recorder *MoqServer_starGenType_ServeCodec_fnRecorder
}

// MoqServer_starGenType_ServeRequest_params holds the params of the
// Server_starGenType type
type MoqServer_starGenType_ServeRequest_params struct{ Codec rpc.ServerCodec }

// MoqServer_starGenType_ServeRequest_paramsKey holds the map key params of the
// Server_starGenType type
type MoqServer_starGenType_ServeRequest_paramsKey struct {
	Params struct{ Codec rpc.ServerCodec }
	Hashes struct{ Codec hash.Hash }
}

// MoqServer_starGenType_ServeRequest_resultsByParams contains the results for
// a given set of parameters for the Server_starGenType type
type MoqServer_starGenType_ServeRequest_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqServer_starGenType_ServeRequest_paramsKey]*MoqServer_starGenType_ServeRequest_results
}

// MoqServer_starGenType_ServeRequest_doFn defines the type of function needed
// when calling AndDo for the Server_starGenType type
type MoqServer_starGenType_ServeRequest_doFn func(codec rpc.ServerCodec)

// MoqServer_starGenType_ServeRequest_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Server_starGenType type
type MoqServer_starGenType_ServeRequest_doReturnFn func(codec rpc.ServerCodec) error

// MoqServer_starGenType_ServeRequest_results holds the results of the
// Server_starGenType type
type MoqServer_starGenType_ServeRequest_results struct {
	Params  MoqServer_starGenType_ServeRequest_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeRequest_doFn
		DoReturnFn MoqServer_starGenType_ServeRequest_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqServer_starGenType_ServeRequest_fnRecorder routes recorded function calls
// to the MoqServer_starGenType moq
type MoqServer_starGenType_ServeRequest_fnRecorder struct {
	Params    MoqServer_starGenType_ServeRequest_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqServer_starGenType_ServeRequest_results
	Moq       *MoqServer_starGenType
}

// MoqServer_starGenType_ServeRequest_anyParams isolates the any params
// functions of the Server_starGenType type
type MoqServer_starGenType_ServeRequest_anyParams struct {
	Recorder *MoqServer_starGenType_ServeRequest_fnRecorder
}

// MoqServer_starGenType_Accept_params holds the params of the
// Server_starGenType type
type MoqServer_starGenType_Accept_params struct{ Lis net.Listener }

// MoqServer_starGenType_Accept_paramsKey holds the map key params of the
// Server_starGenType type
type MoqServer_starGenType_Accept_paramsKey struct {
	Params struct{ Lis net.Listener }
	Hashes struct{ Lis hash.Hash }
}

// MoqServer_starGenType_Accept_resultsByParams contains the results for a
// given set of parameters for the Server_starGenType type
type MoqServer_starGenType_Accept_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqServer_starGenType_Accept_paramsKey]*MoqServer_starGenType_Accept_results
}

// MoqServer_starGenType_Accept_doFn defines the type of function needed when
// calling AndDo for the Server_starGenType type
type MoqServer_starGenType_Accept_doFn func(lis net.Listener)

// MoqServer_starGenType_Accept_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Server_starGenType type
type MoqServer_starGenType_Accept_doReturnFn func(lis net.Listener)

// MoqServer_starGenType_Accept_results holds the results of the
// Server_starGenType type
type MoqServer_starGenType_Accept_results struct {
	Params  MoqServer_starGenType_Accept_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_Accept_doFn
		DoReturnFn MoqServer_starGenType_Accept_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqServer_starGenType_Accept_fnRecorder routes recorded function calls to
// the MoqServer_starGenType moq
type MoqServer_starGenType_Accept_fnRecorder struct {
	Params    MoqServer_starGenType_Accept_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqServer_starGenType_Accept_results
	Moq       *MoqServer_starGenType
}

// MoqServer_starGenType_Accept_anyParams isolates the any params functions of
// the Server_starGenType type
type MoqServer_starGenType_Accept_anyParams struct {
	Recorder *MoqServer_starGenType_Accept_fnRecorder
}

// MoqServer_starGenType_ServeHTTP_params holds the params of the
// Server_starGenType type
type MoqServer_starGenType_ServeHTTP_params struct {
	W   http.ResponseWriter
	Req *http.Request
}

// MoqServer_starGenType_ServeHTTP_paramsKey holds the map key params of the
// Server_starGenType type
type MoqServer_starGenType_ServeHTTP_paramsKey struct {
	Params struct {
		W   http.ResponseWriter
		Req *http.Request
	}
	Hashes struct {
		W   hash.Hash
		Req hash.Hash
	}
}

// MoqServer_starGenType_ServeHTTP_resultsByParams contains the results for a
// given set of parameters for the Server_starGenType type
type MoqServer_starGenType_ServeHTTP_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqServer_starGenType_ServeHTTP_paramsKey]*MoqServer_starGenType_ServeHTTP_results
}

// MoqServer_starGenType_ServeHTTP_doFn defines the type of function needed
// when calling AndDo for the Server_starGenType type
type MoqServer_starGenType_ServeHTTP_doFn func(w http.ResponseWriter, req *http.Request)

// MoqServer_starGenType_ServeHTTP_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Server_starGenType type
type MoqServer_starGenType_ServeHTTP_doReturnFn func(w http.ResponseWriter, req *http.Request)

// MoqServer_starGenType_ServeHTTP_results holds the results of the
// Server_starGenType type
type MoqServer_starGenType_ServeHTTP_results struct {
	Params  MoqServer_starGenType_ServeHTTP_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeHTTP_doFn
		DoReturnFn MoqServer_starGenType_ServeHTTP_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqServer_starGenType_ServeHTTP_fnRecorder routes recorded function calls to
// the MoqServer_starGenType moq
type MoqServer_starGenType_ServeHTTP_fnRecorder struct {
	Params    MoqServer_starGenType_ServeHTTP_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqServer_starGenType_ServeHTTP_results
	Moq       *MoqServer_starGenType
}

// MoqServer_starGenType_ServeHTTP_anyParams isolates the any params functions
// of the Server_starGenType type
type MoqServer_starGenType_ServeHTTP_anyParams struct {
	Recorder *MoqServer_starGenType_ServeHTTP_fnRecorder
}

// MoqServer_starGenType_HandleHTTP_params holds the params of the
// Server_starGenType type
type MoqServer_starGenType_HandleHTTP_params struct{ RpcPath, DebugPath string }

// MoqServer_starGenType_HandleHTTP_paramsKey holds the map key params of the
// Server_starGenType type
type MoqServer_starGenType_HandleHTTP_paramsKey struct {
	Params struct{ RpcPath, DebugPath string }
	Hashes struct{ RpcPath, DebugPath hash.Hash }
}

// MoqServer_starGenType_HandleHTTP_resultsByParams contains the results for a
// given set of parameters for the Server_starGenType type
type MoqServer_starGenType_HandleHTTP_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqServer_starGenType_HandleHTTP_paramsKey]*MoqServer_starGenType_HandleHTTP_results
}

// MoqServer_starGenType_HandleHTTP_doFn defines the type of function needed
// when calling AndDo for the Server_starGenType type
type MoqServer_starGenType_HandleHTTP_doFn func(rpcPath, debugPath string)

// MoqServer_starGenType_HandleHTTP_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Server_starGenType type
type MoqServer_starGenType_HandleHTTP_doReturnFn func(rpcPath, debugPath string)

// MoqServer_starGenType_HandleHTTP_results holds the results of the
// Server_starGenType type
type MoqServer_starGenType_HandleHTTP_results struct {
	Params  MoqServer_starGenType_HandleHTTP_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_HandleHTTP_doFn
		DoReturnFn MoqServer_starGenType_HandleHTTP_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqServer_starGenType_HandleHTTP_fnRecorder routes recorded function calls
// to the MoqServer_starGenType moq
type MoqServer_starGenType_HandleHTTP_fnRecorder struct {
	Params    MoqServer_starGenType_HandleHTTP_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqServer_starGenType_HandleHTTP_results
	Moq       *MoqServer_starGenType
}

// MoqServer_starGenType_HandleHTTP_anyParams isolates the any params functions
// of the Server_starGenType type
type MoqServer_starGenType_HandleHTTP_anyParams struct {
	Recorder *MoqServer_starGenType_HandleHTTP_fnRecorder
}

// NewMoqServer_starGenType creates a new moq of the Server_starGenType type
func NewMoqServer_starGenType(scene *moq.Scene, config *moq.Config) *MoqServer_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqServer_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqServer_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Register struct {
					Rcvr moq.ParamIndexing
				}
				RegisterName struct {
					Name moq.ParamIndexing
					Rcvr moq.ParamIndexing
				}
				ServeConn struct {
					Conn moq.ParamIndexing
				}
				ServeCodec struct {
					Codec moq.ParamIndexing
				}
				ServeRequest struct {
					Codec moq.ParamIndexing
				}
				Accept struct {
					Lis moq.ParamIndexing
				}
				ServeHTTP struct {
					W   moq.ParamIndexing
					Req moq.ParamIndexing
				}
				HandleHTTP struct {
					RpcPath   moq.ParamIndexing
					DebugPath moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			Register struct {
				Rcvr moq.ParamIndexing
			}
			RegisterName struct {
				Name moq.ParamIndexing
				Rcvr moq.ParamIndexing
			}
			ServeConn struct {
				Conn moq.ParamIndexing
			}
			ServeCodec struct {
				Codec moq.ParamIndexing
			}
			ServeRequest struct {
				Codec moq.ParamIndexing
			}
			Accept struct {
				Lis moq.ParamIndexing
			}
			ServeHTTP struct {
				W   moq.ParamIndexing
				Req moq.ParamIndexing
			}
			HandleHTTP struct {
				RpcPath   moq.ParamIndexing
				DebugPath moq.ParamIndexing
			}
		}{
			Register: struct {
				Rcvr moq.ParamIndexing
			}{
				Rcvr: moq.ParamIndexByHash,
			},
			RegisterName: struct {
				Name moq.ParamIndexing
				Rcvr moq.ParamIndexing
			}{
				Name: moq.ParamIndexByValue,
				Rcvr: moq.ParamIndexByHash,
			},
			ServeConn: struct {
				Conn moq.ParamIndexing
			}{
				Conn: moq.ParamIndexByHash,
			},
			ServeCodec: struct {
				Codec moq.ParamIndexing
			}{
				Codec: moq.ParamIndexByHash,
			},
			ServeRequest: struct {
				Codec moq.ParamIndexing
			}{
				Codec: moq.ParamIndexByHash,
			},
			Accept: struct {
				Lis moq.ParamIndexing
			}{
				Lis: moq.ParamIndexByHash,
			},
			ServeHTTP: struct {
				W   moq.ParamIndexing
				Req moq.ParamIndexing
			}{
				W:   moq.ParamIndexByHash,
				Req: moq.ParamIndexByHash,
			},
			HandleHTTP: struct {
				RpcPath   moq.ParamIndexing
				DebugPath moq.ParamIndexing
			}{
				RpcPath:   moq.ParamIndexByValue,
				DebugPath: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Server_starGenType type
func (m *MoqServer_starGenType) Mock() *MoqServer_starGenType_mock { return m.Moq }

func (m *MoqServer_starGenType_mock) Register(rcvr interface{}) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqServer_starGenType_Register_params{
		Rcvr: rcvr,
	}
	var results *MoqServer_starGenType_Register_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Register {
		paramsKey := m.Moq.ParamsKey_Register(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Register(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Register(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Register(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(rcvr)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(rcvr)
	}
	return
}

func (m *MoqServer_starGenType_mock) RegisterName(name string, rcvr interface{}) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqServer_starGenType_RegisterName_params{
		Name: name,
		Rcvr: rcvr,
	}
	var results *MoqServer_starGenType_RegisterName_results
	for _, resultsByParams := range m.Moq.ResultsByParams_RegisterName {
		paramsKey := m.Moq.ParamsKey_RegisterName(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_RegisterName(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_RegisterName(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_RegisterName(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(name, rcvr)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(name, rcvr)
	}
	return
}

func (m *MoqServer_starGenType_mock) ServeConn(conn io.ReadWriteCloser) {
	m.Moq.Scene.T.Helper()
	params := MoqServer_starGenType_ServeConn_params{
		Conn: conn,
	}
	var results *MoqServer_starGenType_ServeConn_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ServeConn {
		paramsKey := m.Moq.ParamsKey_ServeConn(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ServeConn(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ServeConn(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ServeConn(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(conn)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(conn)
	}
	return
}

func (m *MoqServer_starGenType_mock) ServeCodec(codec rpc.ServerCodec) {
	m.Moq.Scene.T.Helper()
	params := MoqServer_starGenType_ServeCodec_params{
		Codec: codec,
	}
	var results *MoqServer_starGenType_ServeCodec_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ServeCodec {
		paramsKey := m.Moq.ParamsKey_ServeCodec(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ServeCodec(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ServeCodec(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ServeCodec(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(codec)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(codec)
	}
	return
}

func (m *MoqServer_starGenType_mock) ServeRequest(codec rpc.ServerCodec) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqServer_starGenType_ServeRequest_params{
		Codec: codec,
	}
	var results *MoqServer_starGenType_ServeRequest_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ServeRequest {
		paramsKey := m.Moq.ParamsKey_ServeRequest(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ServeRequest(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ServeRequest(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ServeRequest(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(codec)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(codec)
	}
	return
}

func (m *MoqServer_starGenType_mock) Accept(lis net.Listener) {
	m.Moq.Scene.T.Helper()
	params := MoqServer_starGenType_Accept_params{
		Lis: lis,
	}
	var results *MoqServer_starGenType_Accept_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Accept {
		paramsKey := m.Moq.ParamsKey_Accept(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Accept(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Accept(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Accept(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(lis)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(lis)
	}
	return
}

func (m *MoqServer_starGenType_mock) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	m.Moq.Scene.T.Helper()
	params := MoqServer_starGenType_ServeHTTP_params{
		W:   w,
		Req: req,
	}
	var results *MoqServer_starGenType_ServeHTTP_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ServeHTTP {
		paramsKey := m.Moq.ParamsKey_ServeHTTP(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ServeHTTP(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ServeHTTP(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ServeHTTP(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(w, req)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(w, req)
	}
	return
}

func (m *MoqServer_starGenType_mock) HandleHTTP(rpcPath, debugPath string) {
	m.Moq.Scene.T.Helper()
	params := MoqServer_starGenType_HandleHTTP_params{
		RpcPath:   rpcPath,
		DebugPath: debugPath,
	}
	var results *MoqServer_starGenType_HandleHTTP_results
	for _, resultsByParams := range m.Moq.ResultsByParams_HandleHTTP {
		paramsKey := m.Moq.ParamsKey_HandleHTTP(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_HandleHTTP(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_HandleHTTP(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_HandleHTTP(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(rpcPath, debugPath)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(rpcPath, debugPath)
	}
	return
}

// OnCall returns the recorder implementation of the Server_starGenType type
func (m *MoqServer_starGenType) OnCall() *MoqServer_starGenType_recorder {
	return &MoqServer_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqServer_starGenType_recorder) Register(rcvr interface{}) *MoqServer_starGenType_Register_fnRecorder {
	return &MoqServer_starGenType_Register_fnRecorder{
		Params: MoqServer_starGenType_Register_params{
			Rcvr: rcvr,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqServer_starGenType_Register_fnRecorder) Any() *MoqServer_starGenType_Register_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Register(r.Params))
		return nil
	}
	return &MoqServer_starGenType_Register_anyParams{Recorder: r}
}

func (a *MoqServer_starGenType_Register_anyParams) Rcvr() *MoqServer_starGenType_Register_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqServer_starGenType_Register_fnRecorder) Seq() *MoqServer_starGenType_Register_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Register(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqServer_starGenType_Register_fnRecorder) NoSeq() *MoqServer_starGenType_Register_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Register(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqServer_starGenType_Register_fnRecorder) ReturnResults(result1 error) *MoqServer_starGenType_Register_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqServer_starGenType_Register_doFn
		DoReturnFn MoqServer_starGenType_Register_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqServer_starGenType_Register_fnRecorder) AndDo(fn MoqServer_starGenType_Register_doFn) *MoqServer_starGenType_Register_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqServer_starGenType_Register_fnRecorder) DoReturnResults(fn MoqServer_starGenType_Register_doReturnFn) *MoqServer_starGenType_Register_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqServer_starGenType_Register_doFn
		DoReturnFn MoqServer_starGenType_Register_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqServer_starGenType_Register_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqServer_starGenType_Register_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Register {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqServer_starGenType_Register_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqServer_starGenType_Register_paramsKey]*MoqServer_starGenType_Register_results{},
		}
		r.Moq.ResultsByParams_Register = append(r.Moq.ResultsByParams_Register, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Register) {
			copy(r.Moq.ResultsByParams_Register[insertAt+1:], r.Moq.ResultsByParams_Register[insertAt:0])
			r.Moq.ResultsByParams_Register[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Register(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqServer_starGenType_Register_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqServer_starGenType_Register_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqServer_starGenType_Register_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqServer_starGenType_Register_doFn
				DoReturnFn MoqServer_starGenType_Register_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqServer_starGenType) PrettyParams_Register(params MoqServer_starGenType_Register_params) string {
	return fmt.Sprintf("Register(%#v)", params.Rcvr)
}

func (m *MoqServer_starGenType) ParamsKey_Register(params MoqServer_starGenType_Register_params, anyParams uint64) MoqServer_starGenType_Register_paramsKey {
	m.Scene.T.Helper()
	var rcvrUsed interface{}
	var rcvrUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Register.Rcvr == moq.ParamIndexByValue {
			rcvrUsed = params.Rcvr
		} else {
			rcvrUsedHash = hash.DeepHash(params.Rcvr)
		}
	}
	return MoqServer_starGenType_Register_paramsKey{
		Params: struct{ Rcvr interface{} }{
			Rcvr: rcvrUsed,
		},
		Hashes: struct{ Rcvr hash.Hash }{
			Rcvr: rcvrUsedHash,
		},
	}
}

func (m *MoqServer_starGenType_recorder) RegisterName(name string, rcvr interface{}) *MoqServer_starGenType_RegisterName_fnRecorder {
	return &MoqServer_starGenType_RegisterName_fnRecorder{
		Params: MoqServer_starGenType_RegisterName_params{
			Name: name,
			Rcvr: rcvr,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqServer_starGenType_RegisterName_fnRecorder) Any() *MoqServer_starGenType_RegisterName_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RegisterName(r.Params))
		return nil
	}
	return &MoqServer_starGenType_RegisterName_anyParams{Recorder: r}
}

func (a *MoqServer_starGenType_RegisterName_anyParams) Name() *MoqServer_starGenType_RegisterName_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqServer_starGenType_RegisterName_anyParams) Rcvr() *MoqServer_starGenType_RegisterName_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqServer_starGenType_RegisterName_fnRecorder) Seq() *MoqServer_starGenType_RegisterName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RegisterName(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqServer_starGenType_RegisterName_fnRecorder) NoSeq() *MoqServer_starGenType_RegisterName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RegisterName(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqServer_starGenType_RegisterName_fnRecorder) ReturnResults(result1 error) *MoqServer_starGenType_RegisterName_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqServer_starGenType_RegisterName_doFn
		DoReturnFn MoqServer_starGenType_RegisterName_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqServer_starGenType_RegisterName_fnRecorder) AndDo(fn MoqServer_starGenType_RegisterName_doFn) *MoqServer_starGenType_RegisterName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqServer_starGenType_RegisterName_fnRecorder) DoReturnResults(fn MoqServer_starGenType_RegisterName_doReturnFn) *MoqServer_starGenType_RegisterName_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqServer_starGenType_RegisterName_doFn
		DoReturnFn MoqServer_starGenType_RegisterName_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqServer_starGenType_RegisterName_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqServer_starGenType_RegisterName_resultsByParams
	for n, res := range r.Moq.ResultsByParams_RegisterName {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqServer_starGenType_RegisterName_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqServer_starGenType_RegisterName_paramsKey]*MoqServer_starGenType_RegisterName_results{},
		}
		r.Moq.ResultsByParams_RegisterName = append(r.Moq.ResultsByParams_RegisterName, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_RegisterName) {
			copy(r.Moq.ResultsByParams_RegisterName[insertAt+1:], r.Moq.ResultsByParams_RegisterName[insertAt:0])
			r.Moq.ResultsByParams_RegisterName[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_RegisterName(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqServer_starGenType_RegisterName_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqServer_starGenType_RegisterName_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqServer_starGenType_RegisterName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqServer_starGenType_RegisterName_doFn
				DoReturnFn MoqServer_starGenType_RegisterName_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqServer_starGenType) PrettyParams_RegisterName(params MoqServer_starGenType_RegisterName_params) string {
	return fmt.Sprintf("RegisterName(%#v, %#v)", params.Name, params.Rcvr)
}

func (m *MoqServer_starGenType) ParamsKey_RegisterName(params MoqServer_starGenType_RegisterName_params, anyParams uint64) MoqServer_starGenType_RegisterName_paramsKey {
	m.Scene.T.Helper()
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.RegisterName.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	var rcvrUsed interface{}
	var rcvrUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.RegisterName.Rcvr == moq.ParamIndexByValue {
			rcvrUsed = params.Rcvr
		} else {
			rcvrUsedHash = hash.DeepHash(params.Rcvr)
		}
	}
	return MoqServer_starGenType_RegisterName_paramsKey{
		Params: struct {
			Name string
			Rcvr interface{}
		}{
			Name: nameUsed,
			Rcvr: rcvrUsed,
		},
		Hashes: struct {
			Name hash.Hash
			Rcvr hash.Hash
		}{
			Name: nameUsedHash,
			Rcvr: rcvrUsedHash,
		},
	}
}

func (m *MoqServer_starGenType_recorder) ServeConn(conn io.ReadWriteCloser) *MoqServer_starGenType_ServeConn_fnRecorder {
	return &MoqServer_starGenType_ServeConn_fnRecorder{
		Params: MoqServer_starGenType_ServeConn_params{
			Conn: conn,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqServer_starGenType_ServeConn_fnRecorder) Any() *MoqServer_starGenType_ServeConn_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeConn(r.Params))
		return nil
	}
	return &MoqServer_starGenType_ServeConn_anyParams{Recorder: r}
}

func (a *MoqServer_starGenType_ServeConn_anyParams) Conn() *MoqServer_starGenType_ServeConn_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqServer_starGenType_ServeConn_fnRecorder) Seq() *MoqServer_starGenType_ServeConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeConn(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqServer_starGenType_ServeConn_fnRecorder) NoSeq() *MoqServer_starGenType_ServeConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeConn(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqServer_starGenType_ServeConn_fnRecorder) ReturnResults() *MoqServer_starGenType_ServeConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeConn_doFn
		DoReturnFn MoqServer_starGenType_ServeConn_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqServer_starGenType_ServeConn_fnRecorder) AndDo(fn MoqServer_starGenType_ServeConn_doFn) *MoqServer_starGenType_ServeConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqServer_starGenType_ServeConn_fnRecorder) DoReturnResults(fn MoqServer_starGenType_ServeConn_doReturnFn) *MoqServer_starGenType_ServeConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeConn_doFn
		DoReturnFn MoqServer_starGenType_ServeConn_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqServer_starGenType_ServeConn_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqServer_starGenType_ServeConn_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ServeConn {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqServer_starGenType_ServeConn_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqServer_starGenType_ServeConn_paramsKey]*MoqServer_starGenType_ServeConn_results{},
		}
		r.Moq.ResultsByParams_ServeConn = append(r.Moq.ResultsByParams_ServeConn, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ServeConn) {
			copy(r.Moq.ResultsByParams_ServeConn[insertAt+1:], r.Moq.ResultsByParams_ServeConn[insertAt:0])
			r.Moq.ResultsByParams_ServeConn[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ServeConn(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqServer_starGenType_ServeConn_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqServer_starGenType_ServeConn_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqServer_starGenType_ServeConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqServer_starGenType_ServeConn_doFn
				DoReturnFn MoqServer_starGenType_ServeConn_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqServer_starGenType) PrettyParams_ServeConn(params MoqServer_starGenType_ServeConn_params) string {
	return fmt.Sprintf("ServeConn(%#v)", params.Conn)
}

func (m *MoqServer_starGenType) ParamsKey_ServeConn(params MoqServer_starGenType_ServeConn_params, anyParams uint64) MoqServer_starGenType_ServeConn_paramsKey {
	m.Scene.T.Helper()
	var connUsed io.ReadWriteCloser
	var connUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ServeConn.Conn == moq.ParamIndexByValue {
			connUsed = params.Conn
		} else {
			connUsedHash = hash.DeepHash(params.Conn)
		}
	}
	return MoqServer_starGenType_ServeConn_paramsKey{
		Params: struct{ Conn io.ReadWriteCloser }{
			Conn: connUsed,
		},
		Hashes: struct{ Conn hash.Hash }{
			Conn: connUsedHash,
		},
	}
}

func (m *MoqServer_starGenType_recorder) ServeCodec(codec rpc.ServerCodec) *MoqServer_starGenType_ServeCodec_fnRecorder {
	return &MoqServer_starGenType_ServeCodec_fnRecorder{
		Params: MoqServer_starGenType_ServeCodec_params{
			Codec: codec,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqServer_starGenType_ServeCodec_fnRecorder) Any() *MoqServer_starGenType_ServeCodec_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeCodec(r.Params))
		return nil
	}
	return &MoqServer_starGenType_ServeCodec_anyParams{Recorder: r}
}

func (a *MoqServer_starGenType_ServeCodec_anyParams) Codec() *MoqServer_starGenType_ServeCodec_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqServer_starGenType_ServeCodec_fnRecorder) Seq() *MoqServer_starGenType_ServeCodec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeCodec(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqServer_starGenType_ServeCodec_fnRecorder) NoSeq() *MoqServer_starGenType_ServeCodec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeCodec(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqServer_starGenType_ServeCodec_fnRecorder) ReturnResults() *MoqServer_starGenType_ServeCodec_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeCodec_doFn
		DoReturnFn MoqServer_starGenType_ServeCodec_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqServer_starGenType_ServeCodec_fnRecorder) AndDo(fn MoqServer_starGenType_ServeCodec_doFn) *MoqServer_starGenType_ServeCodec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqServer_starGenType_ServeCodec_fnRecorder) DoReturnResults(fn MoqServer_starGenType_ServeCodec_doReturnFn) *MoqServer_starGenType_ServeCodec_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeCodec_doFn
		DoReturnFn MoqServer_starGenType_ServeCodec_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqServer_starGenType_ServeCodec_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqServer_starGenType_ServeCodec_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ServeCodec {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqServer_starGenType_ServeCodec_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqServer_starGenType_ServeCodec_paramsKey]*MoqServer_starGenType_ServeCodec_results{},
		}
		r.Moq.ResultsByParams_ServeCodec = append(r.Moq.ResultsByParams_ServeCodec, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ServeCodec) {
			copy(r.Moq.ResultsByParams_ServeCodec[insertAt+1:], r.Moq.ResultsByParams_ServeCodec[insertAt:0])
			r.Moq.ResultsByParams_ServeCodec[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ServeCodec(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqServer_starGenType_ServeCodec_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqServer_starGenType_ServeCodec_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqServer_starGenType_ServeCodec_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqServer_starGenType_ServeCodec_doFn
				DoReturnFn MoqServer_starGenType_ServeCodec_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqServer_starGenType) PrettyParams_ServeCodec(params MoqServer_starGenType_ServeCodec_params) string {
	return fmt.Sprintf("ServeCodec(%#v)", params.Codec)
}

func (m *MoqServer_starGenType) ParamsKey_ServeCodec(params MoqServer_starGenType_ServeCodec_params, anyParams uint64) MoqServer_starGenType_ServeCodec_paramsKey {
	m.Scene.T.Helper()
	var codecUsed rpc.ServerCodec
	var codecUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ServeCodec.Codec == moq.ParamIndexByValue {
			codecUsed = params.Codec
		} else {
			codecUsedHash = hash.DeepHash(params.Codec)
		}
	}
	return MoqServer_starGenType_ServeCodec_paramsKey{
		Params: struct{ Codec rpc.ServerCodec }{
			Codec: codecUsed,
		},
		Hashes: struct{ Codec hash.Hash }{
			Codec: codecUsedHash,
		},
	}
}

func (m *MoqServer_starGenType_recorder) ServeRequest(codec rpc.ServerCodec) *MoqServer_starGenType_ServeRequest_fnRecorder {
	return &MoqServer_starGenType_ServeRequest_fnRecorder{
		Params: MoqServer_starGenType_ServeRequest_params{
			Codec: codec,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqServer_starGenType_ServeRequest_fnRecorder) Any() *MoqServer_starGenType_ServeRequest_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeRequest(r.Params))
		return nil
	}
	return &MoqServer_starGenType_ServeRequest_anyParams{Recorder: r}
}

func (a *MoqServer_starGenType_ServeRequest_anyParams) Codec() *MoqServer_starGenType_ServeRequest_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqServer_starGenType_ServeRequest_fnRecorder) Seq() *MoqServer_starGenType_ServeRequest_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeRequest(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqServer_starGenType_ServeRequest_fnRecorder) NoSeq() *MoqServer_starGenType_ServeRequest_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeRequest(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqServer_starGenType_ServeRequest_fnRecorder) ReturnResults(result1 error) *MoqServer_starGenType_ServeRequest_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeRequest_doFn
		DoReturnFn MoqServer_starGenType_ServeRequest_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqServer_starGenType_ServeRequest_fnRecorder) AndDo(fn MoqServer_starGenType_ServeRequest_doFn) *MoqServer_starGenType_ServeRequest_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqServer_starGenType_ServeRequest_fnRecorder) DoReturnResults(fn MoqServer_starGenType_ServeRequest_doReturnFn) *MoqServer_starGenType_ServeRequest_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeRequest_doFn
		DoReturnFn MoqServer_starGenType_ServeRequest_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqServer_starGenType_ServeRequest_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqServer_starGenType_ServeRequest_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ServeRequest {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqServer_starGenType_ServeRequest_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqServer_starGenType_ServeRequest_paramsKey]*MoqServer_starGenType_ServeRequest_results{},
		}
		r.Moq.ResultsByParams_ServeRequest = append(r.Moq.ResultsByParams_ServeRequest, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ServeRequest) {
			copy(r.Moq.ResultsByParams_ServeRequest[insertAt+1:], r.Moq.ResultsByParams_ServeRequest[insertAt:0])
			r.Moq.ResultsByParams_ServeRequest[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ServeRequest(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqServer_starGenType_ServeRequest_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqServer_starGenType_ServeRequest_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqServer_starGenType_ServeRequest_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqServer_starGenType_ServeRequest_doFn
				DoReturnFn MoqServer_starGenType_ServeRequest_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqServer_starGenType) PrettyParams_ServeRequest(params MoqServer_starGenType_ServeRequest_params) string {
	return fmt.Sprintf("ServeRequest(%#v)", params.Codec)
}

func (m *MoqServer_starGenType) ParamsKey_ServeRequest(params MoqServer_starGenType_ServeRequest_params, anyParams uint64) MoqServer_starGenType_ServeRequest_paramsKey {
	m.Scene.T.Helper()
	var codecUsed rpc.ServerCodec
	var codecUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ServeRequest.Codec == moq.ParamIndexByValue {
			codecUsed = params.Codec
		} else {
			codecUsedHash = hash.DeepHash(params.Codec)
		}
	}
	return MoqServer_starGenType_ServeRequest_paramsKey{
		Params: struct{ Codec rpc.ServerCodec }{
			Codec: codecUsed,
		},
		Hashes: struct{ Codec hash.Hash }{
			Codec: codecUsedHash,
		},
	}
}

func (m *MoqServer_starGenType_recorder) Accept(lis net.Listener) *MoqServer_starGenType_Accept_fnRecorder {
	return &MoqServer_starGenType_Accept_fnRecorder{
		Params: MoqServer_starGenType_Accept_params{
			Lis: lis,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqServer_starGenType_Accept_fnRecorder) Any() *MoqServer_starGenType_Accept_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Accept(r.Params))
		return nil
	}
	return &MoqServer_starGenType_Accept_anyParams{Recorder: r}
}

func (a *MoqServer_starGenType_Accept_anyParams) Lis() *MoqServer_starGenType_Accept_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqServer_starGenType_Accept_fnRecorder) Seq() *MoqServer_starGenType_Accept_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Accept(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqServer_starGenType_Accept_fnRecorder) NoSeq() *MoqServer_starGenType_Accept_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Accept(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqServer_starGenType_Accept_fnRecorder) ReturnResults() *MoqServer_starGenType_Accept_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_Accept_doFn
		DoReturnFn MoqServer_starGenType_Accept_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqServer_starGenType_Accept_fnRecorder) AndDo(fn MoqServer_starGenType_Accept_doFn) *MoqServer_starGenType_Accept_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqServer_starGenType_Accept_fnRecorder) DoReturnResults(fn MoqServer_starGenType_Accept_doReturnFn) *MoqServer_starGenType_Accept_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_Accept_doFn
		DoReturnFn MoqServer_starGenType_Accept_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqServer_starGenType_Accept_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqServer_starGenType_Accept_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Accept {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqServer_starGenType_Accept_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqServer_starGenType_Accept_paramsKey]*MoqServer_starGenType_Accept_results{},
		}
		r.Moq.ResultsByParams_Accept = append(r.Moq.ResultsByParams_Accept, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Accept) {
			copy(r.Moq.ResultsByParams_Accept[insertAt+1:], r.Moq.ResultsByParams_Accept[insertAt:0])
			r.Moq.ResultsByParams_Accept[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Accept(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqServer_starGenType_Accept_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqServer_starGenType_Accept_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqServer_starGenType_Accept_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqServer_starGenType_Accept_doFn
				DoReturnFn MoqServer_starGenType_Accept_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqServer_starGenType) PrettyParams_Accept(params MoqServer_starGenType_Accept_params) string {
	return fmt.Sprintf("Accept(%#v)", params.Lis)
}

func (m *MoqServer_starGenType) ParamsKey_Accept(params MoqServer_starGenType_Accept_params, anyParams uint64) MoqServer_starGenType_Accept_paramsKey {
	m.Scene.T.Helper()
	var lisUsed net.Listener
	var lisUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Accept.Lis == moq.ParamIndexByValue {
			lisUsed = params.Lis
		} else {
			lisUsedHash = hash.DeepHash(params.Lis)
		}
	}
	return MoqServer_starGenType_Accept_paramsKey{
		Params: struct{ Lis net.Listener }{
			Lis: lisUsed,
		},
		Hashes: struct{ Lis hash.Hash }{
			Lis: lisUsedHash,
		},
	}
}

func (m *MoqServer_starGenType_recorder) ServeHTTP(w http.ResponseWriter, req *http.Request) *MoqServer_starGenType_ServeHTTP_fnRecorder {
	return &MoqServer_starGenType_ServeHTTP_fnRecorder{
		Params: MoqServer_starGenType_ServeHTTP_params{
			W:   w,
			Req: req,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqServer_starGenType_ServeHTTP_fnRecorder) Any() *MoqServer_starGenType_ServeHTTP_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeHTTP(r.Params))
		return nil
	}
	return &MoqServer_starGenType_ServeHTTP_anyParams{Recorder: r}
}

func (a *MoqServer_starGenType_ServeHTTP_anyParams) W() *MoqServer_starGenType_ServeHTTP_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqServer_starGenType_ServeHTTP_anyParams) Req() *MoqServer_starGenType_ServeHTTP_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqServer_starGenType_ServeHTTP_fnRecorder) Seq() *MoqServer_starGenType_ServeHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeHTTP(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqServer_starGenType_ServeHTTP_fnRecorder) NoSeq() *MoqServer_starGenType_ServeHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ServeHTTP(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqServer_starGenType_ServeHTTP_fnRecorder) ReturnResults() *MoqServer_starGenType_ServeHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeHTTP_doFn
		DoReturnFn MoqServer_starGenType_ServeHTTP_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqServer_starGenType_ServeHTTP_fnRecorder) AndDo(fn MoqServer_starGenType_ServeHTTP_doFn) *MoqServer_starGenType_ServeHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqServer_starGenType_ServeHTTP_fnRecorder) DoReturnResults(fn MoqServer_starGenType_ServeHTTP_doReturnFn) *MoqServer_starGenType_ServeHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_ServeHTTP_doFn
		DoReturnFn MoqServer_starGenType_ServeHTTP_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqServer_starGenType_ServeHTTP_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqServer_starGenType_ServeHTTP_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ServeHTTP {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqServer_starGenType_ServeHTTP_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqServer_starGenType_ServeHTTP_paramsKey]*MoqServer_starGenType_ServeHTTP_results{},
		}
		r.Moq.ResultsByParams_ServeHTTP = append(r.Moq.ResultsByParams_ServeHTTP, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ServeHTTP) {
			copy(r.Moq.ResultsByParams_ServeHTTP[insertAt+1:], r.Moq.ResultsByParams_ServeHTTP[insertAt:0])
			r.Moq.ResultsByParams_ServeHTTP[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ServeHTTP(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqServer_starGenType_ServeHTTP_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqServer_starGenType_ServeHTTP_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqServer_starGenType_ServeHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqServer_starGenType_ServeHTTP_doFn
				DoReturnFn MoqServer_starGenType_ServeHTTP_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqServer_starGenType) PrettyParams_ServeHTTP(params MoqServer_starGenType_ServeHTTP_params) string {
	return fmt.Sprintf("ServeHTTP(%#v, %#v)", params.W, params.Req)
}

func (m *MoqServer_starGenType) ParamsKey_ServeHTTP(params MoqServer_starGenType_ServeHTTP_params, anyParams uint64) MoqServer_starGenType_ServeHTTP_paramsKey {
	m.Scene.T.Helper()
	var wUsed http.ResponseWriter
	var wUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ServeHTTP.W == moq.ParamIndexByValue {
			wUsed = params.W
		} else {
			wUsedHash = hash.DeepHash(params.W)
		}
	}
	var reqUsed *http.Request
	var reqUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ServeHTTP.Req == moq.ParamIndexByValue {
			reqUsed = params.Req
		} else {
			reqUsedHash = hash.DeepHash(params.Req)
		}
	}
	return MoqServer_starGenType_ServeHTTP_paramsKey{
		Params: struct {
			W   http.ResponseWriter
			Req *http.Request
		}{
			W:   wUsed,
			Req: reqUsed,
		},
		Hashes: struct {
			W   hash.Hash
			Req hash.Hash
		}{
			W:   wUsedHash,
			Req: reqUsedHash,
		},
	}
}

func (m *MoqServer_starGenType_recorder) HandleHTTP(rpcPath, debugPath string) *MoqServer_starGenType_HandleHTTP_fnRecorder {
	return &MoqServer_starGenType_HandleHTTP_fnRecorder{
		Params: MoqServer_starGenType_HandleHTTP_params{
			RpcPath:   rpcPath,
			DebugPath: debugPath,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqServer_starGenType_HandleHTTP_fnRecorder) Any() *MoqServer_starGenType_HandleHTTP_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_HandleHTTP(r.Params))
		return nil
	}
	return &MoqServer_starGenType_HandleHTTP_anyParams{Recorder: r}
}

func (a *MoqServer_starGenType_HandleHTTP_anyParams) RpcPath() *MoqServer_starGenType_HandleHTTP_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqServer_starGenType_HandleHTTP_anyParams) DebugPath() *MoqServer_starGenType_HandleHTTP_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqServer_starGenType_HandleHTTP_fnRecorder) Seq() *MoqServer_starGenType_HandleHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_HandleHTTP(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqServer_starGenType_HandleHTTP_fnRecorder) NoSeq() *MoqServer_starGenType_HandleHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_HandleHTTP(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqServer_starGenType_HandleHTTP_fnRecorder) ReturnResults() *MoqServer_starGenType_HandleHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_HandleHTTP_doFn
		DoReturnFn MoqServer_starGenType_HandleHTTP_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqServer_starGenType_HandleHTTP_fnRecorder) AndDo(fn MoqServer_starGenType_HandleHTTP_doFn) *MoqServer_starGenType_HandleHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqServer_starGenType_HandleHTTP_fnRecorder) DoReturnResults(fn MoqServer_starGenType_HandleHTTP_doReturnFn) *MoqServer_starGenType_HandleHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqServer_starGenType_HandleHTTP_doFn
		DoReturnFn MoqServer_starGenType_HandleHTTP_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqServer_starGenType_HandleHTTP_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqServer_starGenType_HandleHTTP_resultsByParams
	for n, res := range r.Moq.ResultsByParams_HandleHTTP {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqServer_starGenType_HandleHTTP_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqServer_starGenType_HandleHTTP_paramsKey]*MoqServer_starGenType_HandleHTTP_results{},
		}
		r.Moq.ResultsByParams_HandleHTTP = append(r.Moq.ResultsByParams_HandleHTTP, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_HandleHTTP) {
			copy(r.Moq.ResultsByParams_HandleHTTP[insertAt+1:], r.Moq.ResultsByParams_HandleHTTP[insertAt:0])
			r.Moq.ResultsByParams_HandleHTTP[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_HandleHTTP(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqServer_starGenType_HandleHTTP_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqServer_starGenType_HandleHTTP_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqServer_starGenType_HandleHTTP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqServer_starGenType_HandleHTTP_doFn
				DoReturnFn MoqServer_starGenType_HandleHTTP_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqServer_starGenType) PrettyParams_HandleHTTP(params MoqServer_starGenType_HandleHTTP_params) string {
	return fmt.Sprintf("HandleHTTP(%#v, %#v)", params.RpcPath, params.DebugPath)
}

func (m *MoqServer_starGenType) ParamsKey_HandleHTTP(params MoqServer_starGenType_HandleHTTP_params, anyParams uint64) MoqServer_starGenType_HandleHTTP_paramsKey {
	m.Scene.T.Helper()
	var rpcPathUsed string
	var rpcPathUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.HandleHTTP.RpcPath == moq.ParamIndexByValue {
			rpcPathUsed = params.RpcPath
		} else {
			rpcPathUsedHash = hash.DeepHash(params.RpcPath)
		}
	}
	var debugPathUsed string
	var debugPathUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.HandleHTTP.DebugPath == moq.ParamIndexByValue {
			debugPathUsed = params.DebugPath
		} else {
			debugPathUsedHash = hash.DeepHash(params.DebugPath)
		}
	}
	return MoqServer_starGenType_HandleHTTP_paramsKey{
		Params: struct{ RpcPath, DebugPath string }{
			RpcPath:   rpcPathUsed,
			DebugPath: debugPathUsed,
		},
		Hashes: struct{ RpcPath, DebugPath hash.Hash }{
			RpcPath:   rpcPathUsedHash,
			DebugPath: debugPathUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqServer_starGenType) Reset() {
	m.ResultsByParams_Register = nil
	m.ResultsByParams_RegisterName = nil
	m.ResultsByParams_ServeConn = nil
	m.ResultsByParams_ServeCodec = nil
	m.ResultsByParams_ServeRequest = nil
	m.ResultsByParams_Accept = nil
	m.ResultsByParams_ServeHTTP = nil
	m.ResultsByParams_HandleHTTP = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqServer_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Register {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Register(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_RegisterName {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_RegisterName(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ServeConn {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ServeConn(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ServeCodec {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ServeCodec(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ServeRequest {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ServeRequest(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Accept {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Accept(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ServeHTTP {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ServeHTTP(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_HandleHTTP {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_HandleHTTP(results.Params))
			}
		}
	}
}
