// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package netip

import (
	"fmt"
	"math/bits"
	"net/netip"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that netip.Addr_genType is mocked
// completely
var _ Addr_genType = (*MoqAddr_genType_mock)(nil)

// Addr_genType is the fabricated implementation type of this mock (emitted
// when mocking a collections of methods directly and not from an interface
// type)
type Addr_genType interface {
	IsValid() bool
	BitLen() int
	Zone() string
	Compare(ip2 netip.Addr) int
	Less(ip2 netip.Addr) bool
	Is4() bool
	Is4In6() bool
	Is6() bool
	Unmap() netip.Addr
	WithZone(zone string) netip.Addr
	IsLinkLocalUnicast() bool
	IsLoopback() bool
	IsMulticast() bool
	IsInterfaceLocalMulticast() bool
	IsLinkLocalMulticast() bool
	IsGlobalUnicast() bool
	IsPrivate() bool
	IsUnspecified() bool
	Prefix(b int) (netip.Prefix, error)
	As16() (a16 [16]byte)
	As4() (a4 [4]byte)
	AsSlice() []byte
	Next() netip.Addr
	Prev() netip.Addr
	String() string
	AppendTo(b []byte) []byte
	StringExpanded() string
	MarshalText() ([]byte, error)
	MarshalBinary() ([]byte, error)
}

// MoqAddr_genType holds the state of a moq of the Addr_genType type
type MoqAddr_genType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqAddr_genType_mock

	ResultsByParams_IsValid                   []MoqAddr_genType_IsValid_resultsByParams
	ResultsByParams_BitLen                    []MoqAddr_genType_BitLen_resultsByParams
	ResultsByParams_Zone                      []MoqAddr_genType_Zone_resultsByParams
	ResultsByParams_Compare                   []MoqAddr_genType_Compare_resultsByParams
	ResultsByParams_Less                      []MoqAddr_genType_Less_resultsByParams
	ResultsByParams_Is4                       []MoqAddr_genType_Is4_resultsByParams
	ResultsByParams_Is4In6                    []MoqAddr_genType_Is4In6_resultsByParams
	ResultsByParams_Is6                       []MoqAddr_genType_Is6_resultsByParams
	ResultsByParams_Unmap                     []MoqAddr_genType_Unmap_resultsByParams
	ResultsByParams_WithZone                  []MoqAddr_genType_WithZone_resultsByParams
	ResultsByParams_IsLinkLocalUnicast        []MoqAddr_genType_IsLinkLocalUnicast_resultsByParams
	ResultsByParams_IsLoopback                []MoqAddr_genType_IsLoopback_resultsByParams
	ResultsByParams_IsMulticast               []MoqAddr_genType_IsMulticast_resultsByParams
	ResultsByParams_IsInterfaceLocalMulticast []MoqAddr_genType_IsInterfaceLocalMulticast_resultsByParams
	ResultsByParams_IsLinkLocalMulticast      []MoqAddr_genType_IsLinkLocalMulticast_resultsByParams
	ResultsByParams_IsGlobalUnicast           []MoqAddr_genType_IsGlobalUnicast_resultsByParams
	ResultsByParams_IsPrivate                 []MoqAddr_genType_IsPrivate_resultsByParams
	ResultsByParams_IsUnspecified             []MoqAddr_genType_IsUnspecified_resultsByParams
	ResultsByParams_Prefix                    []MoqAddr_genType_Prefix_resultsByParams
	ResultsByParams_As16                      []MoqAddr_genType_As16_resultsByParams
	ResultsByParams_As4                       []MoqAddr_genType_As4_resultsByParams
	ResultsByParams_AsSlice                   []MoqAddr_genType_AsSlice_resultsByParams
	ResultsByParams_Next                      []MoqAddr_genType_Next_resultsByParams
	ResultsByParams_Prev                      []MoqAddr_genType_Prev_resultsByParams
	ResultsByParams_String                    []MoqAddr_genType_String_resultsByParams
	ResultsByParams_AppendTo                  []MoqAddr_genType_AppendTo_resultsByParams
	ResultsByParams_StringExpanded            []MoqAddr_genType_StringExpanded_resultsByParams
	ResultsByParams_MarshalText               []MoqAddr_genType_MarshalText_resultsByParams
	ResultsByParams_MarshalBinary             []MoqAddr_genType_MarshalBinary_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			IsValid struct{}
			BitLen  struct{}
			Zone    struct{}
			Compare struct {
				Ip2 moq.ParamIndexing
			}
			Less struct {
				Ip2 moq.ParamIndexing
			}
			Is4      struct{}
			Is4In6   struct{}
			Is6      struct{}
			Unmap    struct{}
			WithZone struct {
				Zone moq.ParamIndexing
			}
			IsLinkLocalUnicast        struct{}
			IsLoopback                struct{}
			IsMulticast               struct{}
			IsInterfaceLocalMulticast struct{}
			IsLinkLocalMulticast      struct{}
			IsGlobalUnicast           struct{}
			IsPrivate                 struct{}
			IsUnspecified             struct{}
			Prefix                    struct {
				B moq.ParamIndexing
			}
			As16     struct{}
			As4      struct{}
			AsSlice  struct{}
			Next     struct{}
			Prev     struct{}
			String   struct{}
			AppendTo struct {
				B moq.ParamIndexing
			}
			StringExpanded struct{}
			MarshalText    struct{}
			MarshalBinary  struct{}
		}
	}
}

// MoqAddr_genType_mock isolates the mock interface of the Addr_genType type
type MoqAddr_genType_mock struct {
	Moq *MoqAddr_genType
}

// MoqAddr_genType_recorder isolates the recorder interface of the Addr_genType
// type
type MoqAddr_genType_recorder struct {
	Moq *MoqAddr_genType
}

// MoqAddr_genType_IsValid_params holds the params of the Addr_genType type
type MoqAddr_genType_IsValid_params struct{}

// MoqAddr_genType_IsValid_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_IsValid_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_IsValid_resultsByParams contains the results for a given set
// of parameters for the Addr_genType type
type MoqAddr_genType_IsValid_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_IsValid_paramsKey]*MoqAddr_genType_IsValid_results
}

// MoqAddr_genType_IsValid_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_IsValid_doFn func()

// MoqAddr_genType_IsValid_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_IsValid_doReturnFn func() bool

// MoqAddr_genType_IsValid_results holds the results of the Addr_genType type
type MoqAddr_genType_IsValid_results struct {
	Params  MoqAddr_genType_IsValid_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsValid_doFn
		DoReturnFn MoqAddr_genType_IsValid_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_IsValid_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_IsValid_fnRecorder struct {
	Params    MoqAddr_genType_IsValid_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_IsValid_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_IsValid_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_IsValid_anyParams struct {
	Recorder *MoqAddr_genType_IsValid_fnRecorder
}

// MoqAddr_genType_BitLen_params holds the params of the Addr_genType type
type MoqAddr_genType_BitLen_params struct{}

// MoqAddr_genType_BitLen_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_BitLen_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_BitLen_resultsByParams contains the results for a given set
// of parameters for the Addr_genType type
type MoqAddr_genType_BitLen_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_BitLen_paramsKey]*MoqAddr_genType_BitLen_results
}

// MoqAddr_genType_BitLen_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_BitLen_doFn func()

// MoqAddr_genType_BitLen_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_BitLen_doReturnFn func() int

// MoqAddr_genType_BitLen_results holds the results of the Addr_genType type
type MoqAddr_genType_BitLen_results struct {
	Params  MoqAddr_genType_BitLen_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_BitLen_doFn
		DoReturnFn MoqAddr_genType_BitLen_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_BitLen_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_BitLen_fnRecorder struct {
	Params    MoqAddr_genType_BitLen_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_BitLen_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_BitLen_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_BitLen_anyParams struct {
	Recorder *MoqAddr_genType_BitLen_fnRecorder
}

// MoqAddr_genType_Zone_params holds the params of the Addr_genType type
type MoqAddr_genType_Zone_params struct{}

// MoqAddr_genType_Zone_paramsKey holds the map key params of the Addr_genType
// type
type MoqAddr_genType_Zone_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_Zone_resultsByParams contains the results for a given set of
// parameters for the Addr_genType type
type MoqAddr_genType_Zone_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_Zone_paramsKey]*MoqAddr_genType_Zone_results
}

// MoqAddr_genType_Zone_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_Zone_doFn func()

// MoqAddr_genType_Zone_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_Zone_doReturnFn func() string

// MoqAddr_genType_Zone_results holds the results of the Addr_genType type
type MoqAddr_genType_Zone_results struct {
	Params  MoqAddr_genType_Zone_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Zone_doFn
		DoReturnFn MoqAddr_genType_Zone_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_Zone_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_Zone_fnRecorder struct {
	Params    MoqAddr_genType_Zone_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_Zone_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_Zone_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_Zone_anyParams struct {
	Recorder *MoqAddr_genType_Zone_fnRecorder
}

// MoqAddr_genType_Compare_params holds the params of the Addr_genType type
type MoqAddr_genType_Compare_params struct{ Ip2 netip.Addr }

// MoqAddr_genType_Compare_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_Compare_paramsKey struct {
	Params struct{ Ip2 netip.Addr }
	Hashes struct{ Ip2 hash.Hash }
}

// MoqAddr_genType_Compare_resultsByParams contains the results for a given set
// of parameters for the Addr_genType type
type MoqAddr_genType_Compare_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_Compare_paramsKey]*MoqAddr_genType_Compare_results
}

// MoqAddr_genType_Compare_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_Compare_doFn func(ip2 netip.Addr)

// MoqAddr_genType_Compare_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_Compare_doReturnFn func(ip2 netip.Addr) int

// MoqAddr_genType_Compare_results holds the results of the Addr_genType type
type MoqAddr_genType_Compare_results struct {
	Params  MoqAddr_genType_Compare_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Compare_doFn
		DoReturnFn MoqAddr_genType_Compare_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_Compare_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_Compare_fnRecorder struct {
	Params    MoqAddr_genType_Compare_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_Compare_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_Compare_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_Compare_anyParams struct {
	Recorder *MoqAddr_genType_Compare_fnRecorder
}

// MoqAddr_genType_Less_params holds the params of the Addr_genType type
type MoqAddr_genType_Less_params struct{ Ip2 netip.Addr }

// MoqAddr_genType_Less_paramsKey holds the map key params of the Addr_genType
// type
type MoqAddr_genType_Less_paramsKey struct {
	Params struct{ Ip2 netip.Addr }
	Hashes struct{ Ip2 hash.Hash }
}

// MoqAddr_genType_Less_resultsByParams contains the results for a given set of
// parameters for the Addr_genType type
type MoqAddr_genType_Less_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_Less_paramsKey]*MoqAddr_genType_Less_results
}

// MoqAddr_genType_Less_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_Less_doFn func(ip2 netip.Addr)

// MoqAddr_genType_Less_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_Less_doReturnFn func(ip2 netip.Addr) bool

// MoqAddr_genType_Less_results holds the results of the Addr_genType type
type MoqAddr_genType_Less_results struct {
	Params  MoqAddr_genType_Less_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Less_doFn
		DoReturnFn MoqAddr_genType_Less_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_Less_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_Less_fnRecorder struct {
	Params    MoqAddr_genType_Less_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_Less_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_Less_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_Less_anyParams struct {
	Recorder *MoqAddr_genType_Less_fnRecorder
}

// MoqAddr_genType_Is4_params holds the params of the Addr_genType type
type MoqAddr_genType_Is4_params struct{}

// MoqAddr_genType_Is4_paramsKey holds the map key params of the Addr_genType
// type
type MoqAddr_genType_Is4_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_Is4_resultsByParams contains the results for a given set of
// parameters for the Addr_genType type
type MoqAddr_genType_Is4_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_Is4_paramsKey]*MoqAddr_genType_Is4_results
}

// MoqAddr_genType_Is4_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_Is4_doFn func()

// MoqAddr_genType_Is4_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_Is4_doReturnFn func() bool

// MoqAddr_genType_Is4_results holds the results of the Addr_genType type
type MoqAddr_genType_Is4_results struct {
	Params  MoqAddr_genType_Is4_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Is4_doFn
		DoReturnFn MoqAddr_genType_Is4_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_Is4_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_Is4_fnRecorder struct {
	Params    MoqAddr_genType_Is4_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_Is4_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_Is4_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_Is4_anyParams struct {
	Recorder *MoqAddr_genType_Is4_fnRecorder
}

// MoqAddr_genType_Is4In6_params holds the params of the Addr_genType type
type MoqAddr_genType_Is4In6_params struct{}

// MoqAddr_genType_Is4In6_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_Is4In6_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_Is4In6_resultsByParams contains the results for a given set
// of parameters for the Addr_genType type
type MoqAddr_genType_Is4In6_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_Is4In6_paramsKey]*MoqAddr_genType_Is4In6_results
}

// MoqAddr_genType_Is4In6_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_Is4In6_doFn func()

// MoqAddr_genType_Is4In6_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_Is4In6_doReturnFn func() bool

// MoqAddr_genType_Is4In6_results holds the results of the Addr_genType type
type MoqAddr_genType_Is4In6_results struct {
	Params  MoqAddr_genType_Is4In6_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Is4In6_doFn
		DoReturnFn MoqAddr_genType_Is4In6_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_Is4In6_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_Is4In6_fnRecorder struct {
	Params    MoqAddr_genType_Is4In6_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_Is4In6_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_Is4In6_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_Is4In6_anyParams struct {
	Recorder *MoqAddr_genType_Is4In6_fnRecorder
}

// MoqAddr_genType_Is6_params holds the params of the Addr_genType type
type MoqAddr_genType_Is6_params struct{}

// MoqAddr_genType_Is6_paramsKey holds the map key params of the Addr_genType
// type
type MoqAddr_genType_Is6_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_Is6_resultsByParams contains the results for a given set of
// parameters for the Addr_genType type
type MoqAddr_genType_Is6_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_Is6_paramsKey]*MoqAddr_genType_Is6_results
}

// MoqAddr_genType_Is6_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_Is6_doFn func()

// MoqAddr_genType_Is6_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_Is6_doReturnFn func() bool

// MoqAddr_genType_Is6_results holds the results of the Addr_genType type
type MoqAddr_genType_Is6_results struct {
	Params  MoqAddr_genType_Is6_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Is6_doFn
		DoReturnFn MoqAddr_genType_Is6_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_Is6_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_Is6_fnRecorder struct {
	Params    MoqAddr_genType_Is6_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_Is6_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_Is6_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_Is6_anyParams struct {
	Recorder *MoqAddr_genType_Is6_fnRecorder
}

// MoqAddr_genType_Unmap_params holds the params of the Addr_genType type
type MoqAddr_genType_Unmap_params struct{}

// MoqAddr_genType_Unmap_paramsKey holds the map key params of the Addr_genType
// type
type MoqAddr_genType_Unmap_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_Unmap_resultsByParams contains the results for a given set
// of parameters for the Addr_genType type
type MoqAddr_genType_Unmap_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_Unmap_paramsKey]*MoqAddr_genType_Unmap_results
}

// MoqAddr_genType_Unmap_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_Unmap_doFn func()

// MoqAddr_genType_Unmap_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_Unmap_doReturnFn func() netip.Addr

// MoqAddr_genType_Unmap_results holds the results of the Addr_genType type
type MoqAddr_genType_Unmap_results struct {
	Params  MoqAddr_genType_Unmap_params
	Results []struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Unmap_doFn
		DoReturnFn MoqAddr_genType_Unmap_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_Unmap_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_Unmap_fnRecorder struct {
	Params    MoqAddr_genType_Unmap_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_Unmap_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_Unmap_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_Unmap_anyParams struct {
	Recorder *MoqAddr_genType_Unmap_fnRecorder
}

// MoqAddr_genType_WithZone_params holds the params of the Addr_genType type
type MoqAddr_genType_WithZone_params struct{ Zone string }

// MoqAddr_genType_WithZone_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_WithZone_paramsKey struct {
	Params struct{ Zone string }
	Hashes struct{ Zone hash.Hash }
}

// MoqAddr_genType_WithZone_resultsByParams contains the results for a given
// set of parameters for the Addr_genType type
type MoqAddr_genType_WithZone_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_WithZone_paramsKey]*MoqAddr_genType_WithZone_results
}

// MoqAddr_genType_WithZone_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_WithZone_doFn func(zone string)

// MoqAddr_genType_WithZone_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_WithZone_doReturnFn func(zone string) netip.Addr

// MoqAddr_genType_WithZone_results holds the results of the Addr_genType type
type MoqAddr_genType_WithZone_results struct {
	Params  MoqAddr_genType_WithZone_params
	Results []struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_WithZone_doFn
		DoReturnFn MoqAddr_genType_WithZone_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_WithZone_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_WithZone_fnRecorder struct {
	Params    MoqAddr_genType_WithZone_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_WithZone_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_WithZone_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_WithZone_anyParams struct {
	Recorder *MoqAddr_genType_WithZone_fnRecorder
}

// MoqAddr_genType_IsLinkLocalUnicast_params holds the params of the
// Addr_genType type
type MoqAddr_genType_IsLinkLocalUnicast_params struct{}

// MoqAddr_genType_IsLinkLocalUnicast_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_IsLinkLocalUnicast_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_IsLinkLocalUnicast_resultsByParams contains the results for
// a given set of parameters for the Addr_genType type
type MoqAddr_genType_IsLinkLocalUnicast_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_IsLinkLocalUnicast_paramsKey]*MoqAddr_genType_IsLinkLocalUnicast_results
}

// MoqAddr_genType_IsLinkLocalUnicast_doFn defines the type of function needed
// when calling AndDo for the Addr_genType type
type MoqAddr_genType_IsLinkLocalUnicast_doFn func()

// MoqAddr_genType_IsLinkLocalUnicast_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_IsLinkLocalUnicast_doReturnFn func() bool

// MoqAddr_genType_IsLinkLocalUnicast_results holds the results of the
// Addr_genType type
type MoqAddr_genType_IsLinkLocalUnicast_results struct {
	Params  MoqAddr_genType_IsLinkLocalUnicast_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsLinkLocalUnicast_doFn
		DoReturnFn MoqAddr_genType_IsLinkLocalUnicast_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_IsLinkLocalUnicast_fnRecorder routes recorded function calls
// to the MoqAddr_genType moq
type MoqAddr_genType_IsLinkLocalUnicast_fnRecorder struct {
	Params    MoqAddr_genType_IsLinkLocalUnicast_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_IsLinkLocalUnicast_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_IsLinkLocalUnicast_anyParams isolates the any params
// functions of the Addr_genType type
type MoqAddr_genType_IsLinkLocalUnicast_anyParams struct {
	Recorder *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder
}

// MoqAddr_genType_IsLoopback_params holds the params of the Addr_genType type
type MoqAddr_genType_IsLoopback_params struct{}

// MoqAddr_genType_IsLoopback_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_IsLoopback_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_IsLoopback_resultsByParams contains the results for a given
// set of parameters for the Addr_genType type
type MoqAddr_genType_IsLoopback_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_IsLoopback_paramsKey]*MoqAddr_genType_IsLoopback_results
}

// MoqAddr_genType_IsLoopback_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_IsLoopback_doFn func()

// MoqAddr_genType_IsLoopback_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_IsLoopback_doReturnFn func() bool

// MoqAddr_genType_IsLoopback_results holds the results of the Addr_genType
// type
type MoqAddr_genType_IsLoopback_results struct {
	Params  MoqAddr_genType_IsLoopback_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsLoopback_doFn
		DoReturnFn MoqAddr_genType_IsLoopback_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_IsLoopback_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_IsLoopback_fnRecorder struct {
	Params    MoqAddr_genType_IsLoopback_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_IsLoopback_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_IsLoopback_anyParams isolates the any params functions of
// the Addr_genType type
type MoqAddr_genType_IsLoopback_anyParams struct {
	Recorder *MoqAddr_genType_IsLoopback_fnRecorder
}

// MoqAddr_genType_IsMulticast_params holds the params of the Addr_genType type
type MoqAddr_genType_IsMulticast_params struct{}

// MoqAddr_genType_IsMulticast_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_IsMulticast_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_IsMulticast_resultsByParams contains the results for a given
// set of parameters for the Addr_genType type
type MoqAddr_genType_IsMulticast_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_IsMulticast_paramsKey]*MoqAddr_genType_IsMulticast_results
}

// MoqAddr_genType_IsMulticast_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_IsMulticast_doFn func()

// MoqAddr_genType_IsMulticast_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_IsMulticast_doReturnFn func() bool

// MoqAddr_genType_IsMulticast_results holds the results of the Addr_genType
// type
type MoqAddr_genType_IsMulticast_results struct {
	Params  MoqAddr_genType_IsMulticast_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsMulticast_doFn
		DoReturnFn MoqAddr_genType_IsMulticast_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_IsMulticast_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_IsMulticast_fnRecorder struct {
	Params    MoqAddr_genType_IsMulticast_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_IsMulticast_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_IsMulticast_anyParams isolates the any params functions of
// the Addr_genType type
type MoqAddr_genType_IsMulticast_anyParams struct {
	Recorder *MoqAddr_genType_IsMulticast_fnRecorder
}

// MoqAddr_genType_IsInterfaceLocalMulticast_params holds the params of the
// Addr_genType type
type MoqAddr_genType_IsInterfaceLocalMulticast_params struct{}

// MoqAddr_genType_IsInterfaceLocalMulticast_paramsKey holds the map key params
// of the Addr_genType type
type MoqAddr_genType_IsInterfaceLocalMulticast_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_IsInterfaceLocalMulticast_resultsByParams contains the
// results for a given set of parameters for the Addr_genType type
type MoqAddr_genType_IsInterfaceLocalMulticast_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_IsInterfaceLocalMulticast_paramsKey]*MoqAddr_genType_IsInterfaceLocalMulticast_results
}

// MoqAddr_genType_IsInterfaceLocalMulticast_doFn defines the type of function
// needed when calling AndDo for the Addr_genType type
type MoqAddr_genType_IsInterfaceLocalMulticast_doFn func()

// MoqAddr_genType_IsInterfaceLocalMulticast_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_IsInterfaceLocalMulticast_doReturnFn func() bool

// MoqAddr_genType_IsInterfaceLocalMulticast_results holds the results of the
// Addr_genType type
type MoqAddr_genType_IsInterfaceLocalMulticast_results struct {
	Params  MoqAddr_genType_IsInterfaceLocalMulticast_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsInterfaceLocalMulticast_doFn
		DoReturnFn MoqAddr_genType_IsInterfaceLocalMulticast_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder routes recorded
// function calls to the MoqAddr_genType moq
type MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder struct {
	Params    MoqAddr_genType_IsInterfaceLocalMulticast_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_IsInterfaceLocalMulticast_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_IsInterfaceLocalMulticast_anyParams isolates the any params
// functions of the Addr_genType type
type MoqAddr_genType_IsInterfaceLocalMulticast_anyParams struct {
	Recorder *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder
}

// MoqAddr_genType_IsLinkLocalMulticast_params holds the params of the
// Addr_genType type
type MoqAddr_genType_IsLinkLocalMulticast_params struct{}

// MoqAddr_genType_IsLinkLocalMulticast_paramsKey holds the map key params of
// the Addr_genType type
type MoqAddr_genType_IsLinkLocalMulticast_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_IsLinkLocalMulticast_resultsByParams contains the results
// for a given set of parameters for the Addr_genType type
type MoqAddr_genType_IsLinkLocalMulticast_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_IsLinkLocalMulticast_paramsKey]*MoqAddr_genType_IsLinkLocalMulticast_results
}

// MoqAddr_genType_IsLinkLocalMulticast_doFn defines the type of function
// needed when calling AndDo for the Addr_genType type
type MoqAddr_genType_IsLinkLocalMulticast_doFn func()

// MoqAddr_genType_IsLinkLocalMulticast_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_IsLinkLocalMulticast_doReturnFn func() bool

// MoqAddr_genType_IsLinkLocalMulticast_results holds the results of the
// Addr_genType type
type MoqAddr_genType_IsLinkLocalMulticast_results struct {
	Params  MoqAddr_genType_IsLinkLocalMulticast_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsLinkLocalMulticast_doFn
		DoReturnFn MoqAddr_genType_IsLinkLocalMulticast_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_IsLinkLocalMulticast_fnRecorder routes recorded function
// calls to the MoqAddr_genType moq
type MoqAddr_genType_IsLinkLocalMulticast_fnRecorder struct {
	Params    MoqAddr_genType_IsLinkLocalMulticast_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_IsLinkLocalMulticast_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_IsLinkLocalMulticast_anyParams isolates the any params
// functions of the Addr_genType type
type MoqAddr_genType_IsLinkLocalMulticast_anyParams struct {
	Recorder *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder
}

// MoqAddr_genType_IsGlobalUnicast_params holds the params of the Addr_genType
// type
type MoqAddr_genType_IsGlobalUnicast_params struct{}

// MoqAddr_genType_IsGlobalUnicast_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_IsGlobalUnicast_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_IsGlobalUnicast_resultsByParams contains the results for a
// given set of parameters for the Addr_genType type
type MoqAddr_genType_IsGlobalUnicast_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_IsGlobalUnicast_paramsKey]*MoqAddr_genType_IsGlobalUnicast_results
}

// MoqAddr_genType_IsGlobalUnicast_doFn defines the type of function needed
// when calling AndDo for the Addr_genType type
type MoqAddr_genType_IsGlobalUnicast_doFn func()

// MoqAddr_genType_IsGlobalUnicast_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_IsGlobalUnicast_doReturnFn func() bool

// MoqAddr_genType_IsGlobalUnicast_results holds the results of the
// Addr_genType type
type MoqAddr_genType_IsGlobalUnicast_results struct {
	Params  MoqAddr_genType_IsGlobalUnicast_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsGlobalUnicast_doFn
		DoReturnFn MoqAddr_genType_IsGlobalUnicast_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_IsGlobalUnicast_fnRecorder routes recorded function calls to
// the MoqAddr_genType moq
type MoqAddr_genType_IsGlobalUnicast_fnRecorder struct {
	Params    MoqAddr_genType_IsGlobalUnicast_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_IsGlobalUnicast_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_IsGlobalUnicast_anyParams isolates the any params functions
// of the Addr_genType type
type MoqAddr_genType_IsGlobalUnicast_anyParams struct {
	Recorder *MoqAddr_genType_IsGlobalUnicast_fnRecorder
}

// MoqAddr_genType_IsPrivate_params holds the params of the Addr_genType type
type MoqAddr_genType_IsPrivate_params struct{}

// MoqAddr_genType_IsPrivate_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_IsPrivate_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_IsPrivate_resultsByParams contains the results for a given
// set of parameters for the Addr_genType type
type MoqAddr_genType_IsPrivate_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_IsPrivate_paramsKey]*MoqAddr_genType_IsPrivate_results
}

// MoqAddr_genType_IsPrivate_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_IsPrivate_doFn func()

// MoqAddr_genType_IsPrivate_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_IsPrivate_doReturnFn func() bool

// MoqAddr_genType_IsPrivate_results holds the results of the Addr_genType type
type MoqAddr_genType_IsPrivate_results struct {
	Params  MoqAddr_genType_IsPrivate_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsPrivate_doFn
		DoReturnFn MoqAddr_genType_IsPrivate_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_IsPrivate_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_IsPrivate_fnRecorder struct {
	Params    MoqAddr_genType_IsPrivate_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_IsPrivate_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_IsPrivate_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_IsPrivate_anyParams struct {
	Recorder *MoqAddr_genType_IsPrivate_fnRecorder
}

// MoqAddr_genType_IsUnspecified_params holds the params of the Addr_genType
// type
type MoqAddr_genType_IsUnspecified_params struct{}

// MoqAddr_genType_IsUnspecified_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_IsUnspecified_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_IsUnspecified_resultsByParams contains the results for a
// given set of parameters for the Addr_genType type
type MoqAddr_genType_IsUnspecified_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_IsUnspecified_paramsKey]*MoqAddr_genType_IsUnspecified_results
}

// MoqAddr_genType_IsUnspecified_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_IsUnspecified_doFn func()

// MoqAddr_genType_IsUnspecified_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_IsUnspecified_doReturnFn func() bool

// MoqAddr_genType_IsUnspecified_results holds the results of the Addr_genType
// type
type MoqAddr_genType_IsUnspecified_results struct {
	Params  MoqAddr_genType_IsUnspecified_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsUnspecified_doFn
		DoReturnFn MoqAddr_genType_IsUnspecified_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_IsUnspecified_fnRecorder routes recorded function calls to
// the MoqAddr_genType moq
type MoqAddr_genType_IsUnspecified_fnRecorder struct {
	Params    MoqAddr_genType_IsUnspecified_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_IsUnspecified_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_IsUnspecified_anyParams isolates the any params functions of
// the Addr_genType type
type MoqAddr_genType_IsUnspecified_anyParams struct {
	Recorder *MoqAddr_genType_IsUnspecified_fnRecorder
}

// MoqAddr_genType_Prefix_params holds the params of the Addr_genType type
type MoqAddr_genType_Prefix_params struct{ B int }

// MoqAddr_genType_Prefix_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_Prefix_paramsKey struct {
	Params struct{ B int }
	Hashes struct{ B hash.Hash }
}

// MoqAddr_genType_Prefix_resultsByParams contains the results for a given set
// of parameters for the Addr_genType type
type MoqAddr_genType_Prefix_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_Prefix_paramsKey]*MoqAddr_genType_Prefix_results
}

// MoqAddr_genType_Prefix_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_Prefix_doFn func(b int)

// MoqAddr_genType_Prefix_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_Prefix_doReturnFn func(b int) (netip.Prefix, error)

// MoqAddr_genType_Prefix_results holds the results of the Addr_genType type
type MoqAddr_genType_Prefix_results struct {
	Params  MoqAddr_genType_Prefix_params
	Results []struct {
		Values *struct {
			Result1 netip.Prefix
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Prefix_doFn
		DoReturnFn MoqAddr_genType_Prefix_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_Prefix_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_Prefix_fnRecorder struct {
	Params    MoqAddr_genType_Prefix_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_Prefix_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_Prefix_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_Prefix_anyParams struct {
	Recorder *MoqAddr_genType_Prefix_fnRecorder
}

// MoqAddr_genType_As16_params holds the params of the Addr_genType type
type MoqAddr_genType_As16_params struct{}

// MoqAddr_genType_As16_paramsKey holds the map key params of the Addr_genType
// type
type MoqAddr_genType_As16_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_As16_resultsByParams contains the results for a given set of
// parameters for the Addr_genType type
type MoqAddr_genType_As16_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_As16_paramsKey]*MoqAddr_genType_As16_results
}

// MoqAddr_genType_As16_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_As16_doFn func()

// MoqAddr_genType_As16_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_As16_doReturnFn func() (a16 [16]byte)

// MoqAddr_genType_As16_results holds the results of the Addr_genType type
type MoqAddr_genType_As16_results struct {
	Params  MoqAddr_genType_As16_params
	Results []struct {
		Values     *struct{ A16 [16]byte }
		Sequence   uint32
		DoFn       MoqAddr_genType_As16_doFn
		DoReturnFn MoqAddr_genType_As16_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_As16_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_As16_fnRecorder struct {
	Params    MoqAddr_genType_As16_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_As16_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_As16_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_As16_anyParams struct {
	Recorder *MoqAddr_genType_As16_fnRecorder
}

// MoqAddr_genType_As4_params holds the params of the Addr_genType type
type MoqAddr_genType_As4_params struct{}

// MoqAddr_genType_As4_paramsKey holds the map key params of the Addr_genType
// type
type MoqAddr_genType_As4_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_As4_resultsByParams contains the results for a given set of
// parameters for the Addr_genType type
type MoqAddr_genType_As4_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_As4_paramsKey]*MoqAddr_genType_As4_results
}

// MoqAddr_genType_As4_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_As4_doFn func()

// MoqAddr_genType_As4_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_As4_doReturnFn func() (a4 [4]byte)

// MoqAddr_genType_As4_results holds the results of the Addr_genType type
type MoqAddr_genType_As4_results struct {
	Params  MoqAddr_genType_As4_params
	Results []struct {
		Values     *struct{ A4 [4]byte }
		Sequence   uint32
		DoFn       MoqAddr_genType_As4_doFn
		DoReturnFn MoqAddr_genType_As4_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_As4_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_As4_fnRecorder struct {
	Params    MoqAddr_genType_As4_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_As4_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_As4_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_As4_anyParams struct {
	Recorder *MoqAddr_genType_As4_fnRecorder
}

// MoqAddr_genType_AsSlice_params holds the params of the Addr_genType type
type MoqAddr_genType_AsSlice_params struct{}

// MoqAddr_genType_AsSlice_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_AsSlice_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_AsSlice_resultsByParams contains the results for a given set
// of parameters for the Addr_genType type
type MoqAddr_genType_AsSlice_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_AsSlice_paramsKey]*MoqAddr_genType_AsSlice_results
}

// MoqAddr_genType_AsSlice_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_AsSlice_doFn func()

// MoqAddr_genType_AsSlice_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_AsSlice_doReturnFn func() []byte

// MoqAddr_genType_AsSlice_results holds the results of the Addr_genType type
type MoqAddr_genType_AsSlice_results struct {
	Params  MoqAddr_genType_AsSlice_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_AsSlice_doFn
		DoReturnFn MoqAddr_genType_AsSlice_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_AsSlice_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_AsSlice_fnRecorder struct {
	Params    MoqAddr_genType_AsSlice_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_AsSlice_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_AsSlice_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_AsSlice_anyParams struct {
	Recorder *MoqAddr_genType_AsSlice_fnRecorder
}

// MoqAddr_genType_Next_params holds the params of the Addr_genType type
type MoqAddr_genType_Next_params struct{}

// MoqAddr_genType_Next_paramsKey holds the map key params of the Addr_genType
// type
type MoqAddr_genType_Next_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_Next_resultsByParams contains the results for a given set of
// parameters for the Addr_genType type
type MoqAddr_genType_Next_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_Next_paramsKey]*MoqAddr_genType_Next_results
}

// MoqAddr_genType_Next_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_Next_doFn func()

// MoqAddr_genType_Next_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_Next_doReturnFn func() netip.Addr

// MoqAddr_genType_Next_results holds the results of the Addr_genType type
type MoqAddr_genType_Next_results struct {
	Params  MoqAddr_genType_Next_params
	Results []struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Next_doFn
		DoReturnFn MoqAddr_genType_Next_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_Next_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_Next_fnRecorder struct {
	Params    MoqAddr_genType_Next_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_Next_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_Next_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_Next_anyParams struct {
	Recorder *MoqAddr_genType_Next_fnRecorder
}

// MoqAddr_genType_Prev_params holds the params of the Addr_genType type
type MoqAddr_genType_Prev_params struct{}

// MoqAddr_genType_Prev_paramsKey holds the map key params of the Addr_genType
// type
type MoqAddr_genType_Prev_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_Prev_resultsByParams contains the results for a given set of
// parameters for the Addr_genType type
type MoqAddr_genType_Prev_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_Prev_paramsKey]*MoqAddr_genType_Prev_results
}

// MoqAddr_genType_Prev_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_Prev_doFn func()

// MoqAddr_genType_Prev_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_Prev_doReturnFn func() netip.Addr

// MoqAddr_genType_Prev_results holds the results of the Addr_genType type
type MoqAddr_genType_Prev_results struct {
	Params  MoqAddr_genType_Prev_params
	Results []struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Prev_doFn
		DoReturnFn MoqAddr_genType_Prev_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_Prev_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_Prev_fnRecorder struct {
	Params    MoqAddr_genType_Prev_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_Prev_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_Prev_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_Prev_anyParams struct {
	Recorder *MoqAddr_genType_Prev_fnRecorder
}

// MoqAddr_genType_String_params holds the params of the Addr_genType type
type MoqAddr_genType_String_params struct{}

// MoqAddr_genType_String_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_String_resultsByParams contains the results for a given set
// of parameters for the Addr_genType type
type MoqAddr_genType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_String_paramsKey]*MoqAddr_genType_String_results
}

// MoqAddr_genType_String_doFn defines the type of function needed when calling
// AndDo for the Addr_genType type
type MoqAddr_genType_String_doFn func()

// MoqAddr_genType_String_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_String_doReturnFn func() string

// MoqAddr_genType_String_results holds the results of the Addr_genType type
type MoqAddr_genType_String_results struct {
	Params  MoqAddr_genType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_String_doFn
		DoReturnFn MoqAddr_genType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_String_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_String_fnRecorder struct {
	Params    MoqAddr_genType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_String_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_String_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_String_anyParams struct {
	Recorder *MoqAddr_genType_String_fnRecorder
}

// MoqAddr_genType_AppendTo_params holds the params of the Addr_genType type
type MoqAddr_genType_AppendTo_params struct{ B []byte }

// MoqAddr_genType_AppendTo_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_AppendTo_paramsKey struct {
	Params struct{}
	Hashes struct{ B hash.Hash }
}

// MoqAddr_genType_AppendTo_resultsByParams contains the results for a given
// set of parameters for the Addr_genType type
type MoqAddr_genType_AppendTo_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_AppendTo_paramsKey]*MoqAddr_genType_AppendTo_results
}

// MoqAddr_genType_AppendTo_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_AppendTo_doFn func(b []byte)

// MoqAddr_genType_AppendTo_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_AppendTo_doReturnFn func(b []byte) []byte

// MoqAddr_genType_AppendTo_results holds the results of the Addr_genType type
type MoqAddr_genType_AppendTo_results struct {
	Params  MoqAddr_genType_AppendTo_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_AppendTo_doFn
		DoReturnFn MoqAddr_genType_AppendTo_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_AppendTo_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_AppendTo_fnRecorder struct {
	Params    MoqAddr_genType_AppendTo_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_AppendTo_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_AppendTo_anyParams isolates the any params functions of the
// Addr_genType type
type MoqAddr_genType_AppendTo_anyParams struct {
	Recorder *MoqAddr_genType_AppendTo_fnRecorder
}

// MoqAddr_genType_StringExpanded_params holds the params of the Addr_genType
// type
type MoqAddr_genType_StringExpanded_params struct{}

// MoqAddr_genType_StringExpanded_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_StringExpanded_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_StringExpanded_resultsByParams contains the results for a
// given set of parameters for the Addr_genType type
type MoqAddr_genType_StringExpanded_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_StringExpanded_paramsKey]*MoqAddr_genType_StringExpanded_results
}

// MoqAddr_genType_StringExpanded_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_StringExpanded_doFn func()

// MoqAddr_genType_StringExpanded_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_StringExpanded_doReturnFn func() string

// MoqAddr_genType_StringExpanded_results holds the results of the Addr_genType
// type
type MoqAddr_genType_StringExpanded_results struct {
	Params  MoqAddr_genType_StringExpanded_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_StringExpanded_doFn
		DoReturnFn MoqAddr_genType_StringExpanded_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_StringExpanded_fnRecorder routes recorded function calls to
// the MoqAddr_genType moq
type MoqAddr_genType_StringExpanded_fnRecorder struct {
	Params    MoqAddr_genType_StringExpanded_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_StringExpanded_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_StringExpanded_anyParams isolates the any params functions
// of the Addr_genType type
type MoqAddr_genType_StringExpanded_anyParams struct {
	Recorder *MoqAddr_genType_StringExpanded_fnRecorder
}

// MoqAddr_genType_MarshalText_params holds the params of the Addr_genType type
type MoqAddr_genType_MarshalText_params struct{}

// MoqAddr_genType_MarshalText_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_MarshalText_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_MarshalText_resultsByParams contains the results for a given
// set of parameters for the Addr_genType type
type MoqAddr_genType_MarshalText_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_MarshalText_paramsKey]*MoqAddr_genType_MarshalText_results
}

// MoqAddr_genType_MarshalText_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_MarshalText_doFn func()

// MoqAddr_genType_MarshalText_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_MarshalText_doReturnFn func() ([]byte, error)

// MoqAddr_genType_MarshalText_results holds the results of the Addr_genType
// type
type MoqAddr_genType_MarshalText_results struct {
	Params  MoqAddr_genType_MarshalText_params
	Results []struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_MarshalText_doFn
		DoReturnFn MoqAddr_genType_MarshalText_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_MarshalText_fnRecorder routes recorded function calls to the
// MoqAddr_genType moq
type MoqAddr_genType_MarshalText_fnRecorder struct {
	Params    MoqAddr_genType_MarshalText_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_MarshalText_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_MarshalText_anyParams isolates the any params functions of
// the Addr_genType type
type MoqAddr_genType_MarshalText_anyParams struct {
	Recorder *MoqAddr_genType_MarshalText_fnRecorder
}

// MoqAddr_genType_MarshalBinary_params holds the params of the Addr_genType
// type
type MoqAddr_genType_MarshalBinary_params struct{}

// MoqAddr_genType_MarshalBinary_paramsKey holds the map key params of the
// Addr_genType type
type MoqAddr_genType_MarshalBinary_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqAddr_genType_MarshalBinary_resultsByParams contains the results for a
// given set of parameters for the Addr_genType type
type MoqAddr_genType_MarshalBinary_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqAddr_genType_MarshalBinary_paramsKey]*MoqAddr_genType_MarshalBinary_results
}

// MoqAddr_genType_MarshalBinary_doFn defines the type of function needed when
// calling AndDo for the Addr_genType type
type MoqAddr_genType_MarshalBinary_doFn func()

// MoqAddr_genType_MarshalBinary_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Addr_genType type
type MoqAddr_genType_MarshalBinary_doReturnFn func() ([]byte, error)

// MoqAddr_genType_MarshalBinary_results holds the results of the Addr_genType
// type
type MoqAddr_genType_MarshalBinary_results struct {
	Params  MoqAddr_genType_MarshalBinary_params
	Results []struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_MarshalBinary_doFn
		DoReturnFn MoqAddr_genType_MarshalBinary_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqAddr_genType_MarshalBinary_fnRecorder routes recorded function calls to
// the MoqAddr_genType moq
type MoqAddr_genType_MarshalBinary_fnRecorder struct {
	Params    MoqAddr_genType_MarshalBinary_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqAddr_genType_MarshalBinary_results
	Moq       *MoqAddr_genType
}

// MoqAddr_genType_MarshalBinary_anyParams isolates the any params functions of
// the Addr_genType type
type MoqAddr_genType_MarshalBinary_anyParams struct {
	Recorder *MoqAddr_genType_MarshalBinary_fnRecorder
}

// NewMoqAddr_genType creates a new moq of the Addr_genType type
func NewMoqAddr_genType(scene *moq.Scene, config *moq.Config) *MoqAddr_genType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqAddr_genType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqAddr_genType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				IsValid struct{}
				BitLen  struct{}
				Zone    struct{}
				Compare struct {
					Ip2 moq.ParamIndexing
				}
				Less struct {
					Ip2 moq.ParamIndexing
				}
				Is4      struct{}
				Is4In6   struct{}
				Is6      struct{}
				Unmap    struct{}
				WithZone struct {
					Zone moq.ParamIndexing
				}
				IsLinkLocalUnicast        struct{}
				IsLoopback                struct{}
				IsMulticast               struct{}
				IsInterfaceLocalMulticast struct{}
				IsLinkLocalMulticast      struct{}
				IsGlobalUnicast           struct{}
				IsPrivate                 struct{}
				IsUnspecified             struct{}
				Prefix                    struct {
					B moq.ParamIndexing
				}
				As16     struct{}
				As4      struct{}
				AsSlice  struct{}
				Next     struct{}
				Prev     struct{}
				String   struct{}
				AppendTo struct {
					B moq.ParamIndexing
				}
				StringExpanded struct{}
				MarshalText    struct{}
				MarshalBinary  struct{}
			}
		}{ParameterIndexing: struct {
			IsValid struct{}
			BitLen  struct{}
			Zone    struct{}
			Compare struct {
				Ip2 moq.ParamIndexing
			}
			Less struct {
				Ip2 moq.ParamIndexing
			}
			Is4      struct{}
			Is4In6   struct{}
			Is6      struct{}
			Unmap    struct{}
			WithZone struct {
				Zone moq.ParamIndexing
			}
			IsLinkLocalUnicast        struct{}
			IsLoopback                struct{}
			IsMulticast               struct{}
			IsInterfaceLocalMulticast struct{}
			IsLinkLocalMulticast      struct{}
			IsGlobalUnicast           struct{}
			IsPrivate                 struct{}
			IsUnspecified             struct{}
			Prefix                    struct {
				B moq.ParamIndexing
			}
			As16     struct{}
			As4      struct{}
			AsSlice  struct{}
			Next     struct{}
			Prev     struct{}
			String   struct{}
			AppendTo struct {
				B moq.ParamIndexing
			}
			StringExpanded struct{}
			MarshalText    struct{}
			MarshalBinary  struct{}
		}{
			IsValid: struct{}{},
			BitLen:  struct{}{},
			Zone:    struct{}{},
			Compare: struct {
				Ip2 moq.ParamIndexing
			}{
				Ip2: moq.ParamIndexByHash,
			},
			Less: struct {
				Ip2 moq.ParamIndexing
			}{
				Ip2: moq.ParamIndexByHash,
			},
			Is4:    struct{}{},
			Is4In6: struct{}{},
			Is6:    struct{}{},
			Unmap:  struct{}{},
			WithZone: struct {
				Zone moq.ParamIndexing
			}{
				Zone: moq.ParamIndexByValue,
			},
			IsLinkLocalUnicast:        struct{}{},
			IsLoopback:                struct{}{},
			IsMulticast:               struct{}{},
			IsInterfaceLocalMulticast: struct{}{},
			IsLinkLocalMulticast:      struct{}{},
			IsGlobalUnicast:           struct{}{},
			IsPrivate:                 struct{}{},
			IsUnspecified:             struct{}{},
			Prefix: struct {
				B moq.ParamIndexing
			}{
				B: moq.ParamIndexByValue,
			},
			As16:    struct{}{},
			As4:     struct{}{},
			AsSlice: struct{}{},
			Next:    struct{}{},
			Prev:    struct{}{},
			String:  struct{}{},
			AppendTo: struct {
				B moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
			},
			StringExpanded: struct{}{},
			MarshalText:    struct{}{},
			MarshalBinary:  struct{}{},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Addr_genType type
func (m *MoqAddr_genType) Mock() *MoqAddr_genType_mock { return m.Moq }

func (m *MoqAddr_genType_mock) IsValid() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_IsValid_params{}
	var results *MoqAddr_genType_IsValid_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsValid {
		paramsKey := m.Moq.ParamsKey_IsValid(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsValid(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsValid(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsValid(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) BitLen() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_BitLen_params{}
	var results *MoqAddr_genType_BitLen_results
	for _, resultsByParams := range m.Moq.ResultsByParams_BitLen {
		paramsKey := m.Moq.ParamsKey_BitLen(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_BitLen(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_BitLen(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_BitLen(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) Zone() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_Zone_params{}
	var results *MoqAddr_genType_Zone_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Zone {
		paramsKey := m.Moq.ParamsKey_Zone(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Zone(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Zone(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Zone(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) Compare(ip2 netip.Addr) (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_Compare_params{
		Ip2: ip2,
	}
	var results *MoqAddr_genType_Compare_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Compare {
		paramsKey := m.Moq.ParamsKey_Compare(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Compare(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Compare(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Compare(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ip2)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(ip2)
	}
	return
}

func (m *MoqAddr_genType_mock) Less(ip2 netip.Addr) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_Less_params{
		Ip2: ip2,
	}
	var results *MoqAddr_genType_Less_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Less {
		paramsKey := m.Moq.ParamsKey_Less(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Less(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Less(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Less(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ip2)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(ip2)
	}
	return
}

func (m *MoqAddr_genType_mock) Is4() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_Is4_params{}
	var results *MoqAddr_genType_Is4_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Is4 {
		paramsKey := m.Moq.ParamsKey_Is4(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Is4(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Is4(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Is4(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) Is4In6() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_Is4In6_params{}
	var results *MoqAddr_genType_Is4In6_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Is4In6 {
		paramsKey := m.Moq.ParamsKey_Is4In6(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Is4In6(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Is4In6(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Is4In6(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) Is6() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_Is6_params{}
	var results *MoqAddr_genType_Is6_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Is6 {
		paramsKey := m.Moq.ParamsKey_Is6(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Is6(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Is6(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Is6(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) Unmap() (result1 netip.Addr) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_Unmap_params{}
	var results *MoqAddr_genType_Unmap_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Unmap {
		paramsKey := m.Moq.ParamsKey_Unmap(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Unmap(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Unmap(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Unmap(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) WithZone(zone string) (result1 netip.Addr) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_WithZone_params{
		Zone: zone,
	}
	var results *MoqAddr_genType_WithZone_results
	for _, resultsByParams := range m.Moq.ResultsByParams_WithZone {
		paramsKey := m.Moq.ParamsKey_WithZone(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_WithZone(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_WithZone(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_WithZone(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(zone)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(zone)
	}
	return
}

func (m *MoqAddr_genType_mock) IsLinkLocalUnicast() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_IsLinkLocalUnicast_params{}
	var results *MoqAddr_genType_IsLinkLocalUnicast_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsLinkLocalUnicast {
		paramsKey := m.Moq.ParamsKey_IsLinkLocalUnicast(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsLinkLocalUnicast(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsLinkLocalUnicast(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsLinkLocalUnicast(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) IsLoopback() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_IsLoopback_params{}
	var results *MoqAddr_genType_IsLoopback_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsLoopback {
		paramsKey := m.Moq.ParamsKey_IsLoopback(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsLoopback(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsLoopback(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsLoopback(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) IsMulticast() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_IsMulticast_params{}
	var results *MoqAddr_genType_IsMulticast_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsMulticast {
		paramsKey := m.Moq.ParamsKey_IsMulticast(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsMulticast(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsMulticast(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsMulticast(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) IsInterfaceLocalMulticast() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_IsInterfaceLocalMulticast_params{}
	var results *MoqAddr_genType_IsInterfaceLocalMulticast_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsInterfaceLocalMulticast {
		paramsKey := m.Moq.ParamsKey_IsInterfaceLocalMulticast(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsInterfaceLocalMulticast(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsInterfaceLocalMulticast(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsInterfaceLocalMulticast(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) IsLinkLocalMulticast() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_IsLinkLocalMulticast_params{}
	var results *MoqAddr_genType_IsLinkLocalMulticast_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsLinkLocalMulticast {
		paramsKey := m.Moq.ParamsKey_IsLinkLocalMulticast(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsLinkLocalMulticast(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsLinkLocalMulticast(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsLinkLocalMulticast(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) IsGlobalUnicast() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_IsGlobalUnicast_params{}
	var results *MoqAddr_genType_IsGlobalUnicast_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsGlobalUnicast {
		paramsKey := m.Moq.ParamsKey_IsGlobalUnicast(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsGlobalUnicast(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsGlobalUnicast(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsGlobalUnicast(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) IsPrivate() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_IsPrivate_params{}
	var results *MoqAddr_genType_IsPrivate_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsPrivate {
		paramsKey := m.Moq.ParamsKey_IsPrivate(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsPrivate(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsPrivate(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsPrivate(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) IsUnspecified() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_IsUnspecified_params{}
	var results *MoqAddr_genType_IsUnspecified_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsUnspecified {
		paramsKey := m.Moq.ParamsKey_IsUnspecified(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsUnspecified(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsUnspecified(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsUnspecified(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) Prefix(b int) (result1 netip.Prefix, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_Prefix_params{
		B: b,
	}
	var results *MoqAddr_genType_Prefix_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Prefix {
		paramsKey := m.Moq.ParamsKey_Prefix(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Prefix(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Prefix(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Prefix(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(b)
	}
	return
}

func (m *MoqAddr_genType_mock) As16() (a16 [16]byte) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_As16_params{}
	var results *MoqAddr_genType_As16_results
	for _, resultsByParams := range m.Moq.ResultsByParams_As16 {
		paramsKey := m.Moq.ParamsKey_As16(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_As16(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_As16(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_As16(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		a16 = result.Values.A16
	}
	if result.DoReturnFn != nil {
		a16 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) As4() (a4 [4]byte) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_As4_params{}
	var results *MoqAddr_genType_As4_results
	for _, resultsByParams := range m.Moq.ResultsByParams_As4 {
		paramsKey := m.Moq.ParamsKey_As4(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_As4(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_As4(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_As4(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		a4 = result.Values.A4
	}
	if result.DoReturnFn != nil {
		a4 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) AsSlice() (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_AsSlice_params{}
	var results *MoqAddr_genType_AsSlice_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AsSlice {
		paramsKey := m.Moq.ParamsKey_AsSlice(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AsSlice(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AsSlice(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AsSlice(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) Next() (result1 netip.Addr) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_Next_params{}
	var results *MoqAddr_genType_Next_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Next {
		paramsKey := m.Moq.ParamsKey_Next(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Next(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Next(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Next(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) Prev() (result1 netip.Addr) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_Prev_params{}
	var results *MoqAddr_genType_Prev_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Prev {
		paramsKey := m.Moq.ParamsKey_Prev(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Prev(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Prev(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Prev(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_String_params{}
	var results *MoqAddr_genType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) AppendTo(b []byte) (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_AppendTo_params{
		B: b,
	}
	var results *MoqAddr_genType_AppendTo_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AppendTo {
		paramsKey := m.Moq.ParamsKey_AppendTo(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AppendTo(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AppendTo(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AppendTo(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(b)
	}
	return
}

func (m *MoqAddr_genType_mock) StringExpanded() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_StringExpanded_params{}
	var results *MoqAddr_genType_StringExpanded_results
	for _, resultsByParams := range m.Moq.ResultsByParams_StringExpanded {
		paramsKey := m.Moq.ParamsKey_StringExpanded(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_StringExpanded(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_StringExpanded(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_StringExpanded(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) MarshalText() (result1 []byte, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_MarshalText_params{}
	var results *MoqAddr_genType_MarshalText_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MarshalText {
		paramsKey := m.Moq.ParamsKey_MarshalText(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MarshalText(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MarshalText(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MarshalText(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqAddr_genType_mock) MarshalBinary() (result1 []byte, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqAddr_genType_MarshalBinary_params{}
	var results *MoqAddr_genType_MarshalBinary_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MarshalBinary {
		paramsKey := m.Moq.ParamsKey_MarshalBinary(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MarshalBinary(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MarshalBinary(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MarshalBinary(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

// OnCall returns the recorder implementation of the Addr_genType type
func (m *MoqAddr_genType) OnCall() *MoqAddr_genType_recorder {
	return &MoqAddr_genType_recorder{
		Moq: m,
	}
}

func (m *MoqAddr_genType_recorder) IsValid() *MoqAddr_genType_IsValid_fnRecorder {
	return &MoqAddr_genType_IsValid_fnRecorder{
		Params:   MoqAddr_genType_IsValid_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_IsValid_fnRecorder) Any() *MoqAddr_genType_IsValid_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsValid(r.Params))
		return nil
	}
	return &MoqAddr_genType_IsValid_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_IsValid_fnRecorder) Seq() *MoqAddr_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsValid(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_IsValid_fnRecorder) NoSeq() *MoqAddr_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsValid(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_IsValid_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsValid_doFn
		DoReturnFn MoqAddr_genType_IsValid_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_IsValid_fnRecorder) AndDo(fn MoqAddr_genType_IsValid_doFn) *MoqAddr_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_IsValid_fnRecorder) DoReturnResults(fn MoqAddr_genType_IsValid_doReturnFn) *MoqAddr_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsValid_doFn
		DoReturnFn MoqAddr_genType_IsValid_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_IsValid_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_IsValid_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsValid {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_IsValid_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_IsValid_paramsKey]*MoqAddr_genType_IsValid_results{},
		}
		r.Moq.ResultsByParams_IsValid = append(r.Moq.ResultsByParams_IsValid, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsValid) {
			copy(r.Moq.ResultsByParams_IsValid[insertAt+1:], r.Moq.ResultsByParams_IsValid[insertAt:0])
			r.Moq.ResultsByParams_IsValid[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsValid(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_IsValid_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_IsValid_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_IsValid_doFn
				DoReturnFn MoqAddr_genType_IsValid_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_IsValid(params MoqAddr_genType_IsValid_params) string {
	return fmt.Sprintf("IsValid()")
}

func (m *MoqAddr_genType) ParamsKey_IsValid(params MoqAddr_genType_IsValid_params, anyParams uint64) MoqAddr_genType_IsValid_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_IsValid_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) BitLen() *MoqAddr_genType_BitLen_fnRecorder {
	return &MoqAddr_genType_BitLen_fnRecorder{
		Params:   MoqAddr_genType_BitLen_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_BitLen_fnRecorder) Any() *MoqAddr_genType_BitLen_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_BitLen(r.Params))
		return nil
	}
	return &MoqAddr_genType_BitLen_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_BitLen_fnRecorder) Seq() *MoqAddr_genType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_BitLen(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_BitLen_fnRecorder) NoSeq() *MoqAddr_genType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_BitLen(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_BitLen_fnRecorder) ReturnResults(result1 int) *MoqAddr_genType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_BitLen_doFn
		DoReturnFn MoqAddr_genType_BitLen_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_BitLen_fnRecorder) AndDo(fn MoqAddr_genType_BitLen_doFn) *MoqAddr_genType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_BitLen_fnRecorder) DoReturnResults(fn MoqAddr_genType_BitLen_doReturnFn) *MoqAddr_genType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_BitLen_doFn
		DoReturnFn MoqAddr_genType_BitLen_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_BitLen_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_BitLen_resultsByParams
	for n, res := range r.Moq.ResultsByParams_BitLen {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_BitLen_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_BitLen_paramsKey]*MoqAddr_genType_BitLen_results{},
		}
		r.Moq.ResultsByParams_BitLen = append(r.Moq.ResultsByParams_BitLen, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_BitLen) {
			copy(r.Moq.ResultsByParams_BitLen[insertAt+1:], r.Moq.ResultsByParams_BitLen[insertAt:0])
			r.Moq.ResultsByParams_BitLen[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_BitLen(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_BitLen_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_BitLen_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_BitLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_BitLen_doFn
				DoReturnFn MoqAddr_genType_BitLen_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_BitLen(params MoqAddr_genType_BitLen_params) string {
	return fmt.Sprintf("BitLen()")
}

func (m *MoqAddr_genType) ParamsKey_BitLen(params MoqAddr_genType_BitLen_params, anyParams uint64) MoqAddr_genType_BitLen_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_BitLen_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) Zone() *MoqAddr_genType_Zone_fnRecorder {
	return &MoqAddr_genType_Zone_fnRecorder{
		Params:   MoqAddr_genType_Zone_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_Zone_fnRecorder) Any() *MoqAddr_genType_Zone_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Zone(r.Params))
		return nil
	}
	return &MoqAddr_genType_Zone_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_Zone_fnRecorder) Seq() *MoqAddr_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Zone(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_Zone_fnRecorder) NoSeq() *MoqAddr_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Zone(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_Zone_fnRecorder) ReturnResults(result1 string) *MoqAddr_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Zone_doFn
		DoReturnFn MoqAddr_genType_Zone_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_Zone_fnRecorder) AndDo(fn MoqAddr_genType_Zone_doFn) *MoqAddr_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_Zone_fnRecorder) DoReturnResults(fn MoqAddr_genType_Zone_doReturnFn) *MoqAddr_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Zone_doFn
		DoReturnFn MoqAddr_genType_Zone_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_Zone_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_Zone_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Zone {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_Zone_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_Zone_paramsKey]*MoqAddr_genType_Zone_results{},
		}
		r.Moq.ResultsByParams_Zone = append(r.Moq.ResultsByParams_Zone, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Zone) {
			copy(r.Moq.ResultsByParams_Zone[insertAt+1:], r.Moq.ResultsByParams_Zone[insertAt:0])
			r.Moq.ResultsByParams_Zone[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Zone(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_Zone_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_Zone_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_Zone_doFn
				DoReturnFn MoqAddr_genType_Zone_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_Zone(params MoqAddr_genType_Zone_params) string {
	return fmt.Sprintf("Zone()")
}

func (m *MoqAddr_genType) ParamsKey_Zone(params MoqAddr_genType_Zone_params, anyParams uint64) MoqAddr_genType_Zone_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_Zone_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) Compare(ip2 netip.Addr) *MoqAddr_genType_Compare_fnRecorder {
	return &MoqAddr_genType_Compare_fnRecorder{
		Params: MoqAddr_genType_Compare_params{
			Ip2: ip2,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_Compare_fnRecorder) Any() *MoqAddr_genType_Compare_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Compare(r.Params))
		return nil
	}
	return &MoqAddr_genType_Compare_anyParams{Recorder: r}
}

func (a *MoqAddr_genType_Compare_anyParams) Ip2() *MoqAddr_genType_Compare_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqAddr_genType_Compare_fnRecorder) Seq() *MoqAddr_genType_Compare_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Compare(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_Compare_fnRecorder) NoSeq() *MoqAddr_genType_Compare_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Compare(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_Compare_fnRecorder) ReturnResults(result1 int) *MoqAddr_genType_Compare_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Compare_doFn
		DoReturnFn MoqAddr_genType_Compare_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_Compare_fnRecorder) AndDo(fn MoqAddr_genType_Compare_doFn) *MoqAddr_genType_Compare_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_Compare_fnRecorder) DoReturnResults(fn MoqAddr_genType_Compare_doReturnFn) *MoqAddr_genType_Compare_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Compare_doFn
		DoReturnFn MoqAddr_genType_Compare_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_Compare_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_Compare_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Compare {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_Compare_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_Compare_paramsKey]*MoqAddr_genType_Compare_results{},
		}
		r.Moq.ResultsByParams_Compare = append(r.Moq.ResultsByParams_Compare, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Compare) {
			copy(r.Moq.ResultsByParams_Compare[insertAt+1:], r.Moq.ResultsByParams_Compare[insertAt:0])
			r.Moq.ResultsByParams_Compare[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Compare(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_Compare_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_Compare_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_Compare_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_Compare_doFn
				DoReturnFn MoqAddr_genType_Compare_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_Compare(params MoqAddr_genType_Compare_params) string {
	return fmt.Sprintf("Compare(%#v)", params.Ip2)
}

func (m *MoqAddr_genType) ParamsKey_Compare(params MoqAddr_genType_Compare_params, anyParams uint64) MoqAddr_genType_Compare_paramsKey {
	m.Scene.T.Helper()
	var ip2Used netip.Addr
	var ip2UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Compare.Ip2 == moq.ParamIndexByValue {
			ip2Used = params.Ip2
		} else {
			ip2UsedHash = hash.DeepHash(params.Ip2)
		}
	}
	return MoqAddr_genType_Compare_paramsKey{
		Params: struct{ Ip2 netip.Addr }{
			Ip2: ip2Used,
		},
		Hashes: struct{ Ip2 hash.Hash }{
			Ip2: ip2UsedHash,
		},
	}
}

func (m *MoqAddr_genType_recorder) Less(ip2 netip.Addr) *MoqAddr_genType_Less_fnRecorder {
	return &MoqAddr_genType_Less_fnRecorder{
		Params: MoqAddr_genType_Less_params{
			Ip2: ip2,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_Less_fnRecorder) Any() *MoqAddr_genType_Less_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Less(r.Params))
		return nil
	}
	return &MoqAddr_genType_Less_anyParams{Recorder: r}
}

func (a *MoqAddr_genType_Less_anyParams) Ip2() *MoqAddr_genType_Less_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqAddr_genType_Less_fnRecorder) Seq() *MoqAddr_genType_Less_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Less(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_Less_fnRecorder) NoSeq() *MoqAddr_genType_Less_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Less(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_Less_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_Less_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Less_doFn
		DoReturnFn MoqAddr_genType_Less_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_Less_fnRecorder) AndDo(fn MoqAddr_genType_Less_doFn) *MoqAddr_genType_Less_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_Less_fnRecorder) DoReturnResults(fn MoqAddr_genType_Less_doReturnFn) *MoqAddr_genType_Less_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Less_doFn
		DoReturnFn MoqAddr_genType_Less_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_Less_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_Less_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Less {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_Less_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_Less_paramsKey]*MoqAddr_genType_Less_results{},
		}
		r.Moq.ResultsByParams_Less = append(r.Moq.ResultsByParams_Less, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Less) {
			copy(r.Moq.ResultsByParams_Less[insertAt+1:], r.Moq.ResultsByParams_Less[insertAt:0])
			r.Moq.ResultsByParams_Less[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Less(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_Less_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_Less_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_Less_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_Less_doFn
				DoReturnFn MoqAddr_genType_Less_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_Less(params MoqAddr_genType_Less_params) string {
	return fmt.Sprintf("Less(%#v)", params.Ip2)
}

func (m *MoqAddr_genType) ParamsKey_Less(params MoqAddr_genType_Less_params, anyParams uint64) MoqAddr_genType_Less_paramsKey {
	m.Scene.T.Helper()
	var ip2Used netip.Addr
	var ip2UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Less.Ip2 == moq.ParamIndexByValue {
			ip2Used = params.Ip2
		} else {
			ip2UsedHash = hash.DeepHash(params.Ip2)
		}
	}
	return MoqAddr_genType_Less_paramsKey{
		Params: struct{ Ip2 netip.Addr }{
			Ip2: ip2Used,
		},
		Hashes: struct{ Ip2 hash.Hash }{
			Ip2: ip2UsedHash,
		},
	}
}

func (m *MoqAddr_genType_recorder) Is4() *MoqAddr_genType_Is4_fnRecorder {
	return &MoqAddr_genType_Is4_fnRecorder{
		Params:   MoqAddr_genType_Is4_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_Is4_fnRecorder) Any() *MoqAddr_genType_Is4_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Is4(r.Params))
		return nil
	}
	return &MoqAddr_genType_Is4_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_Is4_fnRecorder) Seq() *MoqAddr_genType_Is4_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Is4(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_Is4_fnRecorder) NoSeq() *MoqAddr_genType_Is4_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Is4(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_Is4_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_Is4_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Is4_doFn
		DoReturnFn MoqAddr_genType_Is4_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_Is4_fnRecorder) AndDo(fn MoqAddr_genType_Is4_doFn) *MoqAddr_genType_Is4_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_Is4_fnRecorder) DoReturnResults(fn MoqAddr_genType_Is4_doReturnFn) *MoqAddr_genType_Is4_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Is4_doFn
		DoReturnFn MoqAddr_genType_Is4_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_Is4_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_Is4_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Is4 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_Is4_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_Is4_paramsKey]*MoqAddr_genType_Is4_results{},
		}
		r.Moq.ResultsByParams_Is4 = append(r.Moq.ResultsByParams_Is4, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Is4) {
			copy(r.Moq.ResultsByParams_Is4[insertAt+1:], r.Moq.ResultsByParams_Is4[insertAt:0])
			r.Moq.ResultsByParams_Is4[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Is4(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_Is4_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_Is4_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_Is4_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_Is4_doFn
				DoReturnFn MoqAddr_genType_Is4_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_Is4(params MoqAddr_genType_Is4_params) string {
	return fmt.Sprintf("Is4()")
}

func (m *MoqAddr_genType) ParamsKey_Is4(params MoqAddr_genType_Is4_params, anyParams uint64) MoqAddr_genType_Is4_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_Is4_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) Is4In6() *MoqAddr_genType_Is4In6_fnRecorder {
	return &MoqAddr_genType_Is4In6_fnRecorder{
		Params:   MoqAddr_genType_Is4In6_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_Is4In6_fnRecorder) Any() *MoqAddr_genType_Is4In6_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Is4In6(r.Params))
		return nil
	}
	return &MoqAddr_genType_Is4In6_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_Is4In6_fnRecorder) Seq() *MoqAddr_genType_Is4In6_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Is4In6(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_Is4In6_fnRecorder) NoSeq() *MoqAddr_genType_Is4In6_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Is4In6(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_Is4In6_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_Is4In6_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Is4In6_doFn
		DoReturnFn MoqAddr_genType_Is4In6_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_Is4In6_fnRecorder) AndDo(fn MoqAddr_genType_Is4In6_doFn) *MoqAddr_genType_Is4In6_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_Is4In6_fnRecorder) DoReturnResults(fn MoqAddr_genType_Is4In6_doReturnFn) *MoqAddr_genType_Is4In6_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Is4In6_doFn
		DoReturnFn MoqAddr_genType_Is4In6_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_Is4In6_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_Is4In6_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Is4In6 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_Is4In6_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_Is4In6_paramsKey]*MoqAddr_genType_Is4In6_results{},
		}
		r.Moq.ResultsByParams_Is4In6 = append(r.Moq.ResultsByParams_Is4In6, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Is4In6) {
			copy(r.Moq.ResultsByParams_Is4In6[insertAt+1:], r.Moq.ResultsByParams_Is4In6[insertAt:0])
			r.Moq.ResultsByParams_Is4In6[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Is4In6(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_Is4In6_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_Is4In6_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_Is4In6_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_Is4In6_doFn
				DoReturnFn MoqAddr_genType_Is4In6_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_Is4In6(params MoqAddr_genType_Is4In6_params) string {
	return fmt.Sprintf("Is4In6()")
}

func (m *MoqAddr_genType) ParamsKey_Is4In6(params MoqAddr_genType_Is4In6_params, anyParams uint64) MoqAddr_genType_Is4In6_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_Is4In6_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) Is6() *MoqAddr_genType_Is6_fnRecorder {
	return &MoqAddr_genType_Is6_fnRecorder{
		Params:   MoqAddr_genType_Is6_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_Is6_fnRecorder) Any() *MoqAddr_genType_Is6_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Is6(r.Params))
		return nil
	}
	return &MoqAddr_genType_Is6_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_Is6_fnRecorder) Seq() *MoqAddr_genType_Is6_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Is6(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_Is6_fnRecorder) NoSeq() *MoqAddr_genType_Is6_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Is6(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_Is6_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_Is6_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Is6_doFn
		DoReturnFn MoqAddr_genType_Is6_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_Is6_fnRecorder) AndDo(fn MoqAddr_genType_Is6_doFn) *MoqAddr_genType_Is6_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_Is6_fnRecorder) DoReturnResults(fn MoqAddr_genType_Is6_doReturnFn) *MoqAddr_genType_Is6_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Is6_doFn
		DoReturnFn MoqAddr_genType_Is6_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_Is6_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_Is6_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Is6 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_Is6_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_Is6_paramsKey]*MoqAddr_genType_Is6_results{},
		}
		r.Moq.ResultsByParams_Is6 = append(r.Moq.ResultsByParams_Is6, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Is6) {
			copy(r.Moq.ResultsByParams_Is6[insertAt+1:], r.Moq.ResultsByParams_Is6[insertAt:0])
			r.Moq.ResultsByParams_Is6[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Is6(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_Is6_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_Is6_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_Is6_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_Is6_doFn
				DoReturnFn MoqAddr_genType_Is6_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_Is6(params MoqAddr_genType_Is6_params) string {
	return fmt.Sprintf("Is6()")
}

func (m *MoqAddr_genType) ParamsKey_Is6(params MoqAddr_genType_Is6_params, anyParams uint64) MoqAddr_genType_Is6_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_Is6_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) Unmap() *MoqAddr_genType_Unmap_fnRecorder {
	return &MoqAddr_genType_Unmap_fnRecorder{
		Params:   MoqAddr_genType_Unmap_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_Unmap_fnRecorder) Any() *MoqAddr_genType_Unmap_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Unmap(r.Params))
		return nil
	}
	return &MoqAddr_genType_Unmap_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_Unmap_fnRecorder) Seq() *MoqAddr_genType_Unmap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Unmap(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_Unmap_fnRecorder) NoSeq() *MoqAddr_genType_Unmap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Unmap(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_Unmap_fnRecorder) ReturnResults(result1 netip.Addr) *MoqAddr_genType_Unmap_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Unmap_doFn
		DoReturnFn MoqAddr_genType_Unmap_doReturnFn
	}{
		Values: &struct {
			Result1 netip.Addr
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_Unmap_fnRecorder) AndDo(fn MoqAddr_genType_Unmap_doFn) *MoqAddr_genType_Unmap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_Unmap_fnRecorder) DoReturnResults(fn MoqAddr_genType_Unmap_doReturnFn) *MoqAddr_genType_Unmap_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Unmap_doFn
		DoReturnFn MoqAddr_genType_Unmap_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_Unmap_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_Unmap_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Unmap {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_Unmap_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_Unmap_paramsKey]*MoqAddr_genType_Unmap_results{},
		}
		r.Moq.ResultsByParams_Unmap = append(r.Moq.ResultsByParams_Unmap, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Unmap) {
			copy(r.Moq.ResultsByParams_Unmap[insertAt+1:], r.Moq.ResultsByParams_Unmap[insertAt:0])
			r.Moq.ResultsByParams_Unmap[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Unmap(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_Unmap_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_Unmap_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_Unmap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 netip.Addr
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_Unmap_doFn
				DoReturnFn MoqAddr_genType_Unmap_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_Unmap(params MoqAddr_genType_Unmap_params) string {
	return fmt.Sprintf("Unmap()")
}

func (m *MoqAddr_genType) ParamsKey_Unmap(params MoqAddr_genType_Unmap_params, anyParams uint64) MoqAddr_genType_Unmap_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_Unmap_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) WithZone(zone string) *MoqAddr_genType_WithZone_fnRecorder {
	return &MoqAddr_genType_WithZone_fnRecorder{
		Params: MoqAddr_genType_WithZone_params{
			Zone: zone,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_WithZone_fnRecorder) Any() *MoqAddr_genType_WithZone_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WithZone(r.Params))
		return nil
	}
	return &MoqAddr_genType_WithZone_anyParams{Recorder: r}
}

func (a *MoqAddr_genType_WithZone_anyParams) Zone() *MoqAddr_genType_WithZone_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqAddr_genType_WithZone_fnRecorder) Seq() *MoqAddr_genType_WithZone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WithZone(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_WithZone_fnRecorder) NoSeq() *MoqAddr_genType_WithZone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_WithZone(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_WithZone_fnRecorder) ReturnResults(result1 netip.Addr) *MoqAddr_genType_WithZone_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_WithZone_doFn
		DoReturnFn MoqAddr_genType_WithZone_doReturnFn
	}{
		Values: &struct {
			Result1 netip.Addr
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_WithZone_fnRecorder) AndDo(fn MoqAddr_genType_WithZone_doFn) *MoqAddr_genType_WithZone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_WithZone_fnRecorder) DoReturnResults(fn MoqAddr_genType_WithZone_doReturnFn) *MoqAddr_genType_WithZone_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_WithZone_doFn
		DoReturnFn MoqAddr_genType_WithZone_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_WithZone_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_WithZone_resultsByParams
	for n, res := range r.Moq.ResultsByParams_WithZone {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_WithZone_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_WithZone_paramsKey]*MoqAddr_genType_WithZone_results{},
		}
		r.Moq.ResultsByParams_WithZone = append(r.Moq.ResultsByParams_WithZone, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_WithZone) {
			copy(r.Moq.ResultsByParams_WithZone[insertAt+1:], r.Moq.ResultsByParams_WithZone[insertAt:0])
			r.Moq.ResultsByParams_WithZone[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_WithZone(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_WithZone_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_WithZone_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_WithZone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 netip.Addr
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_WithZone_doFn
				DoReturnFn MoqAddr_genType_WithZone_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_WithZone(params MoqAddr_genType_WithZone_params) string {
	return fmt.Sprintf("WithZone(%#v)", params.Zone)
}

func (m *MoqAddr_genType) ParamsKey_WithZone(params MoqAddr_genType_WithZone_params, anyParams uint64) MoqAddr_genType_WithZone_paramsKey {
	m.Scene.T.Helper()
	var zoneUsed string
	var zoneUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.WithZone.Zone == moq.ParamIndexByValue {
			zoneUsed = params.Zone
		} else {
			zoneUsedHash = hash.DeepHash(params.Zone)
		}
	}
	return MoqAddr_genType_WithZone_paramsKey{
		Params: struct{ Zone string }{
			Zone: zoneUsed,
		},
		Hashes: struct{ Zone hash.Hash }{
			Zone: zoneUsedHash,
		},
	}
}

func (m *MoqAddr_genType_recorder) IsLinkLocalUnicast() *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder {
	return &MoqAddr_genType_IsLinkLocalUnicast_fnRecorder{
		Params:   MoqAddr_genType_IsLinkLocalUnicast_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder) Any() *MoqAddr_genType_IsLinkLocalUnicast_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsLinkLocalUnicast(r.Params))
		return nil
	}
	return &MoqAddr_genType_IsLinkLocalUnicast_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder) Seq() *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsLinkLocalUnicast(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder) NoSeq() *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsLinkLocalUnicast(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsLinkLocalUnicast_doFn
		DoReturnFn MoqAddr_genType_IsLinkLocalUnicast_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder) AndDo(fn MoqAddr_genType_IsLinkLocalUnicast_doFn) *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder) DoReturnResults(fn MoqAddr_genType_IsLinkLocalUnicast_doReturnFn) *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsLinkLocalUnicast_doFn
		DoReturnFn MoqAddr_genType_IsLinkLocalUnicast_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_IsLinkLocalUnicast_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsLinkLocalUnicast {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_IsLinkLocalUnicast_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_IsLinkLocalUnicast_paramsKey]*MoqAddr_genType_IsLinkLocalUnicast_results{},
		}
		r.Moq.ResultsByParams_IsLinkLocalUnicast = append(r.Moq.ResultsByParams_IsLinkLocalUnicast, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsLinkLocalUnicast) {
			copy(r.Moq.ResultsByParams_IsLinkLocalUnicast[insertAt+1:], r.Moq.ResultsByParams_IsLinkLocalUnicast[insertAt:0])
			r.Moq.ResultsByParams_IsLinkLocalUnicast[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsLinkLocalUnicast(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_IsLinkLocalUnicast_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_IsLinkLocalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_IsLinkLocalUnicast_doFn
				DoReturnFn MoqAddr_genType_IsLinkLocalUnicast_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_IsLinkLocalUnicast(params MoqAddr_genType_IsLinkLocalUnicast_params) string {
	return fmt.Sprintf("IsLinkLocalUnicast()")
}

func (m *MoqAddr_genType) ParamsKey_IsLinkLocalUnicast(params MoqAddr_genType_IsLinkLocalUnicast_params, anyParams uint64) MoqAddr_genType_IsLinkLocalUnicast_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_IsLinkLocalUnicast_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) IsLoopback() *MoqAddr_genType_IsLoopback_fnRecorder {
	return &MoqAddr_genType_IsLoopback_fnRecorder{
		Params:   MoqAddr_genType_IsLoopback_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_IsLoopback_fnRecorder) Any() *MoqAddr_genType_IsLoopback_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsLoopback(r.Params))
		return nil
	}
	return &MoqAddr_genType_IsLoopback_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_IsLoopback_fnRecorder) Seq() *MoqAddr_genType_IsLoopback_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsLoopback(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_IsLoopback_fnRecorder) NoSeq() *MoqAddr_genType_IsLoopback_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsLoopback(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_IsLoopback_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_IsLoopback_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsLoopback_doFn
		DoReturnFn MoqAddr_genType_IsLoopback_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_IsLoopback_fnRecorder) AndDo(fn MoqAddr_genType_IsLoopback_doFn) *MoqAddr_genType_IsLoopback_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_IsLoopback_fnRecorder) DoReturnResults(fn MoqAddr_genType_IsLoopback_doReturnFn) *MoqAddr_genType_IsLoopback_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsLoopback_doFn
		DoReturnFn MoqAddr_genType_IsLoopback_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_IsLoopback_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_IsLoopback_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsLoopback {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_IsLoopback_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_IsLoopback_paramsKey]*MoqAddr_genType_IsLoopback_results{},
		}
		r.Moq.ResultsByParams_IsLoopback = append(r.Moq.ResultsByParams_IsLoopback, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsLoopback) {
			copy(r.Moq.ResultsByParams_IsLoopback[insertAt+1:], r.Moq.ResultsByParams_IsLoopback[insertAt:0])
			r.Moq.ResultsByParams_IsLoopback[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsLoopback(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_IsLoopback_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_IsLoopback_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_IsLoopback_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_IsLoopback_doFn
				DoReturnFn MoqAddr_genType_IsLoopback_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_IsLoopback(params MoqAddr_genType_IsLoopback_params) string {
	return fmt.Sprintf("IsLoopback()")
}

func (m *MoqAddr_genType) ParamsKey_IsLoopback(params MoqAddr_genType_IsLoopback_params, anyParams uint64) MoqAddr_genType_IsLoopback_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_IsLoopback_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) IsMulticast() *MoqAddr_genType_IsMulticast_fnRecorder {
	return &MoqAddr_genType_IsMulticast_fnRecorder{
		Params:   MoqAddr_genType_IsMulticast_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_IsMulticast_fnRecorder) Any() *MoqAddr_genType_IsMulticast_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsMulticast(r.Params))
		return nil
	}
	return &MoqAddr_genType_IsMulticast_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_IsMulticast_fnRecorder) Seq() *MoqAddr_genType_IsMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsMulticast(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_IsMulticast_fnRecorder) NoSeq() *MoqAddr_genType_IsMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsMulticast(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_IsMulticast_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_IsMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsMulticast_doFn
		DoReturnFn MoqAddr_genType_IsMulticast_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_IsMulticast_fnRecorder) AndDo(fn MoqAddr_genType_IsMulticast_doFn) *MoqAddr_genType_IsMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_IsMulticast_fnRecorder) DoReturnResults(fn MoqAddr_genType_IsMulticast_doReturnFn) *MoqAddr_genType_IsMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsMulticast_doFn
		DoReturnFn MoqAddr_genType_IsMulticast_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_IsMulticast_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_IsMulticast_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsMulticast {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_IsMulticast_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_IsMulticast_paramsKey]*MoqAddr_genType_IsMulticast_results{},
		}
		r.Moq.ResultsByParams_IsMulticast = append(r.Moq.ResultsByParams_IsMulticast, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsMulticast) {
			copy(r.Moq.ResultsByParams_IsMulticast[insertAt+1:], r.Moq.ResultsByParams_IsMulticast[insertAt:0])
			r.Moq.ResultsByParams_IsMulticast[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsMulticast(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_IsMulticast_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_IsMulticast_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_IsMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_IsMulticast_doFn
				DoReturnFn MoqAddr_genType_IsMulticast_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_IsMulticast(params MoqAddr_genType_IsMulticast_params) string {
	return fmt.Sprintf("IsMulticast()")
}

func (m *MoqAddr_genType) ParamsKey_IsMulticast(params MoqAddr_genType_IsMulticast_params, anyParams uint64) MoqAddr_genType_IsMulticast_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_IsMulticast_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) IsInterfaceLocalMulticast() *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder {
	return &MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder{
		Params:   MoqAddr_genType_IsInterfaceLocalMulticast_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder) Any() *MoqAddr_genType_IsInterfaceLocalMulticast_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInterfaceLocalMulticast(r.Params))
		return nil
	}
	return &MoqAddr_genType_IsInterfaceLocalMulticast_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder) Seq() *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInterfaceLocalMulticast(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder) NoSeq() *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsInterfaceLocalMulticast(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsInterfaceLocalMulticast_doFn
		DoReturnFn MoqAddr_genType_IsInterfaceLocalMulticast_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder) AndDo(fn MoqAddr_genType_IsInterfaceLocalMulticast_doFn) *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder) DoReturnResults(fn MoqAddr_genType_IsInterfaceLocalMulticast_doReturnFn) *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsInterfaceLocalMulticast_doFn
		DoReturnFn MoqAddr_genType_IsInterfaceLocalMulticast_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_IsInterfaceLocalMulticast_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsInterfaceLocalMulticast {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_IsInterfaceLocalMulticast_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_IsInterfaceLocalMulticast_paramsKey]*MoqAddr_genType_IsInterfaceLocalMulticast_results{},
		}
		r.Moq.ResultsByParams_IsInterfaceLocalMulticast = append(r.Moq.ResultsByParams_IsInterfaceLocalMulticast, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsInterfaceLocalMulticast) {
			copy(r.Moq.ResultsByParams_IsInterfaceLocalMulticast[insertAt+1:], r.Moq.ResultsByParams_IsInterfaceLocalMulticast[insertAt:0])
			r.Moq.ResultsByParams_IsInterfaceLocalMulticast[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsInterfaceLocalMulticast(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_IsInterfaceLocalMulticast_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_IsInterfaceLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_IsInterfaceLocalMulticast_doFn
				DoReturnFn MoqAddr_genType_IsInterfaceLocalMulticast_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_IsInterfaceLocalMulticast(params MoqAddr_genType_IsInterfaceLocalMulticast_params) string {
	return fmt.Sprintf("IsInterfaceLocalMulticast()")
}

func (m *MoqAddr_genType) ParamsKey_IsInterfaceLocalMulticast(params MoqAddr_genType_IsInterfaceLocalMulticast_params, anyParams uint64) MoqAddr_genType_IsInterfaceLocalMulticast_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_IsInterfaceLocalMulticast_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) IsLinkLocalMulticast() *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder {
	return &MoqAddr_genType_IsLinkLocalMulticast_fnRecorder{
		Params:   MoqAddr_genType_IsLinkLocalMulticast_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder) Any() *MoqAddr_genType_IsLinkLocalMulticast_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsLinkLocalMulticast(r.Params))
		return nil
	}
	return &MoqAddr_genType_IsLinkLocalMulticast_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder) Seq() *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsLinkLocalMulticast(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder) NoSeq() *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsLinkLocalMulticast(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsLinkLocalMulticast_doFn
		DoReturnFn MoqAddr_genType_IsLinkLocalMulticast_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder) AndDo(fn MoqAddr_genType_IsLinkLocalMulticast_doFn) *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder) DoReturnResults(fn MoqAddr_genType_IsLinkLocalMulticast_doReturnFn) *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsLinkLocalMulticast_doFn
		DoReturnFn MoqAddr_genType_IsLinkLocalMulticast_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_IsLinkLocalMulticast_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsLinkLocalMulticast {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_IsLinkLocalMulticast_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_IsLinkLocalMulticast_paramsKey]*MoqAddr_genType_IsLinkLocalMulticast_results{},
		}
		r.Moq.ResultsByParams_IsLinkLocalMulticast = append(r.Moq.ResultsByParams_IsLinkLocalMulticast, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsLinkLocalMulticast) {
			copy(r.Moq.ResultsByParams_IsLinkLocalMulticast[insertAt+1:], r.Moq.ResultsByParams_IsLinkLocalMulticast[insertAt:0])
			r.Moq.ResultsByParams_IsLinkLocalMulticast[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsLinkLocalMulticast(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_IsLinkLocalMulticast_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_IsLinkLocalMulticast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_IsLinkLocalMulticast_doFn
				DoReturnFn MoqAddr_genType_IsLinkLocalMulticast_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_IsLinkLocalMulticast(params MoqAddr_genType_IsLinkLocalMulticast_params) string {
	return fmt.Sprintf("IsLinkLocalMulticast()")
}

func (m *MoqAddr_genType) ParamsKey_IsLinkLocalMulticast(params MoqAddr_genType_IsLinkLocalMulticast_params, anyParams uint64) MoqAddr_genType_IsLinkLocalMulticast_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_IsLinkLocalMulticast_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) IsGlobalUnicast() *MoqAddr_genType_IsGlobalUnicast_fnRecorder {
	return &MoqAddr_genType_IsGlobalUnicast_fnRecorder{
		Params:   MoqAddr_genType_IsGlobalUnicast_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_IsGlobalUnicast_fnRecorder) Any() *MoqAddr_genType_IsGlobalUnicast_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsGlobalUnicast(r.Params))
		return nil
	}
	return &MoqAddr_genType_IsGlobalUnicast_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_IsGlobalUnicast_fnRecorder) Seq() *MoqAddr_genType_IsGlobalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsGlobalUnicast(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_IsGlobalUnicast_fnRecorder) NoSeq() *MoqAddr_genType_IsGlobalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsGlobalUnicast(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_IsGlobalUnicast_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_IsGlobalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsGlobalUnicast_doFn
		DoReturnFn MoqAddr_genType_IsGlobalUnicast_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_IsGlobalUnicast_fnRecorder) AndDo(fn MoqAddr_genType_IsGlobalUnicast_doFn) *MoqAddr_genType_IsGlobalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_IsGlobalUnicast_fnRecorder) DoReturnResults(fn MoqAddr_genType_IsGlobalUnicast_doReturnFn) *MoqAddr_genType_IsGlobalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsGlobalUnicast_doFn
		DoReturnFn MoqAddr_genType_IsGlobalUnicast_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_IsGlobalUnicast_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_IsGlobalUnicast_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsGlobalUnicast {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_IsGlobalUnicast_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_IsGlobalUnicast_paramsKey]*MoqAddr_genType_IsGlobalUnicast_results{},
		}
		r.Moq.ResultsByParams_IsGlobalUnicast = append(r.Moq.ResultsByParams_IsGlobalUnicast, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsGlobalUnicast) {
			copy(r.Moq.ResultsByParams_IsGlobalUnicast[insertAt+1:], r.Moq.ResultsByParams_IsGlobalUnicast[insertAt:0])
			r.Moq.ResultsByParams_IsGlobalUnicast[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsGlobalUnicast(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_IsGlobalUnicast_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_IsGlobalUnicast_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_IsGlobalUnicast_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_IsGlobalUnicast_doFn
				DoReturnFn MoqAddr_genType_IsGlobalUnicast_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_IsGlobalUnicast(params MoqAddr_genType_IsGlobalUnicast_params) string {
	return fmt.Sprintf("IsGlobalUnicast()")
}

func (m *MoqAddr_genType) ParamsKey_IsGlobalUnicast(params MoqAddr_genType_IsGlobalUnicast_params, anyParams uint64) MoqAddr_genType_IsGlobalUnicast_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_IsGlobalUnicast_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) IsPrivate() *MoqAddr_genType_IsPrivate_fnRecorder {
	return &MoqAddr_genType_IsPrivate_fnRecorder{
		Params:   MoqAddr_genType_IsPrivate_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_IsPrivate_fnRecorder) Any() *MoqAddr_genType_IsPrivate_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsPrivate(r.Params))
		return nil
	}
	return &MoqAddr_genType_IsPrivate_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_IsPrivate_fnRecorder) Seq() *MoqAddr_genType_IsPrivate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsPrivate(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_IsPrivate_fnRecorder) NoSeq() *MoqAddr_genType_IsPrivate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsPrivate(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_IsPrivate_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_IsPrivate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsPrivate_doFn
		DoReturnFn MoqAddr_genType_IsPrivate_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_IsPrivate_fnRecorder) AndDo(fn MoqAddr_genType_IsPrivate_doFn) *MoqAddr_genType_IsPrivate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_IsPrivate_fnRecorder) DoReturnResults(fn MoqAddr_genType_IsPrivate_doReturnFn) *MoqAddr_genType_IsPrivate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsPrivate_doFn
		DoReturnFn MoqAddr_genType_IsPrivate_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_IsPrivate_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_IsPrivate_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsPrivate {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_IsPrivate_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_IsPrivate_paramsKey]*MoqAddr_genType_IsPrivate_results{},
		}
		r.Moq.ResultsByParams_IsPrivate = append(r.Moq.ResultsByParams_IsPrivate, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsPrivate) {
			copy(r.Moq.ResultsByParams_IsPrivate[insertAt+1:], r.Moq.ResultsByParams_IsPrivate[insertAt:0])
			r.Moq.ResultsByParams_IsPrivate[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsPrivate(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_IsPrivate_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_IsPrivate_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_IsPrivate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_IsPrivate_doFn
				DoReturnFn MoqAddr_genType_IsPrivate_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_IsPrivate(params MoqAddr_genType_IsPrivate_params) string {
	return fmt.Sprintf("IsPrivate()")
}

func (m *MoqAddr_genType) ParamsKey_IsPrivate(params MoqAddr_genType_IsPrivate_params, anyParams uint64) MoqAddr_genType_IsPrivate_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_IsPrivate_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) IsUnspecified() *MoqAddr_genType_IsUnspecified_fnRecorder {
	return &MoqAddr_genType_IsUnspecified_fnRecorder{
		Params:   MoqAddr_genType_IsUnspecified_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_IsUnspecified_fnRecorder) Any() *MoqAddr_genType_IsUnspecified_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsUnspecified(r.Params))
		return nil
	}
	return &MoqAddr_genType_IsUnspecified_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_IsUnspecified_fnRecorder) Seq() *MoqAddr_genType_IsUnspecified_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsUnspecified(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_IsUnspecified_fnRecorder) NoSeq() *MoqAddr_genType_IsUnspecified_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsUnspecified(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_IsUnspecified_fnRecorder) ReturnResults(result1 bool) *MoqAddr_genType_IsUnspecified_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsUnspecified_doFn
		DoReturnFn MoqAddr_genType_IsUnspecified_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_IsUnspecified_fnRecorder) AndDo(fn MoqAddr_genType_IsUnspecified_doFn) *MoqAddr_genType_IsUnspecified_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_IsUnspecified_fnRecorder) DoReturnResults(fn MoqAddr_genType_IsUnspecified_doReturnFn) *MoqAddr_genType_IsUnspecified_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_IsUnspecified_doFn
		DoReturnFn MoqAddr_genType_IsUnspecified_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_IsUnspecified_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_IsUnspecified_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsUnspecified {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_IsUnspecified_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_IsUnspecified_paramsKey]*MoqAddr_genType_IsUnspecified_results{},
		}
		r.Moq.ResultsByParams_IsUnspecified = append(r.Moq.ResultsByParams_IsUnspecified, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsUnspecified) {
			copy(r.Moq.ResultsByParams_IsUnspecified[insertAt+1:], r.Moq.ResultsByParams_IsUnspecified[insertAt:0])
			r.Moq.ResultsByParams_IsUnspecified[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsUnspecified(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_IsUnspecified_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_IsUnspecified_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_IsUnspecified_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_IsUnspecified_doFn
				DoReturnFn MoqAddr_genType_IsUnspecified_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_IsUnspecified(params MoqAddr_genType_IsUnspecified_params) string {
	return fmt.Sprintf("IsUnspecified()")
}

func (m *MoqAddr_genType) ParamsKey_IsUnspecified(params MoqAddr_genType_IsUnspecified_params, anyParams uint64) MoqAddr_genType_IsUnspecified_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_IsUnspecified_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) Prefix(b int) *MoqAddr_genType_Prefix_fnRecorder {
	return &MoqAddr_genType_Prefix_fnRecorder{
		Params: MoqAddr_genType_Prefix_params{
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_Prefix_fnRecorder) Any() *MoqAddr_genType_Prefix_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prefix(r.Params))
		return nil
	}
	return &MoqAddr_genType_Prefix_anyParams{Recorder: r}
}

func (a *MoqAddr_genType_Prefix_anyParams) B() *MoqAddr_genType_Prefix_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqAddr_genType_Prefix_fnRecorder) Seq() *MoqAddr_genType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prefix(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_Prefix_fnRecorder) NoSeq() *MoqAddr_genType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prefix(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_Prefix_fnRecorder) ReturnResults(result1 netip.Prefix, result2 error) *MoqAddr_genType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 netip.Prefix
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Prefix_doFn
		DoReturnFn MoqAddr_genType_Prefix_doReturnFn
	}{
		Values: &struct {
			Result1 netip.Prefix
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_Prefix_fnRecorder) AndDo(fn MoqAddr_genType_Prefix_doFn) *MoqAddr_genType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_Prefix_fnRecorder) DoReturnResults(fn MoqAddr_genType_Prefix_doReturnFn) *MoqAddr_genType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 netip.Prefix
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Prefix_doFn
		DoReturnFn MoqAddr_genType_Prefix_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_Prefix_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_Prefix_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Prefix {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_Prefix_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_Prefix_paramsKey]*MoqAddr_genType_Prefix_results{},
		}
		r.Moq.ResultsByParams_Prefix = append(r.Moq.ResultsByParams_Prefix, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Prefix) {
			copy(r.Moq.ResultsByParams_Prefix[insertAt+1:], r.Moq.ResultsByParams_Prefix[insertAt:0])
			r.Moq.ResultsByParams_Prefix[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Prefix(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_Prefix_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_Prefix_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_Prefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 netip.Prefix
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_Prefix_doFn
				DoReturnFn MoqAddr_genType_Prefix_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_Prefix(params MoqAddr_genType_Prefix_params) string {
	return fmt.Sprintf("Prefix(%#v)", params.B)
}

func (m *MoqAddr_genType) ParamsKey_Prefix(params MoqAddr_genType_Prefix_params, anyParams uint64) MoqAddr_genType_Prefix_paramsKey {
	m.Scene.T.Helper()
	var bUsed int
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Prefix.B == moq.ParamIndexByValue {
			bUsed = params.B
		} else {
			bUsedHash = hash.DeepHash(params.B)
		}
	}
	return MoqAddr_genType_Prefix_paramsKey{
		Params: struct{ B int }{
			B: bUsed,
		},
		Hashes: struct{ B hash.Hash }{
			B: bUsedHash,
		},
	}
}

func (m *MoqAddr_genType_recorder) As16() *MoqAddr_genType_As16_fnRecorder {
	return &MoqAddr_genType_As16_fnRecorder{
		Params:   MoqAddr_genType_As16_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_As16_fnRecorder) Any() *MoqAddr_genType_As16_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_As16(r.Params))
		return nil
	}
	return &MoqAddr_genType_As16_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_As16_fnRecorder) Seq() *MoqAddr_genType_As16_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_As16(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_As16_fnRecorder) NoSeq() *MoqAddr_genType_As16_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_As16(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_As16_fnRecorder) ReturnResults(a16 [16]byte) *MoqAddr_genType_As16_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ A16 [16]byte }
		Sequence   uint32
		DoFn       MoqAddr_genType_As16_doFn
		DoReturnFn MoqAddr_genType_As16_doReturnFn
	}{
		Values: &struct{ A16 [16]byte }{
			A16: a16,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_As16_fnRecorder) AndDo(fn MoqAddr_genType_As16_doFn) *MoqAddr_genType_As16_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_As16_fnRecorder) DoReturnResults(fn MoqAddr_genType_As16_doReturnFn) *MoqAddr_genType_As16_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ A16 [16]byte }
		Sequence   uint32
		DoFn       MoqAddr_genType_As16_doFn
		DoReturnFn MoqAddr_genType_As16_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_As16_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_As16_resultsByParams
	for n, res := range r.Moq.ResultsByParams_As16 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_As16_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_As16_paramsKey]*MoqAddr_genType_As16_results{},
		}
		r.Moq.ResultsByParams_As16 = append(r.Moq.ResultsByParams_As16, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_As16) {
			copy(r.Moq.ResultsByParams_As16[insertAt+1:], r.Moq.ResultsByParams_As16[insertAt:0])
			r.Moq.ResultsByParams_As16[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_As16(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_As16_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_As16_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_As16_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ A16 [16]byte }
				Sequence   uint32
				DoFn       MoqAddr_genType_As16_doFn
				DoReturnFn MoqAddr_genType_As16_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_As16(params MoqAddr_genType_As16_params) string {
	return fmt.Sprintf("As16()")
}

func (m *MoqAddr_genType) ParamsKey_As16(params MoqAddr_genType_As16_params, anyParams uint64) MoqAddr_genType_As16_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_As16_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) As4() *MoqAddr_genType_As4_fnRecorder {
	return &MoqAddr_genType_As4_fnRecorder{
		Params:   MoqAddr_genType_As4_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_As4_fnRecorder) Any() *MoqAddr_genType_As4_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_As4(r.Params))
		return nil
	}
	return &MoqAddr_genType_As4_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_As4_fnRecorder) Seq() *MoqAddr_genType_As4_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_As4(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_As4_fnRecorder) NoSeq() *MoqAddr_genType_As4_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_As4(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_As4_fnRecorder) ReturnResults(a4 [4]byte) *MoqAddr_genType_As4_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ A4 [4]byte }
		Sequence   uint32
		DoFn       MoqAddr_genType_As4_doFn
		DoReturnFn MoqAddr_genType_As4_doReturnFn
	}{
		Values: &struct{ A4 [4]byte }{
			A4: a4,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_As4_fnRecorder) AndDo(fn MoqAddr_genType_As4_doFn) *MoqAddr_genType_As4_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_As4_fnRecorder) DoReturnResults(fn MoqAddr_genType_As4_doReturnFn) *MoqAddr_genType_As4_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ A4 [4]byte }
		Sequence   uint32
		DoFn       MoqAddr_genType_As4_doFn
		DoReturnFn MoqAddr_genType_As4_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_As4_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_As4_resultsByParams
	for n, res := range r.Moq.ResultsByParams_As4 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_As4_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_As4_paramsKey]*MoqAddr_genType_As4_results{},
		}
		r.Moq.ResultsByParams_As4 = append(r.Moq.ResultsByParams_As4, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_As4) {
			copy(r.Moq.ResultsByParams_As4[insertAt+1:], r.Moq.ResultsByParams_As4[insertAt:0])
			r.Moq.ResultsByParams_As4[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_As4(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_As4_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_As4_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_As4_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ A4 [4]byte }
				Sequence   uint32
				DoFn       MoqAddr_genType_As4_doFn
				DoReturnFn MoqAddr_genType_As4_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_As4(params MoqAddr_genType_As4_params) string {
	return fmt.Sprintf("As4()")
}

func (m *MoqAddr_genType) ParamsKey_As4(params MoqAddr_genType_As4_params, anyParams uint64) MoqAddr_genType_As4_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_As4_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) AsSlice() *MoqAddr_genType_AsSlice_fnRecorder {
	return &MoqAddr_genType_AsSlice_fnRecorder{
		Params:   MoqAddr_genType_AsSlice_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_AsSlice_fnRecorder) Any() *MoqAddr_genType_AsSlice_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AsSlice(r.Params))
		return nil
	}
	return &MoqAddr_genType_AsSlice_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_AsSlice_fnRecorder) Seq() *MoqAddr_genType_AsSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AsSlice(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_AsSlice_fnRecorder) NoSeq() *MoqAddr_genType_AsSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AsSlice(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_AsSlice_fnRecorder) ReturnResults(result1 []byte) *MoqAddr_genType_AsSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_AsSlice_doFn
		DoReturnFn MoqAddr_genType_AsSlice_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_AsSlice_fnRecorder) AndDo(fn MoqAddr_genType_AsSlice_doFn) *MoqAddr_genType_AsSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_AsSlice_fnRecorder) DoReturnResults(fn MoqAddr_genType_AsSlice_doReturnFn) *MoqAddr_genType_AsSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_AsSlice_doFn
		DoReturnFn MoqAddr_genType_AsSlice_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_AsSlice_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_AsSlice_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AsSlice {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_AsSlice_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_AsSlice_paramsKey]*MoqAddr_genType_AsSlice_results{},
		}
		r.Moq.ResultsByParams_AsSlice = append(r.Moq.ResultsByParams_AsSlice, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AsSlice) {
			copy(r.Moq.ResultsByParams_AsSlice[insertAt+1:], r.Moq.ResultsByParams_AsSlice[insertAt:0])
			r.Moq.ResultsByParams_AsSlice[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AsSlice(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_AsSlice_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_AsSlice_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_AsSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_AsSlice_doFn
				DoReturnFn MoqAddr_genType_AsSlice_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_AsSlice(params MoqAddr_genType_AsSlice_params) string {
	return fmt.Sprintf("AsSlice()")
}

func (m *MoqAddr_genType) ParamsKey_AsSlice(params MoqAddr_genType_AsSlice_params, anyParams uint64) MoqAddr_genType_AsSlice_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_AsSlice_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) Next() *MoqAddr_genType_Next_fnRecorder {
	return &MoqAddr_genType_Next_fnRecorder{
		Params:   MoqAddr_genType_Next_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_Next_fnRecorder) Any() *MoqAddr_genType_Next_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Next(r.Params))
		return nil
	}
	return &MoqAddr_genType_Next_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_Next_fnRecorder) Seq() *MoqAddr_genType_Next_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Next(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_Next_fnRecorder) NoSeq() *MoqAddr_genType_Next_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Next(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_Next_fnRecorder) ReturnResults(result1 netip.Addr) *MoqAddr_genType_Next_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Next_doFn
		DoReturnFn MoqAddr_genType_Next_doReturnFn
	}{
		Values: &struct {
			Result1 netip.Addr
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_Next_fnRecorder) AndDo(fn MoqAddr_genType_Next_doFn) *MoqAddr_genType_Next_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_Next_fnRecorder) DoReturnResults(fn MoqAddr_genType_Next_doReturnFn) *MoqAddr_genType_Next_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Next_doFn
		DoReturnFn MoqAddr_genType_Next_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_Next_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_Next_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Next {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_Next_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_Next_paramsKey]*MoqAddr_genType_Next_results{},
		}
		r.Moq.ResultsByParams_Next = append(r.Moq.ResultsByParams_Next, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Next) {
			copy(r.Moq.ResultsByParams_Next[insertAt+1:], r.Moq.ResultsByParams_Next[insertAt:0])
			r.Moq.ResultsByParams_Next[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Next(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_Next_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_Next_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_Next_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 netip.Addr
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_Next_doFn
				DoReturnFn MoqAddr_genType_Next_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_Next(params MoqAddr_genType_Next_params) string {
	return fmt.Sprintf("Next()")
}

func (m *MoqAddr_genType) ParamsKey_Next(params MoqAddr_genType_Next_params, anyParams uint64) MoqAddr_genType_Next_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_Next_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) Prev() *MoqAddr_genType_Prev_fnRecorder {
	return &MoqAddr_genType_Prev_fnRecorder{
		Params:   MoqAddr_genType_Prev_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_Prev_fnRecorder) Any() *MoqAddr_genType_Prev_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prev(r.Params))
		return nil
	}
	return &MoqAddr_genType_Prev_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_Prev_fnRecorder) Seq() *MoqAddr_genType_Prev_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prev(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_Prev_fnRecorder) NoSeq() *MoqAddr_genType_Prev_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Prev(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_Prev_fnRecorder) ReturnResults(result1 netip.Addr) *MoqAddr_genType_Prev_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Prev_doFn
		DoReturnFn MoqAddr_genType_Prev_doReturnFn
	}{
		Values: &struct {
			Result1 netip.Addr
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_Prev_fnRecorder) AndDo(fn MoqAddr_genType_Prev_doFn) *MoqAddr_genType_Prev_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_Prev_fnRecorder) DoReturnResults(fn MoqAddr_genType_Prev_doReturnFn) *MoqAddr_genType_Prev_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 netip.Addr
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_Prev_doFn
		DoReturnFn MoqAddr_genType_Prev_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_Prev_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_Prev_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Prev {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_Prev_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_Prev_paramsKey]*MoqAddr_genType_Prev_results{},
		}
		r.Moq.ResultsByParams_Prev = append(r.Moq.ResultsByParams_Prev, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Prev) {
			copy(r.Moq.ResultsByParams_Prev[insertAt+1:], r.Moq.ResultsByParams_Prev[insertAt:0])
			r.Moq.ResultsByParams_Prev[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Prev(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_Prev_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_Prev_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_Prev_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 netip.Addr
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_Prev_doFn
				DoReturnFn MoqAddr_genType_Prev_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_Prev(params MoqAddr_genType_Prev_params) string {
	return fmt.Sprintf("Prev()")
}

func (m *MoqAddr_genType) ParamsKey_Prev(params MoqAddr_genType_Prev_params, anyParams uint64) MoqAddr_genType_Prev_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_Prev_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) String() *MoqAddr_genType_String_fnRecorder {
	return &MoqAddr_genType_String_fnRecorder{
		Params:   MoqAddr_genType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_String_fnRecorder) Any() *MoqAddr_genType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqAddr_genType_String_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_String_fnRecorder) Seq() *MoqAddr_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_String_fnRecorder) NoSeq() *MoqAddr_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_String_fnRecorder) ReturnResults(result1 string) *MoqAddr_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_String_doFn
		DoReturnFn MoqAddr_genType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_String_fnRecorder) AndDo(fn MoqAddr_genType_String_doFn) *MoqAddr_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_String_fnRecorder) DoReturnResults(fn MoqAddr_genType_String_doReturnFn) *MoqAddr_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_String_doFn
		DoReturnFn MoqAddr_genType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_String_paramsKey]*MoqAddr_genType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_String_doFn
				DoReturnFn MoqAddr_genType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_String(params MoqAddr_genType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqAddr_genType) ParamsKey_String(params MoqAddr_genType_String_params, anyParams uint64) MoqAddr_genType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) AppendTo(b []byte) *MoqAddr_genType_AppendTo_fnRecorder {
	return &MoqAddr_genType_AppendTo_fnRecorder{
		Params: MoqAddr_genType_AppendTo_params{
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_AppendTo_fnRecorder) Any() *MoqAddr_genType_AppendTo_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AppendTo(r.Params))
		return nil
	}
	return &MoqAddr_genType_AppendTo_anyParams{Recorder: r}
}

func (a *MoqAddr_genType_AppendTo_anyParams) B() *MoqAddr_genType_AppendTo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqAddr_genType_AppendTo_fnRecorder) Seq() *MoqAddr_genType_AppendTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AppendTo(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_AppendTo_fnRecorder) NoSeq() *MoqAddr_genType_AppendTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AppendTo(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_AppendTo_fnRecorder) ReturnResults(result1 []byte) *MoqAddr_genType_AppendTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_AppendTo_doFn
		DoReturnFn MoqAddr_genType_AppendTo_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_AppendTo_fnRecorder) AndDo(fn MoqAddr_genType_AppendTo_doFn) *MoqAddr_genType_AppendTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_AppendTo_fnRecorder) DoReturnResults(fn MoqAddr_genType_AppendTo_doReturnFn) *MoqAddr_genType_AppendTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_AppendTo_doFn
		DoReturnFn MoqAddr_genType_AppendTo_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_AppendTo_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_AppendTo_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AppendTo {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_AppendTo_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_AppendTo_paramsKey]*MoqAddr_genType_AppendTo_results{},
		}
		r.Moq.ResultsByParams_AppendTo = append(r.Moq.ResultsByParams_AppendTo, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AppendTo) {
			copy(r.Moq.ResultsByParams_AppendTo[insertAt+1:], r.Moq.ResultsByParams_AppendTo[insertAt:0])
			r.Moq.ResultsByParams_AppendTo[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AppendTo(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_AppendTo_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_AppendTo_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_AppendTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_AppendTo_doFn
				DoReturnFn MoqAddr_genType_AppendTo_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_AppendTo(params MoqAddr_genType_AppendTo_params) string {
	return fmt.Sprintf("AppendTo(%#v)", params.B)
}

func (m *MoqAddr_genType) ParamsKey_AppendTo(params MoqAddr_genType_AppendTo_params, anyParams uint64) MoqAddr_genType_AppendTo_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.AppendTo.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the AppendTo function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	return MoqAddr_genType_AppendTo_paramsKey{
		Params: struct{}{},
		Hashes: struct{ B hash.Hash }{
			B: bUsedHash,
		},
	}
}

func (m *MoqAddr_genType_recorder) StringExpanded() *MoqAddr_genType_StringExpanded_fnRecorder {
	return &MoqAddr_genType_StringExpanded_fnRecorder{
		Params:   MoqAddr_genType_StringExpanded_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_StringExpanded_fnRecorder) Any() *MoqAddr_genType_StringExpanded_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StringExpanded(r.Params))
		return nil
	}
	return &MoqAddr_genType_StringExpanded_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_StringExpanded_fnRecorder) Seq() *MoqAddr_genType_StringExpanded_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StringExpanded(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_StringExpanded_fnRecorder) NoSeq() *MoqAddr_genType_StringExpanded_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_StringExpanded(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_StringExpanded_fnRecorder) ReturnResults(result1 string) *MoqAddr_genType_StringExpanded_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_StringExpanded_doFn
		DoReturnFn MoqAddr_genType_StringExpanded_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_StringExpanded_fnRecorder) AndDo(fn MoqAddr_genType_StringExpanded_doFn) *MoqAddr_genType_StringExpanded_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_StringExpanded_fnRecorder) DoReturnResults(fn MoqAddr_genType_StringExpanded_doReturnFn) *MoqAddr_genType_StringExpanded_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_StringExpanded_doFn
		DoReturnFn MoqAddr_genType_StringExpanded_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_StringExpanded_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_StringExpanded_resultsByParams
	for n, res := range r.Moq.ResultsByParams_StringExpanded {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_StringExpanded_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_StringExpanded_paramsKey]*MoqAddr_genType_StringExpanded_results{},
		}
		r.Moq.ResultsByParams_StringExpanded = append(r.Moq.ResultsByParams_StringExpanded, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_StringExpanded) {
			copy(r.Moq.ResultsByParams_StringExpanded[insertAt+1:], r.Moq.ResultsByParams_StringExpanded[insertAt:0])
			r.Moq.ResultsByParams_StringExpanded[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_StringExpanded(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_StringExpanded_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_StringExpanded_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_StringExpanded_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_StringExpanded_doFn
				DoReturnFn MoqAddr_genType_StringExpanded_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_StringExpanded(params MoqAddr_genType_StringExpanded_params) string {
	return fmt.Sprintf("StringExpanded()")
}

func (m *MoqAddr_genType) ParamsKey_StringExpanded(params MoqAddr_genType_StringExpanded_params, anyParams uint64) MoqAddr_genType_StringExpanded_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_StringExpanded_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) MarshalText() *MoqAddr_genType_MarshalText_fnRecorder {
	return &MoqAddr_genType_MarshalText_fnRecorder{
		Params:   MoqAddr_genType_MarshalText_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_MarshalText_fnRecorder) Any() *MoqAddr_genType_MarshalText_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	return &MoqAddr_genType_MarshalText_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_MarshalText_fnRecorder) Seq() *MoqAddr_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_MarshalText_fnRecorder) NoSeq() *MoqAddr_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_MarshalText_fnRecorder) ReturnResults(result1 []byte, result2 error) *MoqAddr_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_MarshalText_doFn
		DoReturnFn MoqAddr_genType_MarshalText_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_MarshalText_fnRecorder) AndDo(fn MoqAddr_genType_MarshalText_doFn) *MoqAddr_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_MarshalText_fnRecorder) DoReturnResults(fn MoqAddr_genType_MarshalText_doReturnFn) *MoqAddr_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_MarshalText_doFn
		DoReturnFn MoqAddr_genType_MarshalText_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_MarshalText_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_MarshalText_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MarshalText {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_MarshalText_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_MarshalText_paramsKey]*MoqAddr_genType_MarshalText_results{},
		}
		r.Moq.ResultsByParams_MarshalText = append(r.Moq.ResultsByParams_MarshalText, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MarshalText) {
			copy(r.Moq.ResultsByParams_MarshalText[insertAt+1:], r.Moq.ResultsByParams_MarshalText[insertAt:0])
			r.Moq.ResultsByParams_MarshalText[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MarshalText(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_MarshalText_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_MarshalText_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_MarshalText_doFn
				DoReturnFn MoqAddr_genType_MarshalText_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_MarshalText(params MoqAddr_genType_MarshalText_params) string {
	return fmt.Sprintf("MarshalText()")
}

func (m *MoqAddr_genType) ParamsKey_MarshalText(params MoqAddr_genType_MarshalText_params, anyParams uint64) MoqAddr_genType_MarshalText_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_MarshalText_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqAddr_genType_recorder) MarshalBinary() *MoqAddr_genType_MarshalBinary_fnRecorder {
	return &MoqAddr_genType_MarshalBinary_fnRecorder{
		Params:   MoqAddr_genType_MarshalBinary_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqAddr_genType_MarshalBinary_fnRecorder) Any() *MoqAddr_genType_MarshalBinary_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalBinary(r.Params))
		return nil
	}
	return &MoqAddr_genType_MarshalBinary_anyParams{Recorder: r}
}

func (r *MoqAddr_genType_MarshalBinary_fnRecorder) Seq() *MoqAddr_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalBinary(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqAddr_genType_MarshalBinary_fnRecorder) NoSeq() *MoqAddr_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalBinary(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqAddr_genType_MarshalBinary_fnRecorder) ReturnResults(result1 []byte, result2 error) *MoqAddr_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_MarshalBinary_doFn
		DoReturnFn MoqAddr_genType_MarshalBinary_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqAddr_genType_MarshalBinary_fnRecorder) AndDo(fn MoqAddr_genType_MarshalBinary_doFn) *MoqAddr_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqAddr_genType_MarshalBinary_fnRecorder) DoReturnResults(fn MoqAddr_genType_MarshalBinary_doReturnFn) *MoqAddr_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqAddr_genType_MarshalBinary_doFn
		DoReturnFn MoqAddr_genType_MarshalBinary_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqAddr_genType_MarshalBinary_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqAddr_genType_MarshalBinary_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MarshalBinary {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqAddr_genType_MarshalBinary_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqAddr_genType_MarshalBinary_paramsKey]*MoqAddr_genType_MarshalBinary_results{},
		}
		r.Moq.ResultsByParams_MarshalBinary = append(r.Moq.ResultsByParams_MarshalBinary, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MarshalBinary) {
			copy(r.Moq.ResultsByParams_MarshalBinary[insertAt+1:], r.Moq.ResultsByParams_MarshalBinary[insertAt:0])
			r.Moq.ResultsByParams_MarshalBinary[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MarshalBinary(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqAddr_genType_MarshalBinary_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqAddr_genType_MarshalBinary_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqAddr_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqAddr_genType_MarshalBinary_doFn
				DoReturnFn MoqAddr_genType_MarshalBinary_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqAddr_genType) PrettyParams_MarshalBinary(params MoqAddr_genType_MarshalBinary_params) string {
	return fmt.Sprintf("MarshalBinary()")
}

func (m *MoqAddr_genType) ParamsKey_MarshalBinary(params MoqAddr_genType_MarshalBinary_params, anyParams uint64) MoqAddr_genType_MarshalBinary_paramsKey {
	m.Scene.T.Helper()
	return MoqAddr_genType_MarshalBinary_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqAddr_genType) Reset() {
	m.ResultsByParams_IsValid = nil
	m.ResultsByParams_BitLen = nil
	m.ResultsByParams_Zone = nil
	m.ResultsByParams_Compare = nil
	m.ResultsByParams_Less = nil
	m.ResultsByParams_Is4 = nil
	m.ResultsByParams_Is4In6 = nil
	m.ResultsByParams_Is6 = nil
	m.ResultsByParams_Unmap = nil
	m.ResultsByParams_WithZone = nil
	m.ResultsByParams_IsLinkLocalUnicast = nil
	m.ResultsByParams_IsLoopback = nil
	m.ResultsByParams_IsMulticast = nil
	m.ResultsByParams_IsInterfaceLocalMulticast = nil
	m.ResultsByParams_IsLinkLocalMulticast = nil
	m.ResultsByParams_IsGlobalUnicast = nil
	m.ResultsByParams_IsPrivate = nil
	m.ResultsByParams_IsUnspecified = nil
	m.ResultsByParams_Prefix = nil
	m.ResultsByParams_As16 = nil
	m.ResultsByParams_As4 = nil
	m.ResultsByParams_AsSlice = nil
	m.ResultsByParams_Next = nil
	m.ResultsByParams_Prev = nil
	m.ResultsByParams_String = nil
	m.ResultsByParams_AppendTo = nil
	m.ResultsByParams_StringExpanded = nil
	m.ResultsByParams_MarshalText = nil
	m.ResultsByParams_MarshalBinary = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqAddr_genType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_IsValid {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsValid(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_BitLen {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_BitLen(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Zone {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Zone(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Compare {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Compare(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Less {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Less(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Is4 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Is4(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Is4In6 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Is4In6(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Is6 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Is6(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Unmap {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Unmap(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_WithZone {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_WithZone(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsLinkLocalUnicast {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsLinkLocalUnicast(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsLoopback {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsLoopback(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsMulticast {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsMulticast(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsInterfaceLocalMulticast {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsInterfaceLocalMulticast(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsLinkLocalMulticast {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsLinkLocalMulticast(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsGlobalUnicast {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsGlobalUnicast(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsPrivate {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsPrivate(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsUnspecified {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsUnspecified(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Prefix {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Prefix(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_As16 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_As16(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_As4 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_As4(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AsSlice {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AsSlice(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Next {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Next(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Prev {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Prev(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AppendTo {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AppendTo(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_StringExpanded {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_StringExpanded(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MarshalText {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MarshalText(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MarshalBinary {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MarshalBinary(results.Params))
			}
		}
	}
}
