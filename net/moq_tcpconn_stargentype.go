// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package net

import (
	"fmt"
	"io"
	"math/bits"
	"sync/atomic"
	"syscall"
	"time"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that net.TCPConn_starGenType is mocked
// completely
var _ TCPConn_starGenType = (*MoqTCPConn_starGenType_mock)(nil)

// TCPConn_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type TCPConn_starGenType interface {
	SyscallConn() (syscall.RawConn, error)
	ReadFrom(r io.Reader) (int64, error)
	CloseRead() error
	CloseWrite() error
	SetLinger(sec int) error
	SetKeepAlive(keepalive bool) error
	SetKeepAlivePeriod(d time.Duration) error
	SetNoDelay(noDelay bool) error
}

// MoqTCPConn_starGenType holds the state of a moq of the TCPConn_starGenType
// type
type MoqTCPConn_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqTCPConn_starGenType_mock

	ResultsByParams_SyscallConn        []MoqTCPConn_starGenType_SyscallConn_resultsByParams
	ResultsByParams_ReadFrom           []MoqTCPConn_starGenType_ReadFrom_resultsByParams
	ResultsByParams_CloseRead          []MoqTCPConn_starGenType_CloseRead_resultsByParams
	ResultsByParams_CloseWrite         []MoqTCPConn_starGenType_CloseWrite_resultsByParams
	ResultsByParams_SetLinger          []MoqTCPConn_starGenType_SetLinger_resultsByParams
	ResultsByParams_SetKeepAlive       []MoqTCPConn_starGenType_SetKeepAlive_resultsByParams
	ResultsByParams_SetKeepAlivePeriod []MoqTCPConn_starGenType_SetKeepAlivePeriod_resultsByParams
	ResultsByParams_SetNoDelay         []MoqTCPConn_starGenType_SetNoDelay_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			SyscallConn struct{}
			ReadFrom    struct {
				Param1 moq.ParamIndexing
			}
			CloseRead  struct{}
			CloseWrite struct{}
			SetLinger  struct {
				Sec moq.ParamIndexing
			}
			SetKeepAlive struct {
				Keepalive moq.ParamIndexing
			}
			SetKeepAlivePeriod struct {
				D moq.ParamIndexing
			}
			SetNoDelay struct {
				NoDelay moq.ParamIndexing
			}
		}
	}
	// MoqTCPConn_starGenType_mock isolates the mock interface of the
}

// TCPConn_starGenType type
type MoqTCPConn_starGenType_mock struct {
	Moq *MoqTCPConn_starGenType
}

// MoqTCPConn_starGenType_recorder isolates the recorder interface of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_recorder struct {
	Moq *MoqTCPConn_starGenType
}

// MoqTCPConn_starGenType_SyscallConn_params holds the params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SyscallConn_params struct{}

// MoqTCPConn_starGenType_SyscallConn_paramsKey holds the map key params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SyscallConn_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTCPConn_starGenType_SyscallConn_resultsByParams contains the results for
// a given set of parameters for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SyscallConn_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTCPConn_starGenType_SyscallConn_paramsKey]*MoqTCPConn_starGenType_SyscallConn_results
}

// MoqTCPConn_starGenType_SyscallConn_doFn defines the type of function needed
// when calling AndDo for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SyscallConn_doFn func()

// MoqTCPConn_starGenType_SyscallConn_doReturnFn defines the type of function
// needed when calling DoReturnResults for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SyscallConn_doReturnFn func() (syscall.RawConn, error)

// MoqTCPConn_starGenType_SyscallConn_results holds the results of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SyscallConn_results struct {
	Params  MoqTCPConn_starGenType_SyscallConn_params
	Results []struct {
		Values *struct {
			Result1 syscall.RawConn
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SyscallConn_doFn
		DoReturnFn MoqTCPConn_starGenType_SyscallConn_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTCPConn_starGenType_SyscallConn_fnRecorder routes recorded function calls
// to the MoqTCPConn_starGenType moq
type MoqTCPConn_starGenType_SyscallConn_fnRecorder struct {
	Params    MoqTCPConn_starGenType_SyscallConn_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTCPConn_starGenType_SyscallConn_results
	Moq       *MoqTCPConn_starGenType
}

// MoqTCPConn_starGenType_SyscallConn_anyParams isolates the any params
// functions of the TCPConn_starGenType type
type MoqTCPConn_starGenType_SyscallConn_anyParams struct {
	Recorder *MoqTCPConn_starGenType_SyscallConn_fnRecorder
}

// MoqTCPConn_starGenType_ReadFrom_params holds the params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_ReadFrom_params struct{ Param1 io.Reader }

// MoqTCPConn_starGenType_ReadFrom_paramsKey holds the map key params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_ReadFrom_paramsKey struct {
	Params struct{ Param1 io.Reader }
	Hashes struct{ Param1 hash.Hash }
}

// MoqTCPConn_starGenType_ReadFrom_resultsByParams contains the results for a
// given set of parameters for the TCPConn_starGenType type
type MoqTCPConn_starGenType_ReadFrom_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTCPConn_starGenType_ReadFrom_paramsKey]*MoqTCPConn_starGenType_ReadFrom_results
}

// MoqTCPConn_starGenType_ReadFrom_doFn defines the type of function needed
// when calling AndDo for the TCPConn_starGenType type
type MoqTCPConn_starGenType_ReadFrom_doFn func(r io.Reader)

// MoqTCPConn_starGenType_ReadFrom_doReturnFn defines the type of function
// needed when calling DoReturnResults for the TCPConn_starGenType type
type MoqTCPConn_starGenType_ReadFrom_doReturnFn func(r io.Reader) (int64, error)

// MoqTCPConn_starGenType_ReadFrom_results holds the results of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_ReadFrom_results struct {
	Params  MoqTCPConn_starGenType_ReadFrom_params
	Results []struct {
		Values *struct {
			Result1 int64
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_ReadFrom_doFn
		DoReturnFn MoqTCPConn_starGenType_ReadFrom_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTCPConn_starGenType_ReadFrom_fnRecorder routes recorded function calls to
// the MoqTCPConn_starGenType moq
type MoqTCPConn_starGenType_ReadFrom_fnRecorder struct {
	Params    MoqTCPConn_starGenType_ReadFrom_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTCPConn_starGenType_ReadFrom_results
	Moq       *MoqTCPConn_starGenType
}

// MoqTCPConn_starGenType_ReadFrom_anyParams isolates the any params functions
// of the TCPConn_starGenType type
type MoqTCPConn_starGenType_ReadFrom_anyParams struct {
	Recorder *MoqTCPConn_starGenType_ReadFrom_fnRecorder
}

// MoqTCPConn_starGenType_CloseRead_params holds the params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseRead_params struct{}

// MoqTCPConn_starGenType_CloseRead_paramsKey holds the map key params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseRead_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTCPConn_starGenType_CloseRead_resultsByParams contains the results for a
// given set of parameters for the TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseRead_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTCPConn_starGenType_CloseRead_paramsKey]*MoqTCPConn_starGenType_CloseRead_results
}

// MoqTCPConn_starGenType_CloseRead_doFn defines the type of function needed
// when calling AndDo for the TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseRead_doFn func()

// MoqTCPConn_starGenType_CloseRead_doReturnFn defines the type of function
// needed when calling DoReturnResults for the TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseRead_doReturnFn func() error

// MoqTCPConn_starGenType_CloseRead_results holds the results of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseRead_results struct {
	Params  MoqTCPConn_starGenType_CloseRead_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_CloseRead_doFn
		DoReturnFn MoqTCPConn_starGenType_CloseRead_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTCPConn_starGenType_CloseRead_fnRecorder routes recorded function calls
// to the MoqTCPConn_starGenType moq
type MoqTCPConn_starGenType_CloseRead_fnRecorder struct {
	Params    MoqTCPConn_starGenType_CloseRead_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTCPConn_starGenType_CloseRead_results
	Moq       *MoqTCPConn_starGenType
}

// MoqTCPConn_starGenType_CloseRead_anyParams isolates the any params functions
// of the TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseRead_anyParams struct {
	Recorder *MoqTCPConn_starGenType_CloseRead_fnRecorder
}

// MoqTCPConn_starGenType_CloseWrite_params holds the params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseWrite_params struct{}

// MoqTCPConn_starGenType_CloseWrite_paramsKey holds the map key params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseWrite_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTCPConn_starGenType_CloseWrite_resultsByParams contains the results for a
// given set of parameters for the TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseWrite_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTCPConn_starGenType_CloseWrite_paramsKey]*MoqTCPConn_starGenType_CloseWrite_results
}

// MoqTCPConn_starGenType_CloseWrite_doFn defines the type of function needed
// when calling AndDo for the TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseWrite_doFn func()

// MoqTCPConn_starGenType_CloseWrite_doReturnFn defines the type of function
// needed when calling DoReturnResults for the TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseWrite_doReturnFn func() error

// MoqTCPConn_starGenType_CloseWrite_results holds the results of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseWrite_results struct {
	Params  MoqTCPConn_starGenType_CloseWrite_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_CloseWrite_doFn
		DoReturnFn MoqTCPConn_starGenType_CloseWrite_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTCPConn_starGenType_CloseWrite_fnRecorder routes recorded function calls
// to the MoqTCPConn_starGenType moq
type MoqTCPConn_starGenType_CloseWrite_fnRecorder struct {
	Params    MoqTCPConn_starGenType_CloseWrite_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTCPConn_starGenType_CloseWrite_results
	Moq       *MoqTCPConn_starGenType
}

// MoqTCPConn_starGenType_CloseWrite_anyParams isolates the any params
// functions of the TCPConn_starGenType type
type MoqTCPConn_starGenType_CloseWrite_anyParams struct {
	Recorder *MoqTCPConn_starGenType_CloseWrite_fnRecorder
}

// MoqTCPConn_starGenType_SetLinger_params holds the params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SetLinger_params struct{ Sec int }

// MoqTCPConn_starGenType_SetLinger_paramsKey holds the map key params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SetLinger_paramsKey struct {
	Params struct{ Sec int }
	Hashes struct{ Sec hash.Hash }
}

// MoqTCPConn_starGenType_SetLinger_resultsByParams contains the results for a
// given set of parameters for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetLinger_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTCPConn_starGenType_SetLinger_paramsKey]*MoqTCPConn_starGenType_SetLinger_results
}

// MoqTCPConn_starGenType_SetLinger_doFn defines the type of function needed
// when calling AndDo for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetLinger_doFn func(sec int)

// MoqTCPConn_starGenType_SetLinger_doReturnFn defines the type of function
// needed when calling DoReturnResults for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetLinger_doReturnFn func(sec int) error

// MoqTCPConn_starGenType_SetLinger_results holds the results of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SetLinger_results struct {
	Params  MoqTCPConn_starGenType_SetLinger_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetLinger_doFn
		DoReturnFn MoqTCPConn_starGenType_SetLinger_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTCPConn_starGenType_SetLinger_fnRecorder routes recorded function calls
// to the MoqTCPConn_starGenType moq
type MoqTCPConn_starGenType_SetLinger_fnRecorder struct {
	Params    MoqTCPConn_starGenType_SetLinger_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTCPConn_starGenType_SetLinger_results
	Moq       *MoqTCPConn_starGenType
}

// MoqTCPConn_starGenType_SetLinger_anyParams isolates the any params functions
// of the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetLinger_anyParams struct {
	Recorder *MoqTCPConn_starGenType_SetLinger_fnRecorder
}

// MoqTCPConn_starGenType_SetKeepAlive_params holds the params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlive_params struct{ Keepalive bool }

// MoqTCPConn_starGenType_SetKeepAlive_paramsKey holds the map key params of
// the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlive_paramsKey struct {
	Params struct{ Keepalive bool }
	Hashes struct{ Keepalive hash.Hash }
}

// MoqTCPConn_starGenType_SetKeepAlive_resultsByParams contains the results for
// a given set of parameters for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlive_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTCPConn_starGenType_SetKeepAlive_paramsKey]*MoqTCPConn_starGenType_SetKeepAlive_results
}

// MoqTCPConn_starGenType_SetKeepAlive_doFn defines the type of function needed
// when calling AndDo for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlive_doFn func(keepalive bool)

// MoqTCPConn_starGenType_SetKeepAlive_doReturnFn defines the type of function
// needed when calling DoReturnResults for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlive_doReturnFn func(keepalive bool) error

// MoqTCPConn_starGenType_SetKeepAlive_results holds the results of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlive_results struct {
	Params  MoqTCPConn_starGenType_SetKeepAlive_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetKeepAlive_doFn
		DoReturnFn MoqTCPConn_starGenType_SetKeepAlive_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTCPConn_starGenType_SetKeepAlive_fnRecorder routes recorded function
// calls to the MoqTCPConn_starGenType moq
type MoqTCPConn_starGenType_SetKeepAlive_fnRecorder struct {
	Params    MoqTCPConn_starGenType_SetKeepAlive_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTCPConn_starGenType_SetKeepAlive_results
	Moq       *MoqTCPConn_starGenType
}

// MoqTCPConn_starGenType_SetKeepAlive_anyParams isolates the any params
// functions of the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlive_anyParams struct {
	Recorder *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder
}

// MoqTCPConn_starGenType_SetKeepAlivePeriod_params holds the params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlivePeriod_params struct{ D time.Duration }

// MoqTCPConn_starGenType_SetKeepAlivePeriod_paramsKey holds the map key params
// of the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlivePeriod_paramsKey struct {
	Params struct{ D time.Duration }
	Hashes struct{ D hash.Hash }
}

// MoqTCPConn_starGenType_SetKeepAlivePeriod_resultsByParams contains the
// results for a given set of parameters for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlivePeriod_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTCPConn_starGenType_SetKeepAlivePeriod_paramsKey]*MoqTCPConn_starGenType_SetKeepAlivePeriod_results
}

// MoqTCPConn_starGenType_SetKeepAlivePeriod_doFn defines the type of function
// needed when calling AndDo for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlivePeriod_doFn func(d time.Duration)

// MoqTCPConn_starGenType_SetKeepAlivePeriod_doReturnFn defines the type of
// function needed when calling DoReturnResults for the TCPConn_starGenType
// type
type MoqTCPConn_starGenType_SetKeepAlivePeriod_doReturnFn func(d time.Duration) error

// MoqTCPConn_starGenType_SetKeepAlivePeriod_results holds the results of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlivePeriod_results struct {
	Params  MoqTCPConn_starGenType_SetKeepAlivePeriod_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetKeepAlivePeriod_doFn
		DoReturnFn MoqTCPConn_starGenType_SetKeepAlivePeriod_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder routes recorded
// function calls to the MoqTCPConn_starGenType moq
type MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder struct {
	Params    MoqTCPConn_starGenType_SetKeepAlivePeriod_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTCPConn_starGenType_SetKeepAlivePeriod_results
	Moq       *MoqTCPConn_starGenType
}

// MoqTCPConn_starGenType_SetKeepAlivePeriod_anyParams isolates the any params
// functions of the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetKeepAlivePeriod_anyParams struct {
	Recorder *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder
}

// MoqTCPConn_starGenType_SetNoDelay_params holds the params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SetNoDelay_params struct{ NoDelay bool }

// MoqTCPConn_starGenType_SetNoDelay_paramsKey holds the map key params of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SetNoDelay_paramsKey struct {
	Params struct{ NoDelay bool }
	Hashes struct{ NoDelay hash.Hash }
}

// MoqTCPConn_starGenType_SetNoDelay_resultsByParams contains the results for a
// given set of parameters for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetNoDelay_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTCPConn_starGenType_SetNoDelay_paramsKey]*MoqTCPConn_starGenType_SetNoDelay_results
}

// MoqTCPConn_starGenType_SetNoDelay_doFn defines the type of function needed
// when calling AndDo for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetNoDelay_doFn func(noDelay bool)

// MoqTCPConn_starGenType_SetNoDelay_doReturnFn defines the type of function
// needed when calling DoReturnResults for the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetNoDelay_doReturnFn func(noDelay bool) error

// MoqTCPConn_starGenType_SetNoDelay_results holds the results of the
// TCPConn_starGenType type
type MoqTCPConn_starGenType_SetNoDelay_results struct {
	Params  MoqTCPConn_starGenType_SetNoDelay_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetNoDelay_doFn
		DoReturnFn MoqTCPConn_starGenType_SetNoDelay_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTCPConn_starGenType_SetNoDelay_fnRecorder routes recorded function calls
// to the MoqTCPConn_starGenType moq
type MoqTCPConn_starGenType_SetNoDelay_fnRecorder struct {
	Params    MoqTCPConn_starGenType_SetNoDelay_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTCPConn_starGenType_SetNoDelay_results
	Moq       *MoqTCPConn_starGenType
}

// MoqTCPConn_starGenType_SetNoDelay_anyParams isolates the any params
// functions of the TCPConn_starGenType type
type MoqTCPConn_starGenType_SetNoDelay_anyParams struct {
	Recorder *MoqTCPConn_starGenType_SetNoDelay_fnRecorder
}

// NewMoqTCPConn_starGenType creates a new moq of the TCPConn_starGenType type
func NewMoqTCPConn_starGenType(scene *moq.Scene, config *moq.Config) *MoqTCPConn_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqTCPConn_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqTCPConn_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				SyscallConn struct{}
				ReadFrom    struct {
					Param1 moq.ParamIndexing
				}
				CloseRead  struct{}
				CloseWrite struct{}
				SetLinger  struct {
					Sec moq.ParamIndexing
				}
				SetKeepAlive struct {
					Keepalive moq.ParamIndexing
				}
				SetKeepAlivePeriod struct {
					D moq.ParamIndexing
				}
				SetNoDelay struct {
					NoDelay moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			SyscallConn struct{}
			ReadFrom    struct {
				Param1 moq.ParamIndexing
			}
			CloseRead  struct{}
			CloseWrite struct{}
			SetLinger  struct {
				Sec moq.ParamIndexing
			}
			SetKeepAlive struct {
				Keepalive moq.ParamIndexing
			}
			SetKeepAlivePeriod struct {
				D moq.ParamIndexing
			}
			SetNoDelay struct {
				NoDelay moq.ParamIndexing
			}
		}{
			SyscallConn: struct{}{},
			ReadFrom: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByHash,
			},
			CloseRead:  struct{}{},
			CloseWrite: struct{}{},
			SetLinger: struct {
				Sec moq.ParamIndexing
			}{
				Sec: moq.ParamIndexByValue,
			},
			SetKeepAlive: struct {
				Keepalive moq.ParamIndexing
			}{
				Keepalive: moq.ParamIndexByValue,
			},
			SetKeepAlivePeriod: struct {
				D moq.ParamIndexing
			}{
				D: moq.ParamIndexByValue,
			},
			SetNoDelay: struct {
				NoDelay moq.ParamIndexing
			}{
				NoDelay: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the TCPConn_starGenType type
func (m *MoqTCPConn_starGenType) Mock() *MoqTCPConn_starGenType_mock { return m.Moq }

func (m *MoqTCPConn_starGenType_mock) SyscallConn() (result1 syscall.RawConn, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTCPConn_starGenType_SyscallConn_params{}
	var results *MoqTCPConn_starGenType_SyscallConn_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SyscallConn {
		paramsKey := m.Moq.ParamsKey_SyscallConn(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SyscallConn(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SyscallConn(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SyscallConn(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqTCPConn_starGenType_mock) ReadFrom(param1 io.Reader) (result1 int64, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTCPConn_starGenType_ReadFrom_params{
		Param1: param1,
	}
	var results *MoqTCPConn_starGenType_ReadFrom_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReadFrom {
		paramsKey := m.Moq.ParamsKey_ReadFrom(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReadFrom(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReadFrom(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReadFrom(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqTCPConn_starGenType_mock) CloseRead() (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTCPConn_starGenType_CloseRead_params{}
	var results *MoqTCPConn_starGenType_CloseRead_results
	for _, resultsByParams := range m.Moq.ResultsByParams_CloseRead {
		paramsKey := m.Moq.ParamsKey_CloseRead(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_CloseRead(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_CloseRead(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_CloseRead(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTCPConn_starGenType_mock) CloseWrite() (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTCPConn_starGenType_CloseWrite_params{}
	var results *MoqTCPConn_starGenType_CloseWrite_results
	for _, resultsByParams := range m.Moq.ResultsByParams_CloseWrite {
		paramsKey := m.Moq.ParamsKey_CloseWrite(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_CloseWrite(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_CloseWrite(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_CloseWrite(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTCPConn_starGenType_mock) SetLinger(sec int) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTCPConn_starGenType_SetLinger_params{
		Sec: sec,
	}
	var results *MoqTCPConn_starGenType_SetLinger_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetLinger {
		paramsKey := m.Moq.ParamsKey_SetLinger(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetLinger(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetLinger(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetLinger(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(sec)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(sec)
	}
	return
}

func (m *MoqTCPConn_starGenType_mock) SetKeepAlive(keepalive bool) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTCPConn_starGenType_SetKeepAlive_params{
		Keepalive: keepalive,
	}
	var results *MoqTCPConn_starGenType_SetKeepAlive_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetKeepAlive {
		paramsKey := m.Moq.ParamsKey_SetKeepAlive(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetKeepAlive(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetKeepAlive(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetKeepAlive(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(keepalive)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(keepalive)
	}
	return
}

func (m *MoqTCPConn_starGenType_mock) SetKeepAlivePeriod(d time.Duration) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTCPConn_starGenType_SetKeepAlivePeriod_params{
		D: d,
	}
	var results *MoqTCPConn_starGenType_SetKeepAlivePeriod_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetKeepAlivePeriod {
		paramsKey := m.Moq.ParamsKey_SetKeepAlivePeriod(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetKeepAlivePeriod(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetKeepAlivePeriod(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetKeepAlivePeriod(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(d)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(d)
	}
	return
}

func (m *MoqTCPConn_starGenType_mock) SetNoDelay(noDelay bool) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTCPConn_starGenType_SetNoDelay_params{
		NoDelay: noDelay,
	}
	var results *MoqTCPConn_starGenType_SetNoDelay_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetNoDelay {
		paramsKey := m.Moq.ParamsKey_SetNoDelay(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetNoDelay(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetNoDelay(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetNoDelay(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(noDelay)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(noDelay)
	}
	return
}

// OnCall returns the recorder implementation of the TCPConn_starGenType type
func (m *MoqTCPConn_starGenType) OnCall() *MoqTCPConn_starGenType_recorder {
	return &MoqTCPConn_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqTCPConn_starGenType_recorder) SyscallConn() *MoqTCPConn_starGenType_SyscallConn_fnRecorder {
	return &MoqTCPConn_starGenType_SyscallConn_fnRecorder{
		Params:   MoqTCPConn_starGenType_SyscallConn_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTCPConn_starGenType_SyscallConn_fnRecorder) Any() *MoqTCPConn_starGenType_SyscallConn_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SyscallConn(r.Params))
		return nil
	}
	return &MoqTCPConn_starGenType_SyscallConn_anyParams{Recorder: r}
}

func (r *MoqTCPConn_starGenType_SyscallConn_fnRecorder) Seq() *MoqTCPConn_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SyscallConn(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTCPConn_starGenType_SyscallConn_fnRecorder) NoSeq() *MoqTCPConn_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SyscallConn(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTCPConn_starGenType_SyscallConn_fnRecorder) ReturnResults(result1 syscall.RawConn, result2 error) *MoqTCPConn_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 syscall.RawConn
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SyscallConn_doFn
		DoReturnFn MoqTCPConn_starGenType_SyscallConn_doReturnFn
	}{
		Values: &struct {
			Result1 syscall.RawConn
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTCPConn_starGenType_SyscallConn_fnRecorder) AndDo(fn MoqTCPConn_starGenType_SyscallConn_doFn) *MoqTCPConn_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTCPConn_starGenType_SyscallConn_fnRecorder) DoReturnResults(fn MoqTCPConn_starGenType_SyscallConn_doReturnFn) *MoqTCPConn_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 syscall.RawConn
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SyscallConn_doFn
		DoReturnFn MoqTCPConn_starGenType_SyscallConn_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTCPConn_starGenType_SyscallConn_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTCPConn_starGenType_SyscallConn_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SyscallConn {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTCPConn_starGenType_SyscallConn_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTCPConn_starGenType_SyscallConn_paramsKey]*MoqTCPConn_starGenType_SyscallConn_results{},
		}
		r.Moq.ResultsByParams_SyscallConn = append(r.Moq.ResultsByParams_SyscallConn, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SyscallConn) {
			copy(r.Moq.ResultsByParams_SyscallConn[insertAt+1:], r.Moq.ResultsByParams_SyscallConn[insertAt:0])
			r.Moq.ResultsByParams_SyscallConn[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SyscallConn(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTCPConn_starGenType_SyscallConn_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTCPConn_starGenType_SyscallConn_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTCPConn_starGenType_SyscallConn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 syscall.RawConn
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqTCPConn_starGenType_SyscallConn_doFn
				DoReturnFn MoqTCPConn_starGenType_SyscallConn_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTCPConn_starGenType) PrettyParams_SyscallConn(params MoqTCPConn_starGenType_SyscallConn_params) string {
	return fmt.Sprintf("SyscallConn()")
}

func (m *MoqTCPConn_starGenType) ParamsKey_SyscallConn(params MoqTCPConn_starGenType_SyscallConn_params, anyParams uint64) MoqTCPConn_starGenType_SyscallConn_paramsKey {
	m.Scene.T.Helper()
	return MoqTCPConn_starGenType_SyscallConn_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTCPConn_starGenType_recorder) ReadFrom(param1 io.Reader) *MoqTCPConn_starGenType_ReadFrom_fnRecorder {
	return &MoqTCPConn_starGenType_ReadFrom_fnRecorder{
		Params: MoqTCPConn_starGenType_ReadFrom_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTCPConn_starGenType_ReadFrom_fnRecorder) Any() *MoqTCPConn_starGenType_ReadFrom_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadFrom(r.Params))
		return nil
	}
	return &MoqTCPConn_starGenType_ReadFrom_anyParams{Recorder: r}
}

func (a *MoqTCPConn_starGenType_ReadFrom_anyParams) Param1() *MoqTCPConn_starGenType_ReadFrom_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTCPConn_starGenType_ReadFrom_fnRecorder) Seq() *MoqTCPConn_starGenType_ReadFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadFrom(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTCPConn_starGenType_ReadFrom_fnRecorder) NoSeq() *MoqTCPConn_starGenType_ReadFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReadFrom(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTCPConn_starGenType_ReadFrom_fnRecorder) ReturnResults(result1 int64, result2 error) *MoqTCPConn_starGenType_ReadFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_ReadFrom_doFn
		DoReturnFn MoqTCPConn_starGenType_ReadFrom_doReturnFn
	}{
		Values: &struct {
			Result1 int64
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTCPConn_starGenType_ReadFrom_fnRecorder) AndDo(fn MoqTCPConn_starGenType_ReadFrom_doFn) *MoqTCPConn_starGenType_ReadFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTCPConn_starGenType_ReadFrom_fnRecorder) DoReturnResults(fn MoqTCPConn_starGenType_ReadFrom_doReturnFn) *MoqTCPConn_starGenType_ReadFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_ReadFrom_doFn
		DoReturnFn MoqTCPConn_starGenType_ReadFrom_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTCPConn_starGenType_ReadFrom_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTCPConn_starGenType_ReadFrom_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReadFrom {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTCPConn_starGenType_ReadFrom_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTCPConn_starGenType_ReadFrom_paramsKey]*MoqTCPConn_starGenType_ReadFrom_results{},
		}
		r.Moq.ResultsByParams_ReadFrom = append(r.Moq.ResultsByParams_ReadFrom, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReadFrom) {
			copy(r.Moq.ResultsByParams_ReadFrom[insertAt+1:], r.Moq.ResultsByParams_ReadFrom[insertAt:0])
			r.Moq.ResultsByParams_ReadFrom[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReadFrom(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTCPConn_starGenType_ReadFrom_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTCPConn_starGenType_ReadFrom_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTCPConn_starGenType_ReadFrom_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int64
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqTCPConn_starGenType_ReadFrom_doFn
				DoReturnFn MoqTCPConn_starGenType_ReadFrom_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTCPConn_starGenType) PrettyParams_ReadFrom(params MoqTCPConn_starGenType_ReadFrom_params) string {
	return fmt.Sprintf("ReadFrom(%#v)", params.Param1)
}

func (m *MoqTCPConn_starGenType) ParamsKey_ReadFrom(params MoqTCPConn_starGenType_ReadFrom_params, anyParams uint64) MoqTCPConn_starGenType_ReadFrom_paramsKey {
	m.Scene.T.Helper()
	var param1Used io.Reader
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ReadFrom.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqTCPConn_starGenType_ReadFrom_paramsKey{
		Params: struct{ Param1 io.Reader }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqTCPConn_starGenType_recorder) CloseRead() *MoqTCPConn_starGenType_CloseRead_fnRecorder {
	return &MoqTCPConn_starGenType_CloseRead_fnRecorder{
		Params:   MoqTCPConn_starGenType_CloseRead_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTCPConn_starGenType_CloseRead_fnRecorder) Any() *MoqTCPConn_starGenType_CloseRead_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CloseRead(r.Params))
		return nil
	}
	return &MoqTCPConn_starGenType_CloseRead_anyParams{Recorder: r}
}

func (r *MoqTCPConn_starGenType_CloseRead_fnRecorder) Seq() *MoqTCPConn_starGenType_CloseRead_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CloseRead(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTCPConn_starGenType_CloseRead_fnRecorder) NoSeq() *MoqTCPConn_starGenType_CloseRead_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CloseRead(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTCPConn_starGenType_CloseRead_fnRecorder) ReturnResults(result1 error) *MoqTCPConn_starGenType_CloseRead_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_CloseRead_doFn
		DoReturnFn MoqTCPConn_starGenType_CloseRead_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTCPConn_starGenType_CloseRead_fnRecorder) AndDo(fn MoqTCPConn_starGenType_CloseRead_doFn) *MoqTCPConn_starGenType_CloseRead_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTCPConn_starGenType_CloseRead_fnRecorder) DoReturnResults(fn MoqTCPConn_starGenType_CloseRead_doReturnFn) *MoqTCPConn_starGenType_CloseRead_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_CloseRead_doFn
		DoReturnFn MoqTCPConn_starGenType_CloseRead_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTCPConn_starGenType_CloseRead_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTCPConn_starGenType_CloseRead_resultsByParams
	for n, res := range r.Moq.ResultsByParams_CloseRead {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTCPConn_starGenType_CloseRead_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTCPConn_starGenType_CloseRead_paramsKey]*MoqTCPConn_starGenType_CloseRead_results{},
		}
		r.Moq.ResultsByParams_CloseRead = append(r.Moq.ResultsByParams_CloseRead, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_CloseRead) {
			copy(r.Moq.ResultsByParams_CloseRead[insertAt+1:], r.Moq.ResultsByParams_CloseRead[insertAt:0])
			r.Moq.ResultsByParams_CloseRead[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_CloseRead(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTCPConn_starGenType_CloseRead_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTCPConn_starGenType_CloseRead_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTCPConn_starGenType_CloseRead_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqTCPConn_starGenType_CloseRead_doFn
				DoReturnFn MoqTCPConn_starGenType_CloseRead_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTCPConn_starGenType) PrettyParams_CloseRead(params MoqTCPConn_starGenType_CloseRead_params) string {
	return fmt.Sprintf("CloseRead()")
}

func (m *MoqTCPConn_starGenType) ParamsKey_CloseRead(params MoqTCPConn_starGenType_CloseRead_params, anyParams uint64) MoqTCPConn_starGenType_CloseRead_paramsKey {
	m.Scene.T.Helper()
	return MoqTCPConn_starGenType_CloseRead_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTCPConn_starGenType_recorder) CloseWrite() *MoqTCPConn_starGenType_CloseWrite_fnRecorder {
	return &MoqTCPConn_starGenType_CloseWrite_fnRecorder{
		Params:   MoqTCPConn_starGenType_CloseWrite_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTCPConn_starGenType_CloseWrite_fnRecorder) Any() *MoqTCPConn_starGenType_CloseWrite_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CloseWrite(r.Params))
		return nil
	}
	return &MoqTCPConn_starGenType_CloseWrite_anyParams{Recorder: r}
}

func (r *MoqTCPConn_starGenType_CloseWrite_fnRecorder) Seq() *MoqTCPConn_starGenType_CloseWrite_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CloseWrite(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTCPConn_starGenType_CloseWrite_fnRecorder) NoSeq() *MoqTCPConn_starGenType_CloseWrite_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CloseWrite(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTCPConn_starGenType_CloseWrite_fnRecorder) ReturnResults(result1 error) *MoqTCPConn_starGenType_CloseWrite_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_CloseWrite_doFn
		DoReturnFn MoqTCPConn_starGenType_CloseWrite_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTCPConn_starGenType_CloseWrite_fnRecorder) AndDo(fn MoqTCPConn_starGenType_CloseWrite_doFn) *MoqTCPConn_starGenType_CloseWrite_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTCPConn_starGenType_CloseWrite_fnRecorder) DoReturnResults(fn MoqTCPConn_starGenType_CloseWrite_doReturnFn) *MoqTCPConn_starGenType_CloseWrite_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_CloseWrite_doFn
		DoReturnFn MoqTCPConn_starGenType_CloseWrite_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTCPConn_starGenType_CloseWrite_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTCPConn_starGenType_CloseWrite_resultsByParams
	for n, res := range r.Moq.ResultsByParams_CloseWrite {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTCPConn_starGenType_CloseWrite_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTCPConn_starGenType_CloseWrite_paramsKey]*MoqTCPConn_starGenType_CloseWrite_results{},
		}
		r.Moq.ResultsByParams_CloseWrite = append(r.Moq.ResultsByParams_CloseWrite, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_CloseWrite) {
			copy(r.Moq.ResultsByParams_CloseWrite[insertAt+1:], r.Moq.ResultsByParams_CloseWrite[insertAt:0])
			r.Moq.ResultsByParams_CloseWrite[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_CloseWrite(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTCPConn_starGenType_CloseWrite_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTCPConn_starGenType_CloseWrite_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTCPConn_starGenType_CloseWrite_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqTCPConn_starGenType_CloseWrite_doFn
				DoReturnFn MoqTCPConn_starGenType_CloseWrite_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTCPConn_starGenType) PrettyParams_CloseWrite(params MoqTCPConn_starGenType_CloseWrite_params) string {
	return fmt.Sprintf("CloseWrite()")
}

func (m *MoqTCPConn_starGenType) ParamsKey_CloseWrite(params MoqTCPConn_starGenType_CloseWrite_params, anyParams uint64) MoqTCPConn_starGenType_CloseWrite_paramsKey {
	m.Scene.T.Helper()
	return MoqTCPConn_starGenType_CloseWrite_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTCPConn_starGenType_recorder) SetLinger(sec int) *MoqTCPConn_starGenType_SetLinger_fnRecorder {
	return &MoqTCPConn_starGenType_SetLinger_fnRecorder{
		Params: MoqTCPConn_starGenType_SetLinger_params{
			Sec: sec,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTCPConn_starGenType_SetLinger_fnRecorder) Any() *MoqTCPConn_starGenType_SetLinger_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLinger(r.Params))
		return nil
	}
	return &MoqTCPConn_starGenType_SetLinger_anyParams{Recorder: r}
}

func (a *MoqTCPConn_starGenType_SetLinger_anyParams) Sec() *MoqTCPConn_starGenType_SetLinger_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTCPConn_starGenType_SetLinger_fnRecorder) Seq() *MoqTCPConn_starGenType_SetLinger_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLinger(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTCPConn_starGenType_SetLinger_fnRecorder) NoSeq() *MoqTCPConn_starGenType_SetLinger_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLinger(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTCPConn_starGenType_SetLinger_fnRecorder) ReturnResults(result1 error) *MoqTCPConn_starGenType_SetLinger_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetLinger_doFn
		DoReturnFn MoqTCPConn_starGenType_SetLinger_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTCPConn_starGenType_SetLinger_fnRecorder) AndDo(fn MoqTCPConn_starGenType_SetLinger_doFn) *MoqTCPConn_starGenType_SetLinger_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTCPConn_starGenType_SetLinger_fnRecorder) DoReturnResults(fn MoqTCPConn_starGenType_SetLinger_doReturnFn) *MoqTCPConn_starGenType_SetLinger_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetLinger_doFn
		DoReturnFn MoqTCPConn_starGenType_SetLinger_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTCPConn_starGenType_SetLinger_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTCPConn_starGenType_SetLinger_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetLinger {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTCPConn_starGenType_SetLinger_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTCPConn_starGenType_SetLinger_paramsKey]*MoqTCPConn_starGenType_SetLinger_results{},
		}
		r.Moq.ResultsByParams_SetLinger = append(r.Moq.ResultsByParams_SetLinger, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetLinger) {
			copy(r.Moq.ResultsByParams_SetLinger[insertAt+1:], r.Moq.ResultsByParams_SetLinger[insertAt:0])
			r.Moq.ResultsByParams_SetLinger[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetLinger(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTCPConn_starGenType_SetLinger_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTCPConn_starGenType_SetLinger_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTCPConn_starGenType_SetLinger_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqTCPConn_starGenType_SetLinger_doFn
				DoReturnFn MoqTCPConn_starGenType_SetLinger_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTCPConn_starGenType) PrettyParams_SetLinger(params MoqTCPConn_starGenType_SetLinger_params) string {
	return fmt.Sprintf("SetLinger(%#v)", params.Sec)
}

func (m *MoqTCPConn_starGenType) ParamsKey_SetLinger(params MoqTCPConn_starGenType_SetLinger_params, anyParams uint64) MoqTCPConn_starGenType_SetLinger_paramsKey {
	m.Scene.T.Helper()
	var secUsed int
	var secUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetLinger.Sec == moq.ParamIndexByValue {
			secUsed = params.Sec
		} else {
			secUsedHash = hash.DeepHash(params.Sec)
		}
	}
	return MoqTCPConn_starGenType_SetLinger_paramsKey{
		Params: struct{ Sec int }{
			Sec: secUsed,
		},
		Hashes: struct{ Sec hash.Hash }{
			Sec: secUsedHash,
		},
	}
}

func (m *MoqTCPConn_starGenType_recorder) SetKeepAlive(keepalive bool) *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder {
	return &MoqTCPConn_starGenType_SetKeepAlive_fnRecorder{
		Params: MoqTCPConn_starGenType_SetKeepAlive_params{
			Keepalive: keepalive,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder) Any() *MoqTCPConn_starGenType_SetKeepAlive_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetKeepAlive(r.Params))
		return nil
	}
	return &MoqTCPConn_starGenType_SetKeepAlive_anyParams{Recorder: r}
}

func (a *MoqTCPConn_starGenType_SetKeepAlive_anyParams) Keepalive() *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder) Seq() *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetKeepAlive(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder) NoSeq() *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetKeepAlive(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder) ReturnResults(result1 error) *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetKeepAlive_doFn
		DoReturnFn MoqTCPConn_starGenType_SetKeepAlive_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder) AndDo(fn MoqTCPConn_starGenType_SetKeepAlive_doFn) *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder) DoReturnResults(fn MoqTCPConn_starGenType_SetKeepAlive_doReturnFn) *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetKeepAlive_doFn
		DoReturnFn MoqTCPConn_starGenType_SetKeepAlive_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTCPConn_starGenType_SetKeepAlive_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetKeepAlive {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTCPConn_starGenType_SetKeepAlive_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTCPConn_starGenType_SetKeepAlive_paramsKey]*MoqTCPConn_starGenType_SetKeepAlive_results{},
		}
		r.Moq.ResultsByParams_SetKeepAlive = append(r.Moq.ResultsByParams_SetKeepAlive, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetKeepAlive) {
			copy(r.Moq.ResultsByParams_SetKeepAlive[insertAt+1:], r.Moq.ResultsByParams_SetKeepAlive[insertAt:0])
			r.Moq.ResultsByParams_SetKeepAlive[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetKeepAlive(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTCPConn_starGenType_SetKeepAlive_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTCPConn_starGenType_SetKeepAlive_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqTCPConn_starGenType_SetKeepAlive_doFn
				DoReturnFn MoqTCPConn_starGenType_SetKeepAlive_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTCPConn_starGenType) PrettyParams_SetKeepAlive(params MoqTCPConn_starGenType_SetKeepAlive_params) string {
	return fmt.Sprintf("SetKeepAlive(%#v)", params.Keepalive)
}

func (m *MoqTCPConn_starGenType) ParamsKey_SetKeepAlive(params MoqTCPConn_starGenType_SetKeepAlive_params, anyParams uint64) MoqTCPConn_starGenType_SetKeepAlive_paramsKey {
	m.Scene.T.Helper()
	var keepaliveUsed bool
	var keepaliveUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetKeepAlive.Keepalive == moq.ParamIndexByValue {
			keepaliveUsed = params.Keepalive
		} else {
			keepaliveUsedHash = hash.DeepHash(params.Keepalive)
		}
	}
	return MoqTCPConn_starGenType_SetKeepAlive_paramsKey{
		Params: struct{ Keepalive bool }{
			Keepalive: keepaliveUsed,
		},
		Hashes: struct{ Keepalive hash.Hash }{
			Keepalive: keepaliveUsedHash,
		},
	}
}

func (m *MoqTCPConn_starGenType_recorder) SetKeepAlivePeriod(d time.Duration) *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder {
	return &MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder{
		Params: MoqTCPConn_starGenType_SetKeepAlivePeriod_params{
			D: d,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder) Any() *MoqTCPConn_starGenType_SetKeepAlivePeriod_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetKeepAlivePeriod(r.Params))
		return nil
	}
	return &MoqTCPConn_starGenType_SetKeepAlivePeriod_anyParams{Recorder: r}
}

func (a *MoqTCPConn_starGenType_SetKeepAlivePeriod_anyParams) D() *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder) Seq() *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetKeepAlivePeriod(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder) NoSeq() *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetKeepAlivePeriod(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder) ReturnResults(result1 error) *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetKeepAlivePeriod_doFn
		DoReturnFn MoqTCPConn_starGenType_SetKeepAlivePeriod_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder) AndDo(fn MoqTCPConn_starGenType_SetKeepAlivePeriod_doFn) *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder) DoReturnResults(fn MoqTCPConn_starGenType_SetKeepAlivePeriod_doReturnFn) *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetKeepAlivePeriod_doFn
		DoReturnFn MoqTCPConn_starGenType_SetKeepAlivePeriod_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTCPConn_starGenType_SetKeepAlivePeriod_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetKeepAlivePeriod {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTCPConn_starGenType_SetKeepAlivePeriod_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTCPConn_starGenType_SetKeepAlivePeriod_paramsKey]*MoqTCPConn_starGenType_SetKeepAlivePeriod_results{},
		}
		r.Moq.ResultsByParams_SetKeepAlivePeriod = append(r.Moq.ResultsByParams_SetKeepAlivePeriod, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetKeepAlivePeriod) {
			copy(r.Moq.ResultsByParams_SetKeepAlivePeriod[insertAt+1:], r.Moq.ResultsByParams_SetKeepAlivePeriod[insertAt:0])
			r.Moq.ResultsByParams_SetKeepAlivePeriod[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetKeepAlivePeriod(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTCPConn_starGenType_SetKeepAlivePeriod_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTCPConn_starGenType_SetKeepAlivePeriod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqTCPConn_starGenType_SetKeepAlivePeriod_doFn
				DoReturnFn MoqTCPConn_starGenType_SetKeepAlivePeriod_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTCPConn_starGenType) PrettyParams_SetKeepAlivePeriod(params MoqTCPConn_starGenType_SetKeepAlivePeriod_params) string {
	return fmt.Sprintf("SetKeepAlivePeriod(%#v)", params.D)
}

func (m *MoqTCPConn_starGenType) ParamsKey_SetKeepAlivePeriod(params MoqTCPConn_starGenType_SetKeepAlivePeriod_params, anyParams uint64) MoqTCPConn_starGenType_SetKeepAlivePeriod_paramsKey {
	m.Scene.T.Helper()
	var dUsed time.Duration
	var dUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetKeepAlivePeriod.D == moq.ParamIndexByValue {
			dUsed = params.D
		} else {
			dUsedHash = hash.DeepHash(params.D)
		}
	}
	return MoqTCPConn_starGenType_SetKeepAlivePeriod_paramsKey{
		Params: struct{ D time.Duration }{
			D: dUsed,
		},
		Hashes: struct{ D hash.Hash }{
			D: dUsedHash,
		},
	}
}

func (m *MoqTCPConn_starGenType_recorder) SetNoDelay(noDelay bool) *MoqTCPConn_starGenType_SetNoDelay_fnRecorder {
	return &MoqTCPConn_starGenType_SetNoDelay_fnRecorder{
		Params: MoqTCPConn_starGenType_SetNoDelay_params{
			NoDelay: noDelay,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTCPConn_starGenType_SetNoDelay_fnRecorder) Any() *MoqTCPConn_starGenType_SetNoDelay_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetNoDelay(r.Params))
		return nil
	}
	return &MoqTCPConn_starGenType_SetNoDelay_anyParams{Recorder: r}
}

func (a *MoqTCPConn_starGenType_SetNoDelay_anyParams) NoDelay() *MoqTCPConn_starGenType_SetNoDelay_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTCPConn_starGenType_SetNoDelay_fnRecorder) Seq() *MoqTCPConn_starGenType_SetNoDelay_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetNoDelay(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTCPConn_starGenType_SetNoDelay_fnRecorder) NoSeq() *MoqTCPConn_starGenType_SetNoDelay_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetNoDelay(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTCPConn_starGenType_SetNoDelay_fnRecorder) ReturnResults(result1 error) *MoqTCPConn_starGenType_SetNoDelay_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetNoDelay_doFn
		DoReturnFn MoqTCPConn_starGenType_SetNoDelay_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTCPConn_starGenType_SetNoDelay_fnRecorder) AndDo(fn MoqTCPConn_starGenType_SetNoDelay_doFn) *MoqTCPConn_starGenType_SetNoDelay_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTCPConn_starGenType_SetNoDelay_fnRecorder) DoReturnResults(fn MoqTCPConn_starGenType_SetNoDelay_doReturnFn) *MoqTCPConn_starGenType_SetNoDelay_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqTCPConn_starGenType_SetNoDelay_doFn
		DoReturnFn MoqTCPConn_starGenType_SetNoDelay_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTCPConn_starGenType_SetNoDelay_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTCPConn_starGenType_SetNoDelay_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetNoDelay {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTCPConn_starGenType_SetNoDelay_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTCPConn_starGenType_SetNoDelay_paramsKey]*MoqTCPConn_starGenType_SetNoDelay_results{},
		}
		r.Moq.ResultsByParams_SetNoDelay = append(r.Moq.ResultsByParams_SetNoDelay, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetNoDelay) {
			copy(r.Moq.ResultsByParams_SetNoDelay[insertAt+1:], r.Moq.ResultsByParams_SetNoDelay[insertAt:0])
			r.Moq.ResultsByParams_SetNoDelay[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetNoDelay(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTCPConn_starGenType_SetNoDelay_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTCPConn_starGenType_SetNoDelay_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTCPConn_starGenType_SetNoDelay_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqTCPConn_starGenType_SetNoDelay_doFn
				DoReturnFn MoqTCPConn_starGenType_SetNoDelay_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTCPConn_starGenType) PrettyParams_SetNoDelay(params MoqTCPConn_starGenType_SetNoDelay_params) string {
	return fmt.Sprintf("SetNoDelay(%#v)", params.NoDelay)
}

func (m *MoqTCPConn_starGenType) ParamsKey_SetNoDelay(params MoqTCPConn_starGenType_SetNoDelay_params, anyParams uint64) MoqTCPConn_starGenType_SetNoDelay_paramsKey {
	m.Scene.T.Helper()
	var noDelayUsed bool
	var noDelayUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetNoDelay.NoDelay == moq.ParamIndexByValue {
			noDelayUsed = params.NoDelay
		} else {
			noDelayUsedHash = hash.DeepHash(params.NoDelay)
		}
	}
	return MoqTCPConn_starGenType_SetNoDelay_paramsKey{
		Params: struct{ NoDelay bool }{
			NoDelay: noDelayUsed,
		},
		Hashes: struct{ NoDelay hash.Hash }{
			NoDelay: noDelayUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqTCPConn_starGenType) Reset() {
	m.ResultsByParams_SyscallConn = nil
	m.ResultsByParams_ReadFrom = nil
	m.ResultsByParams_CloseRead = nil
	m.ResultsByParams_CloseWrite = nil
	m.ResultsByParams_SetLinger = nil
	m.ResultsByParams_SetKeepAlive = nil
	m.ResultsByParams_SetKeepAlivePeriod = nil
	m.ResultsByParams_SetNoDelay = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqTCPConn_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_SyscallConn {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SyscallConn(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReadFrom {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReadFrom(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_CloseRead {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_CloseRead(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_CloseWrite {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_CloseWrite(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetLinger {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetLinger(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetKeepAlive {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetKeepAlive(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetKeepAlivePeriod {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetKeepAlivePeriod(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetNoDelay {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetNoDelay(results.Params))
			}
		}
	}
}
