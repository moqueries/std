// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package url

import (
	"fmt"
	"math/bits"
	"net/url"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that url.URL_starGenType is mocked
// completely
var _ URL_starGenType = (*MoqURL_starGenType_mock)(nil)

// URL_starGenType is the fabricated implementation type of this mock (emitted
// when mocking a collections of methods directly and not from an interface
// type)
type URL_starGenType interface {
	EscapedPath() string
	EscapedFragment() string
	String() string
	Redacted() string
	IsAbs() bool
	Parse(ref string) (*url.URL, error)
	ResolveReference(ref *url.URL) *url.URL
	Query() url.Values
	RequestURI() string
	Hostname() string
	Port() string
	MarshalBinary() (text []byte, err error)
	UnmarshalBinary(text []byte) error
}

// MoqURL_starGenType holds the state of a moq of the URL_starGenType type
type MoqURL_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqURL_starGenType_mock

	ResultsByParams_EscapedPath      []MoqURL_starGenType_EscapedPath_resultsByParams
	ResultsByParams_EscapedFragment  []MoqURL_starGenType_EscapedFragment_resultsByParams
	ResultsByParams_String           []MoqURL_starGenType_String_resultsByParams
	ResultsByParams_Redacted         []MoqURL_starGenType_Redacted_resultsByParams
	ResultsByParams_IsAbs            []MoqURL_starGenType_IsAbs_resultsByParams
	ResultsByParams_Parse            []MoqURL_starGenType_Parse_resultsByParams
	ResultsByParams_ResolveReference []MoqURL_starGenType_ResolveReference_resultsByParams
	ResultsByParams_Query            []MoqURL_starGenType_Query_resultsByParams
	ResultsByParams_RequestURI       []MoqURL_starGenType_RequestURI_resultsByParams
	ResultsByParams_Hostname         []MoqURL_starGenType_Hostname_resultsByParams
	ResultsByParams_Port             []MoqURL_starGenType_Port_resultsByParams
	ResultsByParams_MarshalBinary    []MoqURL_starGenType_MarshalBinary_resultsByParams
	ResultsByParams_UnmarshalBinary  []MoqURL_starGenType_UnmarshalBinary_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			EscapedPath     struct{}
			EscapedFragment struct{}
			String          struct{}
			Redacted        struct{}
			IsAbs           struct{}
			Parse           struct {
				Ref moq.ParamIndexing
			}
			ResolveReference struct {
				Ref moq.ParamIndexing
			}
			Query           struct{}
			RequestURI      struct{}
			Hostname        struct{}
			Port            struct{}
			MarshalBinary   struct{}
			UnmarshalBinary struct {
				Text moq.ParamIndexing
			}
		}
	}
	// MoqURL_starGenType_mock isolates the mock interface of the URL_starGenType
}

// type
type MoqURL_starGenType_mock struct {
	Moq *MoqURL_starGenType
}

// MoqURL_starGenType_recorder isolates the recorder interface of the
// URL_starGenType type
type MoqURL_starGenType_recorder struct {
	Moq *MoqURL_starGenType
}

// MoqURL_starGenType_EscapedPath_params holds the params of the
// URL_starGenType type
type MoqURL_starGenType_EscapedPath_params struct{}

// MoqURL_starGenType_EscapedPath_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_EscapedPath_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqURL_starGenType_EscapedPath_resultsByParams contains the results for a
// given set of parameters for the URL_starGenType type
type MoqURL_starGenType_EscapedPath_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_EscapedPath_paramsKey]*MoqURL_starGenType_EscapedPath_results
}

// MoqURL_starGenType_EscapedPath_doFn defines the type of function needed when
// calling AndDo for the URL_starGenType type
type MoqURL_starGenType_EscapedPath_doFn func()

// MoqURL_starGenType_EscapedPath_doReturnFn defines the type of function
// needed when calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_EscapedPath_doReturnFn func() string

// MoqURL_starGenType_EscapedPath_results holds the results of the
// URL_starGenType type
type MoqURL_starGenType_EscapedPath_results struct {
	Params  MoqURL_starGenType_EscapedPath_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_EscapedPath_doFn
		DoReturnFn MoqURL_starGenType_EscapedPath_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_EscapedPath_fnRecorder routes recorded function calls to
// the MoqURL_starGenType moq
type MoqURL_starGenType_EscapedPath_fnRecorder struct {
	Params    MoqURL_starGenType_EscapedPath_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_EscapedPath_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_EscapedPath_anyParams isolates the any params functions
// of the URL_starGenType type
type MoqURL_starGenType_EscapedPath_anyParams struct {
	Recorder *MoqURL_starGenType_EscapedPath_fnRecorder
}

// MoqURL_starGenType_EscapedFragment_params holds the params of the
// URL_starGenType type
type MoqURL_starGenType_EscapedFragment_params struct{}

// MoqURL_starGenType_EscapedFragment_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_EscapedFragment_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqURL_starGenType_EscapedFragment_resultsByParams contains the results for
// a given set of parameters for the URL_starGenType type
type MoqURL_starGenType_EscapedFragment_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_EscapedFragment_paramsKey]*MoqURL_starGenType_EscapedFragment_results
}

// MoqURL_starGenType_EscapedFragment_doFn defines the type of function needed
// when calling AndDo for the URL_starGenType type
type MoqURL_starGenType_EscapedFragment_doFn func()

// MoqURL_starGenType_EscapedFragment_doReturnFn defines the type of function
// needed when calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_EscapedFragment_doReturnFn func() string

// MoqURL_starGenType_EscapedFragment_results holds the results of the
// URL_starGenType type
type MoqURL_starGenType_EscapedFragment_results struct {
	Params  MoqURL_starGenType_EscapedFragment_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_EscapedFragment_doFn
		DoReturnFn MoqURL_starGenType_EscapedFragment_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_EscapedFragment_fnRecorder routes recorded function calls
// to the MoqURL_starGenType moq
type MoqURL_starGenType_EscapedFragment_fnRecorder struct {
	Params    MoqURL_starGenType_EscapedFragment_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_EscapedFragment_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_EscapedFragment_anyParams isolates the any params
// functions of the URL_starGenType type
type MoqURL_starGenType_EscapedFragment_anyParams struct {
	Recorder *MoqURL_starGenType_EscapedFragment_fnRecorder
}

// MoqURL_starGenType_String_params holds the params of the URL_starGenType
// type
type MoqURL_starGenType_String_params struct{}

// MoqURL_starGenType_String_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqURL_starGenType_String_resultsByParams contains the results for a given
// set of parameters for the URL_starGenType type
type MoqURL_starGenType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_String_paramsKey]*MoqURL_starGenType_String_results
}

// MoqURL_starGenType_String_doFn defines the type of function needed when
// calling AndDo for the URL_starGenType type
type MoqURL_starGenType_String_doFn func()

// MoqURL_starGenType_String_doReturnFn defines the type of function needed
// when calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_String_doReturnFn func() string

// MoqURL_starGenType_String_results holds the results of the URL_starGenType
// type
type MoqURL_starGenType_String_results struct {
	Params  MoqURL_starGenType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_String_doFn
		DoReturnFn MoqURL_starGenType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_String_fnRecorder routes recorded function calls to the
// MoqURL_starGenType moq
type MoqURL_starGenType_String_fnRecorder struct {
	Params    MoqURL_starGenType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_String_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_String_anyParams isolates the any params functions of the
// URL_starGenType type
type MoqURL_starGenType_String_anyParams struct {
	Recorder *MoqURL_starGenType_String_fnRecorder
}

// MoqURL_starGenType_Redacted_params holds the params of the URL_starGenType
// type
type MoqURL_starGenType_Redacted_params struct{}

// MoqURL_starGenType_Redacted_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_Redacted_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqURL_starGenType_Redacted_resultsByParams contains the results for a given
// set of parameters for the URL_starGenType type
type MoqURL_starGenType_Redacted_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_Redacted_paramsKey]*MoqURL_starGenType_Redacted_results
}

// MoqURL_starGenType_Redacted_doFn defines the type of function needed when
// calling AndDo for the URL_starGenType type
type MoqURL_starGenType_Redacted_doFn func()

// MoqURL_starGenType_Redacted_doReturnFn defines the type of function needed
// when calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_Redacted_doReturnFn func() string

// MoqURL_starGenType_Redacted_results holds the results of the URL_starGenType
// type
type MoqURL_starGenType_Redacted_results struct {
	Params  MoqURL_starGenType_Redacted_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Redacted_doFn
		DoReturnFn MoqURL_starGenType_Redacted_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_Redacted_fnRecorder routes recorded function calls to the
// MoqURL_starGenType moq
type MoqURL_starGenType_Redacted_fnRecorder struct {
	Params    MoqURL_starGenType_Redacted_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_Redacted_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_Redacted_anyParams isolates the any params functions of
// the URL_starGenType type
type MoqURL_starGenType_Redacted_anyParams struct {
	Recorder *MoqURL_starGenType_Redacted_fnRecorder
}

// MoqURL_starGenType_IsAbs_params holds the params of the URL_starGenType type
type MoqURL_starGenType_IsAbs_params struct{}

// MoqURL_starGenType_IsAbs_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_IsAbs_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqURL_starGenType_IsAbs_resultsByParams contains the results for a given
// set of parameters for the URL_starGenType type
type MoqURL_starGenType_IsAbs_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_IsAbs_paramsKey]*MoqURL_starGenType_IsAbs_results
}

// MoqURL_starGenType_IsAbs_doFn defines the type of function needed when
// calling AndDo for the URL_starGenType type
type MoqURL_starGenType_IsAbs_doFn func()

// MoqURL_starGenType_IsAbs_doReturnFn defines the type of function needed when
// calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_IsAbs_doReturnFn func() bool

// MoqURL_starGenType_IsAbs_results holds the results of the URL_starGenType
// type
type MoqURL_starGenType_IsAbs_results struct {
	Params  MoqURL_starGenType_IsAbs_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_IsAbs_doFn
		DoReturnFn MoqURL_starGenType_IsAbs_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_IsAbs_fnRecorder routes recorded function calls to the
// MoqURL_starGenType moq
type MoqURL_starGenType_IsAbs_fnRecorder struct {
	Params    MoqURL_starGenType_IsAbs_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_IsAbs_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_IsAbs_anyParams isolates the any params functions of the
// URL_starGenType type
type MoqURL_starGenType_IsAbs_anyParams struct {
	Recorder *MoqURL_starGenType_IsAbs_fnRecorder
}

// MoqURL_starGenType_Parse_params holds the params of the URL_starGenType type
type MoqURL_starGenType_Parse_params struct{ Ref string }

// MoqURL_starGenType_Parse_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_Parse_paramsKey struct {
	Params struct{ Ref string }
	Hashes struct{ Ref hash.Hash }
}

// MoqURL_starGenType_Parse_resultsByParams contains the results for a given
// set of parameters for the URL_starGenType type
type MoqURL_starGenType_Parse_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_Parse_paramsKey]*MoqURL_starGenType_Parse_results
}

// MoqURL_starGenType_Parse_doFn defines the type of function needed when
// calling AndDo for the URL_starGenType type
type MoqURL_starGenType_Parse_doFn func(ref string)

// MoqURL_starGenType_Parse_doReturnFn defines the type of function needed when
// calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_Parse_doReturnFn func(ref string) (*url.URL, error)

// MoqURL_starGenType_Parse_results holds the results of the URL_starGenType
// type
type MoqURL_starGenType_Parse_results struct {
	Params  MoqURL_starGenType_Parse_params
	Results []struct {
		Values *struct {
			Result1 *url.URL
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Parse_doFn
		DoReturnFn MoqURL_starGenType_Parse_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_Parse_fnRecorder routes recorded function calls to the
// MoqURL_starGenType moq
type MoqURL_starGenType_Parse_fnRecorder struct {
	Params    MoqURL_starGenType_Parse_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_Parse_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_Parse_anyParams isolates the any params functions of the
// URL_starGenType type
type MoqURL_starGenType_Parse_anyParams struct {
	Recorder *MoqURL_starGenType_Parse_fnRecorder
}

// MoqURL_starGenType_ResolveReference_params holds the params of the
// URL_starGenType type
type MoqURL_starGenType_ResolveReference_params struct{ Ref *url.URL }

// MoqURL_starGenType_ResolveReference_paramsKey holds the map key params of
// the URL_starGenType type
type MoqURL_starGenType_ResolveReference_paramsKey struct {
	Params struct{ Ref *url.URL }
	Hashes struct{ Ref hash.Hash }
}

// MoqURL_starGenType_ResolveReference_resultsByParams contains the results for
// a given set of parameters for the URL_starGenType type
type MoqURL_starGenType_ResolveReference_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_ResolveReference_paramsKey]*MoqURL_starGenType_ResolveReference_results
}

// MoqURL_starGenType_ResolveReference_doFn defines the type of function needed
// when calling AndDo for the URL_starGenType type
type MoqURL_starGenType_ResolveReference_doFn func(ref *url.URL)

// MoqURL_starGenType_ResolveReference_doReturnFn defines the type of function
// needed when calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_ResolveReference_doReturnFn func(ref *url.URL) *url.URL

// MoqURL_starGenType_ResolveReference_results holds the results of the
// URL_starGenType type
type MoqURL_starGenType_ResolveReference_results struct {
	Params  MoqURL_starGenType_ResolveReference_params
	Results []struct {
		Values *struct {
			Result1 *url.URL
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_ResolveReference_doFn
		DoReturnFn MoqURL_starGenType_ResolveReference_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_ResolveReference_fnRecorder routes recorded function
// calls to the MoqURL_starGenType moq
type MoqURL_starGenType_ResolveReference_fnRecorder struct {
	Params    MoqURL_starGenType_ResolveReference_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_ResolveReference_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_ResolveReference_anyParams isolates the any params
// functions of the URL_starGenType type
type MoqURL_starGenType_ResolveReference_anyParams struct {
	Recorder *MoqURL_starGenType_ResolveReference_fnRecorder
}

// MoqURL_starGenType_Query_params holds the params of the URL_starGenType type
type MoqURL_starGenType_Query_params struct{}

// MoqURL_starGenType_Query_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_Query_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqURL_starGenType_Query_resultsByParams contains the results for a given
// set of parameters for the URL_starGenType type
type MoqURL_starGenType_Query_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_Query_paramsKey]*MoqURL_starGenType_Query_results
}

// MoqURL_starGenType_Query_doFn defines the type of function needed when
// calling AndDo for the URL_starGenType type
type MoqURL_starGenType_Query_doFn func()

// MoqURL_starGenType_Query_doReturnFn defines the type of function needed when
// calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_Query_doReturnFn func() url.Values

// MoqURL_starGenType_Query_results holds the results of the URL_starGenType
// type
type MoqURL_starGenType_Query_results struct {
	Params  MoqURL_starGenType_Query_params
	Results []struct {
		Values *struct {
			Result1 url.Values
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Query_doFn
		DoReturnFn MoqURL_starGenType_Query_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_Query_fnRecorder routes recorded function calls to the
// MoqURL_starGenType moq
type MoqURL_starGenType_Query_fnRecorder struct {
	Params    MoqURL_starGenType_Query_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_Query_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_Query_anyParams isolates the any params functions of the
// URL_starGenType type
type MoqURL_starGenType_Query_anyParams struct {
	Recorder *MoqURL_starGenType_Query_fnRecorder
}

// MoqURL_starGenType_RequestURI_params holds the params of the URL_starGenType
// type
type MoqURL_starGenType_RequestURI_params struct{}

// MoqURL_starGenType_RequestURI_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_RequestURI_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqURL_starGenType_RequestURI_resultsByParams contains the results for a
// given set of parameters for the URL_starGenType type
type MoqURL_starGenType_RequestURI_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_RequestURI_paramsKey]*MoqURL_starGenType_RequestURI_results
}

// MoqURL_starGenType_RequestURI_doFn defines the type of function needed when
// calling AndDo for the URL_starGenType type
type MoqURL_starGenType_RequestURI_doFn func()

// MoqURL_starGenType_RequestURI_doReturnFn defines the type of function needed
// when calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_RequestURI_doReturnFn func() string

// MoqURL_starGenType_RequestURI_results holds the results of the
// URL_starGenType type
type MoqURL_starGenType_RequestURI_results struct {
	Params  MoqURL_starGenType_RequestURI_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_RequestURI_doFn
		DoReturnFn MoqURL_starGenType_RequestURI_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_RequestURI_fnRecorder routes recorded function calls to
// the MoqURL_starGenType moq
type MoqURL_starGenType_RequestURI_fnRecorder struct {
	Params    MoqURL_starGenType_RequestURI_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_RequestURI_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_RequestURI_anyParams isolates the any params functions of
// the URL_starGenType type
type MoqURL_starGenType_RequestURI_anyParams struct {
	Recorder *MoqURL_starGenType_RequestURI_fnRecorder
}

// MoqURL_starGenType_Hostname_params holds the params of the URL_starGenType
// type
type MoqURL_starGenType_Hostname_params struct{}

// MoqURL_starGenType_Hostname_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_Hostname_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqURL_starGenType_Hostname_resultsByParams contains the results for a given
// set of parameters for the URL_starGenType type
type MoqURL_starGenType_Hostname_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_Hostname_paramsKey]*MoqURL_starGenType_Hostname_results
}

// MoqURL_starGenType_Hostname_doFn defines the type of function needed when
// calling AndDo for the URL_starGenType type
type MoqURL_starGenType_Hostname_doFn func()

// MoqURL_starGenType_Hostname_doReturnFn defines the type of function needed
// when calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_Hostname_doReturnFn func() string

// MoqURL_starGenType_Hostname_results holds the results of the URL_starGenType
// type
type MoqURL_starGenType_Hostname_results struct {
	Params  MoqURL_starGenType_Hostname_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Hostname_doFn
		DoReturnFn MoqURL_starGenType_Hostname_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_Hostname_fnRecorder routes recorded function calls to the
// MoqURL_starGenType moq
type MoqURL_starGenType_Hostname_fnRecorder struct {
	Params    MoqURL_starGenType_Hostname_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_Hostname_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_Hostname_anyParams isolates the any params functions of
// the URL_starGenType type
type MoqURL_starGenType_Hostname_anyParams struct {
	Recorder *MoqURL_starGenType_Hostname_fnRecorder
}

// MoqURL_starGenType_Port_params holds the params of the URL_starGenType type
type MoqURL_starGenType_Port_params struct{}

// MoqURL_starGenType_Port_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_Port_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqURL_starGenType_Port_resultsByParams contains the results for a given set
// of parameters for the URL_starGenType type
type MoqURL_starGenType_Port_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_Port_paramsKey]*MoqURL_starGenType_Port_results
}

// MoqURL_starGenType_Port_doFn defines the type of function needed when
// calling AndDo for the URL_starGenType type
type MoqURL_starGenType_Port_doFn func()

// MoqURL_starGenType_Port_doReturnFn defines the type of function needed when
// calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_Port_doReturnFn func() string

// MoqURL_starGenType_Port_results holds the results of the URL_starGenType
// type
type MoqURL_starGenType_Port_results struct {
	Params  MoqURL_starGenType_Port_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Port_doFn
		DoReturnFn MoqURL_starGenType_Port_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_Port_fnRecorder routes recorded function calls to the
// MoqURL_starGenType moq
type MoqURL_starGenType_Port_fnRecorder struct {
	Params    MoqURL_starGenType_Port_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_Port_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_Port_anyParams isolates the any params functions of the
// URL_starGenType type
type MoqURL_starGenType_Port_anyParams struct {
	Recorder *MoqURL_starGenType_Port_fnRecorder
}

// MoqURL_starGenType_MarshalBinary_params holds the params of the
// URL_starGenType type
type MoqURL_starGenType_MarshalBinary_params struct{}

// MoqURL_starGenType_MarshalBinary_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_MarshalBinary_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqURL_starGenType_MarshalBinary_resultsByParams contains the results for a
// given set of parameters for the URL_starGenType type
type MoqURL_starGenType_MarshalBinary_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_MarshalBinary_paramsKey]*MoqURL_starGenType_MarshalBinary_results
}

// MoqURL_starGenType_MarshalBinary_doFn defines the type of function needed
// when calling AndDo for the URL_starGenType type
type MoqURL_starGenType_MarshalBinary_doFn func()

// MoqURL_starGenType_MarshalBinary_doReturnFn defines the type of function
// needed when calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_MarshalBinary_doReturnFn func() (text []byte, err error)

// MoqURL_starGenType_MarshalBinary_results holds the results of the
// URL_starGenType type
type MoqURL_starGenType_MarshalBinary_results struct {
	Params  MoqURL_starGenType_MarshalBinary_params
	Results []struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_MarshalBinary_doFn
		DoReturnFn MoqURL_starGenType_MarshalBinary_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_MarshalBinary_fnRecorder routes recorded function calls
// to the MoqURL_starGenType moq
type MoqURL_starGenType_MarshalBinary_fnRecorder struct {
	Params    MoqURL_starGenType_MarshalBinary_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_MarshalBinary_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_MarshalBinary_anyParams isolates the any params functions
// of the URL_starGenType type
type MoqURL_starGenType_MarshalBinary_anyParams struct {
	Recorder *MoqURL_starGenType_MarshalBinary_fnRecorder
}

// MoqURL_starGenType_UnmarshalBinary_params holds the params of the
// URL_starGenType type
type MoqURL_starGenType_UnmarshalBinary_params struct{ Text []byte }

// MoqURL_starGenType_UnmarshalBinary_paramsKey holds the map key params of the
// URL_starGenType type
type MoqURL_starGenType_UnmarshalBinary_paramsKey struct {
	Params struct{}
	Hashes struct{ Text hash.Hash }
}

// MoqURL_starGenType_UnmarshalBinary_resultsByParams contains the results for
// a given set of parameters for the URL_starGenType type
type MoqURL_starGenType_UnmarshalBinary_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqURL_starGenType_UnmarshalBinary_paramsKey]*MoqURL_starGenType_UnmarshalBinary_results
}

// MoqURL_starGenType_UnmarshalBinary_doFn defines the type of function needed
// when calling AndDo for the URL_starGenType type
type MoqURL_starGenType_UnmarshalBinary_doFn func(text []byte)

// MoqURL_starGenType_UnmarshalBinary_doReturnFn defines the type of function
// needed when calling DoReturnResults for the URL_starGenType type
type MoqURL_starGenType_UnmarshalBinary_doReturnFn func(text []byte) error

// MoqURL_starGenType_UnmarshalBinary_results holds the results of the
// URL_starGenType type
type MoqURL_starGenType_UnmarshalBinary_results struct {
	Params  MoqURL_starGenType_UnmarshalBinary_params
	Results []struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_UnmarshalBinary_doFn
		DoReturnFn MoqURL_starGenType_UnmarshalBinary_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqURL_starGenType_UnmarshalBinary_fnRecorder routes recorded function calls
// to the MoqURL_starGenType moq
type MoqURL_starGenType_UnmarshalBinary_fnRecorder struct {
	Params    MoqURL_starGenType_UnmarshalBinary_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqURL_starGenType_UnmarshalBinary_results
	Moq       *MoqURL_starGenType
}

// MoqURL_starGenType_UnmarshalBinary_anyParams isolates the any params
// functions of the URL_starGenType type
type MoqURL_starGenType_UnmarshalBinary_anyParams struct {
	Recorder *MoqURL_starGenType_UnmarshalBinary_fnRecorder
}

// NewMoqURL_starGenType creates a new moq of the URL_starGenType type
func NewMoqURL_starGenType(scene *moq.Scene, config *moq.Config) *MoqURL_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqURL_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqURL_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				EscapedPath     struct{}
				EscapedFragment struct{}
				String          struct{}
				Redacted        struct{}
				IsAbs           struct{}
				Parse           struct {
					Ref moq.ParamIndexing
				}
				ResolveReference struct {
					Ref moq.ParamIndexing
				}
				Query           struct{}
				RequestURI      struct{}
				Hostname        struct{}
				Port            struct{}
				MarshalBinary   struct{}
				UnmarshalBinary struct {
					Text moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			EscapedPath     struct{}
			EscapedFragment struct{}
			String          struct{}
			Redacted        struct{}
			IsAbs           struct{}
			Parse           struct {
				Ref moq.ParamIndexing
			}
			ResolveReference struct {
				Ref moq.ParamIndexing
			}
			Query           struct{}
			RequestURI      struct{}
			Hostname        struct{}
			Port            struct{}
			MarshalBinary   struct{}
			UnmarshalBinary struct {
				Text moq.ParamIndexing
			}
		}{
			EscapedPath:     struct{}{},
			EscapedFragment: struct{}{},
			String:          struct{}{},
			Redacted:        struct{}{},
			IsAbs:           struct{}{},
			Parse: struct {
				Ref moq.ParamIndexing
			}{
				Ref: moq.ParamIndexByValue,
			},
			ResolveReference: struct {
				Ref moq.ParamIndexing
			}{
				Ref: moq.ParamIndexByHash,
			},
			Query:         struct{}{},
			RequestURI:    struct{}{},
			Hostname:      struct{}{},
			Port:          struct{}{},
			MarshalBinary: struct{}{},
			UnmarshalBinary: struct {
				Text moq.ParamIndexing
			}{
				Text: moq.ParamIndexByHash,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the URL_starGenType type
func (m *MoqURL_starGenType) Mock() *MoqURL_starGenType_mock { return m.Moq }

func (m *MoqURL_starGenType_mock) EscapedPath() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_EscapedPath_params{}
	var results *MoqURL_starGenType_EscapedPath_results
	for _, resultsByParams := range m.Moq.ResultsByParams_EscapedPath {
		paramsKey := m.Moq.ParamsKey_EscapedPath(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_EscapedPath(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_EscapedPath(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_EscapedPath(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqURL_starGenType_mock) EscapedFragment() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_EscapedFragment_params{}
	var results *MoqURL_starGenType_EscapedFragment_results
	for _, resultsByParams := range m.Moq.ResultsByParams_EscapedFragment {
		paramsKey := m.Moq.ParamsKey_EscapedFragment(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_EscapedFragment(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_EscapedFragment(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_EscapedFragment(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqURL_starGenType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_String_params{}
	var results *MoqURL_starGenType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqURL_starGenType_mock) Redacted() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_Redacted_params{}
	var results *MoqURL_starGenType_Redacted_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Redacted {
		paramsKey := m.Moq.ParamsKey_Redacted(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Redacted(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Redacted(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Redacted(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqURL_starGenType_mock) IsAbs() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_IsAbs_params{}
	var results *MoqURL_starGenType_IsAbs_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsAbs {
		paramsKey := m.Moq.ParamsKey_IsAbs(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsAbs(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsAbs(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsAbs(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqURL_starGenType_mock) Parse(ref string) (result1 *url.URL, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_Parse_params{
		Ref: ref,
	}
	var results *MoqURL_starGenType_Parse_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Parse {
		paramsKey := m.Moq.ParamsKey_Parse(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Parse(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Parse(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Parse(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ref)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(ref)
	}
	return
}

func (m *MoqURL_starGenType_mock) ResolveReference(ref *url.URL) (result1 *url.URL) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_ResolveReference_params{
		Ref: ref,
	}
	var results *MoqURL_starGenType_ResolveReference_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ResolveReference {
		paramsKey := m.Moq.ParamsKey_ResolveReference(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ResolveReference(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ResolveReference(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ResolveReference(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ref)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(ref)
	}
	return
}

func (m *MoqURL_starGenType_mock) Query() (result1 url.Values) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_Query_params{}
	var results *MoqURL_starGenType_Query_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Query {
		paramsKey := m.Moq.ParamsKey_Query(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Query(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Query(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Query(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqURL_starGenType_mock) RequestURI() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_RequestURI_params{}
	var results *MoqURL_starGenType_RequestURI_results
	for _, resultsByParams := range m.Moq.ResultsByParams_RequestURI {
		paramsKey := m.Moq.ParamsKey_RequestURI(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_RequestURI(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_RequestURI(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_RequestURI(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqURL_starGenType_mock) Hostname() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_Hostname_params{}
	var results *MoqURL_starGenType_Hostname_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Hostname {
		paramsKey := m.Moq.ParamsKey_Hostname(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Hostname(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Hostname(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Hostname(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqURL_starGenType_mock) Port() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_Port_params{}
	var results *MoqURL_starGenType_Port_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Port {
		paramsKey := m.Moq.ParamsKey_Port(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Port(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Port(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Port(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqURL_starGenType_mock) MarshalBinary() (text []byte, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_MarshalBinary_params{}
	var results *MoqURL_starGenType_MarshalBinary_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MarshalBinary {
		paramsKey := m.Moq.ParamsKey_MarshalBinary(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MarshalBinary(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MarshalBinary(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MarshalBinary(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		text = result.Values.Text
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		text, err = result.DoReturnFn()
	}
	return
}

func (m *MoqURL_starGenType_mock) UnmarshalBinary(text []byte) (result1 error) {
	m.Moq.Scene.T.Helper()
	params := MoqURL_starGenType_UnmarshalBinary_params{
		Text: text,
	}
	var results *MoqURL_starGenType_UnmarshalBinary_results
	for _, resultsByParams := range m.Moq.ResultsByParams_UnmarshalBinary {
		paramsKey := m.Moq.ParamsKey_UnmarshalBinary(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_UnmarshalBinary(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_UnmarshalBinary(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_UnmarshalBinary(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(text)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(text)
	}
	return
}

// OnCall returns the recorder implementation of the URL_starGenType type
func (m *MoqURL_starGenType) OnCall() *MoqURL_starGenType_recorder {
	return &MoqURL_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqURL_starGenType_recorder) EscapedPath() *MoqURL_starGenType_EscapedPath_fnRecorder {
	return &MoqURL_starGenType_EscapedPath_fnRecorder{
		Params:   MoqURL_starGenType_EscapedPath_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_EscapedPath_fnRecorder) Any() *MoqURL_starGenType_EscapedPath_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_EscapedPath(r.Params))
		return nil
	}
	return &MoqURL_starGenType_EscapedPath_anyParams{Recorder: r}
}

func (r *MoqURL_starGenType_EscapedPath_fnRecorder) Seq() *MoqURL_starGenType_EscapedPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_EscapedPath(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_EscapedPath_fnRecorder) NoSeq() *MoqURL_starGenType_EscapedPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_EscapedPath(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_EscapedPath_fnRecorder) ReturnResults(result1 string) *MoqURL_starGenType_EscapedPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_EscapedPath_doFn
		DoReturnFn MoqURL_starGenType_EscapedPath_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_EscapedPath_fnRecorder) AndDo(fn MoqURL_starGenType_EscapedPath_doFn) *MoqURL_starGenType_EscapedPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_EscapedPath_fnRecorder) DoReturnResults(fn MoqURL_starGenType_EscapedPath_doReturnFn) *MoqURL_starGenType_EscapedPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_EscapedPath_doFn
		DoReturnFn MoqURL_starGenType_EscapedPath_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_EscapedPath_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_EscapedPath_resultsByParams
	for n, res := range r.Moq.ResultsByParams_EscapedPath {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_EscapedPath_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_EscapedPath_paramsKey]*MoqURL_starGenType_EscapedPath_results{},
		}
		r.Moq.ResultsByParams_EscapedPath = append(r.Moq.ResultsByParams_EscapedPath, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_EscapedPath) {
			copy(r.Moq.ResultsByParams_EscapedPath[insertAt+1:], r.Moq.ResultsByParams_EscapedPath[insertAt:0])
			r.Moq.ResultsByParams_EscapedPath[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_EscapedPath(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_EscapedPath_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_EscapedPath_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_EscapedPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_EscapedPath_doFn
				DoReturnFn MoqURL_starGenType_EscapedPath_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_EscapedPath(params MoqURL_starGenType_EscapedPath_params) string {
	return fmt.Sprintf("EscapedPath()")
}

func (m *MoqURL_starGenType) ParamsKey_EscapedPath(params MoqURL_starGenType_EscapedPath_params, anyParams uint64) MoqURL_starGenType_EscapedPath_paramsKey {
	m.Scene.T.Helper()
	return MoqURL_starGenType_EscapedPath_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqURL_starGenType_recorder) EscapedFragment() *MoqURL_starGenType_EscapedFragment_fnRecorder {
	return &MoqURL_starGenType_EscapedFragment_fnRecorder{
		Params:   MoqURL_starGenType_EscapedFragment_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_EscapedFragment_fnRecorder) Any() *MoqURL_starGenType_EscapedFragment_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_EscapedFragment(r.Params))
		return nil
	}
	return &MoqURL_starGenType_EscapedFragment_anyParams{Recorder: r}
}

func (r *MoqURL_starGenType_EscapedFragment_fnRecorder) Seq() *MoqURL_starGenType_EscapedFragment_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_EscapedFragment(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_EscapedFragment_fnRecorder) NoSeq() *MoqURL_starGenType_EscapedFragment_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_EscapedFragment(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_EscapedFragment_fnRecorder) ReturnResults(result1 string) *MoqURL_starGenType_EscapedFragment_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_EscapedFragment_doFn
		DoReturnFn MoqURL_starGenType_EscapedFragment_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_EscapedFragment_fnRecorder) AndDo(fn MoqURL_starGenType_EscapedFragment_doFn) *MoqURL_starGenType_EscapedFragment_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_EscapedFragment_fnRecorder) DoReturnResults(fn MoqURL_starGenType_EscapedFragment_doReturnFn) *MoqURL_starGenType_EscapedFragment_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_EscapedFragment_doFn
		DoReturnFn MoqURL_starGenType_EscapedFragment_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_EscapedFragment_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_EscapedFragment_resultsByParams
	for n, res := range r.Moq.ResultsByParams_EscapedFragment {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_EscapedFragment_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_EscapedFragment_paramsKey]*MoqURL_starGenType_EscapedFragment_results{},
		}
		r.Moq.ResultsByParams_EscapedFragment = append(r.Moq.ResultsByParams_EscapedFragment, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_EscapedFragment) {
			copy(r.Moq.ResultsByParams_EscapedFragment[insertAt+1:], r.Moq.ResultsByParams_EscapedFragment[insertAt:0])
			r.Moq.ResultsByParams_EscapedFragment[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_EscapedFragment(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_EscapedFragment_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_EscapedFragment_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_EscapedFragment_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_EscapedFragment_doFn
				DoReturnFn MoqURL_starGenType_EscapedFragment_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_EscapedFragment(params MoqURL_starGenType_EscapedFragment_params) string {
	return fmt.Sprintf("EscapedFragment()")
}

func (m *MoqURL_starGenType) ParamsKey_EscapedFragment(params MoqURL_starGenType_EscapedFragment_params, anyParams uint64) MoqURL_starGenType_EscapedFragment_paramsKey {
	m.Scene.T.Helper()
	return MoqURL_starGenType_EscapedFragment_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqURL_starGenType_recorder) String() *MoqURL_starGenType_String_fnRecorder {
	return &MoqURL_starGenType_String_fnRecorder{
		Params:   MoqURL_starGenType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_String_fnRecorder) Any() *MoqURL_starGenType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqURL_starGenType_String_anyParams{Recorder: r}
}

func (r *MoqURL_starGenType_String_fnRecorder) Seq() *MoqURL_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_String_fnRecorder) NoSeq() *MoqURL_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_String_fnRecorder) ReturnResults(result1 string) *MoqURL_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_String_doFn
		DoReturnFn MoqURL_starGenType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_String_fnRecorder) AndDo(fn MoqURL_starGenType_String_doFn) *MoqURL_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_String_fnRecorder) DoReturnResults(fn MoqURL_starGenType_String_doReturnFn) *MoqURL_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_String_doFn
		DoReturnFn MoqURL_starGenType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_String_paramsKey]*MoqURL_starGenType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_String_doFn
				DoReturnFn MoqURL_starGenType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_String(params MoqURL_starGenType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqURL_starGenType) ParamsKey_String(params MoqURL_starGenType_String_params, anyParams uint64) MoqURL_starGenType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqURL_starGenType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqURL_starGenType_recorder) Redacted() *MoqURL_starGenType_Redacted_fnRecorder {
	return &MoqURL_starGenType_Redacted_fnRecorder{
		Params:   MoqURL_starGenType_Redacted_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_Redacted_fnRecorder) Any() *MoqURL_starGenType_Redacted_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Redacted(r.Params))
		return nil
	}
	return &MoqURL_starGenType_Redacted_anyParams{Recorder: r}
}

func (r *MoqURL_starGenType_Redacted_fnRecorder) Seq() *MoqURL_starGenType_Redacted_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Redacted(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_Redacted_fnRecorder) NoSeq() *MoqURL_starGenType_Redacted_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Redacted(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_Redacted_fnRecorder) ReturnResults(result1 string) *MoqURL_starGenType_Redacted_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Redacted_doFn
		DoReturnFn MoqURL_starGenType_Redacted_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_Redacted_fnRecorder) AndDo(fn MoqURL_starGenType_Redacted_doFn) *MoqURL_starGenType_Redacted_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_Redacted_fnRecorder) DoReturnResults(fn MoqURL_starGenType_Redacted_doReturnFn) *MoqURL_starGenType_Redacted_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Redacted_doFn
		DoReturnFn MoqURL_starGenType_Redacted_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_Redacted_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_Redacted_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Redacted {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_Redacted_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_Redacted_paramsKey]*MoqURL_starGenType_Redacted_results{},
		}
		r.Moq.ResultsByParams_Redacted = append(r.Moq.ResultsByParams_Redacted, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Redacted) {
			copy(r.Moq.ResultsByParams_Redacted[insertAt+1:], r.Moq.ResultsByParams_Redacted[insertAt:0])
			r.Moq.ResultsByParams_Redacted[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Redacted(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_Redacted_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_Redacted_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_Redacted_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_Redacted_doFn
				DoReturnFn MoqURL_starGenType_Redacted_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_Redacted(params MoqURL_starGenType_Redacted_params) string {
	return fmt.Sprintf("Redacted()")
}

func (m *MoqURL_starGenType) ParamsKey_Redacted(params MoqURL_starGenType_Redacted_params, anyParams uint64) MoqURL_starGenType_Redacted_paramsKey {
	m.Scene.T.Helper()
	return MoqURL_starGenType_Redacted_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqURL_starGenType_recorder) IsAbs() *MoqURL_starGenType_IsAbs_fnRecorder {
	return &MoqURL_starGenType_IsAbs_fnRecorder{
		Params:   MoqURL_starGenType_IsAbs_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_IsAbs_fnRecorder) Any() *MoqURL_starGenType_IsAbs_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsAbs(r.Params))
		return nil
	}
	return &MoqURL_starGenType_IsAbs_anyParams{Recorder: r}
}

func (r *MoqURL_starGenType_IsAbs_fnRecorder) Seq() *MoqURL_starGenType_IsAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsAbs(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_IsAbs_fnRecorder) NoSeq() *MoqURL_starGenType_IsAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsAbs(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_IsAbs_fnRecorder) ReturnResults(result1 bool) *MoqURL_starGenType_IsAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_IsAbs_doFn
		DoReturnFn MoqURL_starGenType_IsAbs_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_IsAbs_fnRecorder) AndDo(fn MoqURL_starGenType_IsAbs_doFn) *MoqURL_starGenType_IsAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_IsAbs_fnRecorder) DoReturnResults(fn MoqURL_starGenType_IsAbs_doReturnFn) *MoqURL_starGenType_IsAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_IsAbs_doFn
		DoReturnFn MoqURL_starGenType_IsAbs_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_IsAbs_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_IsAbs_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsAbs {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_IsAbs_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_IsAbs_paramsKey]*MoqURL_starGenType_IsAbs_results{},
		}
		r.Moq.ResultsByParams_IsAbs = append(r.Moq.ResultsByParams_IsAbs, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsAbs) {
			copy(r.Moq.ResultsByParams_IsAbs[insertAt+1:], r.Moq.ResultsByParams_IsAbs[insertAt:0])
			r.Moq.ResultsByParams_IsAbs[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsAbs(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_IsAbs_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_IsAbs_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_IsAbs_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_IsAbs_doFn
				DoReturnFn MoqURL_starGenType_IsAbs_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_IsAbs(params MoqURL_starGenType_IsAbs_params) string {
	return fmt.Sprintf("IsAbs()")
}

func (m *MoqURL_starGenType) ParamsKey_IsAbs(params MoqURL_starGenType_IsAbs_params, anyParams uint64) MoqURL_starGenType_IsAbs_paramsKey {
	m.Scene.T.Helper()
	return MoqURL_starGenType_IsAbs_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqURL_starGenType_recorder) Parse(ref string) *MoqURL_starGenType_Parse_fnRecorder {
	return &MoqURL_starGenType_Parse_fnRecorder{
		Params: MoqURL_starGenType_Parse_params{
			Ref: ref,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_Parse_fnRecorder) Any() *MoqURL_starGenType_Parse_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parse(r.Params))
		return nil
	}
	return &MoqURL_starGenType_Parse_anyParams{Recorder: r}
}

func (a *MoqURL_starGenType_Parse_anyParams) Ref() *MoqURL_starGenType_Parse_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqURL_starGenType_Parse_fnRecorder) Seq() *MoqURL_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parse(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_Parse_fnRecorder) NoSeq() *MoqURL_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Parse(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_Parse_fnRecorder) ReturnResults(result1 *url.URL, result2 error) *MoqURL_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *url.URL
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Parse_doFn
		DoReturnFn MoqURL_starGenType_Parse_doReturnFn
	}{
		Values: &struct {
			Result1 *url.URL
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_Parse_fnRecorder) AndDo(fn MoqURL_starGenType_Parse_doFn) *MoqURL_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_Parse_fnRecorder) DoReturnResults(fn MoqURL_starGenType_Parse_doReturnFn) *MoqURL_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *url.URL
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Parse_doFn
		DoReturnFn MoqURL_starGenType_Parse_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_Parse_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_Parse_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Parse {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_Parse_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_Parse_paramsKey]*MoqURL_starGenType_Parse_results{},
		}
		r.Moq.ResultsByParams_Parse = append(r.Moq.ResultsByParams_Parse, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Parse) {
			copy(r.Moq.ResultsByParams_Parse[insertAt+1:], r.Moq.ResultsByParams_Parse[insertAt:0])
			r.Moq.ResultsByParams_Parse[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Parse(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_Parse_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_Parse_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_Parse_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *url.URL
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_Parse_doFn
				DoReturnFn MoqURL_starGenType_Parse_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_Parse(params MoqURL_starGenType_Parse_params) string {
	return fmt.Sprintf("Parse(%#v)", params.Ref)
}

func (m *MoqURL_starGenType) ParamsKey_Parse(params MoqURL_starGenType_Parse_params, anyParams uint64) MoqURL_starGenType_Parse_paramsKey {
	m.Scene.T.Helper()
	var refUsed string
	var refUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Parse.Ref == moq.ParamIndexByValue {
			refUsed = params.Ref
		} else {
			refUsedHash = hash.DeepHash(params.Ref)
		}
	}
	return MoqURL_starGenType_Parse_paramsKey{
		Params: struct{ Ref string }{
			Ref: refUsed,
		},
		Hashes: struct{ Ref hash.Hash }{
			Ref: refUsedHash,
		},
	}
}

func (m *MoqURL_starGenType_recorder) ResolveReference(ref *url.URL) *MoqURL_starGenType_ResolveReference_fnRecorder {
	return &MoqURL_starGenType_ResolveReference_fnRecorder{
		Params: MoqURL_starGenType_ResolveReference_params{
			Ref: ref,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_ResolveReference_fnRecorder) Any() *MoqURL_starGenType_ResolveReference_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ResolveReference(r.Params))
		return nil
	}
	return &MoqURL_starGenType_ResolveReference_anyParams{Recorder: r}
}

func (a *MoqURL_starGenType_ResolveReference_anyParams) Ref() *MoqURL_starGenType_ResolveReference_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqURL_starGenType_ResolveReference_fnRecorder) Seq() *MoqURL_starGenType_ResolveReference_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ResolveReference(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_ResolveReference_fnRecorder) NoSeq() *MoqURL_starGenType_ResolveReference_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ResolveReference(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_ResolveReference_fnRecorder) ReturnResults(result1 *url.URL) *MoqURL_starGenType_ResolveReference_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *url.URL
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_ResolveReference_doFn
		DoReturnFn MoqURL_starGenType_ResolveReference_doReturnFn
	}{
		Values: &struct {
			Result1 *url.URL
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_ResolveReference_fnRecorder) AndDo(fn MoqURL_starGenType_ResolveReference_doFn) *MoqURL_starGenType_ResolveReference_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_ResolveReference_fnRecorder) DoReturnResults(fn MoqURL_starGenType_ResolveReference_doReturnFn) *MoqURL_starGenType_ResolveReference_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *url.URL
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_ResolveReference_doFn
		DoReturnFn MoqURL_starGenType_ResolveReference_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_ResolveReference_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_ResolveReference_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ResolveReference {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_ResolveReference_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_ResolveReference_paramsKey]*MoqURL_starGenType_ResolveReference_results{},
		}
		r.Moq.ResultsByParams_ResolveReference = append(r.Moq.ResultsByParams_ResolveReference, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ResolveReference) {
			copy(r.Moq.ResultsByParams_ResolveReference[insertAt+1:], r.Moq.ResultsByParams_ResolveReference[insertAt:0])
			r.Moq.ResultsByParams_ResolveReference[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ResolveReference(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_ResolveReference_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_ResolveReference_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_ResolveReference_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *url.URL
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_ResolveReference_doFn
				DoReturnFn MoqURL_starGenType_ResolveReference_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_ResolveReference(params MoqURL_starGenType_ResolveReference_params) string {
	return fmt.Sprintf("ResolveReference(%#v)", params.Ref)
}

func (m *MoqURL_starGenType) ParamsKey_ResolveReference(params MoqURL_starGenType_ResolveReference_params, anyParams uint64) MoqURL_starGenType_ResolveReference_paramsKey {
	m.Scene.T.Helper()
	var refUsed *url.URL
	var refUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ResolveReference.Ref == moq.ParamIndexByValue {
			refUsed = params.Ref
		} else {
			refUsedHash = hash.DeepHash(params.Ref)
		}
	}
	return MoqURL_starGenType_ResolveReference_paramsKey{
		Params: struct{ Ref *url.URL }{
			Ref: refUsed,
		},
		Hashes: struct{ Ref hash.Hash }{
			Ref: refUsedHash,
		},
	}
}

func (m *MoqURL_starGenType_recorder) Query() *MoqURL_starGenType_Query_fnRecorder {
	return &MoqURL_starGenType_Query_fnRecorder{
		Params:   MoqURL_starGenType_Query_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_Query_fnRecorder) Any() *MoqURL_starGenType_Query_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Query(r.Params))
		return nil
	}
	return &MoqURL_starGenType_Query_anyParams{Recorder: r}
}

func (r *MoqURL_starGenType_Query_fnRecorder) Seq() *MoqURL_starGenType_Query_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Query(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_Query_fnRecorder) NoSeq() *MoqURL_starGenType_Query_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Query(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_Query_fnRecorder) ReturnResults(result1 url.Values) *MoqURL_starGenType_Query_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 url.Values
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Query_doFn
		DoReturnFn MoqURL_starGenType_Query_doReturnFn
	}{
		Values: &struct {
			Result1 url.Values
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_Query_fnRecorder) AndDo(fn MoqURL_starGenType_Query_doFn) *MoqURL_starGenType_Query_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_Query_fnRecorder) DoReturnResults(fn MoqURL_starGenType_Query_doReturnFn) *MoqURL_starGenType_Query_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 url.Values
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Query_doFn
		DoReturnFn MoqURL_starGenType_Query_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_Query_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_Query_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Query {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_Query_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_Query_paramsKey]*MoqURL_starGenType_Query_results{},
		}
		r.Moq.ResultsByParams_Query = append(r.Moq.ResultsByParams_Query, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Query) {
			copy(r.Moq.ResultsByParams_Query[insertAt+1:], r.Moq.ResultsByParams_Query[insertAt:0])
			r.Moq.ResultsByParams_Query[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Query(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_Query_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_Query_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_Query_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 url.Values
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_Query_doFn
				DoReturnFn MoqURL_starGenType_Query_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_Query(params MoqURL_starGenType_Query_params) string {
	return fmt.Sprintf("Query()")
}

func (m *MoqURL_starGenType) ParamsKey_Query(params MoqURL_starGenType_Query_params, anyParams uint64) MoqURL_starGenType_Query_paramsKey {
	m.Scene.T.Helper()
	return MoqURL_starGenType_Query_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqURL_starGenType_recorder) RequestURI() *MoqURL_starGenType_RequestURI_fnRecorder {
	return &MoqURL_starGenType_RequestURI_fnRecorder{
		Params:   MoqURL_starGenType_RequestURI_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_RequestURI_fnRecorder) Any() *MoqURL_starGenType_RequestURI_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RequestURI(r.Params))
		return nil
	}
	return &MoqURL_starGenType_RequestURI_anyParams{Recorder: r}
}

func (r *MoqURL_starGenType_RequestURI_fnRecorder) Seq() *MoqURL_starGenType_RequestURI_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RequestURI(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_RequestURI_fnRecorder) NoSeq() *MoqURL_starGenType_RequestURI_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RequestURI(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_RequestURI_fnRecorder) ReturnResults(result1 string) *MoqURL_starGenType_RequestURI_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_RequestURI_doFn
		DoReturnFn MoqURL_starGenType_RequestURI_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_RequestURI_fnRecorder) AndDo(fn MoqURL_starGenType_RequestURI_doFn) *MoqURL_starGenType_RequestURI_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_RequestURI_fnRecorder) DoReturnResults(fn MoqURL_starGenType_RequestURI_doReturnFn) *MoqURL_starGenType_RequestURI_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_RequestURI_doFn
		DoReturnFn MoqURL_starGenType_RequestURI_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_RequestURI_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_RequestURI_resultsByParams
	for n, res := range r.Moq.ResultsByParams_RequestURI {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_RequestURI_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_RequestURI_paramsKey]*MoqURL_starGenType_RequestURI_results{},
		}
		r.Moq.ResultsByParams_RequestURI = append(r.Moq.ResultsByParams_RequestURI, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_RequestURI) {
			copy(r.Moq.ResultsByParams_RequestURI[insertAt+1:], r.Moq.ResultsByParams_RequestURI[insertAt:0])
			r.Moq.ResultsByParams_RequestURI[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_RequestURI(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_RequestURI_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_RequestURI_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_RequestURI_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_RequestURI_doFn
				DoReturnFn MoqURL_starGenType_RequestURI_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_RequestURI(params MoqURL_starGenType_RequestURI_params) string {
	return fmt.Sprintf("RequestURI()")
}

func (m *MoqURL_starGenType) ParamsKey_RequestURI(params MoqURL_starGenType_RequestURI_params, anyParams uint64) MoqURL_starGenType_RequestURI_paramsKey {
	m.Scene.T.Helper()
	return MoqURL_starGenType_RequestURI_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqURL_starGenType_recorder) Hostname() *MoqURL_starGenType_Hostname_fnRecorder {
	return &MoqURL_starGenType_Hostname_fnRecorder{
		Params:   MoqURL_starGenType_Hostname_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_Hostname_fnRecorder) Any() *MoqURL_starGenType_Hostname_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Hostname(r.Params))
		return nil
	}
	return &MoqURL_starGenType_Hostname_anyParams{Recorder: r}
}

func (r *MoqURL_starGenType_Hostname_fnRecorder) Seq() *MoqURL_starGenType_Hostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Hostname(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_Hostname_fnRecorder) NoSeq() *MoqURL_starGenType_Hostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Hostname(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_Hostname_fnRecorder) ReturnResults(result1 string) *MoqURL_starGenType_Hostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Hostname_doFn
		DoReturnFn MoqURL_starGenType_Hostname_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_Hostname_fnRecorder) AndDo(fn MoqURL_starGenType_Hostname_doFn) *MoqURL_starGenType_Hostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_Hostname_fnRecorder) DoReturnResults(fn MoqURL_starGenType_Hostname_doReturnFn) *MoqURL_starGenType_Hostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Hostname_doFn
		DoReturnFn MoqURL_starGenType_Hostname_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_Hostname_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_Hostname_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Hostname {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_Hostname_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_Hostname_paramsKey]*MoqURL_starGenType_Hostname_results{},
		}
		r.Moq.ResultsByParams_Hostname = append(r.Moq.ResultsByParams_Hostname, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Hostname) {
			copy(r.Moq.ResultsByParams_Hostname[insertAt+1:], r.Moq.ResultsByParams_Hostname[insertAt:0])
			r.Moq.ResultsByParams_Hostname[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Hostname(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_Hostname_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_Hostname_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_Hostname_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_Hostname_doFn
				DoReturnFn MoqURL_starGenType_Hostname_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_Hostname(params MoqURL_starGenType_Hostname_params) string {
	return fmt.Sprintf("Hostname()")
}

func (m *MoqURL_starGenType) ParamsKey_Hostname(params MoqURL_starGenType_Hostname_params, anyParams uint64) MoqURL_starGenType_Hostname_paramsKey {
	m.Scene.T.Helper()
	return MoqURL_starGenType_Hostname_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqURL_starGenType_recorder) Port() *MoqURL_starGenType_Port_fnRecorder {
	return &MoqURL_starGenType_Port_fnRecorder{
		Params:   MoqURL_starGenType_Port_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_Port_fnRecorder) Any() *MoqURL_starGenType_Port_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Port(r.Params))
		return nil
	}
	return &MoqURL_starGenType_Port_anyParams{Recorder: r}
}

func (r *MoqURL_starGenType_Port_fnRecorder) Seq() *MoqURL_starGenType_Port_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Port(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_Port_fnRecorder) NoSeq() *MoqURL_starGenType_Port_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Port(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_Port_fnRecorder) ReturnResults(result1 string) *MoqURL_starGenType_Port_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Port_doFn
		DoReturnFn MoqURL_starGenType_Port_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_Port_fnRecorder) AndDo(fn MoqURL_starGenType_Port_doFn) *MoqURL_starGenType_Port_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_Port_fnRecorder) DoReturnResults(fn MoqURL_starGenType_Port_doReturnFn) *MoqURL_starGenType_Port_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_Port_doFn
		DoReturnFn MoqURL_starGenType_Port_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_Port_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_Port_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Port {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_Port_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_Port_paramsKey]*MoqURL_starGenType_Port_results{},
		}
		r.Moq.ResultsByParams_Port = append(r.Moq.ResultsByParams_Port, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Port) {
			copy(r.Moq.ResultsByParams_Port[insertAt+1:], r.Moq.ResultsByParams_Port[insertAt:0])
			r.Moq.ResultsByParams_Port[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Port(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_Port_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_Port_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_Port_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_Port_doFn
				DoReturnFn MoqURL_starGenType_Port_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_Port(params MoqURL_starGenType_Port_params) string {
	return fmt.Sprintf("Port()")
}

func (m *MoqURL_starGenType) ParamsKey_Port(params MoqURL_starGenType_Port_params, anyParams uint64) MoqURL_starGenType_Port_paramsKey {
	m.Scene.T.Helper()
	return MoqURL_starGenType_Port_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqURL_starGenType_recorder) MarshalBinary() *MoqURL_starGenType_MarshalBinary_fnRecorder {
	return &MoqURL_starGenType_MarshalBinary_fnRecorder{
		Params:   MoqURL_starGenType_MarshalBinary_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_MarshalBinary_fnRecorder) Any() *MoqURL_starGenType_MarshalBinary_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalBinary(r.Params))
		return nil
	}
	return &MoqURL_starGenType_MarshalBinary_anyParams{Recorder: r}
}

func (r *MoqURL_starGenType_MarshalBinary_fnRecorder) Seq() *MoqURL_starGenType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalBinary(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_MarshalBinary_fnRecorder) NoSeq() *MoqURL_starGenType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalBinary(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_MarshalBinary_fnRecorder) ReturnResults(text []byte, err error) *MoqURL_starGenType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_MarshalBinary_doFn
		DoReturnFn MoqURL_starGenType_MarshalBinary_doReturnFn
	}{
		Values: &struct {
			Text []byte
			Err  error
		}{
			Text: text,
			Err:  err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_MarshalBinary_fnRecorder) AndDo(fn MoqURL_starGenType_MarshalBinary_doFn) *MoqURL_starGenType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_MarshalBinary_fnRecorder) DoReturnResults(fn MoqURL_starGenType_MarshalBinary_doReturnFn) *MoqURL_starGenType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Text []byte
			Err  error
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_MarshalBinary_doFn
		DoReturnFn MoqURL_starGenType_MarshalBinary_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_MarshalBinary_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_MarshalBinary_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MarshalBinary {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_MarshalBinary_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_MarshalBinary_paramsKey]*MoqURL_starGenType_MarshalBinary_results{},
		}
		r.Moq.ResultsByParams_MarshalBinary = append(r.Moq.ResultsByParams_MarshalBinary, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MarshalBinary) {
			copy(r.Moq.ResultsByParams_MarshalBinary[insertAt+1:], r.Moq.ResultsByParams_MarshalBinary[insertAt:0])
			r.Moq.ResultsByParams_MarshalBinary[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MarshalBinary(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_MarshalBinary_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_MarshalBinary_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Text []byte
					Err  error
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_MarshalBinary_doFn
				DoReturnFn MoqURL_starGenType_MarshalBinary_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_MarshalBinary(params MoqURL_starGenType_MarshalBinary_params) string {
	return fmt.Sprintf("MarshalBinary()")
}

func (m *MoqURL_starGenType) ParamsKey_MarshalBinary(params MoqURL_starGenType_MarshalBinary_params, anyParams uint64) MoqURL_starGenType_MarshalBinary_paramsKey {
	m.Scene.T.Helper()
	return MoqURL_starGenType_MarshalBinary_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqURL_starGenType_recorder) UnmarshalBinary(text []byte) *MoqURL_starGenType_UnmarshalBinary_fnRecorder {
	return &MoqURL_starGenType_UnmarshalBinary_fnRecorder{
		Params: MoqURL_starGenType_UnmarshalBinary_params{
			Text: text,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqURL_starGenType_UnmarshalBinary_fnRecorder) Any() *MoqURL_starGenType_UnmarshalBinary_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalBinary(r.Params))
		return nil
	}
	return &MoqURL_starGenType_UnmarshalBinary_anyParams{Recorder: r}
}

func (a *MoqURL_starGenType_UnmarshalBinary_anyParams) Text() *MoqURL_starGenType_UnmarshalBinary_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqURL_starGenType_UnmarshalBinary_fnRecorder) Seq() *MoqURL_starGenType_UnmarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalBinary(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqURL_starGenType_UnmarshalBinary_fnRecorder) NoSeq() *MoqURL_starGenType_UnmarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnmarshalBinary(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqURL_starGenType_UnmarshalBinary_fnRecorder) ReturnResults(result1 error) *MoqURL_starGenType_UnmarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_UnmarshalBinary_doFn
		DoReturnFn MoqURL_starGenType_UnmarshalBinary_doReturnFn
	}{
		Values: &struct {
			Result1 error
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqURL_starGenType_UnmarshalBinary_fnRecorder) AndDo(fn MoqURL_starGenType_UnmarshalBinary_doFn) *MoqURL_starGenType_UnmarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqURL_starGenType_UnmarshalBinary_fnRecorder) DoReturnResults(fn MoqURL_starGenType_UnmarshalBinary_doReturnFn) *MoqURL_starGenType_UnmarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 error
		}
		Sequence   uint32
		DoFn       MoqURL_starGenType_UnmarshalBinary_doFn
		DoReturnFn MoqURL_starGenType_UnmarshalBinary_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqURL_starGenType_UnmarshalBinary_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqURL_starGenType_UnmarshalBinary_resultsByParams
	for n, res := range r.Moq.ResultsByParams_UnmarshalBinary {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqURL_starGenType_UnmarshalBinary_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqURL_starGenType_UnmarshalBinary_paramsKey]*MoqURL_starGenType_UnmarshalBinary_results{},
		}
		r.Moq.ResultsByParams_UnmarshalBinary = append(r.Moq.ResultsByParams_UnmarshalBinary, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_UnmarshalBinary) {
			copy(r.Moq.ResultsByParams_UnmarshalBinary[insertAt+1:], r.Moq.ResultsByParams_UnmarshalBinary[insertAt:0])
			r.Moq.ResultsByParams_UnmarshalBinary[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_UnmarshalBinary(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqURL_starGenType_UnmarshalBinary_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqURL_starGenType_UnmarshalBinary_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqURL_starGenType_UnmarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 error
				}
				Sequence   uint32
				DoFn       MoqURL_starGenType_UnmarshalBinary_doFn
				DoReturnFn MoqURL_starGenType_UnmarshalBinary_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqURL_starGenType) PrettyParams_UnmarshalBinary(params MoqURL_starGenType_UnmarshalBinary_params) string {
	return fmt.Sprintf("UnmarshalBinary(%#v)", params.Text)
}

func (m *MoqURL_starGenType) ParamsKey_UnmarshalBinary(params MoqURL_starGenType_UnmarshalBinary_params, anyParams uint64) MoqURL_starGenType_UnmarshalBinary_paramsKey {
	m.Scene.T.Helper()
	var textUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.UnmarshalBinary.Text == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The text parameter of the UnmarshalBinary function can't be indexed by value")
		}
		textUsedHash = hash.DeepHash(params.Text)
	}
	return MoqURL_starGenType_UnmarshalBinary_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Text hash.Hash }{
			Text: textUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqURL_starGenType) Reset() {
	m.ResultsByParams_EscapedPath = nil
	m.ResultsByParams_EscapedFragment = nil
	m.ResultsByParams_String = nil
	m.ResultsByParams_Redacted = nil
	m.ResultsByParams_IsAbs = nil
	m.ResultsByParams_Parse = nil
	m.ResultsByParams_ResolveReference = nil
	m.ResultsByParams_Query = nil
	m.ResultsByParams_RequestURI = nil
	m.ResultsByParams_Hostname = nil
	m.ResultsByParams_Port = nil
	m.ResultsByParams_MarshalBinary = nil
	m.ResultsByParams_UnmarshalBinary = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqURL_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_EscapedPath {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_EscapedPath(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_EscapedFragment {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_EscapedFragment(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Redacted {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Redacted(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsAbs {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsAbs(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Parse {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Parse(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ResolveReference {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ResolveReference(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Query {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Query(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_RequestURI {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_RequestURI(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Hostname {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Hostname(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Port {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Port(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MarshalBinary {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MarshalBinary(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_UnmarshalBinary {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_UnmarshalBinary(results.Params))
			}
		}
	}
}
