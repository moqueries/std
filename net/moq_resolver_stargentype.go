// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package net

import (
	"context"
	"fmt"
	"math/bits"
	"net"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that net.Resolver_starGenType is mocked
// completely
var _ Resolver_starGenType = (*MoqResolver_starGenType_mock)(nil)

// Resolver_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Resolver_starGenType interface {
	LookupHost(ctx context.Context, host string) (addrs []string, err error)
	LookupIPAddr(ctx context.Context, host string) ([]net.IPAddr, error)
	LookupIP(ctx context.Context, network, host string) ([]net.IP, error)
	LookupPort(ctx context.Context, network, service string) (port int, err error)
	LookupCNAME(ctx context.Context, host string) (string, error)
	LookupSRV(ctx context.Context, service, proto, name string) (string, []*net.SRV, error)
	LookupMX(ctx context.Context, name string) ([]*net.MX, error)
	LookupNS(ctx context.Context, name string) ([]*net.NS, error)
	LookupTXT(ctx context.Context, name string) ([]string, error)
	LookupAddr(ctx context.Context, addr string) ([]string, error)
}

// MoqResolver_starGenType holds the state of a moq of the Resolver_starGenType
// type
type MoqResolver_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqResolver_starGenType_mock

	ResultsByParams_LookupHost   []MoqResolver_starGenType_LookupHost_resultsByParams
	ResultsByParams_LookupIPAddr []MoqResolver_starGenType_LookupIPAddr_resultsByParams
	ResultsByParams_LookupIP     []MoqResolver_starGenType_LookupIP_resultsByParams
	ResultsByParams_LookupPort   []MoqResolver_starGenType_LookupPort_resultsByParams
	ResultsByParams_LookupCNAME  []MoqResolver_starGenType_LookupCNAME_resultsByParams
	ResultsByParams_LookupSRV    []MoqResolver_starGenType_LookupSRV_resultsByParams
	ResultsByParams_LookupMX     []MoqResolver_starGenType_LookupMX_resultsByParams
	ResultsByParams_LookupNS     []MoqResolver_starGenType_LookupNS_resultsByParams
	ResultsByParams_LookupTXT    []MoqResolver_starGenType_LookupTXT_resultsByParams
	ResultsByParams_LookupAddr   []MoqResolver_starGenType_LookupAddr_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			LookupHost struct {
				Ctx  moq.ParamIndexing
				Host moq.ParamIndexing
			}
			LookupIPAddr struct {
				Ctx  moq.ParamIndexing
				Host moq.ParamIndexing
			}
			LookupIP struct {
				Ctx     moq.ParamIndexing
				Network moq.ParamIndexing
				Host    moq.ParamIndexing
			}
			LookupPort struct {
				Ctx     moq.ParamIndexing
				Network moq.ParamIndexing
				Service moq.ParamIndexing
			}
			LookupCNAME struct {
				Ctx  moq.ParamIndexing
				Host moq.ParamIndexing
			}
			LookupSRV struct {
				Ctx     moq.ParamIndexing
				Service moq.ParamIndexing
				Proto   moq.ParamIndexing
				Name    moq.ParamIndexing
			}
			LookupMX struct {
				Ctx  moq.ParamIndexing
				Name moq.ParamIndexing
			}
			LookupNS struct {
				Ctx  moq.ParamIndexing
				Name moq.ParamIndexing
			}
			LookupTXT struct {
				Ctx  moq.ParamIndexing
				Name moq.ParamIndexing
			}
			LookupAddr struct {
				Ctx  moq.ParamIndexing
				Addr moq.ParamIndexing
			}
		}
	}
	// MoqResolver_starGenType_mock isolates the mock interface of the
}

// Resolver_starGenType type
type MoqResolver_starGenType_mock struct {
	Moq *MoqResolver_starGenType
}

// MoqResolver_starGenType_recorder isolates the recorder interface of the
// Resolver_starGenType type
type MoqResolver_starGenType_recorder struct {
	Moq *MoqResolver_starGenType
}

// MoqResolver_starGenType_LookupHost_params holds the params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupHost_params struct {
	Ctx  context.Context
	Host string
}

// MoqResolver_starGenType_LookupHost_paramsKey holds the map key params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupHost_paramsKey struct {
	Params struct {
		Ctx  context.Context
		Host string
	}
	Hashes struct {
		Ctx  hash.Hash
		Host hash.Hash
	}
}

// MoqResolver_starGenType_LookupHost_resultsByParams contains the results for
// a given set of parameters for the Resolver_starGenType type
type MoqResolver_starGenType_LookupHost_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqResolver_starGenType_LookupHost_paramsKey]*MoqResolver_starGenType_LookupHost_results
}

// MoqResolver_starGenType_LookupHost_doFn defines the type of function needed
// when calling AndDo for the Resolver_starGenType type
type MoqResolver_starGenType_LookupHost_doFn func(ctx context.Context, host string)

// MoqResolver_starGenType_LookupHost_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Resolver_starGenType type
type MoqResolver_starGenType_LookupHost_doReturnFn func(ctx context.Context, host string) (addrs []string, err error)

// MoqResolver_starGenType_LookupHost_results holds the results of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupHost_results struct {
	Params  MoqResolver_starGenType_LookupHost_params
	Results []struct {
		Values *struct {
			Addrs []string
			Err   error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupHost_doFn
		DoReturnFn MoqResolver_starGenType_LookupHost_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqResolver_starGenType_LookupHost_fnRecorder routes recorded function calls
// to the MoqResolver_starGenType moq
type MoqResolver_starGenType_LookupHost_fnRecorder struct {
	Params    MoqResolver_starGenType_LookupHost_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqResolver_starGenType_LookupHost_results
	Moq       *MoqResolver_starGenType
}

// MoqResolver_starGenType_LookupHost_anyParams isolates the any params
// functions of the Resolver_starGenType type
type MoqResolver_starGenType_LookupHost_anyParams struct {
	Recorder *MoqResolver_starGenType_LookupHost_fnRecorder
}

// MoqResolver_starGenType_LookupIPAddr_params holds the params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupIPAddr_params struct {
	Ctx  context.Context
	Host string
}

// MoqResolver_starGenType_LookupIPAddr_paramsKey holds the map key params of
// the Resolver_starGenType type
type MoqResolver_starGenType_LookupIPAddr_paramsKey struct {
	Params struct {
		Ctx  context.Context
		Host string
	}
	Hashes struct {
		Ctx  hash.Hash
		Host hash.Hash
	}
}

// MoqResolver_starGenType_LookupIPAddr_resultsByParams contains the results
// for a given set of parameters for the Resolver_starGenType type
type MoqResolver_starGenType_LookupIPAddr_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqResolver_starGenType_LookupIPAddr_paramsKey]*MoqResolver_starGenType_LookupIPAddr_results
}

// MoqResolver_starGenType_LookupIPAddr_doFn defines the type of function
// needed when calling AndDo for the Resolver_starGenType type
type MoqResolver_starGenType_LookupIPAddr_doFn func(ctx context.Context, host string)

// MoqResolver_starGenType_LookupIPAddr_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Resolver_starGenType type
type MoqResolver_starGenType_LookupIPAddr_doReturnFn func(ctx context.Context, host string) ([]net.IPAddr, error)

// MoqResolver_starGenType_LookupIPAddr_results holds the results of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupIPAddr_results struct {
	Params  MoqResolver_starGenType_LookupIPAddr_params
	Results []struct {
		Values *struct {
			Result1 []net.IPAddr
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupIPAddr_doFn
		DoReturnFn MoqResolver_starGenType_LookupIPAddr_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqResolver_starGenType_LookupIPAddr_fnRecorder routes recorded function
// calls to the MoqResolver_starGenType moq
type MoqResolver_starGenType_LookupIPAddr_fnRecorder struct {
	Params    MoqResolver_starGenType_LookupIPAddr_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqResolver_starGenType_LookupIPAddr_results
	Moq       *MoqResolver_starGenType
}

// MoqResolver_starGenType_LookupIPAddr_anyParams isolates the any params
// functions of the Resolver_starGenType type
type MoqResolver_starGenType_LookupIPAddr_anyParams struct {
	Recorder *MoqResolver_starGenType_LookupIPAddr_fnRecorder
}

// MoqResolver_starGenType_LookupIP_params holds the params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupIP_params struct {
	Ctx           context.Context
	Network, Host string
}

// MoqResolver_starGenType_LookupIP_paramsKey holds the map key params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupIP_paramsKey struct {
	Params struct {
		Ctx           context.Context
		Network, Host string
	}
	Hashes struct {
		Ctx           hash.Hash
		Network, Host hash.Hash
	}
}

// MoqResolver_starGenType_LookupIP_resultsByParams contains the results for a
// given set of parameters for the Resolver_starGenType type
type MoqResolver_starGenType_LookupIP_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqResolver_starGenType_LookupIP_paramsKey]*MoqResolver_starGenType_LookupIP_results
}

// MoqResolver_starGenType_LookupIP_doFn defines the type of function needed
// when calling AndDo for the Resolver_starGenType type
type MoqResolver_starGenType_LookupIP_doFn func(ctx context.Context, network, host string)

// MoqResolver_starGenType_LookupIP_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Resolver_starGenType type
type MoqResolver_starGenType_LookupIP_doReturnFn func(ctx context.Context, network, host string) ([]net.IP, error)

// MoqResolver_starGenType_LookupIP_results holds the results of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupIP_results struct {
	Params  MoqResolver_starGenType_LookupIP_params
	Results []struct {
		Values *struct {
			Result1 []net.IP
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupIP_doFn
		DoReturnFn MoqResolver_starGenType_LookupIP_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqResolver_starGenType_LookupIP_fnRecorder routes recorded function calls
// to the MoqResolver_starGenType moq
type MoqResolver_starGenType_LookupIP_fnRecorder struct {
	Params    MoqResolver_starGenType_LookupIP_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqResolver_starGenType_LookupIP_results
	Moq       *MoqResolver_starGenType
}

// MoqResolver_starGenType_LookupIP_anyParams isolates the any params functions
// of the Resolver_starGenType type
type MoqResolver_starGenType_LookupIP_anyParams struct {
	Recorder *MoqResolver_starGenType_LookupIP_fnRecorder
}

// MoqResolver_starGenType_LookupPort_params holds the params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupPort_params struct {
	Ctx              context.Context
	Network, Service string
}

// MoqResolver_starGenType_LookupPort_paramsKey holds the map key params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupPort_paramsKey struct {
	Params struct {
		Ctx              context.Context
		Network, Service string
	}
	Hashes struct {
		Ctx              hash.Hash
		Network, Service hash.Hash
	}
}

// MoqResolver_starGenType_LookupPort_resultsByParams contains the results for
// a given set of parameters for the Resolver_starGenType type
type MoqResolver_starGenType_LookupPort_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqResolver_starGenType_LookupPort_paramsKey]*MoqResolver_starGenType_LookupPort_results
}

// MoqResolver_starGenType_LookupPort_doFn defines the type of function needed
// when calling AndDo for the Resolver_starGenType type
type MoqResolver_starGenType_LookupPort_doFn func(ctx context.Context, network, service string)

// MoqResolver_starGenType_LookupPort_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Resolver_starGenType type
type MoqResolver_starGenType_LookupPort_doReturnFn func(ctx context.Context, network, service string) (port int, err error)

// MoqResolver_starGenType_LookupPort_results holds the results of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupPort_results struct {
	Params  MoqResolver_starGenType_LookupPort_params
	Results []struct {
		Values *struct {
			Port int
			Err  error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupPort_doFn
		DoReturnFn MoqResolver_starGenType_LookupPort_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqResolver_starGenType_LookupPort_fnRecorder routes recorded function calls
// to the MoqResolver_starGenType moq
type MoqResolver_starGenType_LookupPort_fnRecorder struct {
	Params    MoqResolver_starGenType_LookupPort_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqResolver_starGenType_LookupPort_results
	Moq       *MoqResolver_starGenType
}

// MoqResolver_starGenType_LookupPort_anyParams isolates the any params
// functions of the Resolver_starGenType type
type MoqResolver_starGenType_LookupPort_anyParams struct {
	Recorder *MoqResolver_starGenType_LookupPort_fnRecorder
}

// MoqResolver_starGenType_LookupCNAME_params holds the params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupCNAME_params struct {
	Ctx  context.Context
	Host string
}

// MoqResolver_starGenType_LookupCNAME_paramsKey holds the map key params of
// the Resolver_starGenType type
type MoqResolver_starGenType_LookupCNAME_paramsKey struct {
	Params struct {
		Ctx  context.Context
		Host string
	}
	Hashes struct {
		Ctx  hash.Hash
		Host hash.Hash
	}
}

// MoqResolver_starGenType_LookupCNAME_resultsByParams contains the results for
// a given set of parameters for the Resolver_starGenType type
type MoqResolver_starGenType_LookupCNAME_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqResolver_starGenType_LookupCNAME_paramsKey]*MoqResolver_starGenType_LookupCNAME_results
}

// MoqResolver_starGenType_LookupCNAME_doFn defines the type of function needed
// when calling AndDo for the Resolver_starGenType type
type MoqResolver_starGenType_LookupCNAME_doFn func(ctx context.Context, host string)

// MoqResolver_starGenType_LookupCNAME_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Resolver_starGenType type
type MoqResolver_starGenType_LookupCNAME_doReturnFn func(ctx context.Context, host string) (string, error)

// MoqResolver_starGenType_LookupCNAME_results holds the results of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupCNAME_results struct {
	Params  MoqResolver_starGenType_LookupCNAME_params
	Results []struct {
		Values *struct {
			Result1 string
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupCNAME_doFn
		DoReturnFn MoqResolver_starGenType_LookupCNAME_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqResolver_starGenType_LookupCNAME_fnRecorder routes recorded function
// calls to the MoqResolver_starGenType moq
type MoqResolver_starGenType_LookupCNAME_fnRecorder struct {
	Params    MoqResolver_starGenType_LookupCNAME_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqResolver_starGenType_LookupCNAME_results
	Moq       *MoqResolver_starGenType
}

// MoqResolver_starGenType_LookupCNAME_anyParams isolates the any params
// functions of the Resolver_starGenType type
type MoqResolver_starGenType_LookupCNAME_anyParams struct {
	Recorder *MoqResolver_starGenType_LookupCNAME_fnRecorder
}

// MoqResolver_starGenType_LookupSRV_params holds the params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupSRV_params struct {
	Ctx                  context.Context
	Service, Proto, Name string
}

// MoqResolver_starGenType_LookupSRV_paramsKey holds the map key params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupSRV_paramsKey struct {
	Params struct {
		Ctx                  context.Context
		Service, Proto, Name string
	}
	Hashes struct {
		Ctx                  hash.Hash
		Service, Proto, Name hash.Hash
	}
}

// MoqResolver_starGenType_LookupSRV_resultsByParams contains the results for a
// given set of parameters for the Resolver_starGenType type
type MoqResolver_starGenType_LookupSRV_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqResolver_starGenType_LookupSRV_paramsKey]*MoqResolver_starGenType_LookupSRV_results
}

// MoqResolver_starGenType_LookupSRV_doFn defines the type of function needed
// when calling AndDo for the Resolver_starGenType type
type MoqResolver_starGenType_LookupSRV_doFn func(ctx context.Context, service, proto, name string)

// MoqResolver_starGenType_LookupSRV_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Resolver_starGenType type
type MoqResolver_starGenType_LookupSRV_doReturnFn func(ctx context.Context, service, proto, name string) (string, []*net.SRV, error)

// MoqResolver_starGenType_LookupSRV_results holds the results of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupSRV_results struct {
	Params  MoqResolver_starGenType_LookupSRV_params
	Results []struct {
		Values *struct {
			Result1 string
			Result2 []*net.SRV
			Result3 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupSRV_doFn
		DoReturnFn MoqResolver_starGenType_LookupSRV_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqResolver_starGenType_LookupSRV_fnRecorder routes recorded function calls
// to the MoqResolver_starGenType moq
type MoqResolver_starGenType_LookupSRV_fnRecorder struct {
	Params    MoqResolver_starGenType_LookupSRV_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqResolver_starGenType_LookupSRV_results
	Moq       *MoqResolver_starGenType
}

// MoqResolver_starGenType_LookupSRV_anyParams isolates the any params
// functions of the Resolver_starGenType type
type MoqResolver_starGenType_LookupSRV_anyParams struct {
	Recorder *MoqResolver_starGenType_LookupSRV_fnRecorder
}

// MoqResolver_starGenType_LookupMX_params holds the params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupMX_params struct {
	Ctx  context.Context
	Name string
}

// MoqResolver_starGenType_LookupMX_paramsKey holds the map key params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupMX_paramsKey struct {
	Params struct {
		Ctx  context.Context
		Name string
	}
	Hashes struct {
		Ctx  hash.Hash
		Name hash.Hash
	}
}

// MoqResolver_starGenType_LookupMX_resultsByParams contains the results for a
// given set of parameters for the Resolver_starGenType type
type MoqResolver_starGenType_LookupMX_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqResolver_starGenType_LookupMX_paramsKey]*MoqResolver_starGenType_LookupMX_results
}

// MoqResolver_starGenType_LookupMX_doFn defines the type of function needed
// when calling AndDo for the Resolver_starGenType type
type MoqResolver_starGenType_LookupMX_doFn func(ctx context.Context, name string)

// MoqResolver_starGenType_LookupMX_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Resolver_starGenType type
type MoqResolver_starGenType_LookupMX_doReturnFn func(ctx context.Context, name string) ([]*net.MX, error)

// MoqResolver_starGenType_LookupMX_results holds the results of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupMX_results struct {
	Params  MoqResolver_starGenType_LookupMX_params
	Results []struct {
		Values *struct {
			Result1 []*net.MX
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupMX_doFn
		DoReturnFn MoqResolver_starGenType_LookupMX_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqResolver_starGenType_LookupMX_fnRecorder routes recorded function calls
// to the MoqResolver_starGenType moq
type MoqResolver_starGenType_LookupMX_fnRecorder struct {
	Params    MoqResolver_starGenType_LookupMX_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqResolver_starGenType_LookupMX_results
	Moq       *MoqResolver_starGenType
}

// MoqResolver_starGenType_LookupMX_anyParams isolates the any params functions
// of the Resolver_starGenType type
type MoqResolver_starGenType_LookupMX_anyParams struct {
	Recorder *MoqResolver_starGenType_LookupMX_fnRecorder
}

// MoqResolver_starGenType_LookupNS_params holds the params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupNS_params struct {
	Ctx  context.Context
	Name string
}

// MoqResolver_starGenType_LookupNS_paramsKey holds the map key params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupNS_paramsKey struct {
	Params struct {
		Ctx  context.Context
		Name string
	}
	Hashes struct {
		Ctx  hash.Hash
		Name hash.Hash
	}
}

// MoqResolver_starGenType_LookupNS_resultsByParams contains the results for a
// given set of parameters for the Resolver_starGenType type
type MoqResolver_starGenType_LookupNS_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqResolver_starGenType_LookupNS_paramsKey]*MoqResolver_starGenType_LookupNS_results
}

// MoqResolver_starGenType_LookupNS_doFn defines the type of function needed
// when calling AndDo for the Resolver_starGenType type
type MoqResolver_starGenType_LookupNS_doFn func(ctx context.Context, name string)

// MoqResolver_starGenType_LookupNS_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Resolver_starGenType type
type MoqResolver_starGenType_LookupNS_doReturnFn func(ctx context.Context, name string) ([]*net.NS, error)

// MoqResolver_starGenType_LookupNS_results holds the results of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupNS_results struct {
	Params  MoqResolver_starGenType_LookupNS_params
	Results []struct {
		Values *struct {
			Result1 []*net.NS
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupNS_doFn
		DoReturnFn MoqResolver_starGenType_LookupNS_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqResolver_starGenType_LookupNS_fnRecorder routes recorded function calls
// to the MoqResolver_starGenType moq
type MoqResolver_starGenType_LookupNS_fnRecorder struct {
	Params    MoqResolver_starGenType_LookupNS_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqResolver_starGenType_LookupNS_results
	Moq       *MoqResolver_starGenType
}

// MoqResolver_starGenType_LookupNS_anyParams isolates the any params functions
// of the Resolver_starGenType type
type MoqResolver_starGenType_LookupNS_anyParams struct {
	Recorder *MoqResolver_starGenType_LookupNS_fnRecorder
}

// MoqResolver_starGenType_LookupTXT_params holds the params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupTXT_params struct {
	Ctx  context.Context
	Name string
}

// MoqResolver_starGenType_LookupTXT_paramsKey holds the map key params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupTXT_paramsKey struct {
	Params struct {
		Ctx  context.Context
		Name string
	}
	Hashes struct {
		Ctx  hash.Hash
		Name hash.Hash
	}
}

// MoqResolver_starGenType_LookupTXT_resultsByParams contains the results for a
// given set of parameters for the Resolver_starGenType type
type MoqResolver_starGenType_LookupTXT_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqResolver_starGenType_LookupTXT_paramsKey]*MoqResolver_starGenType_LookupTXT_results
}

// MoqResolver_starGenType_LookupTXT_doFn defines the type of function needed
// when calling AndDo for the Resolver_starGenType type
type MoqResolver_starGenType_LookupTXT_doFn func(ctx context.Context, name string)

// MoqResolver_starGenType_LookupTXT_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Resolver_starGenType type
type MoqResolver_starGenType_LookupTXT_doReturnFn func(ctx context.Context, name string) ([]string, error)

// MoqResolver_starGenType_LookupTXT_results holds the results of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupTXT_results struct {
	Params  MoqResolver_starGenType_LookupTXT_params
	Results []struct {
		Values *struct {
			Result1 []string
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupTXT_doFn
		DoReturnFn MoqResolver_starGenType_LookupTXT_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqResolver_starGenType_LookupTXT_fnRecorder routes recorded function calls
// to the MoqResolver_starGenType moq
type MoqResolver_starGenType_LookupTXT_fnRecorder struct {
	Params    MoqResolver_starGenType_LookupTXT_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqResolver_starGenType_LookupTXT_results
	Moq       *MoqResolver_starGenType
}

// MoqResolver_starGenType_LookupTXT_anyParams isolates the any params
// functions of the Resolver_starGenType type
type MoqResolver_starGenType_LookupTXT_anyParams struct {
	Recorder *MoqResolver_starGenType_LookupTXT_fnRecorder
}

// MoqResolver_starGenType_LookupAddr_params holds the params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupAddr_params struct {
	Ctx  context.Context
	Addr string
}

// MoqResolver_starGenType_LookupAddr_paramsKey holds the map key params of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupAddr_paramsKey struct {
	Params struct {
		Ctx  context.Context
		Addr string
	}
	Hashes struct {
		Ctx  hash.Hash
		Addr hash.Hash
	}
}

// MoqResolver_starGenType_LookupAddr_resultsByParams contains the results for
// a given set of parameters for the Resolver_starGenType type
type MoqResolver_starGenType_LookupAddr_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqResolver_starGenType_LookupAddr_paramsKey]*MoqResolver_starGenType_LookupAddr_results
}

// MoqResolver_starGenType_LookupAddr_doFn defines the type of function needed
// when calling AndDo for the Resolver_starGenType type
type MoqResolver_starGenType_LookupAddr_doFn func(ctx context.Context, addr string)

// MoqResolver_starGenType_LookupAddr_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Resolver_starGenType type
type MoqResolver_starGenType_LookupAddr_doReturnFn func(ctx context.Context, addr string) ([]string, error)

// MoqResolver_starGenType_LookupAddr_results holds the results of the
// Resolver_starGenType type
type MoqResolver_starGenType_LookupAddr_results struct {
	Params  MoqResolver_starGenType_LookupAddr_params
	Results []struct {
		Values *struct {
			Result1 []string
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupAddr_doFn
		DoReturnFn MoqResolver_starGenType_LookupAddr_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqResolver_starGenType_LookupAddr_fnRecorder routes recorded function calls
// to the MoqResolver_starGenType moq
type MoqResolver_starGenType_LookupAddr_fnRecorder struct {
	Params    MoqResolver_starGenType_LookupAddr_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqResolver_starGenType_LookupAddr_results
	Moq       *MoqResolver_starGenType
}

// MoqResolver_starGenType_LookupAddr_anyParams isolates the any params
// functions of the Resolver_starGenType type
type MoqResolver_starGenType_LookupAddr_anyParams struct {
	Recorder *MoqResolver_starGenType_LookupAddr_fnRecorder
}

// NewMoqResolver_starGenType creates a new moq of the Resolver_starGenType
// type
func NewMoqResolver_starGenType(scene *moq.Scene, config *moq.Config) *MoqResolver_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqResolver_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqResolver_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				LookupHost struct {
					Ctx  moq.ParamIndexing
					Host moq.ParamIndexing
				}
				LookupIPAddr struct {
					Ctx  moq.ParamIndexing
					Host moq.ParamIndexing
				}
				LookupIP struct {
					Ctx     moq.ParamIndexing
					Network moq.ParamIndexing
					Host    moq.ParamIndexing
				}
				LookupPort struct {
					Ctx     moq.ParamIndexing
					Network moq.ParamIndexing
					Service moq.ParamIndexing
				}
				LookupCNAME struct {
					Ctx  moq.ParamIndexing
					Host moq.ParamIndexing
				}
				LookupSRV struct {
					Ctx     moq.ParamIndexing
					Service moq.ParamIndexing
					Proto   moq.ParamIndexing
					Name    moq.ParamIndexing
				}
				LookupMX struct {
					Ctx  moq.ParamIndexing
					Name moq.ParamIndexing
				}
				LookupNS struct {
					Ctx  moq.ParamIndexing
					Name moq.ParamIndexing
				}
				LookupTXT struct {
					Ctx  moq.ParamIndexing
					Name moq.ParamIndexing
				}
				LookupAddr struct {
					Ctx  moq.ParamIndexing
					Addr moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			LookupHost struct {
				Ctx  moq.ParamIndexing
				Host moq.ParamIndexing
			}
			LookupIPAddr struct {
				Ctx  moq.ParamIndexing
				Host moq.ParamIndexing
			}
			LookupIP struct {
				Ctx     moq.ParamIndexing
				Network moq.ParamIndexing
				Host    moq.ParamIndexing
			}
			LookupPort struct {
				Ctx     moq.ParamIndexing
				Network moq.ParamIndexing
				Service moq.ParamIndexing
			}
			LookupCNAME struct {
				Ctx  moq.ParamIndexing
				Host moq.ParamIndexing
			}
			LookupSRV struct {
				Ctx     moq.ParamIndexing
				Service moq.ParamIndexing
				Proto   moq.ParamIndexing
				Name    moq.ParamIndexing
			}
			LookupMX struct {
				Ctx  moq.ParamIndexing
				Name moq.ParamIndexing
			}
			LookupNS struct {
				Ctx  moq.ParamIndexing
				Name moq.ParamIndexing
			}
			LookupTXT struct {
				Ctx  moq.ParamIndexing
				Name moq.ParamIndexing
			}
			LookupAddr struct {
				Ctx  moq.ParamIndexing
				Addr moq.ParamIndexing
			}
		}{
			LookupHost: struct {
				Ctx  moq.ParamIndexing
				Host moq.ParamIndexing
			}{
				Ctx:  moq.ParamIndexByHash,
				Host: moq.ParamIndexByValue,
			},
			LookupIPAddr: struct {
				Ctx  moq.ParamIndexing
				Host moq.ParamIndexing
			}{
				Ctx:  moq.ParamIndexByHash,
				Host: moq.ParamIndexByValue,
			},
			LookupIP: struct {
				Ctx     moq.ParamIndexing
				Network moq.ParamIndexing
				Host    moq.ParamIndexing
			}{
				Ctx:     moq.ParamIndexByHash,
				Network: moq.ParamIndexByValue,
				Host:    moq.ParamIndexByValue,
			},
			LookupPort: struct {
				Ctx     moq.ParamIndexing
				Network moq.ParamIndexing
				Service moq.ParamIndexing
			}{
				Ctx:     moq.ParamIndexByHash,
				Network: moq.ParamIndexByValue,
				Service: moq.ParamIndexByValue,
			},
			LookupCNAME: struct {
				Ctx  moq.ParamIndexing
				Host moq.ParamIndexing
			}{
				Ctx:  moq.ParamIndexByHash,
				Host: moq.ParamIndexByValue,
			},
			LookupSRV: struct {
				Ctx     moq.ParamIndexing
				Service moq.ParamIndexing
				Proto   moq.ParamIndexing
				Name    moq.ParamIndexing
			}{
				Ctx:     moq.ParamIndexByHash,
				Service: moq.ParamIndexByValue,
				Proto:   moq.ParamIndexByValue,
				Name:    moq.ParamIndexByValue,
			},
			LookupMX: struct {
				Ctx  moq.ParamIndexing
				Name moq.ParamIndexing
			}{
				Ctx:  moq.ParamIndexByHash,
				Name: moq.ParamIndexByValue,
			},
			LookupNS: struct {
				Ctx  moq.ParamIndexing
				Name moq.ParamIndexing
			}{
				Ctx:  moq.ParamIndexByHash,
				Name: moq.ParamIndexByValue,
			},
			LookupTXT: struct {
				Ctx  moq.ParamIndexing
				Name moq.ParamIndexing
			}{
				Ctx:  moq.ParamIndexByHash,
				Name: moq.ParamIndexByValue,
			},
			LookupAddr: struct {
				Ctx  moq.ParamIndexing
				Addr moq.ParamIndexing
			}{
				Ctx:  moq.ParamIndexByHash,
				Addr: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Resolver_starGenType type
func (m *MoqResolver_starGenType) Mock() *MoqResolver_starGenType_mock { return m.Moq }

func (m *MoqResolver_starGenType_mock) LookupHost(ctx context.Context, host string) (addrs []string, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqResolver_starGenType_LookupHost_params{
		Ctx:  ctx,
		Host: host,
	}
	var results *MoqResolver_starGenType_LookupHost_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LookupHost {
		paramsKey := m.Moq.ParamsKey_LookupHost(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LookupHost(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LookupHost(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LookupHost(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ctx, host)
	}

	if result.Values != nil {
		addrs = result.Values.Addrs
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		addrs, err = result.DoReturnFn(ctx, host)
	}
	return
}

func (m *MoqResolver_starGenType_mock) LookupIPAddr(ctx context.Context, host string) (result1 []net.IPAddr, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqResolver_starGenType_LookupIPAddr_params{
		Ctx:  ctx,
		Host: host,
	}
	var results *MoqResolver_starGenType_LookupIPAddr_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LookupIPAddr {
		paramsKey := m.Moq.ParamsKey_LookupIPAddr(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LookupIPAddr(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LookupIPAddr(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LookupIPAddr(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ctx, host)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(ctx, host)
	}
	return
}

func (m *MoqResolver_starGenType_mock) LookupIP(ctx context.Context, network, host string) (result1 []net.IP, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqResolver_starGenType_LookupIP_params{
		Ctx:     ctx,
		Network: network,
		Host:    host,
	}
	var results *MoqResolver_starGenType_LookupIP_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LookupIP {
		paramsKey := m.Moq.ParamsKey_LookupIP(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LookupIP(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LookupIP(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LookupIP(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ctx, network, host)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(ctx, network, host)
	}
	return
}

func (m *MoqResolver_starGenType_mock) LookupPort(ctx context.Context, network, service string) (port int, err error) {
	m.Moq.Scene.T.Helper()
	params := MoqResolver_starGenType_LookupPort_params{
		Ctx:     ctx,
		Network: network,
		Service: service,
	}
	var results *MoqResolver_starGenType_LookupPort_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LookupPort {
		paramsKey := m.Moq.ParamsKey_LookupPort(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LookupPort(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LookupPort(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LookupPort(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ctx, network, service)
	}

	if result.Values != nil {
		port = result.Values.Port
		err = result.Values.Err
	}
	if result.DoReturnFn != nil {
		port, err = result.DoReturnFn(ctx, network, service)
	}
	return
}

func (m *MoqResolver_starGenType_mock) LookupCNAME(ctx context.Context, host string) (result1 string, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqResolver_starGenType_LookupCNAME_params{
		Ctx:  ctx,
		Host: host,
	}
	var results *MoqResolver_starGenType_LookupCNAME_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LookupCNAME {
		paramsKey := m.Moq.ParamsKey_LookupCNAME(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LookupCNAME(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LookupCNAME(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LookupCNAME(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ctx, host)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(ctx, host)
	}
	return
}

func (m *MoqResolver_starGenType_mock) LookupSRV(ctx context.Context, service, proto, name string) (result1 string, result2 []*net.SRV, result3 error) {
	m.Moq.Scene.T.Helper()
	params := MoqResolver_starGenType_LookupSRV_params{
		Ctx:     ctx,
		Service: service,
		Proto:   proto,
		Name:    name,
	}
	var results *MoqResolver_starGenType_LookupSRV_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LookupSRV {
		paramsKey := m.Moq.ParamsKey_LookupSRV(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LookupSRV(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LookupSRV(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LookupSRV(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ctx, service, proto, name)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
		result3 = result.Values.Result3
	}
	if result.DoReturnFn != nil {
		result1, result2, result3 = result.DoReturnFn(ctx, service, proto, name)
	}
	return
}

func (m *MoqResolver_starGenType_mock) LookupMX(ctx context.Context, name string) (result1 []*net.MX, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqResolver_starGenType_LookupMX_params{
		Ctx:  ctx,
		Name: name,
	}
	var results *MoqResolver_starGenType_LookupMX_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LookupMX {
		paramsKey := m.Moq.ParamsKey_LookupMX(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LookupMX(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LookupMX(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LookupMX(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ctx, name)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(ctx, name)
	}
	return
}

func (m *MoqResolver_starGenType_mock) LookupNS(ctx context.Context, name string) (result1 []*net.NS, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqResolver_starGenType_LookupNS_params{
		Ctx:  ctx,
		Name: name,
	}
	var results *MoqResolver_starGenType_LookupNS_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LookupNS {
		paramsKey := m.Moq.ParamsKey_LookupNS(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LookupNS(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LookupNS(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LookupNS(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ctx, name)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(ctx, name)
	}
	return
}

func (m *MoqResolver_starGenType_mock) LookupTXT(ctx context.Context, name string) (result1 []string, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqResolver_starGenType_LookupTXT_params{
		Ctx:  ctx,
		Name: name,
	}
	var results *MoqResolver_starGenType_LookupTXT_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LookupTXT {
		paramsKey := m.Moq.ParamsKey_LookupTXT(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LookupTXT(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LookupTXT(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LookupTXT(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ctx, name)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(ctx, name)
	}
	return
}

func (m *MoqResolver_starGenType_mock) LookupAddr(ctx context.Context, addr string) (result1 []string, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqResolver_starGenType_LookupAddr_params{
		Ctx:  ctx,
		Addr: addr,
	}
	var results *MoqResolver_starGenType_LookupAddr_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LookupAddr {
		paramsKey := m.Moq.ParamsKey_LookupAddr(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LookupAddr(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LookupAddr(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LookupAddr(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(ctx, addr)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(ctx, addr)
	}
	return
}

// OnCall returns the recorder implementation of the Resolver_starGenType type
func (m *MoqResolver_starGenType) OnCall() *MoqResolver_starGenType_recorder {
	return &MoqResolver_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqResolver_starGenType_recorder) LookupHost(ctx context.Context, host string) *MoqResolver_starGenType_LookupHost_fnRecorder {
	return &MoqResolver_starGenType_LookupHost_fnRecorder{
		Params: MoqResolver_starGenType_LookupHost_params{
			Ctx:  ctx,
			Host: host,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqResolver_starGenType_LookupHost_fnRecorder) Any() *MoqResolver_starGenType_LookupHost_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupHost(r.Params))
		return nil
	}
	return &MoqResolver_starGenType_LookupHost_anyParams{Recorder: r}
}

func (a *MoqResolver_starGenType_LookupHost_anyParams) Ctx() *MoqResolver_starGenType_LookupHost_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupHost_anyParams) Host() *MoqResolver_starGenType_LookupHost_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqResolver_starGenType_LookupHost_fnRecorder) Seq() *MoqResolver_starGenType_LookupHost_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupHost(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqResolver_starGenType_LookupHost_fnRecorder) NoSeq() *MoqResolver_starGenType_LookupHost_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupHost(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqResolver_starGenType_LookupHost_fnRecorder) ReturnResults(addrs []string, err error) *MoqResolver_starGenType_LookupHost_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Addrs []string
			Err   error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupHost_doFn
		DoReturnFn MoqResolver_starGenType_LookupHost_doReturnFn
	}{
		Values: &struct {
			Addrs []string
			Err   error
		}{
			Addrs: addrs,
			Err:   err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqResolver_starGenType_LookupHost_fnRecorder) AndDo(fn MoqResolver_starGenType_LookupHost_doFn) *MoqResolver_starGenType_LookupHost_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqResolver_starGenType_LookupHost_fnRecorder) DoReturnResults(fn MoqResolver_starGenType_LookupHost_doReturnFn) *MoqResolver_starGenType_LookupHost_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Addrs []string
			Err   error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupHost_doFn
		DoReturnFn MoqResolver_starGenType_LookupHost_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqResolver_starGenType_LookupHost_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqResolver_starGenType_LookupHost_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LookupHost {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqResolver_starGenType_LookupHost_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqResolver_starGenType_LookupHost_paramsKey]*MoqResolver_starGenType_LookupHost_results{},
		}
		r.Moq.ResultsByParams_LookupHost = append(r.Moq.ResultsByParams_LookupHost, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LookupHost) {
			copy(r.Moq.ResultsByParams_LookupHost[insertAt+1:], r.Moq.ResultsByParams_LookupHost[insertAt:0])
			r.Moq.ResultsByParams_LookupHost[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LookupHost(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqResolver_starGenType_LookupHost_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqResolver_starGenType_LookupHost_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqResolver_starGenType_LookupHost_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Addrs []string
					Err   error
				}
				Sequence   uint32
				DoFn       MoqResolver_starGenType_LookupHost_doFn
				DoReturnFn MoqResolver_starGenType_LookupHost_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqResolver_starGenType) PrettyParams_LookupHost(params MoqResolver_starGenType_LookupHost_params) string {
	return fmt.Sprintf("LookupHost(%#v, %#v)", params.Ctx, params.Host)
}

func (m *MoqResolver_starGenType) ParamsKey_LookupHost(params MoqResolver_starGenType_LookupHost_params, anyParams uint64) MoqResolver_starGenType_LookupHost_paramsKey {
	m.Scene.T.Helper()
	var ctxUsed context.Context
	var ctxUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LookupHost.Ctx == moq.ParamIndexByValue {
			ctxUsed = params.Ctx
		} else {
			ctxUsedHash = hash.DeepHash(params.Ctx)
		}
	}
	var hostUsed string
	var hostUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.LookupHost.Host == moq.ParamIndexByValue {
			hostUsed = params.Host
		} else {
			hostUsedHash = hash.DeepHash(params.Host)
		}
	}
	return MoqResolver_starGenType_LookupHost_paramsKey{
		Params: struct {
			Ctx  context.Context
			Host string
		}{
			Ctx:  ctxUsed,
			Host: hostUsed,
		},
		Hashes: struct {
			Ctx  hash.Hash
			Host hash.Hash
		}{
			Ctx:  ctxUsedHash,
			Host: hostUsedHash,
		},
	}
}

func (m *MoqResolver_starGenType_recorder) LookupIPAddr(ctx context.Context, host string) *MoqResolver_starGenType_LookupIPAddr_fnRecorder {
	return &MoqResolver_starGenType_LookupIPAddr_fnRecorder{
		Params: MoqResolver_starGenType_LookupIPAddr_params{
			Ctx:  ctx,
			Host: host,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqResolver_starGenType_LookupIPAddr_fnRecorder) Any() *MoqResolver_starGenType_LookupIPAddr_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupIPAddr(r.Params))
		return nil
	}
	return &MoqResolver_starGenType_LookupIPAddr_anyParams{Recorder: r}
}

func (a *MoqResolver_starGenType_LookupIPAddr_anyParams) Ctx() *MoqResolver_starGenType_LookupIPAddr_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupIPAddr_anyParams) Host() *MoqResolver_starGenType_LookupIPAddr_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqResolver_starGenType_LookupIPAddr_fnRecorder) Seq() *MoqResolver_starGenType_LookupIPAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupIPAddr(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqResolver_starGenType_LookupIPAddr_fnRecorder) NoSeq() *MoqResolver_starGenType_LookupIPAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupIPAddr(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqResolver_starGenType_LookupIPAddr_fnRecorder) ReturnResults(result1 []net.IPAddr, result2 error) *MoqResolver_starGenType_LookupIPAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []net.IPAddr
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupIPAddr_doFn
		DoReturnFn MoqResolver_starGenType_LookupIPAddr_doReturnFn
	}{
		Values: &struct {
			Result1 []net.IPAddr
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqResolver_starGenType_LookupIPAddr_fnRecorder) AndDo(fn MoqResolver_starGenType_LookupIPAddr_doFn) *MoqResolver_starGenType_LookupIPAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqResolver_starGenType_LookupIPAddr_fnRecorder) DoReturnResults(fn MoqResolver_starGenType_LookupIPAddr_doReturnFn) *MoqResolver_starGenType_LookupIPAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []net.IPAddr
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupIPAddr_doFn
		DoReturnFn MoqResolver_starGenType_LookupIPAddr_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqResolver_starGenType_LookupIPAddr_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqResolver_starGenType_LookupIPAddr_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LookupIPAddr {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqResolver_starGenType_LookupIPAddr_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqResolver_starGenType_LookupIPAddr_paramsKey]*MoqResolver_starGenType_LookupIPAddr_results{},
		}
		r.Moq.ResultsByParams_LookupIPAddr = append(r.Moq.ResultsByParams_LookupIPAddr, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LookupIPAddr) {
			copy(r.Moq.ResultsByParams_LookupIPAddr[insertAt+1:], r.Moq.ResultsByParams_LookupIPAddr[insertAt:0])
			r.Moq.ResultsByParams_LookupIPAddr[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LookupIPAddr(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqResolver_starGenType_LookupIPAddr_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqResolver_starGenType_LookupIPAddr_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqResolver_starGenType_LookupIPAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []net.IPAddr
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqResolver_starGenType_LookupIPAddr_doFn
				DoReturnFn MoqResolver_starGenType_LookupIPAddr_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqResolver_starGenType) PrettyParams_LookupIPAddr(params MoqResolver_starGenType_LookupIPAddr_params) string {
	return fmt.Sprintf("LookupIPAddr(%#v, %#v)", params.Ctx, params.Host)
}

func (m *MoqResolver_starGenType) ParamsKey_LookupIPAddr(params MoqResolver_starGenType_LookupIPAddr_params, anyParams uint64) MoqResolver_starGenType_LookupIPAddr_paramsKey {
	m.Scene.T.Helper()
	var ctxUsed context.Context
	var ctxUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LookupIPAddr.Ctx == moq.ParamIndexByValue {
			ctxUsed = params.Ctx
		} else {
			ctxUsedHash = hash.DeepHash(params.Ctx)
		}
	}
	var hostUsed string
	var hostUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.LookupIPAddr.Host == moq.ParamIndexByValue {
			hostUsed = params.Host
		} else {
			hostUsedHash = hash.DeepHash(params.Host)
		}
	}
	return MoqResolver_starGenType_LookupIPAddr_paramsKey{
		Params: struct {
			Ctx  context.Context
			Host string
		}{
			Ctx:  ctxUsed,
			Host: hostUsed,
		},
		Hashes: struct {
			Ctx  hash.Hash
			Host hash.Hash
		}{
			Ctx:  ctxUsedHash,
			Host: hostUsedHash,
		},
	}
}

func (m *MoqResolver_starGenType_recorder) LookupIP(ctx context.Context, network, host string) *MoqResolver_starGenType_LookupIP_fnRecorder {
	return &MoqResolver_starGenType_LookupIP_fnRecorder{
		Params: MoqResolver_starGenType_LookupIP_params{
			Ctx:     ctx,
			Network: network,
			Host:    host,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqResolver_starGenType_LookupIP_fnRecorder) Any() *MoqResolver_starGenType_LookupIP_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupIP(r.Params))
		return nil
	}
	return &MoqResolver_starGenType_LookupIP_anyParams{Recorder: r}
}

func (a *MoqResolver_starGenType_LookupIP_anyParams) Ctx() *MoqResolver_starGenType_LookupIP_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupIP_anyParams) Network() *MoqResolver_starGenType_LookupIP_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupIP_anyParams) Host() *MoqResolver_starGenType_LookupIP_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqResolver_starGenType_LookupIP_fnRecorder) Seq() *MoqResolver_starGenType_LookupIP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupIP(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqResolver_starGenType_LookupIP_fnRecorder) NoSeq() *MoqResolver_starGenType_LookupIP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupIP(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqResolver_starGenType_LookupIP_fnRecorder) ReturnResults(result1 []net.IP, result2 error) *MoqResolver_starGenType_LookupIP_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []net.IP
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupIP_doFn
		DoReturnFn MoqResolver_starGenType_LookupIP_doReturnFn
	}{
		Values: &struct {
			Result1 []net.IP
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqResolver_starGenType_LookupIP_fnRecorder) AndDo(fn MoqResolver_starGenType_LookupIP_doFn) *MoqResolver_starGenType_LookupIP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqResolver_starGenType_LookupIP_fnRecorder) DoReturnResults(fn MoqResolver_starGenType_LookupIP_doReturnFn) *MoqResolver_starGenType_LookupIP_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []net.IP
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupIP_doFn
		DoReturnFn MoqResolver_starGenType_LookupIP_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqResolver_starGenType_LookupIP_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqResolver_starGenType_LookupIP_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LookupIP {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqResolver_starGenType_LookupIP_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqResolver_starGenType_LookupIP_paramsKey]*MoqResolver_starGenType_LookupIP_results{},
		}
		r.Moq.ResultsByParams_LookupIP = append(r.Moq.ResultsByParams_LookupIP, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LookupIP) {
			copy(r.Moq.ResultsByParams_LookupIP[insertAt+1:], r.Moq.ResultsByParams_LookupIP[insertAt:0])
			r.Moq.ResultsByParams_LookupIP[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LookupIP(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqResolver_starGenType_LookupIP_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqResolver_starGenType_LookupIP_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqResolver_starGenType_LookupIP_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []net.IP
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqResolver_starGenType_LookupIP_doFn
				DoReturnFn MoqResolver_starGenType_LookupIP_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqResolver_starGenType) PrettyParams_LookupIP(params MoqResolver_starGenType_LookupIP_params) string {
	return fmt.Sprintf("LookupIP(%#v, %#v, %#v)", params.Ctx, params.Network, params.Host)
}

func (m *MoqResolver_starGenType) ParamsKey_LookupIP(params MoqResolver_starGenType_LookupIP_params, anyParams uint64) MoqResolver_starGenType_LookupIP_paramsKey {
	m.Scene.T.Helper()
	var ctxUsed context.Context
	var ctxUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LookupIP.Ctx == moq.ParamIndexByValue {
			ctxUsed = params.Ctx
		} else {
			ctxUsedHash = hash.DeepHash(params.Ctx)
		}
	}
	var networkUsed string
	var networkUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.LookupIP.Network == moq.ParamIndexByValue {
			networkUsed = params.Network
		} else {
			networkUsedHash = hash.DeepHash(params.Network)
		}
	}
	var hostUsed string
	var hostUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.LookupIP.Host == moq.ParamIndexByValue {
			hostUsed = params.Host
		} else {
			hostUsedHash = hash.DeepHash(params.Host)
		}
	}
	return MoqResolver_starGenType_LookupIP_paramsKey{
		Params: struct {
			Ctx           context.Context
			Network, Host string
		}{
			Ctx:     ctxUsed,
			Network: networkUsed,
			Host:    hostUsed,
		},
		Hashes: struct {
			Ctx           hash.Hash
			Network, Host hash.Hash
		}{
			Ctx:     ctxUsedHash,
			Network: networkUsedHash,
			Host:    hostUsedHash,
		},
	}
}

func (m *MoqResolver_starGenType_recorder) LookupPort(ctx context.Context, network, service string) *MoqResolver_starGenType_LookupPort_fnRecorder {
	return &MoqResolver_starGenType_LookupPort_fnRecorder{
		Params: MoqResolver_starGenType_LookupPort_params{
			Ctx:     ctx,
			Network: network,
			Service: service,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqResolver_starGenType_LookupPort_fnRecorder) Any() *MoqResolver_starGenType_LookupPort_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupPort(r.Params))
		return nil
	}
	return &MoqResolver_starGenType_LookupPort_anyParams{Recorder: r}
}

func (a *MoqResolver_starGenType_LookupPort_anyParams) Ctx() *MoqResolver_starGenType_LookupPort_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupPort_anyParams) Network() *MoqResolver_starGenType_LookupPort_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupPort_anyParams) Service() *MoqResolver_starGenType_LookupPort_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqResolver_starGenType_LookupPort_fnRecorder) Seq() *MoqResolver_starGenType_LookupPort_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupPort(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqResolver_starGenType_LookupPort_fnRecorder) NoSeq() *MoqResolver_starGenType_LookupPort_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupPort(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqResolver_starGenType_LookupPort_fnRecorder) ReturnResults(port int, err error) *MoqResolver_starGenType_LookupPort_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Port int
			Err  error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupPort_doFn
		DoReturnFn MoqResolver_starGenType_LookupPort_doReturnFn
	}{
		Values: &struct {
			Port int
			Err  error
		}{
			Port: port,
			Err:  err,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqResolver_starGenType_LookupPort_fnRecorder) AndDo(fn MoqResolver_starGenType_LookupPort_doFn) *MoqResolver_starGenType_LookupPort_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqResolver_starGenType_LookupPort_fnRecorder) DoReturnResults(fn MoqResolver_starGenType_LookupPort_doReturnFn) *MoqResolver_starGenType_LookupPort_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Port int
			Err  error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupPort_doFn
		DoReturnFn MoqResolver_starGenType_LookupPort_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqResolver_starGenType_LookupPort_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqResolver_starGenType_LookupPort_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LookupPort {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqResolver_starGenType_LookupPort_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqResolver_starGenType_LookupPort_paramsKey]*MoqResolver_starGenType_LookupPort_results{},
		}
		r.Moq.ResultsByParams_LookupPort = append(r.Moq.ResultsByParams_LookupPort, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LookupPort) {
			copy(r.Moq.ResultsByParams_LookupPort[insertAt+1:], r.Moq.ResultsByParams_LookupPort[insertAt:0])
			r.Moq.ResultsByParams_LookupPort[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LookupPort(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqResolver_starGenType_LookupPort_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqResolver_starGenType_LookupPort_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqResolver_starGenType_LookupPort_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Port int
					Err  error
				}
				Sequence   uint32
				DoFn       MoqResolver_starGenType_LookupPort_doFn
				DoReturnFn MoqResolver_starGenType_LookupPort_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqResolver_starGenType) PrettyParams_LookupPort(params MoqResolver_starGenType_LookupPort_params) string {
	return fmt.Sprintf("LookupPort(%#v, %#v, %#v)", params.Ctx, params.Network, params.Service)
}

func (m *MoqResolver_starGenType) ParamsKey_LookupPort(params MoqResolver_starGenType_LookupPort_params, anyParams uint64) MoqResolver_starGenType_LookupPort_paramsKey {
	m.Scene.T.Helper()
	var ctxUsed context.Context
	var ctxUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LookupPort.Ctx == moq.ParamIndexByValue {
			ctxUsed = params.Ctx
		} else {
			ctxUsedHash = hash.DeepHash(params.Ctx)
		}
	}
	var networkUsed string
	var networkUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.LookupPort.Network == moq.ParamIndexByValue {
			networkUsed = params.Network
		} else {
			networkUsedHash = hash.DeepHash(params.Network)
		}
	}
	var serviceUsed string
	var serviceUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.LookupPort.Service == moq.ParamIndexByValue {
			serviceUsed = params.Service
		} else {
			serviceUsedHash = hash.DeepHash(params.Service)
		}
	}
	return MoqResolver_starGenType_LookupPort_paramsKey{
		Params: struct {
			Ctx              context.Context
			Network, Service string
		}{
			Ctx:     ctxUsed,
			Network: networkUsed,
			Service: serviceUsed,
		},
		Hashes: struct {
			Ctx              hash.Hash
			Network, Service hash.Hash
		}{
			Ctx:     ctxUsedHash,
			Network: networkUsedHash,
			Service: serviceUsedHash,
		},
	}
}

func (m *MoqResolver_starGenType_recorder) LookupCNAME(ctx context.Context, host string) *MoqResolver_starGenType_LookupCNAME_fnRecorder {
	return &MoqResolver_starGenType_LookupCNAME_fnRecorder{
		Params: MoqResolver_starGenType_LookupCNAME_params{
			Ctx:  ctx,
			Host: host,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqResolver_starGenType_LookupCNAME_fnRecorder) Any() *MoqResolver_starGenType_LookupCNAME_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupCNAME(r.Params))
		return nil
	}
	return &MoqResolver_starGenType_LookupCNAME_anyParams{Recorder: r}
}

func (a *MoqResolver_starGenType_LookupCNAME_anyParams) Ctx() *MoqResolver_starGenType_LookupCNAME_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupCNAME_anyParams) Host() *MoqResolver_starGenType_LookupCNAME_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqResolver_starGenType_LookupCNAME_fnRecorder) Seq() *MoqResolver_starGenType_LookupCNAME_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupCNAME(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqResolver_starGenType_LookupCNAME_fnRecorder) NoSeq() *MoqResolver_starGenType_LookupCNAME_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupCNAME(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqResolver_starGenType_LookupCNAME_fnRecorder) ReturnResults(result1 string, result2 error) *MoqResolver_starGenType_LookupCNAME_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupCNAME_doFn
		DoReturnFn MoqResolver_starGenType_LookupCNAME_doReturnFn
	}{
		Values: &struct {
			Result1 string
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqResolver_starGenType_LookupCNAME_fnRecorder) AndDo(fn MoqResolver_starGenType_LookupCNAME_doFn) *MoqResolver_starGenType_LookupCNAME_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqResolver_starGenType_LookupCNAME_fnRecorder) DoReturnResults(fn MoqResolver_starGenType_LookupCNAME_doReturnFn) *MoqResolver_starGenType_LookupCNAME_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupCNAME_doFn
		DoReturnFn MoqResolver_starGenType_LookupCNAME_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqResolver_starGenType_LookupCNAME_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqResolver_starGenType_LookupCNAME_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LookupCNAME {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqResolver_starGenType_LookupCNAME_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqResolver_starGenType_LookupCNAME_paramsKey]*MoqResolver_starGenType_LookupCNAME_results{},
		}
		r.Moq.ResultsByParams_LookupCNAME = append(r.Moq.ResultsByParams_LookupCNAME, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LookupCNAME) {
			copy(r.Moq.ResultsByParams_LookupCNAME[insertAt+1:], r.Moq.ResultsByParams_LookupCNAME[insertAt:0])
			r.Moq.ResultsByParams_LookupCNAME[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LookupCNAME(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqResolver_starGenType_LookupCNAME_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqResolver_starGenType_LookupCNAME_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqResolver_starGenType_LookupCNAME_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqResolver_starGenType_LookupCNAME_doFn
				DoReturnFn MoqResolver_starGenType_LookupCNAME_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqResolver_starGenType) PrettyParams_LookupCNAME(params MoqResolver_starGenType_LookupCNAME_params) string {
	return fmt.Sprintf("LookupCNAME(%#v, %#v)", params.Ctx, params.Host)
}

func (m *MoqResolver_starGenType) ParamsKey_LookupCNAME(params MoqResolver_starGenType_LookupCNAME_params, anyParams uint64) MoqResolver_starGenType_LookupCNAME_paramsKey {
	m.Scene.T.Helper()
	var ctxUsed context.Context
	var ctxUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LookupCNAME.Ctx == moq.ParamIndexByValue {
			ctxUsed = params.Ctx
		} else {
			ctxUsedHash = hash.DeepHash(params.Ctx)
		}
	}
	var hostUsed string
	var hostUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.LookupCNAME.Host == moq.ParamIndexByValue {
			hostUsed = params.Host
		} else {
			hostUsedHash = hash.DeepHash(params.Host)
		}
	}
	return MoqResolver_starGenType_LookupCNAME_paramsKey{
		Params: struct {
			Ctx  context.Context
			Host string
		}{
			Ctx:  ctxUsed,
			Host: hostUsed,
		},
		Hashes: struct {
			Ctx  hash.Hash
			Host hash.Hash
		}{
			Ctx:  ctxUsedHash,
			Host: hostUsedHash,
		},
	}
}

func (m *MoqResolver_starGenType_recorder) LookupSRV(ctx context.Context, service, proto, name string) *MoqResolver_starGenType_LookupSRV_fnRecorder {
	return &MoqResolver_starGenType_LookupSRV_fnRecorder{
		Params: MoqResolver_starGenType_LookupSRV_params{
			Ctx:     ctx,
			Service: service,
			Proto:   proto,
			Name:    name,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqResolver_starGenType_LookupSRV_fnRecorder) Any() *MoqResolver_starGenType_LookupSRV_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupSRV(r.Params))
		return nil
	}
	return &MoqResolver_starGenType_LookupSRV_anyParams{Recorder: r}
}

func (a *MoqResolver_starGenType_LookupSRV_anyParams) Ctx() *MoqResolver_starGenType_LookupSRV_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupSRV_anyParams) Service() *MoqResolver_starGenType_LookupSRV_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupSRV_anyParams) Proto() *MoqResolver_starGenType_LookupSRV_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupSRV_anyParams) Name() *MoqResolver_starGenType_LookupSRV_fnRecorder {
	a.Recorder.AnyParams |= 1 << 3
	return a.Recorder
}

func (r *MoqResolver_starGenType_LookupSRV_fnRecorder) Seq() *MoqResolver_starGenType_LookupSRV_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupSRV(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqResolver_starGenType_LookupSRV_fnRecorder) NoSeq() *MoqResolver_starGenType_LookupSRV_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupSRV(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqResolver_starGenType_LookupSRV_fnRecorder) ReturnResults(result1 string, result2 []*net.SRV, result3 error) *MoqResolver_starGenType_LookupSRV_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
			Result2 []*net.SRV
			Result3 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupSRV_doFn
		DoReturnFn MoqResolver_starGenType_LookupSRV_doReturnFn
	}{
		Values: &struct {
			Result1 string
			Result2 []*net.SRV
			Result3 error
		}{
			Result1: result1,
			Result2: result2,
			Result3: result3,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqResolver_starGenType_LookupSRV_fnRecorder) AndDo(fn MoqResolver_starGenType_LookupSRV_doFn) *MoqResolver_starGenType_LookupSRV_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqResolver_starGenType_LookupSRV_fnRecorder) DoReturnResults(fn MoqResolver_starGenType_LookupSRV_doReturnFn) *MoqResolver_starGenType_LookupSRV_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
			Result2 []*net.SRV
			Result3 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupSRV_doFn
		DoReturnFn MoqResolver_starGenType_LookupSRV_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqResolver_starGenType_LookupSRV_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqResolver_starGenType_LookupSRV_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LookupSRV {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqResolver_starGenType_LookupSRV_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqResolver_starGenType_LookupSRV_paramsKey]*MoqResolver_starGenType_LookupSRV_results{},
		}
		r.Moq.ResultsByParams_LookupSRV = append(r.Moq.ResultsByParams_LookupSRV, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LookupSRV) {
			copy(r.Moq.ResultsByParams_LookupSRV[insertAt+1:], r.Moq.ResultsByParams_LookupSRV[insertAt:0])
			r.Moq.ResultsByParams_LookupSRV[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LookupSRV(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqResolver_starGenType_LookupSRV_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqResolver_starGenType_LookupSRV_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqResolver_starGenType_LookupSRV_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
					Result2 []*net.SRV
					Result3 error
				}
				Sequence   uint32
				DoFn       MoqResolver_starGenType_LookupSRV_doFn
				DoReturnFn MoqResolver_starGenType_LookupSRV_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqResolver_starGenType) PrettyParams_LookupSRV(params MoqResolver_starGenType_LookupSRV_params) string {
	return fmt.Sprintf("LookupSRV(%#v, %#v, %#v, %#v)", params.Ctx, params.Service, params.Proto, params.Name)
}

func (m *MoqResolver_starGenType) ParamsKey_LookupSRV(params MoqResolver_starGenType_LookupSRV_params, anyParams uint64) MoqResolver_starGenType_LookupSRV_paramsKey {
	m.Scene.T.Helper()
	var ctxUsed context.Context
	var ctxUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LookupSRV.Ctx == moq.ParamIndexByValue {
			ctxUsed = params.Ctx
		} else {
			ctxUsedHash = hash.DeepHash(params.Ctx)
		}
	}
	var serviceUsed string
	var serviceUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.LookupSRV.Service == moq.ParamIndexByValue {
			serviceUsed = params.Service
		} else {
			serviceUsedHash = hash.DeepHash(params.Service)
		}
	}
	var protoUsed string
	var protoUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.LookupSRV.Proto == moq.ParamIndexByValue {
			protoUsed = params.Proto
		} else {
			protoUsedHash = hash.DeepHash(params.Proto)
		}
	}
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<3) == 0 {
		if m.Runtime.ParameterIndexing.LookupSRV.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	return MoqResolver_starGenType_LookupSRV_paramsKey{
		Params: struct {
			Ctx                  context.Context
			Service, Proto, Name string
		}{
			Ctx:     ctxUsed,
			Service: serviceUsed,
			Proto:   protoUsed,
			Name:    nameUsed,
		},
		Hashes: struct {
			Ctx                  hash.Hash
			Service, Proto, Name hash.Hash
		}{
			Ctx:     ctxUsedHash,
			Service: serviceUsedHash,
			Proto:   protoUsedHash,
			Name:    nameUsedHash,
		},
	}
}

func (m *MoqResolver_starGenType_recorder) LookupMX(ctx context.Context, name string) *MoqResolver_starGenType_LookupMX_fnRecorder {
	return &MoqResolver_starGenType_LookupMX_fnRecorder{
		Params: MoqResolver_starGenType_LookupMX_params{
			Ctx:  ctx,
			Name: name,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqResolver_starGenType_LookupMX_fnRecorder) Any() *MoqResolver_starGenType_LookupMX_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupMX(r.Params))
		return nil
	}
	return &MoqResolver_starGenType_LookupMX_anyParams{Recorder: r}
}

func (a *MoqResolver_starGenType_LookupMX_anyParams) Ctx() *MoqResolver_starGenType_LookupMX_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupMX_anyParams) Name() *MoqResolver_starGenType_LookupMX_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqResolver_starGenType_LookupMX_fnRecorder) Seq() *MoqResolver_starGenType_LookupMX_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupMX(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqResolver_starGenType_LookupMX_fnRecorder) NoSeq() *MoqResolver_starGenType_LookupMX_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupMX(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqResolver_starGenType_LookupMX_fnRecorder) ReturnResults(result1 []*net.MX, result2 error) *MoqResolver_starGenType_LookupMX_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []*net.MX
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupMX_doFn
		DoReturnFn MoqResolver_starGenType_LookupMX_doReturnFn
	}{
		Values: &struct {
			Result1 []*net.MX
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqResolver_starGenType_LookupMX_fnRecorder) AndDo(fn MoqResolver_starGenType_LookupMX_doFn) *MoqResolver_starGenType_LookupMX_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqResolver_starGenType_LookupMX_fnRecorder) DoReturnResults(fn MoqResolver_starGenType_LookupMX_doReturnFn) *MoqResolver_starGenType_LookupMX_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []*net.MX
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupMX_doFn
		DoReturnFn MoqResolver_starGenType_LookupMX_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqResolver_starGenType_LookupMX_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqResolver_starGenType_LookupMX_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LookupMX {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqResolver_starGenType_LookupMX_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqResolver_starGenType_LookupMX_paramsKey]*MoqResolver_starGenType_LookupMX_results{},
		}
		r.Moq.ResultsByParams_LookupMX = append(r.Moq.ResultsByParams_LookupMX, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LookupMX) {
			copy(r.Moq.ResultsByParams_LookupMX[insertAt+1:], r.Moq.ResultsByParams_LookupMX[insertAt:0])
			r.Moq.ResultsByParams_LookupMX[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LookupMX(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqResolver_starGenType_LookupMX_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqResolver_starGenType_LookupMX_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqResolver_starGenType_LookupMX_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []*net.MX
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqResolver_starGenType_LookupMX_doFn
				DoReturnFn MoqResolver_starGenType_LookupMX_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqResolver_starGenType) PrettyParams_LookupMX(params MoqResolver_starGenType_LookupMX_params) string {
	return fmt.Sprintf("LookupMX(%#v, %#v)", params.Ctx, params.Name)
}

func (m *MoqResolver_starGenType) ParamsKey_LookupMX(params MoqResolver_starGenType_LookupMX_params, anyParams uint64) MoqResolver_starGenType_LookupMX_paramsKey {
	m.Scene.T.Helper()
	var ctxUsed context.Context
	var ctxUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LookupMX.Ctx == moq.ParamIndexByValue {
			ctxUsed = params.Ctx
		} else {
			ctxUsedHash = hash.DeepHash(params.Ctx)
		}
	}
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.LookupMX.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	return MoqResolver_starGenType_LookupMX_paramsKey{
		Params: struct {
			Ctx  context.Context
			Name string
		}{
			Ctx:  ctxUsed,
			Name: nameUsed,
		},
		Hashes: struct {
			Ctx  hash.Hash
			Name hash.Hash
		}{
			Ctx:  ctxUsedHash,
			Name: nameUsedHash,
		},
	}
}

func (m *MoqResolver_starGenType_recorder) LookupNS(ctx context.Context, name string) *MoqResolver_starGenType_LookupNS_fnRecorder {
	return &MoqResolver_starGenType_LookupNS_fnRecorder{
		Params: MoqResolver_starGenType_LookupNS_params{
			Ctx:  ctx,
			Name: name,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqResolver_starGenType_LookupNS_fnRecorder) Any() *MoqResolver_starGenType_LookupNS_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupNS(r.Params))
		return nil
	}
	return &MoqResolver_starGenType_LookupNS_anyParams{Recorder: r}
}

func (a *MoqResolver_starGenType_LookupNS_anyParams) Ctx() *MoqResolver_starGenType_LookupNS_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupNS_anyParams) Name() *MoqResolver_starGenType_LookupNS_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqResolver_starGenType_LookupNS_fnRecorder) Seq() *MoqResolver_starGenType_LookupNS_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupNS(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqResolver_starGenType_LookupNS_fnRecorder) NoSeq() *MoqResolver_starGenType_LookupNS_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupNS(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqResolver_starGenType_LookupNS_fnRecorder) ReturnResults(result1 []*net.NS, result2 error) *MoqResolver_starGenType_LookupNS_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []*net.NS
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupNS_doFn
		DoReturnFn MoqResolver_starGenType_LookupNS_doReturnFn
	}{
		Values: &struct {
			Result1 []*net.NS
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqResolver_starGenType_LookupNS_fnRecorder) AndDo(fn MoqResolver_starGenType_LookupNS_doFn) *MoqResolver_starGenType_LookupNS_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqResolver_starGenType_LookupNS_fnRecorder) DoReturnResults(fn MoqResolver_starGenType_LookupNS_doReturnFn) *MoqResolver_starGenType_LookupNS_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []*net.NS
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupNS_doFn
		DoReturnFn MoqResolver_starGenType_LookupNS_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqResolver_starGenType_LookupNS_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqResolver_starGenType_LookupNS_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LookupNS {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqResolver_starGenType_LookupNS_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqResolver_starGenType_LookupNS_paramsKey]*MoqResolver_starGenType_LookupNS_results{},
		}
		r.Moq.ResultsByParams_LookupNS = append(r.Moq.ResultsByParams_LookupNS, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LookupNS) {
			copy(r.Moq.ResultsByParams_LookupNS[insertAt+1:], r.Moq.ResultsByParams_LookupNS[insertAt:0])
			r.Moq.ResultsByParams_LookupNS[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LookupNS(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqResolver_starGenType_LookupNS_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqResolver_starGenType_LookupNS_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqResolver_starGenType_LookupNS_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []*net.NS
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqResolver_starGenType_LookupNS_doFn
				DoReturnFn MoqResolver_starGenType_LookupNS_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqResolver_starGenType) PrettyParams_LookupNS(params MoqResolver_starGenType_LookupNS_params) string {
	return fmt.Sprintf("LookupNS(%#v, %#v)", params.Ctx, params.Name)
}

func (m *MoqResolver_starGenType) ParamsKey_LookupNS(params MoqResolver_starGenType_LookupNS_params, anyParams uint64) MoqResolver_starGenType_LookupNS_paramsKey {
	m.Scene.T.Helper()
	var ctxUsed context.Context
	var ctxUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LookupNS.Ctx == moq.ParamIndexByValue {
			ctxUsed = params.Ctx
		} else {
			ctxUsedHash = hash.DeepHash(params.Ctx)
		}
	}
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.LookupNS.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	return MoqResolver_starGenType_LookupNS_paramsKey{
		Params: struct {
			Ctx  context.Context
			Name string
		}{
			Ctx:  ctxUsed,
			Name: nameUsed,
		},
		Hashes: struct {
			Ctx  hash.Hash
			Name hash.Hash
		}{
			Ctx:  ctxUsedHash,
			Name: nameUsedHash,
		},
	}
}

func (m *MoqResolver_starGenType_recorder) LookupTXT(ctx context.Context, name string) *MoqResolver_starGenType_LookupTXT_fnRecorder {
	return &MoqResolver_starGenType_LookupTXT_fnRecorder{
		Params: MoqResolver_starGenType_LookupTXT_params{
			Ctx:  ctx,
			Name: name,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqResolver_starGenType_LookupTXT_fnRecorder) Any() *MoqResolver_starGenType_LookupTXT_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupTXT(r.Params))
		return nil
	}
	return &MoqResolver_starGenType_LookupTXT_anyParams{Recorder: r}
}

func (a *MoqResolver_starGenType_LookupTXT_anyParams) Ctx() *MoqResolver_starGenType_LookupTXT_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupTXT_anyParams) Name() *MoqResolver_starGenType_LookupTXT_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqResolver_starGenType_LookupTXT_fnRecorder) Seq() *MoqResolver_starGenType_LookupTXT_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupTXT(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqResolver_starGenType_LookupTXT_fnRecorder) NoSeq() *MoqResolver_starGenType_LookupTXT_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupTXT(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqResolver_starGenType_LookupTXT_fnRecorder) ReturnResults(result1 []string, result2 error) *MoqResolver_starGenType_LookupTXT_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupTXT_doFn
		DoReturnFn MoqResolver_starGenType_LookupTXT_doReturnFn
	}{
		Values: &struct {
			Result1 []string
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqResolver_starGenType_LookupTXT_fnRecorder) AndDo(fn MoqResolver_starGenType_LookupTXT_doFn) *MoqResolver_starGenType_LookupTXT_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqResolver_starGenType_LookupTXT_fnRecorder) DoReturnResults(fn MoqResolver_starGenType_LookupTXT_doReturnFn) *MoqResolver_starGenType_LookupTXT_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupTXT_doFn
		DoReturnFn MoqResolver_starGenType_LookupTXT_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqResolver_starGenType_LookupTXT_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqResolver_starGenType_LookupTXT_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LookupTXT {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqResolver_starGenType_LookupTXT_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqResolver_starGenType_LookupTXT_paramsKey]*MoqResolver_starGenType_LookupTXT_results{},
		}
		r.Moq.ResultsByParams_LookupTXT = append(r.Moq.ResultsByParams_LookupTXT, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LookupTXT) {
			copy(r.Moq.ResultsByParams_LookupTXT[insertAt+1:], r.Moq.ResultsByParams_LookupTXT[insertAt:0])
			r.Moq.ResultsByParams_LookupTXT[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LookupTXT(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqResolver_starGenType_LookupTXT_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqResolver_starGenType_LookupTXT_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqResolver_starGenType_LookupTXT_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []string
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqResolver_starGenType_LookupTXT_doFn
				DoReturnFn MoqResolver_starGenType_LookupTXT_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqResolver_starGenType) PrettyParams_LookupTXT(params MoqResolver_starGenType_LookupTXT_params) string {
	return fmt.Sprintf("LookupTXT(%#v, %#v)", params.Ctx, params.Name)
}

func (m *MoqResolver_starGenType) ParamsKey_LookupTXT(params MoqResolver_starGenType_LookupTXT_params, anyParams uint64) MoqResolver_starGenType_LookupTXT_paramsKey {
	m.Scene.T.Helper()
	var ctxUsed context.Context
	var ctxUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LookupTXT.Ctx == moq.ParamIndexByValue {
			ctxUsed = params.Ctx
		} else {
			ctxUsedHash = hash.DeepHash(params.Ctx)
		}
	}
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.LookupTXT.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	return MoqResolver_starGenType_LookupTXT_paramsKey{
		Params: struct {
			Ctx  context.Context
			Name string
		}{
			Ctx:  ctxUsed,
			Name: nameUsed,
		},
		Hashes: struct {
			Ctx  hash.Hash
			Name hash.Hash
		}{
			Ctx:  ctxUsedHash,
			Name: nameUsedHash,
		},
	}
}

func (m *MoqResolver_starGenType_recorder) LookupAddr(ctx context.Context, addr string) *MoqResolver_starGenType_LookupAddr_fnRecorder {
	return &MoqResolver_starGenType_LookupAddr_fnRecorder{
		Params: MoqResolver_starGenType_LookupAddr_params{
			Ctx:  ctx,
			Addr: addr,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqResolver_starGenType_LookupAddr_fnRecorder) Any() *MoqResolver_starGenType_LookupAddr_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupAddr(r.Params))
		return nil
	}
	return &MoqResolver_starGenType_LookupAddr_anyParams{Recorder: r}
}

func (a *MoqResolver_starGenType_LookupAddr_anyParams) Ctx() *MoqResolver_starGenType_LookupAddr_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqResolver_starGenType_LookupAddr_anyParams) Addr() *MoqResolver_starGenType_LookupAddr_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqResolver_starGenType_LookupAddr_fnRecorder) Seq() *MoqResolver_starGenType_LookupAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupAddr(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqResolver_starGenType_LookupAddr_fnRecorder) NoSeq() *MoqResolver_starGenType_LookupAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LookupAddr(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqResolver_starGenType_LookupAddr_fnRecorder) ReturnResults(result1 []string, result2 error) *MoqResolver_starGenType_LookupAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupAddr_doFn
		DoReturnFn MoqResolver_starGenType_LookupAddr_doReturnFn
	}{
		Values: &struct {
			Result1 []string
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqResolver_starGenType_LookupAddr_fnRecorder) AndDo(fn MoqResolver_starGenType_LookupAddr_doFn) *MoqResolver_starGenType_LookupAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqResolver_starGenType_LookupAddr_fnRecorder) DoReturnResults(fn MoqResolver_starGenType_LookupAddr_doReturnFn) *MoqResolver_starGenType_LookupAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqResolver_starGenType_LookupAddr_doFn
		DoReturnFn MoqResolver_starGenType_LookupAddr_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqResolver_starGenType_LookupAddr_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqResolver_starGenType_LookupAddr_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LookupAddr {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqResolver_starGenType_LookupAddr_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqResolver_starGenType_LookupAddr_paramsKey]*MoqResolver_starGenType_LookupAddr_results{},
		}
		r.Moq.ResultsByParams_LookupAddr = append(r.Moq.ResultsByParams_LookupAddr, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LookupAddr) {
			copy(r.Moq.ResultsByParams_LookupAddr[insertAt+1:], r.Moq.ResultsByParams_LookupAddr[insertAt:0])
			r.Moq.ResultsByParams_LookupAddr[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LookupAddr(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqResolver_starGenType_LookupAddr_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqResolver_starGenType_LookupAddr_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqResolver_starGenType_LookupAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []string
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqResolver_starGenType_LookupAddr_doFn
				DoReturnFn MoqResolver_starGenType_LookupAddr_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqResolver_starGenType) PrettyParams_LookupAddr(params MoqResolver_starGenType_LookupAddr_params) string {
	return fmt.Sprintf("LookupAddr(%#v, %#v)", params.Ctx, params.Addr)
}

func (m *MoqResolver_starGenType) ParamsKey_LookupAddr(params MoqResolver_starGenType_LookupAddr_params, anyParams uint64) MoqResolver_starGenType_LookupAddr_paramsKey {
	m.Scene.T.Helper()
	var ctxUsed context.Context
	var ctxUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.LookupAddr.Ctx == moq.ParamIndexByValue {
			ctxUsed = params.Ctx
		} else {
			ctxUsedHash = hash.DeepHash(params.Ctx)
		}
	}
	var addrUsed string
	var addrUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.LookupAddr.Addr == moq.ParamIndexByValue {
			addrUsed = params.Addr
		} else {
			addrUsedHash = hash.DeepHash(params.Addr)
		}
	}
	return MoqResolver_starGenType_LookupAddr_paramsKey{
		Params: struct {
			Ctx  context.Context
			Addr string
		}{
			Ctx:  ctxUsed,
			Addr: addrUsed,
		},
		Hashes: struct {
			Ctx  hash.Hash
			Addr hash.Hash
		}{
			Ctx:  ctxUsedHash,
			Addr: addrUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqResolver_starGenType) Reset() {
	m.ResultsByParams_LookupHost = nil
	m.ResultsByParams_LookupIPAddr = nil
	m.ResultsByParams_LookupIP = nil
	m.ResultsByParams_LookupPort = nil
	m.ResultsByParams_LookupCNAME = nil
	m.ResultsByParams_LookupSRV = nil
	m.ResultsByParams_LookupMX = nil
	m.ResultsByParams_LookupNS = nil
	m.ResultsByParams_LookupTXT = nil
	m.ResultsByParams_LookupAddr = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqResolver_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_LookupHost {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LookupHost(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LookupIPAddr {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LookupIPAddr(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LookupIP {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LookupIP(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LookupPort {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LookupPort(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LookupCNAME {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LookupCNAME(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LookupSRV {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LookupSRV(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LookupMX {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LookupMX(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LookupNS {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LookupNS(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LookupTXT {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LookupTXT(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LookupAddr {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LookupAddr(results.Params))
			}
		}
	}
}
