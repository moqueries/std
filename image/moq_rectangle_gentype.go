// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package image

import (
	"fmt"
	"image"
	"image/color"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that image.Rectangle_genType is mocked
// completely
var _ Rectangle_genType = (*MoqRectangle_genType_mock)(nil)

// Rectangle_genType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Rectangle_genType interface {
	String() string
	Dx() int
	Dy() int
	Size() image.Point
	Add(p image.Point) image.Rectangle
	Sub(p image.Point) image.Rectangle
	Inset(n int) image.Rectangle
	Intersect(s image.Rectangle) image.Rectangle
	Union(s image.Rectangle) image.Rectangle
	Empty() bool
	Eq(s image.Rectangle) bool
	Overlaps(s image.Rectangle) bool
	In(s image.Rectangle) bool
	Canon() image.Rectangle
	At(x, y int) color.Color
	RGBA64At(x, y int) color.RGBA64
	Bounds() image.Rectangle
	ColorModel() color.Model
}

// MoqRectangle_genType holds the state of a moq of the Rectangle_genType type
type MoqRectangle_genType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqRectangle_genType_mock

	ResultsByParams_String     []MoqRectangle_genType_String_resultsByParams
	ResultsByParams_Dx         []MoqRectangle_genType_Dx_resultsByParams
	ResultsByParams_Dy         []MoqRectangle_genType_Dy_resultsByParams
	ResultsByParams_Size       []MoqRectangle_genType_Size_resultsByParams
	ResultsByParams_Add        []MoqRectangle_genType_Add_resultsByParams
	ResultsByParams_Sub        []MoqRectangle_genType_Sub_resultsByParams
	ResultsByParams_Inset      []MoqRectangle_genType_Inset_resultsByParams
	ResultsByParams_Intersect  []MoqRectangle_genType_Intersect_resultsByParams
	ResultsByParams_Union      []MoqRectangle_genType_Union_resultsByParams
	ResultsByParams_Empty      []MoqRectangle_genType_Empty_resultsByParams
	ResultsByParams_Eq         []MoqRectangle_genType_Eq_resultsByParams
	ResultsByParams_Overlaps   []MoqRectangle_genType_Overlaps_resultsByParams
	ResultsByParams_In         []MoqRectangle_genType_In_resultsByParams
	ResultsByParams_Canon      []MoqRectangle_genType_Canon_resultsByParams
	ResultsByParams_At         []MoqRectangle_genType_At_resultsByParams
	ResultsByParams_RGBA64At   []MoqRectangle_genType_RGBA64At_resultsByParams
	ResultsByParams_Bounds     []MoqRectangle_genType_Bounds_resultsByParams
	ResultsByParams_ColorModel []MoqRectangle_genType_ColorModel_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			String struct{}
			Dx     struct{}
			Dy     struct{}
			Size   struct{}
			Add    struct {
				P moq.ParamIndexing
			}
			Sub struct {
				P moq.ParamIndexing
			}
			Inset struct {
				N moq.ParamIndexing
			}
			Intersect struct {
				S moq.ParamIndexing
			}
			Union struct {
				S moq.ParamIndexing
			}
			Empty struct{}
			Eq    struct {
				S moq.ParamIndexing
			}
			Overlaps struct {
				S moq.ParamIndexing
			}
			In struct {
				S moq.ParamIndexing
			}
			Canon struct{}
			At    struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			RGBA64At struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Bounds     struct{}
			ColorModel struct{}
		}
	}
}

// MoqRectangle_genType_mock isolates the mock interface of the
// Rectangle_genType type
type MoqRectangle_genType_mock struct {
	Moq *MoqRectangle_genType
}

// MoqRectangle_genType_recorder isolates the recorder interface of the
// Rectangle_genType type
type MoqRectangle_genType_recorder struct {
	Moq *MoqRectangle_genType
}

// MoqRectangle_genType_String_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_String_params struct{}

// MoqRectangle_genType_String_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRectangle_genType_String_resultsByParams contains the results for a given
// set of parameters for the Rectangle_genType type
type MoqRectangle_genType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_String_paramsKey]*MoqRectangle_genType_String_results
}

// MoqRectangle_genType_String_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_String_doFn func()

// MoqRectangle_genType_String_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_String_doReturnFn func() string

// MoqRectangle_genType_String_results holds the results of the
// Rectangle_genType type
type MoqRectangle_genType_String_results struct {
	Params  MoqRectangle_genType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_String_doFn
		DoReturnFn MoqRectangle_genType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_String_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_String_fnRecorder struct {
	Params    MoqRectangle_genType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_String_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_String_anyParams isolates the any params functions of
// the Rectangle_genType type
type MoqRectangle_genType_String_anyParams struct {
	Recorder *MoqRectangle_genType_String_fnRecorder
}

// MoqRectangle_genType_Dx_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_Dx_params struct{}

// MoqRectangle_genType_Dx_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Dx_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRectangle_genType_Dx_resultsByParams contains the results for a given set
// of parameters for the Rectangle_genType type
type MoqRectangle_genType_Dx_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Dx_paramsKey]*MoqRectangle_genType_Dx_results
}

// MoqRectangle_genType_Dx_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Dx_doFn func()

// MoqRectangle_genType_Dx_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Dx_doReturnFn func() int

// MoqRectangle_genType_Dx_results holds the results of the Rectangle_genType
// type
type MoqRectangle_genType_Dx_results struct {
	Params  MoqRectangle_genType_Dx_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Dx_doFn
		DoReturnFn MoqRectangle_genType_Dx_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Dx_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_Dx_fnRecorder struct {
	Params    MoqRectangle_genType_Dx_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Dx_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Dx_anyParams isolates the any params functions of the
// Rectangle_genType type
type MoqRectangle_genType_Dx_anyParams struct {
	Recorder *MoqRectangle_genType_Dx_fnRecorder
}

// MoqRectangle_genType_Dy_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_Dy_params struct{}

// MoqRectangle_genType_Dy_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Dy_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRectangle_genType_Dy_resultsByParams contains the results for a given set
// of parameters for the Rectangle_genType type
type MoqRectangle_genType_Dy_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Dy_paramsKey]*MoqRectangle_genType_Dy_results
}

// MoqRectangle_genType_Dy_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Dy_doFn func()

// MoqRectangle_genType_Dy_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Dy_doReturnFn func() int

// MoqRectangle_genType_Dy_results holds the results of the Rectangle_genType
// type
type MoqRectangle_genType_Dy_results struct {
	Params  MoqRectangle_genType_Dy_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Dy_doFn
		DoReturnFn MoqRectangle_genType_Dy_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Dy_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_Dy_fnRecorder struct {
	Params    MoqRectangle_genType_Dy_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Dy_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Dy_anyParams isolates the any params functions of the
// Rectangle_genType type
type MoqRectangle_genType_Dy_anyParams struct {
	Recorder *MoqRectangle_genType_Dy_fnRecorder
}

// MoqRectangle_genType_Size_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_Size_params struct{}

// MoqRectangle_genType_Size_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Size_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRectangle_genType_Size_resultsByParams contains the results for a given
// set of parameters for the Rectangle_genType type
type MoqRectangle_genType_Size_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Size_paramsKey]*MoqRectangle_genType_Size_results
}

// MoqRectangle_genType_Size_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Size_doFn func()

// MoqRectangle_genType_Size_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Size_doReturnFn func() image.Point

// MoqRectangle_genType_Size_results holds the results of the Rectangle_genType
// type
type MoqRectangle_genType_Size_results struct {
	Params  MoqRectangle_genType_Size_params
	Results []struct {
		Values *struct {
			Result1 image.Point
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Size_doFn
		DoReturnFn MoqRectangle_genType_Size_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Size_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_Size_fnRecorder struct {
	Params    MoqRectangle_genType_Size_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Size_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Size_anyParams isolates the any params functions of the
// Rectangle_genType type
type MoqRectangle_genType_Size_anyParams struct {
	Recorder *MoqRectangle_genType_Size_fnRecorder
}

// MoqRectangle_genType_Add_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_Add_params struct{ P image.Point }

// MoqRectangle_genType_Add_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Add_paramsKey struct {
	Params struct{ P image.Point }
	Hashes struct{ P hash.Hash }
}

// MoqRectangle_genType_Add_resultsByParams contains the results for a given
// set of parameters for the Rectangle_genType type
type MoqRectangle_genType_Add_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Add_paramsKey]*MoqRectangle_genType_Add_results
}

// MoqRectangle_genType_Add_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Add_doFn func(p image.Point)

// MoqRectangle_genType_Add_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Add_doReturnFn func(p image.Point) image.Rectangle

// MoqRectangle_genType_Add_results holds the results of the Rectangle_genType
// type
type MoqRectangle_genType_Add_results struct {
	Params  MoqRectangle_genType_Add_params
	Results []struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Add_doFn
		DoReturnFn MoqRectangle_genType_Add_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Add_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_Add_fnRecorder struct {
	Params    MoqRectangle_genType_Add_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Add_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Add_anyParams isolates the any params functions of the
// Rectangle_genType type
type MoqRectangle_genType_Add_anyParams struct {
	Recorder *MoqRectangle_genType_Add_fnRecorder
}

// MoqRectangle_genType_Sub_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_Sub_params struct{ P image.Point }

// MoqRectangle_genType_Sub_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Sub_paramsKey struct {
	Params struct{ P image.Point }
	Hashes struct{ P hash.Hash }
}

// MoqRectangle_genType_Sub_resultsByParams contains the results for a given
// set of parameters for the Rectangle_genType type
type MoqRectangle_genType_Sub_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Sub_paramsKey]*MoqRectangle_genType_Sub_results
}

// MoqRectangle_genType_Sub_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Sub_doFn func(p image.Point)

// MoqRectangle_genType_Sub_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Sub_doReturnFn func(p image.Point) image.Rectangle

// MoqRectangle_genType_Sub_results holds the results of the Rectangle_genType
// type
type MoqRectangle_genType_Sub_results struct {
	Params  MoqRectangle_genType_Sub_params
	Results []struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Sub_doFn
		DoReturnFn MoqRectangle_genType_Sub_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Sub_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_Sub_fnRecorder struct {
	Params    MoqRectangle_genType_Sub_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Sub_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Sub_anyParams isolates the any params functions of the
// Rectangle_genType type
type MoqRectangle_genType_Sub_anyParams struct {
	Recorder *MoqRectangle_genType_Sub_fnRecorder
}

// MoqRectangle_genType_Inset_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_Inset_params struct{ N int }

// MoqRectangle_genType_Inset_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Inset_paramsKey struct {
	Params struct{ N int }
	Hashes struct{ N hash.Hash }
}

// MoqRectangle_genType_Inset_resultsByParams contains the results for a given
// set of parameters for the Rectangle_genType type
type MoqRectangle_genType_Inset_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Inset_paramsKey]*MoqRectangle_genType_Inset_results
}

// MoqRectangle_genType_Inset_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Inset_doFn func(n int)

// MoqRectangle_genType_Inset_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Inset_doReturnFn func(n int) image.Rectangle

// MoqRectangle_genType_Inset_results holds the results of the
// Rectangle_genType type
type MoqRectangle_genType_Inset_results struct {
	Params  MoqRectangle_genType_Inset_params
	Results []struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Inset_doFn
		DoReturnFn MoqRectangle_genType_Inset_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Inset_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_Inset_fnRecorder struct {
	Params    MoqRectangle_genType_Inset_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Inset_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Inset_anyParams isolates the any params functions of
// the Rectangle_genType type
type MoqRectangle_genType_Inset_anyParams struct {
	Recorder *MoqRectangle_genType_Inset_fnRecorder
}

// MoqRectangle_genType_Intersect_params holds the params of the
// Rectangle_genType type
type MoqRectangle_genType_Intersect_params struct{ S image.Rectangle }

// MoqRectangle_genType_Intersect_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Intersect_paramsKey struct {
	Params struct{ S image.Rectangle }
	Hashes struct{ S hash.Hash }
}

// MoqRectangle_genType_Intersect_resultsByParams contains the results for a
// given set of parameters for the Rectangle_genType type
type MoqRectangle_genType_Intersect_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Intersect_paramsKey]*MoqRectangle_genType_Intersect_results
}

// MoqRectangle_genType_Intersect_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Intersect_doFn func(s image.Rectangle)

// MoqRectangle_genType_Intersect_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Intersect_doReturnFn func(s image.Rectangle) image.Rectangle

// MoqRectangle_genType_Intersect_results holds the results of the
// Rectangle_genType type
type MoqRectangle_genType_Intersect_results struct {
	Params  MoqRectangle_genType_Intersect_params
	Results []struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Intersect_doFn
		DoReturnFn MoqRectangle_genType_Intersect_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Intersect_fnRecorder routes recorded function calls to
// the MoqRectangle_genType moq
type MoqRectangle_genType_Intersect_fnRecorder struct {
	Params    MoqRectangle_genType_Intersect_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Intersect_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Intersect_anyParams isolates the any params functions
// of the Rectangle_genType type
type MoqRectangle_genType_Intersect_anyParams struct {
	Recorder *MoqRectangle_genType_Intersect_fnRecorder
}

// MoqRectangle_genType_Union_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_Union_params struct{ S image.Rectangle }

// MoqRectangle_genType_Union_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Union_paramsKey struct {
	Params struct{ S image.Rectangle }
	Hashes struct{ S hash.Hash }
}

// MoqRectangle_genType_Union_resultsByParams contains the results for a given
// set of parameters for the Rectangle_genType type
type MoqRectangle_genType_Union_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Union_paramsKey]*MoqRectangle_genType_Union_results
}

// MoqRectangle_genType_Union_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Union_doFn func(s image.Rectangle)

// MoqRectangle_genType_Union_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Union_doReturnFn func(s image.Rectangle) image.Rectangle

// MoqRectangle_genType_Union_results holds the results of the
// Rectangle_genType type
type MoqRectangle_genType_Union_results struct {
	Params  MoqRectangle_genType_Union_params
	Results []struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Union_doFn
		DoReturnFn MoqRectangle_genType_Union_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Union_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_Union_fnRecorder struct {
	Params    MoqRectangle_genType_Union_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Union_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Union_anyParams isolates the any params functions of
// the Rectangle_genType type
type MoqRectangle_genType_Union_anyParams struct {
	Recorder *MoqRectangle_genType_Union_fnRecorder
}

// MoqRectangle_genType_Empty_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_Empty_params struct{}

// MoqRectangle_genType_Empty_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Empty_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRectangle_genType_Empty_resultsByParams contains the results for a given
// set of parameters for the Rectangle_genType type
type MoqRectangle_genType_Empty_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Empty_paramsKey]*MoqRectangle_genType_Empty_results
}

// MoqRectangle_genType_Empty_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Empty_doFn func()

// MoqRectangle_genType_Empty_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Empty_doReturnFn func() bool

// MoqRectangle_genType_Empty_results holds the results of the
// Rectangle_genType type
type MoqRectangle_genType_Empty_results struct {
	Params  MoqRectangle_genType_Empty_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Empty_doFn
		DoReturnFn MoqRectangle_genType_Empty_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Empty_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_Empty_fnRecorder struct {
	Params    MoqRectangle_genType_Empty_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Empty_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Empty_anyParams isolates the any params functions of
// the Rectangle_genType type
type MoqRectangle_genType_Empty_anyParams struct {
	Recorder *MoqRectangle_genType_Empty_fnRecorder
}

// MoqRectangle_genType_Eq_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_Eq_params struct{ S image.Rectangle }

// MoqRectangle_genType_Eq_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Eq_paramsKey struct {
	Params struct{ S image.Rectangle }
	Hashes struct{ S hash.Hash }
}

// MoqRectangle_genType_Eq_resultsByParams contains the results for a given set
// of parameters for the Rectangle_genType type
type MoqRectangle_genType_Eq_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Eq_paramsKey]*MoqRectangle_genType_Eq_results
}

// MoqRectangle_genType_Eq_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Eq_doFn func(s image.Rectangle)

// MoqRectangle_genType_Eq_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Eq_doReturnFn func(s image.Rectangle) bool

// MoqRectangle_genType_Eq_results holds the results of the Rectangle_genType
// type
type MoqRectangle_genType_Eq_results struct {
	Params  MoqRectangle_genType_Eq_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Eq_doFn
		DoReturnFn MoqRectangle_genType_Eq_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Eq_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_Eq_fnRecorder struct {
	Params    MoqRectangle_genType_Eq_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Eq_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Eq_anyParams isolates the any params functions of the
// Rectangle_genType type
type MoqRectangle_genType_Eq_anyParams struct {
	Recorder *MoqRectangle_genType_Eq_fnRecorder
}

// MoqRectangle_genType_Overlaps_params holds the params of the
// Rectangle_genType type
type MoqRectangle_genType_Overlaps_params struct{ S image.Rectangle }

// MoqRectangle_genType_Overlaps_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Overlaps_paramsKey struct {
	Params struct{ S image.Rectangle }
	Hashes struct{ S hash.Hash }
}

// MoqRectangle_genType_Overlaps_resultsByParams contains the results for a
// given set of parameters for the Rectangle_genType type
type MoqRectangle_genType_Overlaps_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Overlaps_paramsKey]*MoqRectangle_genType_Overlaps_results
}

// MoqRectangle_genType_Overlaps_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Overlaps_doFn func(s image.Rectangle)

// MoqRectangle_genType_Overlaps_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Overlaps_doReturnFn func(s image.Rectangle) bool

// MoqRectangle_genType_Overlaps_results holds the results of the
// Rectangle_genType type
type MoqRectangle_genType_Overlaps_results struct {
	Params  MoqRectangle_genType_Overlaps_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Overlaps_doFn
		DoReturnFn MoqRectangle_genType_Overlaps_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Overlaps_fnRecorder routes recorded function calls to
// the MoqRectangle_genType moq
type MoqRectangle_genType_Overlaps_fnRecorder struct {
	Params    MoqRectangle_genType_Overlaps_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Overlaps_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Overlaps_anyParams isolates the any params functions of
// the Rectangle_genType type
type MoqRectangle_genType_Overlaps_anyParams struct {
	Recorder *MoqRectangle_genType_Overlaps_fnRecorder
}

// MoqRectangle_genType_In_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_In_params struct{ S image.Rectangle }

// MoqRectangle_genType_In_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_In_paramsKey struct {
	Params struct{ S image.Rectangle }
	Hashes struct{ S hash.Hash }
}

// MoqRectangle_genType_In_resultsByParams contains the results for a given set
// of parameters for the Rectangle_genType type
type MoqRectangle_genType_In_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_In_paramsKey]*MoqRectangle_genType_In_results
}

// MoqRectangle_genType_In_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_In_doFn func(s image.Rectangle)

// MoqRectangle_genType_In_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_In_doReturnFn func(s image.Rectangle) bool

// MoqRectangle_genType_In_results holds the results of the Rectangle_genType
// type
type MoqRectangle_genType_In_results struct {
	Params  MoqRectangle_genType_In_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_In_doFn
		DoReturnFn MoqRectangle_genType_In_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_In_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_In_fnRecorder struct {
	Params    MoqRectangle_genType_In_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_In_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_In_anyParams isolates the any params functions of the
// Rectangle_genType type
type MoqRectangle_genType_In_anyParams struct {
	Recorder *MoqRectangle_genType_In_fnRecorder
}

// MoqRectangle_genType_Canon_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_Canon_params struct{}

// MoqRectangle_genType_Canon_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Canon_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRectangle_genType_Canon_resultsByParams contains the results for a given
// set of parameters for the Rectangle_genType type
type MoqRectangle_genType_Canon_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Canon_paramsKey]*MoqRectangle_genType_Canon_results
}

// MoqRectangle_genType_Canon_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Canon_doFn func()

// MoqRectangle_genType_Canon_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Canon_doReturnFn func() image.Rectangle

// MoqRectangle_genType_Canon_results holds the results of the
// Rectangle_genType type
type MoqRectangle_genType_Canon_results struct {
	Params  MoqRectangle_genType_Canon_params
	Results []struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Canon_doFn
		DoReturnFn MoqRectangle_genType_Canon_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Canon_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_Canon_fnRecorder struct {
	Params    MoqRectangle_genType_Canon_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Canon_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Canon_anyParams isolates the any params functions of
// the Rectangle_genType type
type MoqRectangle_genType_Canon_anyParams struct {
	Recorder *MoqRectangle_genType_Canon_fnRecorder
}

// MoqRectangle_genType_At_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_At_params struct{ X, Y int }

// MoqRectangle_genType_At_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_At_paramsKey struct {
	Params struct{ X, Y int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqRectangle_genType_At_resultsByParams contains the results for a given set
// of parameters for the Rectangle_genType type
type MoqRectangle_genType_At_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_At_paramsKey]*MoqRectangle_genType_At_results
}

// MoqRectangle_genType_At_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_At_doFn func(x, y int)

// MoqRectangle_genType_At_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_At_doReturnFn func(x, y int) color.Color

// MoqRectangle_genType_At_results holds the results of the Rectangle_genType
// type
type MoqRectangle_genType_At_results struct {
	Params  MoqRectangle_genType_At_params
	Results []struct {
		Values *struct {
			Result1 color.Color
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_At_doFn
		DoReturnFn MoqRectangle_genType_At_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_At_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_At_fnRecorder struct {
	Params    MoqRectangle_genType_At_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_At_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_At_anyParams isolates the any params functions of the
// Rectangle_genType type
type MoqRectangle_genType_At_anyParams struct {
	Recorder *MoqRectangle_genType_At_fnRecorder
}

// MoqRectangle_genType_RGBA64At_params holds the params of the
// Rectangle_genType type
type MoqRectangle_genType_RGBA64At_params struct{ X, Y int }

// MoqRectangle_genType_RGBA64At_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_RGBA64At_paramsKey struct {
	Params struct{ X, Y int }
	Hashes struct{ X, Y hash.Hash }
}

// MoqRectangle_genType_RGBA64At_resultsByParams contains the results for a
// given set of parameters for the Rectangle_genType type
type MoqRectangle_genType_RGBA64At_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_RGBA64At_paramsKey]*MoqRectangle_genType_RGBA64At_results
}

// MoqRectangle_genType_RGBA64At_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_RGBA64At_doFn func(x, y int)

// MoqRectangle_genType_RGBA64At_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_RGBA64At_doReturnFn func(x, y int) color.RGBA64

// MoqRectangle_genType_RGBA64At_results holds the results of the
// Rectangle_genType type
type MoqRectangle_genType_RGBA64At_results struct {
	Params  MoqRectangle_genType_RGBA64At_params
	Results []struct {
		Values *struct {
			Result1 color.RGBA64
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_RGBA64At_doFn
		DoReturnFn MoqRectangle_genType_RGBA64At_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_RGBA64At_fnRecorder routes recorded function calls to
// the MoqRectangle_genType moq
type MoqRectangle_genType_RGBA64At_fnRecorder struct {
	Params    MoqRectangle_genType_RGBA64At_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_RGBA64At_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_RGBA64At_anyParams isolates the any params functions of
// the Rectangle_genType type
type MoqRectangle_genType_RGBA64At_anyParams struct {
	Recorder *MoqRectangle_genType_RGBA64At_fnRecorder
}

// MoqRectangle_genType_Bounds_params holds the params of the Rectangle_genType
// type
type MoqRectangle_genType_Bounds_params struct{}

// MoqRectangle_genType_Bounds_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_Bounds_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRectangle_genType_Bounds_resultsByParams contains the results for a given
// set of parameters for the Rectangle_genType type
type MoqRectangle_genType_Bounds_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_Bounds_paramsKey]*MoqRectangle_genType_Bounds_results
}

// MoqRectangle_genType_Bounds_doFn defines the type of function needed when
// calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_Bounds_doFn func()

// MoqRectangle_genType_Bounds_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_Bounds_doReturnFn func() image.Rectangle

// MoqRectangle_genType_Bounds_results holds the results of the
// Rectangle_genType type
type MoqRectangle_genType_Bounds_results struct {
	Params  MoqRectangle_genType_Bounds_params
	Results []struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Bounds_doFn
		DoReturnFn MoqRectangle_genType_Bounds_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_Bounds_fnRecorder routes recorded function calls to the
// MoqRectangle_genType moq
type MoqRectangle_genType_Bounds_fnRecorder struct {
	Params    MoqRectangle_genType_Bounds_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_Bounds_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_Bounds_anyParams isolates the any params functions of
// the Rectangle_genType type
type MoqRectangle_genType_Bounds_anyParams struct {
	Recorder *MoqRectangle_genType_Bounds_fnRecorder
}

// MoqRectangle_genType_ColorModel_params holds the params of the
// Rectangle_genType type
type MoqRectangle_genType_ColorModel_params struct{}

// MoqRectangle_genType_ColorModel_paramsKey holds the map key params of the
// Rectangle_genType type
type MoqRectangle_genType_ColorModel_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRectangle_genType_ColorModel_resultsByParams contains the results for a
// given set of parameters for the Rectangle_genType type
type MoqRectangle_genType_ColorModel_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRectangle_genType_ColorModel_paramsKey]*MoqRectangle_genType_ColorModel_results
}

// MoqRectangle_genType_ColorModel_doFn defines the type of function needed
// when calling AndDo for the Rectangle_genType type
type MoqRectangle_genType_ColorModel_doFn func()

// MoqRectangle_genType_ColorModel_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Rectangle_genType type
type MoqRectangle_genType_ColorModel_doReturnFn func() color.Model

// MoqRectangle_genType_ColorModel_results holds the results of the
// Rectangle_genType type
type MoqRectangle_genType_ColorModel_results struct {
	Params  MoqRectangle_genType_ColorModel_params
	Results []struct {
		Values *struct {
			Result1 color.Model
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_ColorModel_doFn
		DoReturnFn MoqRectangle_genType_ColorModel_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRectangle_genType_ColorModel_fnRecorder routes recorded function calls to
// the MoqRectangle_genType moq
type MoqRectangle_genType_ColorModel_fnRecorder struct {
	Params    MoqRectangle_genType_ColorModel_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRectangle_genType_ColorModel_results
	Moq       *MoqRectangle_genType
}

// MoqRectangle_genType_ColorModel_anyParams isolates the any params functions
// of the Rectangle_genType type
type MoqRectangle_genType_ColorModel_anyParams struct {
	Recorder *MoqRectangle_genType_ColorModel_fnRecorder
}

// NewMoqRectangle_genType creates a new moq of the Rectangle_genType type
func NewMoqRectangle_genType(scene *moq.Scene, config *moq.Config) *MoqRectangle_genType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqRectangle_genType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqRectangle_genType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				String struct{}
				Dx     struct{}
				Dy     struct{}
				Size   struct{}
				Add    struct {
					P moq.ParamIndexing
				}
				Sub struct {
					P moq.ParamIndexing
				}
				Inset struct {
					N moq.ParamIndexing
				}
				Intersect struct {
					S moq.ParamIndexing
				}
				Union struct {
					S moq.ParamIndexing
				}
				Empty struct{}
				Eq    struct {
					S moq.ParamIndexing
				}
				Overlaps struct {
					S moq.ParamIndexing
				}
				In struct {
					S moq.ParamIndexing
				}
				Canon struct{}
				At    struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				RGBA64At struct {
					X moq.ParamIndexing
					Y moq.ParamIndexing
				}
				Bounds     struct{}
				ColorModel struct{}
			}
		}{ParameterIndexing: struct {
			String struct{}
			Dx     struct{}
			Dy     struct{}
			Size   struct{}
			Add    struct {
				P moq.ParamIndexing
			}
			Sub struct {
				P moq.ParamIndexing
			}
			Inset struct {
				N moq.ParamIndexing
			}
			Intersect struct {
				S moq.ParamIndexing
			}
			Union struct {
				S moq.ParamIndexing
			}
			Empty struct{}
			Eq    struct {
				S moq.ParamIndexing
			}
			Overlaps struct {
				S moq.ParamIndexing
			}
			In struct {
				S moq.ParamIndexing
			}
			Canon struct{}
			At    struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			RGBA64At struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}
			Bounds     struct{}
			ColorModel struct{}
		}{
			String: struct{}{},
			Dx:     struct{}{},
			Dy:     struct{}{},
			Size:   struct{}{},
			Add: struct {
				P moq.ParamIndexing
			}{
				P: moq.ParamIndexByValue,
			},
			Sub: struct {
				P moq.ParamIndexing
			}{
				P: moq.ParamIndexByValue,
			},
			Inset: struct {
				N moq.ParamIndexing
			}{
				N: moq.ParamIndexByValue,
			},
			Intersect: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			Union: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			Empty: struct{}{},
			Eq: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			Overlaps: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			In: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			Canon: struct{}{},
			At: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
				Y: moq.ParamIndexByValue,
			},
			RGBA64At: struct {
				X moq.ParamIndexing
				Y moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
				Y: moq.ParamIndexByValue,
			},
			Bounds:     struct{}{},
			ColorModel: struct{}{},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Rectangle_genType type
func (m *MoqRectangle_genType) Mock() *MoqRectangle_genType_mock { return m.Moq }

func (m *MoqRectangle_genType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_String_params{}
	var results *MoqRectangle_genType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRectangle_genType_mock) Dx() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Dx_params{}
	var results *MoqRectangle_genType_Dx_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Dx {
		paramsKey := m.Moq.ParamsKey_Dx(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Dx(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Dx(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Dx(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRectangle_genType_mock) Dy() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Dy_params{}
	var results *MoqRectangle_genType_Dy_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Dy {
		paramsKey := m.Moq.ParamsKey_Dy(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Dy(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Dy(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Dy(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRectangle_genType_mock) Size() (result1 image.Point) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Size_params{}
	var results *MoqRectangle_genType_Size_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Size {
		paramsKey := m.Moq.ParamsKey_Size(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Size(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Size(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Size(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRectangle_genType_mock) Add(p image.Point) (result1 image.Rectangle) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Add_params{
		P: p,
	}
	var results *MoqRectangle_genType_Add_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Add {
		paramsKey := m.Moq.ParamsKey_Add(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Add(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Add(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Add(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(p)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(p)
	}
	return
}

func (m *MoqRectangle_genType_mock) Sub(p image.Point) (result1 image.Rectangle) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Sub_params{
		P: p,
	}
	var results *MoqRectangle_genType_Sub_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Sub {
		paramsKey := m.Moq.ParamsKey_Sub(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Sub(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Sub(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Sub(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(p)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(p)
	}
	return
}

func (m *MoqRectangle_genType_mock) Inset(n int) (result1 image.Rectangle) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Inset_params{
		N: n,
	}
	var results *MoqRectangle_genType_Inset_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Inset {
		paramsKey := m.Moq.ParamsKey_Inset(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Inset(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Inset(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Inset(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(n)
	}
	return
}

func (m *MoqRectangle_genType_mock) Intersect(s image.Rectangle) (result1 image.Rectangle) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Intersect_params{
		S: s,
	}
	var results *MoqRectangle_genType_Intersect_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Intersect {
		paramsKey := m.Moq.ParamsKey_Intersect(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Intersect(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Intersect(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Intersect(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s)
	}
	return
}

func (m *MoqRectangle_genType_mock) Union(s image.Rectangle) (result1 image.Rectangle) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Union_params{
		S: s,
	}
	var results *MoqRectangle_genType_Union_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Union {
		paramsKey := m.Moq.ParamsKey_Union(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Union(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Union(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Union(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s)
	}
	return
}

func (m *MoqRectangle_genType_mock) Empty() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Empty_params{}
	var results *MoqRectangle_genType_Empty_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Empty {
		paramsKey := m.Moq.ParamsKey_Empty(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Empty(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Empty(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Empty(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRectangle_genType_mock) Eq(s image.Rectangle) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Eq_params{
		S: s,
	}
	var results *MoqRectangle_genType_Eq_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Eq {
		paramsKey := m.Moq.ParamsKey_Eq(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Eq(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Eq(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Eq(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s)
	}
	return
}

func (m *MoqRectangle_genType_mock) Overlaps(s image.Rectangle) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Overlaps_params{
		S: s,
	}
	var results *MoqRectangle_genType_Overlaps_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Overlaps {
		paramsKey := m.Moq.ParamsKey_Overlaps(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Overlaps(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Overlaps(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Overlaps(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s)
	}
	return
}

func (m *MoqRectangle_genType_mock) In(s image.Rectangle) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_In_params{
		S: s,
	}
	var results *MoqRectangle_genType_In_results
	for _, resultsByParams := range m.Moq.ResultsByParams_In {
		paramsKey := m.Moq.ParamsKey_In(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_In(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_In(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_In(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s)
	}
	return
}

func (m *MoqRectangle_genType_mock) Canon() (result1 image.Rectangle) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Canon_params{}
	var results *MoqRectangle_genType_Canon_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Canon {
		paramsKey := m.Moq.ParamsKey_Canon(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Canon(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Canon(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Canon(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRectangle_genType_mock) At(x, y int) (result1 color.Color) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_At_params{
		X: x,
		Y: y,
	}
	var results *MoqRectangle_genType_At_results
	for _, resultsByParams := range m.Moq.ResultsByParams_At {
		paramsKey := m.Moq.ParamsKey_At(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_At(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_At(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_At(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqRectangle_genType_mock) RGBA64At(x, y int) (result1 color.RGBA64) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_RGBA64At_params{
		X: x,
		Y: y,
	}
	var results *MoqRectangle_genType_RGBA64At_results
	for _, resultsByParams := range m.Moq.ResultsByParams_RGBA64At {
		paramsKey := m.Moq.ParamsKey_RGBA64At(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_RGBA64At(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_RGBA64At(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_RGBA64At(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x, y)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x, y)
	}
	return
}

func (m *MoqRectangle_genType_mock) Bounds() (result1 image.Rectangle) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_Bounds_params{}
	var results *MoqRectangle_genType_Bounds_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Bounds {
		paramsKey := m.Moq.ParamsKey_Bounds(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Bounds(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Bounds(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Bounds(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRectangle_genType_mock) ColorModel() (result1 color.Model) {
	m.Moq.Scene.T.Helper()
	params := MoqRectangle_genType_ColorModel_params{}
	var results *MoqRectangle_genType_ColorModel_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ColorModel {
		paramsKey := m.Moq.ParamsKey_ColorModel(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ColorModel(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ColorModel(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ColorModel(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

// OnCall returns the recorder implementation of the Rectangle_genType type
func (m *MoqRectangle_genType) OnCall() *MoqRectangle_genType_recorder {
	return &MoqRectangle_genType_recorder{
		Moq: m,
	}
}

func (m *MoqRectangle_genType_recorder) String() *MoqRectangle_genType_String_fnRecorder {
	return &MoqRectangle_genType_String_fnRecorder{
		Params:   MoqRectangle_genType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_String_fnRecorder) Any() *MoqRectangle_genType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqRectangle_genType_String_anyParams{Recorder: r}
}

func (r *MoqRectangle_genType_String_fnRecorder) Seq() *MoqRectangle_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_String_fnRecorder) NoSeq() *MoqRectangle_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_String_fnRecorder) ReturnResults(result1 string) *MoqRectangle_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_String_doFn
		DoReturnFn MoqRectangle_genType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_String_fnRecorder) AndDo(fn MoqRectangle_genType_String_doFn) *MoqRectangle_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_String_fnRecorder) DoReturnResults(fn MoqRectangle_genType_String_doReturnFn) *MoqRectangle_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_String_doFn
		DoReturnFn MoqRectangle_genType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_String_paramsKey]*MoqRectangle_genType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_String_doFn
				DoReturnFn MoqRectangle_genType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_String(params MoqRectangle_genType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqRectangle_genType) ParamsKey_String(params MoqRectangle_genType_String_params, anyParams uint64) MoqRectangle_genType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqRectangle_genType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRectangle_genType_recorder) Dx() *MoqRectangle_genType_Dx_fnRecorder {
	return &MoqRectangle_genType_Dx_fnRecorder{
		Params:   MoqRectangle_genType_Dx_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Dx_fnRecorder) Any() *MoqRectangle_genType_Dx_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Dx(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Dx_anyParams{Recorder: r}
}

func (r *MoqRectangle_genType_Dx_fnRecorder) Seq() *MoqRectangle_genType_Dx_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Dx(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Dx_fnRecorder) NoSeq() *MoqRectangle_genType_Dx_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Dx(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Dx_fnRecorder) ReturnResults(result1 int) *MoqRectangle_genType_Dx_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Dx_doFn
		DoReturnFn MoqRectangle_genType_Dx_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Dx_fnRecorder) AndDo(fn MoqRectangle_genType_Dx_doFn) *MoqRectangle_genType_Dx_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Dx_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Dx_doReturnFn) *MoqRectangle_genType_Dx_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Dx_doFn
		DoReturnFn MoqRectangle_genType_Dx_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Dx_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Dx_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Dx {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Dx_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Dx_paramsKey]*MoqRectangle_genType_Dx_results{},
		}
		r.Moq.ResultsByParams_Dx = append(r.Moq.ResultsByParams_Dx, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Dx) {
			copy(r.Moq.ResultsByParams_Dx[insertAt+1:], r.Moq.ResultsByParams_Dx[insertAt:0])
			r.Moq.ResultsByParams_Dx[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Dx(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Dx_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Dx_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Dx_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Dx_doFn
				DoReturnFn MoqRectangle_genType_Dx_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Dx(params MoqRectangle_genType_Dx_params) string {
	return fmt.Sprintf("Dx()")
}

func (m *MoqRectangle_genType) ParamsKey_Dx(params MoqRectangle_genType_Dx_params, anyParams uint64) MoqRectangle_genType_Dx_paramsKey {
	m.Scene.T.Helper()
	return MoqRectangle_genType_Dx_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRectangle_genType_recorder) Dy() *MoqRectangle_genType_Dy_fnRecorder {
	return &MoqRectangle_genType_Dy_fnRecorder{
		Params:   MoqRectangle_genType_Dy_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Dy_fnRecorder) Any() *MoqRectangle_genType_Dy_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Dy(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Dy_anyParams{Recorder: r}
}

func (r *MoqRectangle_genType_Dy_fnRecorder) Seq() *MoqRectangle_genType_Dy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Dy(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Dy_fnRecorder) NoSeq() *MoqRectangle_genType_Dy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Dy(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Dy_fnRecorder) ReturnResults(result1 int) *MoqRectangle_genType_Dy_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Dy_doFn
		DoReturnFn MoqRectangle_genType_Dy_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Dy_fnRecorder) AndDo(fn MoqRectangle_genType_Dy_doFn) *MoqRectangle_genType_Dy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Dy_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Dy_doReturnFn) *MoqRectangle_genType_Dy_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Dy_doFn
		DoReturnFn MoqRectangle_genType_Dy_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Dy_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Dy_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Dy {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Dy_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Dy_paramsKey]*MoqRectangle_genType_Dy_results{},
		}
		r.Moq.ResultsByParams_Dy = append(r.Moq.ResultsByParams_Dy, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Dy) {
			copy(r.Moq.ResultsByParams_Dy[insertAt+1:], r.Moq.ResultsByParams_Dy[insertAt:0])
			r.Moq.ResultsByParams_Dy[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Dy(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Dy_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Dy_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Dy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Dy_doFn
				DoReturnFn MoqRectangle_genType_Dy_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Dy(params MoqRectangle_genType_Dy_params) string {
	return fmt.Sprintf("Dy()")
}

func (m *MoqRectangle_genType) ParamsKey_Dy(params MoqRectangle_genType_Dy_params, anyParams uint64) MoqRectangle_genType_Dy_paramsKey {
	m.Scene.T.Helper()
	return MoqRectangle_genType_Dy_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRectangle_genType_recorder) Size() *MoqRectangle_genType_Size_fnRecorder {
	return &MoqRectangle_genType_Size_fnRecorder{
		Params:   MoqRectangle_genType_Size_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Size_fnRecorder) Any() *MoqRectangle_genType_Size_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Size_anyParams{Recorder: r}
}

func (r *MoqRectangle_genType_Size_fnRecorder) Seq() *MoqRectangle_genType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Size_fnRecorder) NoSeq() *MoqRectangle_genType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Size_fnRecorder) ReturnResults(result1 image.Point) *MoqRectangle_genType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Point
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Size_doFn
		DoReturnFn MoqRectangle_genType_Size_doReturnFn
	}{
		Values: &struct {
			Result1 image.Point
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Size_fnRecorder) AndDo(fn MoqRectangle_genType_Size_doFn) *MoqRectangle_genType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Size_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Size_doReturnFn) *MoqRectangle_genType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Point
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Size_doFn
		DoReturnFn MoqRectangle_genType_Size_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Size_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Size_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Size {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Size_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Size_paramsKey]*MoqRectangle_genType_Size_results{},
		}
		r.Moq.ResultsByParams_Size = append(r.Moq.ResultsByParams_Size, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Size) {
			copy(r.Moq.ResultsByParams_Size[insertAt+1:], r.Moq.ResultsByParams_Size[insertAt:0])
			r.Moq.ResultsByParams_Size[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Size(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Size_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Size_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 image.Point
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Size_doFn
				DoReturnFn MoqRectangle_genType_Size_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Size(params MoqRectangle_genType_Size_params) string {
	return fmt.Sprintf("Size()")
}

func (m *MoqRectangle_genType) ParamsKey_Size(params MoqRectangle_genType_Size_params, anyParams uint64) MoqRectangle_genType_Size_paramsKey {
	m.Scene.T.Helper()
	return MoqRectangle_genType_Size_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRectangle_genType_recorder) Add(p image.Point) *MoqRectangle_genType_Add_fnRecorder {
	return &MoqRectangle_genType_Add_fnRecorder{
		Params: MoqRectangle_genType_Add_params{
			P: p,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Add_fnRecorder) Any() *MoqRectangle_genType_Add_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Add_anyParams{Recorder: r}
}

func (a *MoqRectangle_genType_Add_anyParams) P() *MoqRectangle_genType_Add_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRectangle_genType_Add_fnRecorder) Seq() *MoqRectangle_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Add_fnRecorder) NoSeq() *MoqRectangle_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Add_fnRecorder) ReturnResults(result1 image.Rectangle) *MoqRectangle_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Add_doFn
		DoReturnFn MoqRectangle_genType_Add_doReturnFn
	}{
		Values: &struct {
			Result1 image.Rectangle
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Add_fnRecorder) AndDo(fn MoqRectangle_genType_Add_doFn) *MoqRectangle_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Add_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Add_doReturnFn) *MoqRectangle_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Add_doFn
		DoReturnFn MoqRectangle_genType_Add_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Add_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Add_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Add {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Add_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Add_paramsKey]*MoqRectangle_genType_Add_results{},
		}
		r.Moq.ResultsByParams_Add = append(r.Moq.ResultsByParams_Add, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Add) {
			copy(r.Moq.ResultsByParams_Add[insertAt+1:], r.Moq.ResultsByParams_Add[insertAt:0])
			r.Moq.ResultsByParams_Add[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Add(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Add_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Add_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 image.Rectangle
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Add_doFn
				DoReturnFn MoqRectangle_genType_Add_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Add(params MoqRectangle_genType_Add_params) string {
	return fmt.Sprintf("Add(%#v)", params.P)
}

func (m *MoqRectangle_genType) ParamsKey_Add(params MoqRectangle_genType_Add_params, anyParams uint64) MoqRectangle_genType_Add_paramsKey {
	m.Scene.T.Helper()
	var pUsed image.Point
	var pUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Add.P == moq.ParamIndexByValue {
			pUsed = params.P
		} else {
			pUsedHash = hash.DeepHash(params.P)
		}
	}
	return MoqRectangle_genType_Add_paramsKey{
		Params: struct{ P image.Point }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqRectangle_genType_recorder) Sub(p image.Point) *MoqRectangle_genType_Sub_fnRecorder {
	return &MoqRectangle_genType_Sub_fnRecorder{
		Params: MoqRectangle_genType_Sub_params{
			P: p,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Sub_fnRecorder) Any() *MoqRectangle_genType_Sub_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Sub_anyParams{Recorder: r}
}

func (a *MoqRectangle_genType_Sub_anyParams) P() *MoqRectangle_genType_Sub_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRectangle_genType_Sub_fnRecorder) Seq() *MoqRectangle_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Sub_fnRecorder) NoSeq() *MoqRectangle_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Sub_fnRecorder) ReturnResults(result1 image.Rectangle) *MoqRectangle_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Sub_doFn
		DoReturnFn MoqRectangle_genType_Sub_doReturnFn
	}{
		Values: &struct {
			Result1 image.Rectangle
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Sub_fnRecorder) AndDo(fn MoqRectangle_genType_Sub_doFn) *MoqRectangle_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Sub_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Sub_doReturnFn) *MoqRectangle_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Sub_doFn
		DoReturnFn MoqRectangle_genType_Sub_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Sub_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Sub_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Sub {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Sub_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Sub_paramsKey]*MoqRectangle_genType_Sub_results{},
		}
		r.Moq.ResultsByParams_Sub = append(r.Moq.ResultsByParams_Sub, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Sub) {
			copy(r.Moq.ResultsByParams_Sub[insertAt+1:], r.Moq.ResultsByParams_Sub[insertAt:0])
			r.Moq.ResultsByParams_Sub[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Sub(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Sub_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Sub_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 image.Rectangle
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Sub_doFn
				DoReturnFn MoqRectangle_genType_Sub_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Sub(params MoqRectangle_genType_Sub_params) string {
	return fmt.Sprintf("Sub(%#v)", params.P)
}

func (m *MoqRectangle_genType) ParamsKey_Sub(params MoqRectangle_genType_Sub_params, anyParams uint64) MoqRectangle_genType_Sub_paramsKey {
	m.Scene.T.Helper()
	var pUsed image.Point
	var pUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Sub.P == moq.ParamIndexByValue {
			pUsed = params.P
		} else {
			pUsedHash = hash.DeepHash(params.P)
		}
	}
	return MoqRectangle_genType_Sub_paramsKey{
		Params: struct{ P image.Point }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqRectangle_genType_recorder) Inset(n int) *MoqRectangle_genType_Inset_fnRecorder {
	return &MoqRectangle_genType_Inset_fnRecorder{
		Params: MoqRectangle_genType_Inset_params{
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Inset_fnRecorder) Any() *MoqRectangle_genType_Inset_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Inset(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Inset_anyParams{Recorder: r}
}

func (a *MoqRectangle_genType_Inset_anyParams) N() *MoqRectangle_genType_Inset_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRectangle_genType_Inset_fnRecorder) Seq() *MoqRectangle_genType_Inset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Inset(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Inset_fnRecorder) NoSeq() *MoqRectangle_genType_Inset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Inset(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Inset_fnRecorder) ReturnResults(result1 image.Rectangle) *MoqRectangle_genType_Inset_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Inset_doFn
		DoReturnFn MoqRectangle_genType_Inset_doReturnFn
	}{
		Values: &struct {
			Result1 image.Rectangle
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Inset_fnRecorder) AndDo(fn MoqRectangle_genType_Inset_doFn) *MoqRectangle_genType_Inset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Inset_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Inset_doReturnFn) *MoqRectangle_genType_Inset_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Inset_doFn
		DoReturnFn MoqRectangle_genType_Inset_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Inset_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Inset_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Inset {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Inset_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Inset_paramsKey]*MoqRectangle_genType_Inset_results{},
		}
		r.Moq.ResultsByParams_Inset = append(r.Moq.ResultsByParams_Inset, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Inset) {
			copy(r.Moq.ResultsByParams_Inset[insertAt+1:], r.Moq.ResultsByParams_Inset[insertAt:0])
			r.Moq.ResultsByParams_Inset[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Inset(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Inset_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Inset_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Inset_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 image.Rectangle
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Inset_doFn
				DoReturnFn MoqRectangle_genType_Inset_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Inset(params MoqRectangle_genType_Inset_params) string {
	return fmt.Sprintf("Inset(%#v)", params.N)
}

func (m *MoqRectangle_genType) ParamsKey_Inset(params MoqRectangle_genType_Inset_params, anyParams uint64) MoqRectangle_genType_Inset_paramsKey {
	m.Scene.T.Helper()
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Inset.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqRectangle_genType_Inset_paramsKey{
		Params: struct{ N int }{
			N: nUsed,
		},
		Hashes: struct{ N hash.Hash }{
			N: nUsedHash,
		},
	}
}

func (m *MoqRectangle_genType_recorder) Intersect(s image.Rectangle) *MoqRectangle_genType_Intersect_fnRecorder {
	return &MoqRectangle_genType_Intersect_fnRecorder{
		Params: MoqRectangle_genType_Intersect_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Intersect_fnRecorder) Any() *MoqRectangle_genType_Intersect_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Intersect(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Intersect_anyParams{Recorder: r}
}

func (a *MoqRectangle_genType_Intersect_anyParams) S() *MoqRectangle_genType_Intersect_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRectangle_genType_Intersect_fnRecorder) Seq() *MoqRectangle_genType_Intersect_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Intersect(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Intersect_fnRecorder) NoSeq() *MoqRectangle_genType_Intersect_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Intersect(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Intersect_fnRecorder) ReturnResults(result1 image.Rectangle) *MoqRectangle_genType_Intersect_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Intersect_doFn
		DoReturnFn MoqRectangle_genType_Intersect_doReturnFn
	}{
		Values: &struct {
			Result1 image.Rectangle
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Intersect_fnRecorder) AndDo(fn MoqRectangle_genType_Intersect_doFn) *MoqRectangle_genType_Intersect_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Intersect_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Intersect_doReturnFn) *MoqRectangle_genType_Intersect_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Intersect_doFn
		DoReturnFn MoqRectangle_genType_Intersect_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Intersect_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Intersect_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Intersect {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Intersect_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Intersect_paramsKey]*MoqRectangle_genType_Intersect_results{},
		}
		r.Moq.ResultsByParams_Intersect = append(r.Moq.ResultsByParams_Intersect, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Intersect) {
			copy(r.Moq.ResultsByParams_Intersect[insertAt+1:], r.Moq.ResultsByParams_Intersect[insertAt:0])
			r.Moq.ResultsByParams_Intersect[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Intersect(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Intersect_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Intersect_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Intersect_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 image.Rectangle
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Intersect_doFn
				DoReturnFn MoqRectangle_genType_Intersect_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Intersect(params MoqRectangle_genType_Intersect_params) string {
	return fmt.Sprintf("Intersect(%#v)", params.S)
}

func (m *MoqRectangle_genType) ParamsKey_Intersect(params MoqRectangle_genType_Intersect_params, anyParams uint64) MoqRectangle_genType_Intersect_paramsKey {
	m.Scene.T.Helper()
	var sUsed image.Rectangle
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Intersect.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqRectangle_genType_Intersect_paramsKey{
		Params: struct{ S image.Rectangle }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqRectangle_genType_recorder) Union(s image.Rectangle) *MoqRectangle_genType_Union_fnRecorder {
	return &MoqRectangle_genType_Union_fnRecorder{
		Params: MoqRectangle_genType_Union_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Union_fnRecorder) Any() *MoqRectangle_genType_Union_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Union(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Union_anyParams{Recorder: r}
}

func (a *MoqRectangle_genType_Union_anyParams) S() *MoqRectangle_genType_Union_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRectangle_genType_Union_fnRecorder) Seq() *MoqRectangle_genType_Union_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Union(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Union_fnRecorder) NoSeq() *MoqRectangle_genType_Union_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Union(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Union_fnRecorder) ReturnResults(result1 image.Rectangle) *MoqRectangle_genType_Union_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Union_doFn
		DoReturnFn MoqRectangle_genType_Union_doReturnFn
	}{
		Values: &struct {
			Result1 image.Rectangle
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Union_fnRecorder) AndDo(fn MoqRectangle_genType_Union_doFn) *MoqRectangle_genType_Union_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Union_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Union_doReturnFn) *MoqRectangle_genType_Union_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Union_doFn
		DoReturnFn MoqRectangle_genType_Union_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Union_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Union_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Union {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Union_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Union_paramsKey]*MoqRectangle_genType_Union_results{},
		}
		r.Moq.ResultsByParams_Union = append(r.Moq.ResultsByParams_Union, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Union) {
			copy(r.Moq.ResultsByParams_Union[insertAt+1:], r.Moq.ResultsByParams_Union[insertAt:0])
			r.Moq.ResultsByParams_Union[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Union(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Union_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Union_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Union_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 image.Rectangle
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Union_doFn
				DoReturnFn MoqRectangle_genType_Union_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Union(params MoqRectangle_genType_Union_params) string {
	return fmt.Sprintf("Union(%#v)", params.S)
}

func (m *MoqRectangle_genType) ParamsKey_Union(params MoqRectangle_genType_Union_params, anyParams uint64) MoqRectangle_genType_Union_paramsKey {
	m.Scene.T.Helper()
	var sUsed image.Rectangle
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Union.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqRectangle_genType_Union_paramsKey{
		Params: struct{ S image.Rectangle }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqRectangle_genType_recorder) Empty() *MoqRectangle_genType_Empty_fnRecorder {
	return &MoqRectangle_genType_Empty_fnRecorder{
		Params:   MoqRectangle_genType_Empty_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Empty_fnRecorder) Any() *MoqRectangle_genType_Empty_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Empty(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Empty_anyParams{Recorder: r}
}

func (r *MoqRectangle_genType_Empty_fnRecorder) Seq() *MoqRectangle_genType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Empty(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Empty_fnRecorder) NoSeq() *MoqRectangle_genType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Empty(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Empty_fnRecorder) ReturnResults(result1 bool) *MoqRectangle_genType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Empty_doFn
		DoReturnFn MoqRectangle_genType_Empty_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Empty_fnRecorder) AndDo(fn MoqRectangle_genType_Empty_doFn) *MoqRectangle_genType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Empty_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Empty_doReturnFn) *MoqRectangle_genType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Empty_doFn
		DoReturnFn MoqRectangle_genType_Empty_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Empty_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Empty_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Empty {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Empty_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Empty_paramsKey]*MoqRectangle_genType_Empty_results{},
		}
		r.Moq.ResultsByParams_Empty = append(r.Moq.ResultsByParams_Empty, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Empty) {
			copy(r.Moq.ResultsByParams_Empty[insertAt+1:], r.Moq.ResultsByParams_Empty[insertAt:0])
			r.Moq.ResultsByParams_Empty[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Empty(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Empty_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Empty_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Empty_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Empty_doFn
				DoReturnFn MoqRectangle_genType_Empty_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Empty(params MoqRectangle_genType_Empty_params) string {
	return fmt.Sprintf("Empty()")
}

func (m *MoqRectangle_genType) ParamsKey_Empty(params MoqRectangle_genType_Empty_params, anyParams uint64) MoqRectangle_genType_Empty_paramsKey {
	m.Scene.T.Helper()
	return MoqRectangle_genType_Empty_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRectangle_genType_recorder) Eq(s image.Rectangle) *MoqRectangle_genType_Eq_fnRecorder {
	return &MoqRectangle_genType_Eq_fnRecorder{
		Params: MoqRectangle_genType_Eq_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Eq_fnRecorder) Any() *MoqRectangle_genType_Eq_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Eq(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Eq_anyParams{Recorder: r}
}

func (a *MoqRectangle_genType_Eq_anyParams) S() *MoqRectangle_genType_Eq_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRectangle_genType_Eq_fnRecorder) Seq() *MoqRectangle_genType_Eq_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Eq(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Eq_fnRecorder) NoSeq() *MoqRectangle_genType_Eq_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Eq(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Eq_fnRecorder) ReturnResults(result1 bool) *MoqRectangle_genType_Eq_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Eq_doFn
		DoReturnFn MoqRectangle_genType_Eq_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Eq_fnRecorder) AndDo(fn MoqRectangle_genType_Eq_doFn) *MoqRectangle_genType_Eq_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Eq_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Eq_doReturnFn) *MoqRectangle_genType_Eq_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Eq_doFn
		DoReturnFn MoqRectangle_genType_Eq_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Eq_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Eq_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Eq {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Eq_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Eq_paramsKey]*MoqRectangle_genType_Eq_results{},
		}
		r.Moq.ResultsByParams_Eq = append(r.Moq.ResultsByParams_Eq, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Eq) {
			copy(r.Moq.ResultsByParams_Eq[insertAt+1:], r.Moq.ResultsByParams_Eq[insertAt:0])
			r.Moq.ResultsByParams_Eq[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Eq(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Eq_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Eq_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Eq_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Eq_doFn
				DoReturnFn MoqRectangle_genType_Eq_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Eq(params MoqRectangle_genType_Eq_params) string {
	return fmt.Sprintf("Eq(%#v)", params.S)
}

func (m *MoqRectangle_genType) ParamsKey_Eq(params MoqRectangle_genType_Eq_params, anyParams uint64) MoqRectangle_genType_Eq_paramsKey {
	m.Scene.T.Helper()
	var sUsed image.Rectangle
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Eq.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqRectangle_genType_Eq_paramsKey{
		Params: struct{ S image.Rectangle }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqRectangle_genType_recorder) Overlaps(s image.Rectangle) *MoqRectangle_genType_Overlaps_fnRecorder {
	return &MoqRectangle_genType_Overlaps_fnRecorder{
		Params: MoqRectangle_genType_Overlaps_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Overlaps_fnRecorder) Any() *MoqRectangle_genType_Overlaps_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Overlaps(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Overlaps_anyParams{Recorder: r}
}

func (a *MoqRectangle_genType_Overlaps_anyParams) S() *MoqRectangle_genType_Overlaps_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRectangle_genType_Overlaps_fnRecorder) Seq() *MoqRectangle_genType_Overlaps_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Overlaps(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Overlaps_fnRecorder) NoSeq() *MoqRectangle_genType_Overlaps_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Overlaps(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Overlaps_fnRecorder) ReturnResults(result1 bool) *MoqRectangle_genType_Overlaps_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Overlaps_doFn
		DoReturnFn MoqRectangle_genType_Overlaps_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Overlaps_fnRecorder) AndDo(fn MoqRectangle_genType_Overlaps_doFn) *MoqRectangle_genType_Overlaps_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Overlaps_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Overlaps_doReturnFn) *MoqRectangle_genType_Overlaps_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Overlaps_doFn
		DoReturnFn MoqRectangle_genType_Overlaps_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Overlaps_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Overlaps_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Overlaps {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Overlaps_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Overlaps_paramsKey]*MoqRectangle_genType_Overlaps_results{},
		}
		r.Moq.ResultsByParams_Overlaps = append(r.Moq.ResultsByParams_Overlaps, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Overlaps) {
			copy(r.Moq.ResultsByParams_Overlaps[insertAt+1:], r.Moq.ResultsByParams_Overlaps[insertAt:0])
			r.Moq.ResultsByParams_Overlaps[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Overlaps(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Overlaps_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Overlaps_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Overlaps_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Overlaps_doFn
				DoReturnFn MoqRectangle_genType_Overlaps_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Overlaps(params MoqRectangle_genType_Overlaps_params) string {
	return fmt.Sprintf("Overlaps(%#v)", params.S)
}

func (m *MoqRectangle_genType) ParamsKey_Overlaps(params MoqRectangle_genType_Overlaps_params, anyParams uint64) MoqRectangle_genType_Overlaps_paramsKey {
	m.Scene.T.Helper()
	var sUsed image.Rectangle
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Overlaps.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqRectangle_genType_Overlaps_paramsKey{
		Params: struct{ S image.Rectangle }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqRectangle_genType_recorder) In(s image.Rectangle) *MoqRectangle_genType_In_fnRecorder {
	return &MoqRectangle_genType_In_fnRecorder{
		Params: MoqRectangle_genType_In_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_In_fnRecorder) Any() *MoqRectangle_genType_In_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_In(r.Params))
		return nil
	}
	return &MoqRectangle_genType_In_anyParams{Recorder: r}
}

func (a *MoqRectangle_genType_In_anyParams) S() *MoqRectangle_genType_In_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRectangle_genType_In_fnRecorder) Seq() *MoqRectangle_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_In(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_In_fnRecorder) NoSeq() *MoqRectangle_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_In(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_In_fnRecorder) ReturnResults(result1 bool) *MoqRectangle_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_In_doFn
		DoReturnFn MoqRectangle_genType_In_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_In_fnRecorder) AndDo(fn MoqRectangle_genType_In_doFn) *MoqRectangle_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_In_fnRecorder) DoReturnResults(fn MoqRectangle_genType_In_doReturnFn) *MoqRectangle_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_In_doFn
		DoReturnFn MoqRectangle_genType_In_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_In_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_In_resultsByParams
	for n, res := range r.Moq.ResultsByParams_In {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_In_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_In_paramsKey]*MoqRectangle_genType_In_results{},
		}
		r.Moq.ResultsByParams_In = append(r.Moq.ResultsByParams_In, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_In) {
			copy(r.Moq.ResultsByParams_In[insertAt+1:], r.Moq.ResultsByParams_In[insertAt:0])
			r.Moq.ResultsByParams_In[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_In(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_In_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_In_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_In_doFn
				DoReturnFn MoqRectangle_genType_In_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_In(params MoqRectangle_genType_In_params) string {
	return fmt.Sprintf("In(%#v)", params.S)
}

func (m *MoqRectangle_genType) ParamsKey_In(params MoqRectangle_genType_In_params, anyParams uint64) MoqRectangle_genType_In_paramsKey {
	m.Scene.T.Helper()
	var sUsed image.Rectangle
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.In.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqRectangle_genType_In_paramsKey{
		Params: struct{ S image.Rectangle }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqRectangle_genType_recorder) Canon() *MoqRectangle_genType_Canon_fnRecorder {
	return &MoqRectangle_genType_Canon_fnRecorder{
		Params:   MoqRectangle_genType_Canon_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Canon_fnRecorder) Any() *MoqRectangle_genType_Canon_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Canon(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Canon_anyParams{Recorder: r}
}

func (r *MoqRectangle_genType_Canon_fnRecorder) Seq() *MoqRectangle_genType_Canon_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Canon(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Canon_fnRecorder) NoSeq() *MoqRectangle_genType_Canon_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Canon(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Canon_fnRecorder) ReturnResults(result1 image.Rectangle) *MoqRectangle_genType_Canon_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Canon_doFn
		DoReturnFn MoqRectangle_genType_Canon_doReturnFn
	}{
		Values: &struct {
			Result1 image.Rectangle
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Canon_fnRecorder) AndDo(fn MoqRectangle_genType_Canon_doFn) *MoqRectangle_genType_Canon_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Canon_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Canon_doReturnFn) *MoqRectangle_genType_Canon_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Canon_doFn
		DoReturnFn MoqRectangle_genType_Canon_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Canon_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Canon_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Canon {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Canon_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Canon_paramsKey]*MoqRectangle_genType_Canon_results{},
		}
		r.Moq.ResultsByParams_Canon = append(r.Moq.ResultsByParams_Canon, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Canon) {
			copy(r.Moq.ResultsByParams_Canon[insertAt+1:], r.Moq.ResultsByParams_Canon[insertAt:0])
			r.Moq.ResultsByParams_Canon[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Canon(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Canon_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Canon_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Canon_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 image.Rectangle
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Canon_doFn
				DoReturnFn MoqRectangle_genType_Canon_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Canon(params MoqRectangle_genType_Canon_params) string {
	return fmt.Sprintf("Canon()")
}

func (m *MoqRectangle_genType) ParamsKey_Canon(params MoqRectangle_genType_Canon_params, anyParams uint64) MoqRectangle_genType_Canon_paramsKey {
	m.Scene.T.Helper()
	return MoqRectangle_genType_Canon_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRectangle_genType_recorder) At(x, y int) *MoqRectangle_genType_At_fnRecorder {
	return &MoqRectangle_genType_At_fnRecorder{
		Params: MoqRectangle_genType_At_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_At_fnRecorder) Any() *MoqRectangle_genType_At_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_At(r.Params))
		return nil
	}
	return &MoqRectangle_genType_At_anyParams{Recorder: r}
}

func (a *MoqRectangle_genType_At_anyParams) X() *MoqRectangle_genType_At_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRectangle_genType_At_anyParams) Y() *MoqRectangle_genType_At_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRectangle_genType_At_fnRecorder) Seq() *MoqRectangle_genType_At_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_At(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_At_fnRecorder) NoSeq() *MoqRectangle_genType_At_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_At(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_At_fnRecorder) ReturnResults(result1 color.Color) *MoqRectangle_genType_At_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 color.Color
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_At_doFn
		DoReturnFn MoqRectangle_genType_At_doReturnFn
	}{
		Values: &struct {
			Result1 color.Color
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_At_fnRecorder) AndDo(fn MoqRectangle_genType_At_doFn) *MoqRectangle_genType_At_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_At_fnRecorder) DoReturnResults(fn MoqRectangle_genType_At_doReturnFn) *MoqRectangle_genType_At_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 color.Color
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_At_doFn
		DoReturnFn MoqRectangle_genType_At_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_At_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_At_resultsByParams
	for n, res := range r.Moq.ResultsByParams_At {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_At_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_At_paramsKey]*MoqRectangle_genType_At_results{},
		}
		r.Moq.ResultsByParams_At = append(r.Moq.ResultsByParams_At, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_At) {
			copy(r.Moq.ResultsByParams_At[insertAt+1:], r.Moq.ResultsByParams_At[insertAt:0])
			r.Moq.ResultsByParams_At[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_At(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_At_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_At_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_At_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 color.Color
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_At_doFn
				DoReturnFn MoqRectangle_genType_At_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_At(params MoqRectangle_genType_At_params) string {
	return fmt.Sprintf("At(%#v, %#v)", params.X, params.Y)
}

func (m *MoqRectangle_genType) ParamsKey_At(params MoqRectangle_genType_At_params, anyParams uint64) MoqRectangle_genType_At_paramsKey {
	m.Scene.T.Helper()
	var xUsed int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.At.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.At.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqRectangle_genType_At_paramsKey{
		Params: struct{ X, Y int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqRectangle_genType_recorder) RGBA64At(x, y int) *MoqRectangle_genType_RGBA64At_fnRecorder {
	return &MoqRectangle_genType_RGBA64At_fnRecorder{
		Params: MoqRectangle_genType_RGBA64At_params{
			X: x,
			Y: y,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_RGBA64At_fnRecorder) Any() *MoqRectangle_genType_RGBA64At_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RGBA64At(r.Params))
		return nil
	}
	return &MoqRectangle_genType_RGBA64At_anyParams{Recorder: r}
}

func (a *MoqRectangle_genType_RGBA64At_anyParams) X() *MoqRectangle_genType_RGBA64At_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRectangle_genType_RGBA64At_anyParams) Y() *MoqRectangle_genType_RGBA64At_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRectangle_genType_RGBA64At_fnRecorder) Seq() *MoqRectangle_genType_RGBA64At_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RGBA64At(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_RGBA64At_fnRecorder) NoSeq() *MoqRectangle_genType_RGBA64At_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_RGBA64At(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_RGBA64At_fnRecorder) ReturnResults(result1 color.RGBA64) *MoqRectangle_genType_RGBA64At_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 color.RGBA64
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_RGBA64At_doFn
		DoReturnFn MoqRectangle_genType_RGBA64At_doReturnFn
	}{
		Values: &struct {
			Result1 color.RGBA64
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_RGBA64At_fnRecorder) AndDo(fn MoqRectangle_genType_RGBA64At_doFn) *MoqRectangle_genType_RGBA64At_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_RGBA64At_fnRecorder) DoReturnResults(fn MoqRectangle_genType_RGBA64At_doReturnFn) *MoqRectangle_genType_RGBA64At_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 color.RGBA64
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_RGBA64At_doFn
		DoReturnFn MoqRectangle_genType_RGBA64At_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_RGBA64At_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_RGBA64At_resultsByParams
	for n, res := range r.Moq.ResultsByParams_RGBA64At {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_RGBA64At_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_RGBA64At_paramsKey]*MoqRectangle_genType_RGBA64At_results{},
		}
		r.Moq.ResultsByParams_RGBA64At = append(r.Moq.ResultsByParams_RGBA64At, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_RGBA64At) {
			copy(r.Moq.ResultsByParams_RGBA64At[insertAt+1:], r.Moq.ResultsByParams_RGBA64At[insertAt:0])
			r.Moq.ResultsByParams_RGBA64At[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_RGBA64At(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_RGBA64At_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_RGBA64At_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_RGBA64At_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 color.RGBA64
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_RGBA64At_doFn
				DoReturnFn MoqRectangle_genType_RGBA64At_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_RGBA64At(params MoqRectangle_genType_RGBA64At_params) string {
	return fmt.Sprintf("RGBA64At(%#v, %#v)", params.X, params.Y)
}

func (m *MoqRectangle_genType) ParamsKey_RGBA64At(params MoqRectangle_genType_RGBA64At_params, anyParams uint64) MoqRectangle_genType_RGBA64At_paramsKey {
	m.Scene.T.Helper()
	var xUsed int
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.RGBA64At.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	var yUsed int
	var yUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.RGBA64At.Y == moq.ParamIndexByValue {
			yUsed = params.Y
		} else {
			yUsedHash = hash.DeepHash(params.Y)
		}
	}
	return MoqRectangle_genType_RGBA64At_paramsKey{
		Params: struct{ X, Y int }{
			X: xUsed,
			Y: yUsed,
		},
		Hashes: struct{ X, Y hash.Hash }{
			X: xUsedHash,
			Y: yUsedHash,
		},
	}
}

func (m *MoqRectangle_genType_recorder) Bounds() *MoqRectangle_genType_Bounds_fnRecorder {
	return &MoqRectangle_genType_Bounds_fnRecorder{
		Params:   MoqRectangle_genType_Bounds_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_Bounds_fnRecorder) Any() *MoqRectangle_genType_Bounds_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bounds(r.Params))
		return nil
	}
	return &MoqRectangle_genType_Bounds_anyParams{Recorder: r}
}

func (r *MoqRectangle_genType_Bounds_fnRecorder) Seq() *MoqRectangle_genType_Bounds_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bounds(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_Bounds_fnRecorder) NoSeq() *MoqRectangle_genType_Bounds_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bounds(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_Bounds_fnRecorder) ReturnResults(result1 image.Rectangle) *MoqRectangle_genType_Bounds_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Bounds_doFn
		DoReturnFn MoqRectangle_genType_Bounds_doReturnFn
	}{
		Values: &struct {
			Result1 image.Rectangle
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_Bounds_fnRecorder) AndDo(fn MoqRectangle_genType_Bounds_doFn) *MoqRectangle_genType_Bounds_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_Bounds_fnRecorder) DoReturnResults(fn MoqRectangle_genType_Bounds_doReturnFn) *MoqRectangle_genType_Bounds_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 image.Rectangle
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_Bounds_doFn
		DoReturnFn MoqRectangle_genType_Bounds_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_Bounds_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_Bounds_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Bounds {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_Bounds_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_Bounds_paramsKey]*MoqRectangle_genType_Bounds_results{},
		}
		r.Moq.ResultsByParams_Bounds = append(r.Moq.ResultsByParams_Bounds, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Bounds) {
			copy(r.Moq.ResultsByParams_Bounds[insertAt+1:], r.Moq.ResultsByParams_Bounds[insertAt:0])
			r.Moq.ResultsByParams_Bounds[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Bounds(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_Bounds_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_Bounds_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_Bounds_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 image.Rectangle
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_Bounds_doFn
				DoReturnFn MoqRectangle_genType_Bounds_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_Bounds(params MoqRectangle_genType_Bounds_params) string {
	return fmt.Sprintf("Bounds()")
}

func (m *MoqRectangle_genType) ParamsKey_Bounds(params MoqRectangle_genType_Bounds_params, anyParams uint64) MoqRectangle_genType_Bounds_paramsKey {
	m.Scene.T.Helper()
	return MoqRectangle_genType_Bounds_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRectangle_genType_recorder) ColorModel() *MoqRectangle_genType_ColorModel_fnRecorder {
	return &MoqRectangle_genType_ColorModel_fnRecorder{
		Params:   MoqRectangle_genType_ColorModel_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRectangle_genType_ColorModel_fnRecorder) Any() *MoqRectangle_genType_ColorModel_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ColorModel(r.Params))
		return nil
	}
	return &MoqRectangle_genType_ColorModel_anyParams{Recorder: r}
}

func (r *MoqRectangle_genType_ColorModel_fnRecorder) Seq() *MoqRectangle_genType_ColorModel_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ColorModel(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRectangle_genType_ColorModel_fnRecorder) NoSeq() *MoqRectangle_genType_ColorModel_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ColorModel(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRectangle_genType_ColorModel_fnRecorder) ReturnResults(result1 color.Model) *MoqRectangle_genType_ColorModel_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 color.Model
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_ColorModel_doFn
		DoReturnFn MoqRectangle_genType_ColorModel_doReturnFn
	}{
		Values: &struct {
			Result1 color.Model
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRectangle_genType_ColorModel_fnRecorder) AndDo(fn MoqRectangle_genType_ColorModel_doFn) *MoqRectangle_genType_ColorModel_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRectangle_genType_ColorModel_fnRecorder) DoReturnResults(fn MoqRectangle_genType_ColorModel_doReturnFn) *MoqRectangle_genType_ColorModel_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 color.Model
		}
		Sequence   uint32
		DoFn       MoqRectangle_genType_ColorModel_doFn
		DoReturnFn MoqRectangle_genType_ColorModel_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRectangle_genType_ColorModel_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRectangle_genType_ColorModel_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ColorModel {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRectangle_genType_ColorModel_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRectangle_genType_ColorModel_paramsKey]*MoqRectangle_genType_ColorModel_results{},
		}
		r.Moq.ResultsByParams_ColorModel = append(r.Moq.ResultsByParams_ColorModel, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ColorModel) {
			copy(r.Moq.ResultsByParams_ColorModel[insertAt+1:], r.Moq.ResultsByParams_ColorModel[insertAt:0])
			r.Moq.ResultsByParams_ColorModel[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ColorModel(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRectangle_genType_ColorModel_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRectangle_genType_ColorModel_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRectangle_genType_ColorModel_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 color.Model
				}
				Sequence   uint32
				DoFn       MoqRectangle_genType_ColorModel_doFn
				DoReturnFn MoqRectangle_genType_ColorModel_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRectangle_genType) PrettyParams_ColorModel(params MoqRectangle_genType_ColorModel_params) string {
	return fmt.Sprintf("ColorModel()")
}

func (m *MoqRectangle_genType) ParamsKey_ColorModel(params MoqRectangle_genType_ColorModel_params, anyParams uint64) MoqRectangle_genType_ColorModel_paramsKey {
	m.Scene.T.Helper()
	return MoqRectangle_genType_ColorModel_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqRectangle_genType) Reset() {
	m.ResultsByParams_String = nil
	m.ResultsByParams_Dx = nil
	m.ResultsByParams_Dy = nil
	m.ResultsByParams_Size = nil
	m.ResultsByParams_Add = nil
	m.ResultsByParams_Sub = nil
	m.ResultsByParams_Inset = nil
	m.ResultsByParams_Intersect = nil
	m.ResultsByParams_Union = nil
	m.ResultsByParams_Empty = nil
	m.ResultsByParams_Eq = nil
	m.ResultsByParams_Overlaps = nil
	m.ResultsByParams_In = nil
	m.ResultsByParams_Canon = nil
	m.ResultsByParams_At = nil
	m.ResultsByParams_RGBA64At = nil
	m.ResultsByParams_Bounds = nil
	m.ResultsByParams_ColorModel = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqRectangle_genType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Dx {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Dx(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Dy {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Dy(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Size {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Size(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Add {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Add(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Sub {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Sub(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Inset {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Inset(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Intersect {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Intersect(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Union {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Union(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Empty {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Empty(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Eq {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Eq(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Overlaps {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Overlaps(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_In {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_In(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Canon {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Canon(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_At {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_At(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_RGBA64At {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_RGBA64At(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Bounds {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Bounds(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ColorModel {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ColorModel(results.Params))
			}
		}
	}
}
