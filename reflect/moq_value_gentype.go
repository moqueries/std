// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package reflect

import (
	"fmt"
	"math/bits"
	"reflect"
	"sync/atomic"
	"unsafe"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that reflect.Value_genType is mocked
// completely
var _ Value_genType = (*MoqValue_genType_mock)(nil)

// Value_genType is the fabricated implementation type of this mock (emitted
// when mocking a collections of methods directly and not from an interface
// type)
type Value_genType interface {
	Addr() reflect.Value
	Bool() bool
	Bytes() []byte
	CanAddr() bool
	CanSet() bool
	Call(in []reflect.Value) []reflect.Value
	CallSlice(in []reflect.Value) []reflect.Value
	Cap() int
	Close()
	Complex() complex128
	Elem() reflect.Value
	Field(i int) reflect.Value
	FieldByIndex(index []int) reflect.Value
	FieldByName(name string) reflect.Value
	FieldByNameFunc(match func(string) bool) reflect.Value
	Float() float64
	Index(i int) reflect.Value
	Int() int64
	CanInterface() bool
	Interface() (i interface{})
	InterfaceData() [2]uintptr
	IsNil() bool
	IsValid() bool
	IsZero() bool
	Kind() reflect.Kind
	Len() int
	MapIndex(key reflect.Value) reflect.Value
	MapKeys() []reflect.Value
	MapRange() *reflect.MapIter
	Method(i int) reflect.Value
	NumMethod() int
	MethodByName(name string) reflect.Value
	NumField() int
	OverflowComplex(x complex128) bool
	OverflowFloat(x float64) bool
	OverflowInt(x int64) bool
	OverflowUint(x uint64) bool
	Pointer() uintptr
	Recv() (x reflect.Value, ok bool)
	Send(x reflect.Value)
	Set(x reflect.Value)
	SetBool(x bool)
	SetBytes(x []byte)
	SetComplex(x complex128)
	SetFloat(x float64)
	SetInt(x int64)
	SetLen(n int)
	SetCap(n int)
	SetMapIndex(key, elem reflect.Value)
	SetUint(x uint64)
	SetPointer(x unsafe.Pointer)
	SetString(x string)
	Slice(i, j int) reflect.Value
	Slice3(i, j, k int) reflect.Value
	String() string
	TryRecv() (x reflect.Value, ok bool)
	TrySend(x reflect.Value) bool
	Type() reflect.Type
	Uint() uint64
	UnsafeAddr() uintptr
	Convert(t reflect.Type) reflect.Value
}

// MoqValue_genType holds the state of a moq of the Value_genType type
type MoqValue_genType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqValue_genType_mock

	ResultsByParams_Addr            []MoqValue_genType_Addr_resultsByParams
	ResultsByParams_Bool            []MoqValue_genType_Bool_resultsByParams
	ResultsByParams_Bytes           []MoqValue_genType_Bytes_resultsByParams
	ResultsByParams_CanAddr         []MoqValue_genType_CanAddr_resultsByParams
	ResultsByParams_CanSet          []MoqValue_genType_CanSet_resultsByParams
	ResultsByParams_Call            []MoqValue_genType_Call_resultsByParams
	ResultsByParams_CallSlice       []MoqValue_genType_CallSlice_resultsByParams
	ResultsByParams_Cap             []MoqValue_genType_Cap_resultsByParams
	ResultsByParams_Close           []MoqValue_genType_Close_resultsByParams
	ResultsByParams_Complex         []MoqValue_genType_Complex_resultsByParams
	ResultsByParams_Elem            []MoqValue_genType_Elem_resultsByParams
	ResultsByParams_Field           []MoqValue_genType_Field_resultsByParams
	ResultsByParams_FieldByIndex    []MoqValue_genType_FieldByIndex_resultsByParams
	ResultsByParams_FieldByName     []MoqValue_genType_FieldByName_resultsByParams
	ResultsByParams_FieldByNameFunc []MoqValue_genType_FieldByNameFunc_resultsByParams
	ResultsByParams_Float           []MoqValue_genType_Float_resultsByParams
	ResultsByParams_Index           []MoqValue_genType_Index_resultsByParams
	ResultsByParams_Int             []MoqValue_genType_Int_resultsByParams
	ResultsByParams_CanInterface    []MoqValue_genType_CanInterface_resultsByParams
	ResultsByParams_Interface       []MoqValue_genType_Interface_resultsByParams
	ResultsByParams_InterfaceData   []MoqValue_genType_InterfaceData_resultsByParams
	ResultsByParams_IsNil           []MoqValue_genType_IsNil_resultsByParams
	ResultsByParams_IsValid         []MoqValue_genType_IsValid_resultsByParams
	ResultsByParams_IsZero          []MoqValue_genType_IsZero_resultsByParams
	ResultsByParams_Kind            []MoqValue_genType_Kind_resultsByParams
	ResultsByParams_Len             []MoqValue_genType_Len_resultsByParams
	ResultsByParams_MapIndex        []MoqValue_genType_MapIndex_resultsByParams
	ResultsByParams_MapKeys         []MoqValue_genType_MapKeys_resultsByParams
	ResultsByParams_MapRange        []MoqValue_genType_MapRange_resultsByParams
	ResultsByParams_Method          []MoqValue_genType_Method_resultsByParams
	ResultsByParams_NumMethod       []MoqValue_genType_NumMethod_resultsByParams
	ResultsByParams_MethodByName    []MoqValue_genType_MethodByName_resultsByParams
	ResultsByParams_NumField        []MoqValue_genType_NumField_resultsByParams
	ResultsByParams_OverflowComplex []MoqValue_genType_OverflowComplex_resultsByParams
	ResultsByParams_OverflowFloat   []MoqValue_genType_OverflowFloat_resultsByParams
	ResultsByParams_OverflowInt     []MoqValue_genType_OverflowInt_resultsByParams
	ResultsByParams_OverflowUint    []MoqValue_genType_OverflowUint_resultsByParams
	ResultsByParams_Pointer         []MoqValue_genType_Pointer_resultsByParams
	ResultsByParams_Recv            []MoqValue_genType_Recv_resultsByParams
	ResultsByParams_Send            []MoqValue_genType_Send_resultsByParams
	ResultsByParams_Set             []MoqValue_genType_Set_resultsByParams
	ResultsByParams_SetBool         []MoqValue_genType_SetBool_resultsByParams
	ResultsByParams_SetBytes        []MoqValue_genType_SetBytes_resultsByParams
	ResultsByParams_SetComplex      []MoqValue_genType_SetComplex_resultsByParams
	ResultsByParams_SetFloat        []MoqValue_genType_SetFloat_resultsByParams
	ResultsByParams_SetInt          []MoqValue_genType_SetInt_resultsByParams
	ResultsByParams_SetLen          []MoqValue_genType_SetLen_resultsByParams
	ResultsByParams_SetCap          []MoqValue_genType_SetCap_resultsByParams
	ResultsByParams_SetMapIndex     []MoqValue_genType_SetMapIndex_resultsByParams
	ResultsByParams_SetUint         []MoqValue_genType_SetUint_resultsByParams
	ResultsByParams_SetPointer      []MoqValue_genType_SetPointer_resultsByParams
	ResultsByParams_SetString       []MoqValue_genType_SetString_resultsByParams
	ResultsByParams_Slice           []MoqValue_genType_Slice_resultsByParams
	ResultsByParams_Slice3          []MoqValue_genType_Slice3_resultsByParams
	ResultsByParams_String          []MoqValue_genType_String_resultsByParams
	ResultsByParams_TryRecv         []MoqValue_genType_TryRecv_resultsByParams
	ResultsByParams_TrySend         []MoqValue_genType_TrySend_resultsByParams
	ResultsByParams_Type            []MoqValue_genType_Type_resultsByParams
	ResultsByParams_Uint            []MoqValue_genType_Uint_resultsByParams
	ResultsByParams_UnsafeAddr      []MoqValue_genType_UnsafeAddr_resultsByParams
	ResultsByParams_Convert         []MoqValue_genType_Convert_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Addr    struct{}
			Bool    struct{}
			Bytes   struct{}
			CanAddr struct{}
			CanSet  struct{}
			Call    struct {
				In moq.ParamIndexing
			}
			CallSlice struct {
				In moq.ParamIndexing
			}
			Cap     struct{}
			Close   struct{}
			Complex struct{}
			Elem    struct{}
			Field   struct {
				Param1 moq.ParamIndexing
			}
			FieldByIndex struct {
				Index moq.ParamIndexing
			}
			FieldByName struct {
				Name moq.ParamIndexing
			}
			FieldByNameFunc struct {
				Match moq.ParamIndexing
			}
			Float struct{}
			Index struct {
				Param1 moq.ParamIndexing
			}
			Int           struct{}
			CanInterface  struct{}
			Interface     struct{}
			InterfaceData struct{}
			IsNil         struct{}
			IsValid       struct{}
			IsZero        struct{}
			Kind          struct{}
			Len           struct{}
			MapIndex      struct {
				Key moq.ParamIndexing
			}
			MapKeys  struct{}
			MapRange struct{}
			Method   struct {
				Param1 moq.ParamIndexing
			}
			NumMethod    struct{}
			MethodByName struct {
				Name moq.ParamIndexing
			}
			NumField        struct{}
			OverflowComplex struct {
				X moq.ParamIndexing
			}
			OverflowFloat struct {
				X moq.ParamIndexing
			}
			OverflowInt struct {
				X moq.ParamIndexing
			}
			OverflowUint struct {
				X moq.ParamIndexing
			}
			Pointer struct{}
			Recv    struct{}
			Send    struct {
				X moq.ParamIndexing
			}
			Set struct {
				X moq.ParamIndexing
			}
			SetBool struct {
				X moq.ParamIndexing
			}
			SetBytes struct {
				X moq.ParamIndexing
			}
			SetComplex struct {
				X moq.ParamIndexing
			}
			SetFloat struct {
				X moq.ParamIndexing
			}
			SetInt struct {
				X moq.ParamIndexing
			}
			SetLen struct {
				N moq.ParamIndexing
			}
			SetCap struct {
				N moq.ParamIndexing
			}
			SetMapIndex struct {
				Key  moq.ParamIndexing
				Elem moq.ParamIndexing
			}
			SetUint struct {
				X moq.ParamIndexing
			}
			SetPointer struct {
				X moq.ParamIndexing
			}
			SetString struct {
				X moq.ParamIndexing
			}
			Slice struct {
				Param1 moq.ParamIndexing
				J      moq.ParamIndexing
			}
			Slice3 struct {
				Param1 moq.ParamIndexing
				J      moq.ParamIndexing
				K      moq.ParamIndexing
			}
			String  struct{}
			TryRecv struct{}
			TrySend struct {
				X moq.ParamIndexing
			}
			Type       struct{}
			Uint       struct{}
			UnsafeAddr struct{}
			Convert    struct {
				T moq.ParamIndexing
			}
		}
	}
	// MoqValue_genType_mock isolates the mock interface of the Value_genType type
}

type MoqValue_genType_mock struct {
	Moq *MoqValue_genType
}

// MoqValue_genType_recorder isolates the recorder interface of the
// Value_genType type
type MoqValue_genType_recorder struct {
	Moq *MoqValue_genType
}

// MoqValue_genType_Addr_params holds the params of the Value_genType type
type MoqValue_genType_Addr_params struct{}

// MoqValue_genType_Addr_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Addr_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Addr_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Addr_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Addr_paramsKey]*MoqValue_genType_Addr_results
}

// MoqValue_genType_Addr_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Addr_doFn func()

// MoqValue_genType_Addr_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Addr_doReturnFn func() reflect.Value

// MoqValue_genType_Addr_results holds the results of the Value_genType type
type MoqValue_genType_Addr_results struct {
	Params  MoqValue_genType_Addr_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Addr_doFn
		DoReturnFn MoqValue_genType_Addr_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Addr_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Addr_fnRecorder struct {
	Params    MoqValue_genType_Addr_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Addr_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Addr_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Addr_anyParams struct {
	Recorder *MoqValue_genType_Addr_fnRecorder
}

// MoqValue_genType_Bool_params holds the params of the Value_genType type
type MoqValue_genType_Bool_params struct{}

// MoqValue_genType_Bool_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Bool_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Bool_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Bool_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Bool_paramsKey]*MoqValue_genType_Bool_results
}

// MoqValue_genType_Bool_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Bool_doFn func()

// MoqValue_genType_Bool_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Bool_doReturnFn func() bool

// MoqValue_genType_Bool_results holds the results of the Value_genType type
type MoqValue_genType_Bool_results struct {
	Params  MoqValue_genType_Bool_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Bool_doFn
		DoReturnFn MoqValue_genType_Bool_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Bool_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Bool_fnRecorder struct {
	Params    MoqValue_genType_Bool_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Bool_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Bool_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Bool_anyParams struct {
	Recorder *MoqValue_genType_Bool_fnRecorder
}

// MoqValue_genType_Bytes_params holds the params of the Value_genType type
type MoqValue_genType_Bytes_params struct{}

// MoqValue_genType_Bytes_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Bytes_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Bytes_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Bytes_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Bytes_paramsKey]*MoqValue_genType_Bytes_results
}

// MoqValue_genType_Bytes_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Bytes_doFn func()

// MoqValue_genType_Bytes_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Bytes_doReturnFn func() []byte

// MoqValue_genType_Bytes_results holds the results of the Value_genType type
type MoqValue_genType_Bytes_results struct {
	Params  MoqValue_genType_Bytes_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Bytes_doFn
		DoReturnFn MoqValue_genType_Bytes_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Bytes_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Bytes_fnRecorder struct {
	Params    MoqValue_genType_Bytes_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Bytes_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Bytes_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Bytes_anyParams struct {
	Recorder *MoqValue_genType_Bytes_fnRecorder
}

// MoqValue_genType_CanAddr_params holds the params of the Value_genType type
type MoqValue_genType_CanAddr_params struct{}

// MoqValue_genType_CanAddr_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_CanAddr_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_CanAddr_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_CanAddr_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_CanAddr_paramsKey]*MoqValue_genType_CanAddr_results
}

// MoqValue_genType_CanAddr_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_CanAddr_doFn func()

// MoqValue_genType_CanAddr_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_CanAddr_doReturnFn func() bool

// MoqValue_genType_CanAddr_results holds the results of the Value_genType type
type MoqValue_genType_CanAddr_results struct {
	Params  MoqValue_genType_CanAddr_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CanAddr_doFn
		DoReturnFn MoqValue_genType_CanAddr_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_CanAddr_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_CanAddr_fnRecorder struct {
	Params    MoqValue_genType_CanAddr_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_CanAddr_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_CanAddr_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_CanAddr_anyParams struct {
	Recorder *MoqValue_genType_CanAddr_fnRecorder
}

// MoqValue_genType_CanSet_params holds the params of the Value_genType type
type MoqValue_genType_CanSet_params struct{}

// MoqValue_genType_CanSet_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_CanSet_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_CanSet_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_CanSet_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_CanSet_paramsKey]*MoqValue_genType_CanSet_results
}

// MoqValue_genType_CanSet_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_CanSet_doFn func()

// MoqValue_genType_CanSet_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_CanSet_doReturnFn func() bool

// MoqValue_genType_CanSet_results holds the results of the Value_genType type
type MoqValue_genType_CanSet_results struct {
	Params  MoqValue_genType_CanSet_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CanSet_doFn
		DoReturnFn MoqValue_genType_CanSet_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_CanSet_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_CanSet_fnRecorder struct {
	Params    MoqValue_genType_CanSet_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_CanSet_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_CanSet_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_CanSet_anyParams struct {
	Recorder *MoqValue_genType_CanSet_fnRecorder
}

// MoqValue_genType_Call_params holds the params of the Value_genType type
type MoqValue_genType_Call_params struct{ In []reflect.Value }

// MoqValue_genType_Call_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Call_paramsKey struct {
	Params struct{}
	Hashes struct{ In hash.Hash }
}

// MoqValue_genType_Call_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Call_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Call_paramsKey]*MoqValue_genType_Call_results
}

// MoqValue_genType_Call_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Call_doFn func(in []reflect.Value)

// MoqValue_genType_Call_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Call_doReturnFn func(in []reflect.Value) []reflect.Value

// MoqValue_genType_Call_results holds the results of the Value_genType type
type MoqValue_genType_Call_results struct {
	Params  MoqValue_genType_Call_params
	Results []struct {
		Values *struct {
			Result1 []reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Call_doFn
		DoReturnFn MoqValue_genType_Call_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Call_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Call_fnRecorder struct {
	Params    MoqValue_genType_Call_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Call_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Call_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Call_anyParams struct {
	Recorder *MoqValue_genType_Call_fnRecorder
}

// MoqValue_genType_CallSlice_params holds the params of the Value_genType type
type MoqValue_genType_CallSlice_params struct{ In []reflect.Value }

// MoqValue_genType_CallSlice_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_CallSlice_paramsKey struct {
	Params struct{}
	Hashes struct{ In hash.Hash }
}

// MoqValue_genType_CallSlice_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_CallSlice_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_CallSlice_paramsKey]*MoqValue_genType_CallSlice_results
}

// MoqValue_genType_CallSlice_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_CallSlice_doFn func(in []reflect.Value)

// MoqValue_genType_CallSlice_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_CallSlice_doReturnFn func(in []reflect.Value) []reflect.Value

// MoqValue_genType_CallSlice_results holds the results of the Value_genType
// type
type MoqValue_genType_CallSlice_results struct {
	Params  MoqValue_genType_CallSlice_params
	Results []struct {
		Values *struct {
			Result1 []reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CallSlice_doFn
		DoReturnFn MoqValue_genType_CallSlice_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_CallSlice_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_CallSlice_fnRecorder struct {
	Params    MoqValue_genType_CallSlice_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_CallSlice_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_CallSlice_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_CallSlice_anyParams struct {
	Recorder *MoqValue_genType_CallSlice_fnRecorder
}

// MoqValue_genType_Cap_params holds the params of the Value_genType type
type MoqValue_genType_Cap_params struct{}

// MoqValue_genType_Cap_paramsKey holds the map key params of the Value_genType
// type
type MoqValue_genType_Cap_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Cap_resultsByParams contains the results for a given set of
// parameters for the Value_genType type
type MoqValue_genType_Cap_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Cap_paramsKey]*MoqValue_genType_Cap_results
}

// MoqValue_genType_Cap_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Cap_doFn func()

// MoqValue_genType_Cap_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Cap_doReturnFn func() int

// MoqValue_genType_Cap_results holds the results of the Value_genType type
type MoqValue_genType_Cap_results struct {
	Params  MoqValue_genType_Cap_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Cap_doFn
		DoReturnFn MoqValue_genType_Cap_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Cap_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Cap_fnRecorder struct {
	Params    MoqValue_genType_Cap_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Cap_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Cap_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Cap_anyParams struct {
	Recorder *MoqValue_genType_Cap_fnRecorder
}

// MoqValue_genType_Close_params holds the params of the Value_genType type
type MoqValue_genType_Close_params struct{}

// MoqValue_genType_Close_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Close_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Close_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Close_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Close_paramsKey]*MoqValue_genType_Close_results
}

// MoqValue_genType_Close_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Close_doFn func()

// MoqValue_genType_Close_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Close_doReturnFn func()

// MoqValue_genType_Close_results holds the results of the Value_genType type
type MoqValue_genType_Close_results struct {
	Params  MoqValue_genType_Close_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_Close_doFn
		DoReturnFn MoqValue_genType_Close_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Close_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Close_fnRecorder struct {
	Params    MoqValue_genType_Close_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Close_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Close_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Close_anyParams struct {
	Recorder *MoqValue_genType_Close_fnRecorder
}

// MoqValue_genType_Complex_params holds the params of the Value_genType type
type MoqValue_genType_Complex_params struct{}

// MoqValue_genType_Complex_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Complex_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Complex_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_Complex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Complex_paramsKey]*MoqValue_genType_Complex_results
}

// MoqValue_genType_Complex_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_Complex_doFn func()

// MoqValue_genType_Complex_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Complex_doReturnFn func() complex128

// MoqValue_genType_Complex_results holds the results of the Value_genType type
type MoqValue_genType_Complex_results struct {
	Params  MoqValue_genType_Complex_params
	Results []struct {
		Values *struct {
			Result1 complex128
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Complex_doFn
		DoReturnFn MoqValue_genType_Complex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Complex_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Complex_fnRecorder struct {
	Params    MoqValue_genType_Complex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Complex_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Complex_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Complex_anyParams struct {
	Recorder *MoqValue_genType_Complex_fnRecorder
}

// MoqValue_genType_Elem_params holds the params of the Value_genType type
type MoqValue_genType_Elem_params struct{}

// MoqValue_genType_Elem_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Elem_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Elem_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Elem_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Elem_paramsKey]*MoqValue_genType_Elem_results
}

// MoqValue_genType_Elem_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Elem_doFn func()

// MoqValue_genType_Elem_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Elem_doReturnFn func() reflect.Value

// MoqValue_genType_Elem_results holds the results of the Value_genType type
type MoqValue_genType_Elem_results struct {
	Params  MoqValue_genType_Elem_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Elem_doFn
		DoReturnFn MoqValue_genType_Elem_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Elem_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Elem_fnRecorder struct {
	Params    MoqValue_genType_Elem_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Elem_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Elem_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Elem_anyParams struct {
	Recorder *MoqValue_genType_Elem_fnRecorder
}

// MoqValue_genType_Field_params holds the params of the Value_genType type
type MoqValue_genType_Field_params struct{ Param1 int }

// MoqValue_genType_Field_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Field_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqValue_genType_Field_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Field_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Field_paramsKey]*MoqValue_genType_Field_results
}

// MoqValue_genType_Field_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Field_doFn func(i int)

// MoqValue_genType_Field_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Field_doReturnFn func(i int) reflect.Value

// MoqValue_genType_Field_results holds the results of the Value_genType type
type MoqValue_genType_Field_results struct {
	Params  MoqValue_genType_Field_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Field_doFn
		DoReturnFn MoqValue_genType_Field_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Field_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Field_fnRecorder struct {
	Params    MoqValue_genType_Field_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Field_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Field_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Field_anyParams struct {
	Recorder *MoqValue_genType_Field_fnRecorder
}

// MoqValue_genType_FieldByIndex_params holds the params of the Value_genType
// type
type MoqValue_genType_FieldByIndex_params struct{ Index []int }

// MoqValue_genType_FieldByIndex_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_FieldByIndex_paramsKey struct {
	Params struct{}
	Hashes struct{ Index hash.Hash }
}

// MoqValue_genType_FieldByIndex_resultsByParams contains the results for a
// given set of parameters for the Value_genType type
type MoqValue_genType_FieldByIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_FieldByIndex_paramsKey]*MoqValue_genType_FieldByIndex_results
}

// MoqValue_genType_FieldByIndex_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_FieldByIndex_doFn func(index []int)

// MoqValue_genType_FieldByIndex_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_FieldByIndex_doReturnFn func(index []int) reflect.Value

// MoqValue_genType_FieldByIndex_results holds the results of the Value_genType
// type
type MoqValue_genType_FieldByIndex_results struct {
	Params  MoqValue_genType_FieldByIndex_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_FieldByIndex_doFn
		DoReturnFn MoqValue_genType_FieldByIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_FieldByIndex_fnRecorder routes recorded function calls to
// the MoqValue_genType moq
type MoqValue_genType_FieldByIndex_fnRecorder struct {
	Params    MoqValue_genType_FieldByIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_FieldByIndex_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_FieldByIndex_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_FieldByIndex_anyParams struct {
	Recorder *MoqValue_genType_FieldByIndex_fnRecorder
}

// MoqValue_genType_FieldByName_params holds the params of the Value_genType
// type
type MoqValue_genType_FieldByName_params struct{ Name string }

// MoqValue_genType_FieldByName_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_FieldByName_paramsKey struct {
	Params struct{ Name string }
	Hashes struct{ Name hash.Hash }
}

// MoqValue_genType_FieldByName_resultsByParams contains the results for a
// given set of parameters for the Value_genType type
type MoqValue_genType_FieldByName_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_FieldByName_paramsKey]*MoqValue_genType_FieldByName_results
}

// MoqValue_genType_FieldByName_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_FieldByName_doFn func(name string)

// MoqValue_genType_FieldByName_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_FieldByName_doReturnFn func(name string) reflect.Value

// MoqValue_genType_FieldByName_results holds the results of the Value_genType
// type
type MoqValue_genType_FieldByName_results struct {
	Params  MoqValue_genType_FieldByName_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_FieldByName_doFn
		DoReturnFn MoqValue_genType_FieldByName_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_FieldByName_fnRecorder routes recorded function calls to
// the MoqValue_genType moq
type MoqValue_genType_FieldByName_fnRecorder struct {
	Params    MoqValue_genType_FieldByName_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_FieldByName_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_FieldByName_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_FieldByName_anyParams struct {
	Recorder *MoqValue_genType_FieldByName_fnRecorder
}

// MoqValue_genType_FieldByNameFunc_params holds the params of the
// Value_genType type
type MoqValue_genType_FieldByNameFunc_params struct{ Match func(string) bool }

// MoqValue_genType_FieldByNameFunc_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_FieldByNameFunc_paramsKey struct {
	Params struct{}
	Hashes struct{ Match hash.Hash }
}

// MoqValue_genType_FieldByNameFunc_resultsByParams contains the results for a
// given set of parameters for the Value_genType type
type MoqValue_genType_FieldByNameFunc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_FieldByNameFunc_paramsKey]*MoqValue_genType_FieldByNameFunc_results
}

// MoqValue_genType_FieldByNameFunc_doFn defines the type of function needed
// when calling AndDo for the Value_genType type
type MoqValue_genType_FieldByNameFunc_doFn func(match func(string) bool)

// MoqValue_genType_FieldByNameFunc_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Value_genType type
type MoqValue_genType_FieldByNameFunc_doReturnFn func(match func(string) bool) reflect.Value

// MoqValue_genType_FieldByNameFunc_results holds the results of the
// Value_genType type
type MoqValue_genType_FieldByNameFunc_results struct {
	Params  MoqValue_genType_FieldByNameFunc_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_FieldByNameFunc_doFn
		DoReturnFn MoqValue_genType_FieldByNameFunc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_FieldByNameFunc_fnRecorder routes recorded function calls
// to the MoqValue_genType moq
type MoqValue_genType_FieldByNameFunc_fnRecorder struct {
	Params    MoqValue_genType_FieldByNameFunc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_FieldByNameFunc_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_FieldByNameFunc_anyParams isolates the any params functions
// of the Value_genType type
type MoqValue_genType_FieldByNameFunc_anyParams struct {
	Recorder *MoqValue_genType_FieldByNameFunc_fnRecorder
}

// MoqValue_genType_Float_params holds the params of the Value_genType type
type MoqValue_genType_Float_params struct{}

// MoqValue_genType_Float_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Float_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Float_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Float_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Float_paramsKey]*MoqValue_genType_Float_results
}

// MoqValue_genType_Float_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Float_doFn func()

// MoqValue_genType_Float_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Float_doReturnFn func() float64

// MoqValue_genType_Float_results holds the results of the Value_genType type
type MoqValue_genType_Float_results struct {
	Params  MoqValue_genType_Float_params
	Results []struct {
		Values *struct {
			Result1 float64
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Float_doFn
		DoReturnFn MoqValue_genType_Float_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Float_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Float_fnRecorder struct {
	Params    MoqValue_genType_Float_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Float_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Float_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Float_anyParams struct {
	Recorder *MoqValue_genType_Float_fnRecorder
}

// MoqValue_genType_Index_params holds the params of the Value_genType type
type MoqValue_genType_Index_params struct{ Param1 int }

// MoqValue_genType_Index_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Index_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqValue_genType_Index_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Index_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Index_paramsKey]*MoqValue_genType_Index_results
}

// MoqValue_genType_Index_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Index_doFn func(i int)

// MoqValue_genType_Index_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Index_doReturnFn func(i int) reflect.Value

// MoqValue_genType_Index_results holds the results of the Value_genType type
type MoqValue_genType_Index_results struct {
	Params  MoqValue_genType_Index_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Index_doFn
		DoReturnFn MoqValue_genType_Index_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Index_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Index_fnRecorder struct {
	Params    MoqValue_genType_Index_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Index_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Index_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Index_anyParams struct {
	Recorder *MoqValue_genType_Index_fnRecorder
}

// MoqValue_genType_Int_params holds the params of the Value_genType type
type MoqValue_genType_Int_params struct{}

// MoqValue_genType_Int_paramsKey holds the map key params of the Value_genType
// type
type MoqValue_genType_Int_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Int_resultsByParams contains the results for a given set of
// parameters for the Value_genType type
type MoqValue_genType_Int_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Int_paramsKey]*MoqValue_genType_Int_results
}

// MoqValue_genType_Int_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Int_doFn func()

// MoqValue_genType_Int_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Int_doReturnFn func() int64

// MoqValue_genType_Int_results holds the results of the Value_genType type
type MoqValue_genType_Int_results struct {
	Params  MoqValue_genType_Int_params
	Results []struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Int_doFn
		DoReturnFn MoqValue_genType_Int_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Int_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Int_fnRecorder struct {
	Params    MoqValue_genType_Int_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Int_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Int_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Int_anyParams struct {
	Recorder *MoqValue_genType_Int_fnRecorder
}

// MoqValue_genType_CanInterface_params holds the params of the Value_genType
// type
type MoqValue_genType_CanInterface_params struct{}

// MoqValue_genType_CanInterface_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_CanInterface_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_CanInterface_resultsByParams contains the results for a
// given set of parameters for the Value_genType type
type MoqValue_genType_CanInterface_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_CanInterface_paramsKey]*MoqValue_genType_CanInterface_results
}

// MoqValue_genType_CanInterface_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_CanInterface_doFn func()

// MoqValue_genType_CanInterface_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_CanInterface_doReturnFn func() bool

// MoqValue_genType_CanInterface_results holds the results of the Value_genType
// type
type MoqValue_genType_CanInterface_results struct {
	Params  MoqValue_genType_CanInterface_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CanInterface_doFn
		DoReturnFn MoqValue_genType_CanInterface_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_CanInterface_fnRecorder routes recorded function calls to
// the MoqValue_genType moq
type MoqValue_genType_CanInterface_fnRecorder struct {
	Params    MoqValue_genType_CanInterface_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_CanInterface_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_CanInterface_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_CanInterface_anyParams struct {
	Recorder *MoqValue_genType_CanInterface_fnRecorder
}

// MoqValue_genType_Interface_params holds the params of the Value_genType type
type MoqValue_genType_Interface_params struct{}

// MoqValue_genType_Interface_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Interface_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Interface_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_Interface_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Interface_paramsKey]*MoqValue_genType_Interface_results
}

// MoqValue_genType_Interface_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_Interface_doFn func()

// MoqValue_genType_Interface_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_Interface_doReturnFn func() (i interface{})

// MoqValue_genType_Interface_results holds the results of the Value_genType
// type
type MoqValue_genType_Interface_results struct {
	Params  MoqValue_genType_Interface_params
	Results []struct {
		Values     *struct{ Result1 interface{} }
		Sequence   uint32
		DoFn       MoqValue_genType_Interface_doFn
		DoReturnFn MoqValue_genType_Interface_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Interface_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Interface_fnRecorder struct {
	Params    MoqValue_genType_Interface_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Interface_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Interface_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_Interface_anyParams struct {
	Recorder *MoqValue_genType_Interface_fnRecorder
}

// MoqValue_genType_InterfaceData_params holds the params of the Value_genType
// type
type MoqValue_genType_InterfaceData_params struct{}

// MoqValue_genType_InterfaceData_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_InterfaceData_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_InterfaceData_resultsByParams contains the results for a
// given set of parameters for the Value_genType type
type MoqValue_genType_InterfaceData_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_InterfaceData_paramsKey]*MoqValue_genType_InterfaceData_results
}

// MoqValue_genType_InterfaceData_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_InterfaceData_doFn func()

// MoqValue_genType_InterfaceData_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Value_genType type
type MoqValue_genType_InterfaceData_doReturnFn func() [2]uintptr

// MoqValue_genType_InterfaceData_results holds the results of the
// Value_genType type
type MoqValue_genType_InterfaceData_results struct {
	Params  MoqValue_genType_InterfaceData_params
	Results []struct {
		Values *struct {
			Result1 [2]uintptr
		}
		Sequence   uint32
		DoFn       MoqValue_genType_InterfaceData_doFn
		DoReturnFn MoqValue_genType_InterfaceData_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_InterfaceData_fnRecorder routes recorded function calls to
// the MoqValue_genType moq
type MoqValue_genType_InterfaceData_fnRecorder struct {
	Params    MoqValue_genType_InterfaceData_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_InterfaceData_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_InterfaceData_anyParams isolates the any params functions
// of the Value_genType type
type MoqValue_genType_InterfaceData_anyParams struct {
	Recorder *MoqValue_genType_InterfaceData_fnRecorder
}

// MoqValue_genType_IsNil_params holds the params of the Value_genType type
type MoqValue_genType_IsNil_params struct{}

// MoqValue_genType_IsNil_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_IsNil_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_IsNil_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_IsNil_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_IsNil_paramsKey]*MoqValue_genType_IsNil_results
}

// MoqValue_genType_IsNil_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_IsNil_doFn func()

// MoqValue_genType_IsNil_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_IsNil_doReturnFn func() bool

// MoqValue_genType_IsNil_results holds the results of the Value_genType type
type MoqValue_genType_IsNil_results struct {
	Params  MoqValue_genType_IsNil_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_IsNil_doFn
		DoReturnFn MoqValue_genType_IsNil_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_IsNil_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_IsNil_fnRecorder struct {
	Params    MoqValue_genType_IsNil_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_IsNil_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_IsNil_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_IsNil_anyParams struct {
	Recorder *MoqValue_genType_IsNil_fnRecorder
}

// MoqValue_genType_IsValid_params holds the params of the Value_genType type
type MoqValue_genType_IsValid_params struct{}

// MoqValue_genType_IsValid_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_IsValid_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_IsValid_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_IsValid_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_IsValid_paramsKey]*MoqValue_genType_IsValid_results
}

// MoqValue_genType_IsValid_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_IsValid_doFn func()

// MoqValue_genType_IsValid_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_IsValid_doReturnFn func() bool

// MoqValue_genType_IsValid_results holds the results of the Value_genType type
type MoqValue_genType_IsValid_results struct {
	Params  MoqValue_genType_IsValid_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_IsValid_doFn
		DoReturnFn MoqValue_genType_IsValid_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_IsValid_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_IsValid_fnRecorder struct {
	Params    MoqValue_genType_IsValid_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_IsValid_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_IsValid_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_IsValid_anyParams struct {
	Recorder *MoqValue_genType_IsValid_fnRecorder
}

// MoqValue_genType_IsZero_params holds the params of the Value_genType type
type MoqValue_genType_IsZero_params struct{}

// MoqValue_genType_IsZero_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_IsZero_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_IsZero_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_IsZero_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_IsZero_paramsKey]*MoqValue_genType_IsZero_results
}

// MoqValue_genType_IsZero_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_IsZero_doFn func()

// MoqValue_genType_IsZero_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_IsZero_doReturnFn func() bool

// MoqValue_genType_IsZero_results holds the results of the Value_genType type
type MoqValue_genType_IsZero_results struct {
	Params  MoqValue_genType_IsZero_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_IsZero_doFn
		DoReturnFn MoqValue_genType_IsZero_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_IsZero_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_IsZero_fnRecorder struct {
	Params    MoqValue_genType_IsZero_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_IsZero_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_IsZero_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_IsZero_anyParams struct {
	Recorder *MoqValue_genType_IsZero_fnRecorder
}

// MoqValue_genType_Kind_params holds the params of the Value_genType type
type MoqValue_genType_Kind_params struct{}

// MoqValue_genType_Kind_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Kind_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Kind_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Kind_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Kind_paramsKey]*MoqValue_genType_Kind_results
}

// MoqValue_genType_Kind_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Kind_doFn func()

// MoqValue_genType_Kind_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Kind_doReturnFn func() reflect.Kind

// MoqValue_genType_Kind_results holds the results of the Value_genType type
type MoqValue_genType_Kind_results struct {
	Params  MoqValue_genType_Kind_params
	Results []struct {
		Values *struct {
			Result1 reflect.Kind
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Kind_doFn
		DoReturnFn MoqValue_genType_Kind_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Kind_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Kind_fnRecorder struct {
	Params    MoqValue_genType_Kind_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Kind_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Kind_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Kind_anyParams struct {
	Recorder *MoqValue_genType_Kind_fnRecorder
}

// MoqValue_genType_Len_params holds the params of the Value_genType type
type MoqValue_genType_Len_params struct{}

// MoqValue_genType_Len_paramsKey holds the map key params of the Value_genType
// type
type MoqValue_genType_Len_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Len_resultsByParams contains the results for a given set of
// parameters for the Value_genType type
type MoqValue_genType_Len_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Len_paramsKey]*MoqValue_genType_Len_results
}

// MoqValue_genType_Len_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Len_doFn func()

// MoqValue_genType_Len_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Len_doReturnFn func() int

// MoqValue_genType_Len_results holds the results of the Value_genType type
type MoqValue_genType_Len_results struct {
	Params  MoqValue_genType_Len_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Len_doFn
		DoReturnFn MoqValue_genType_Len_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Len_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Len_fnRecorder struct {
	Params    MoqValue_genType_Len_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Len_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Len_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Len_anyParams struct {
	Recorder *MoqValue_genType_Len_fnRecorder
}

// MoqValue_genType_MapIndex_params holds the params of the Value_genType type
type MoqValue_genType_MapIndex_params struct{ Key reflect.Value }

// MoqValue_genType_MapIndex_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_MapIndex_paramsKey struct {
	Params struct{ Key reflect.Value }
	Hashes struct{ Key hash.Hash }
}

// MoqValue_genType_MapIndex_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_MapIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_MapIndex_paramsKey]*MoqValue_genType_MapIndex_results
}

// MoqValue_genType_MapIndex_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_MapIndex_doFn func(key reflect.Value)

// MoqValue_genType_MapIndex_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_MapIndex_doReturnFn func(key reflect.Value) reflect.Value

// MoqValue_genType_MapIndex_results holds the results of the Value_genType
// type
type MoqValue_genType_MapIndex_results struct {
	Params  MoqValue_genType_MapIndex_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MapIndex_doFn
		DoReturnFn MoqValue_genType_MapIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_MapIndex_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_MapIndex_fnRecorder struct {
	Params    MoqValue_genType_MapIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_MapIndex_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_MapIndex_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_MapIndex_anyParams struct {
	Recorder *MoqValue_genType_MapIndex_fnRecorder
}

// MoqValue_genType_MapKeys_params holds the params of the Value_genType type
type MoqValue_genType_MapKeys_params struct{}

// MoqValue_genType_MapKeys_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_MapKeys_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_MapKeys_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_MapKeys_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_MapKeys_paramsKey]*MoqValue_genType_MapKeys_results
}

// MoqValue_genType_MapKeys_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_MapKeys_doFn func()

// MoqValue_genType_MapKeys_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_MapKeys_doReturnFn func() []reflect.Value

// MoqValue_genType_MapKeys_results holds the results of the Value_genType type
type MoqValue_genType_MapKeys_results struct {
	Params  MoqValue_genType_MapKeys_params
	Results []struct {
		Values *struct {
			Result1 []reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MapKeys_doFn
		DoReturnFn MoqValue_genType_MapKeys_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_MapKeys_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_MapKeys_fnRecorder struct {
	Params    MoqValue_genType_MapKeys_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_MapKeys_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_MapKeys_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_MapKeys_anyParams struct {
	Recorder *MoqValue_genType_MapKeys_fnRecorder
}

// MoqValue_genType_MapRange_params holds the params of the Value_genType type
type MoqValue_genType_MapRange_params struct{}

// MoqValue_genType_MapRange_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_MapRange_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_MapRange_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_MapRange_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_MapRange_paramsKey]*MoqValue_genType_MapRange_results
}

// MoqValue_genType_MapRange_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_MapRange_doFn func()

// MoqValue_genType_MapRange_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_MapRange_doReturnFn func() *reflect.MapIter

// MoqValue_genType_MapRange_results holds the results of the Value_genType
// type
type MoqValue_genType_MapRange_results struct {
	Params  MoqValue_genType_MapRange_params
	Results []struct {
		Values *struct {
			Result1 *reflect.MapIter
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MapRange_doFn
		DoReturnFn MoqValue_genType_MapRange_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_MapRange_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_MapRange_fnRecorder struct {
	Params    MoqValue_genType_MapRange_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_MapRange_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_MapRange_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_MapRange_anyParams struct {
	Recorder *MoqValue_genType_MapRange_fnRecorder
}

// MoqValue_genType_Method_params holds the params of the Value_genType type
type MoqValue_genType_Method_params struct{ Param1 int }

// MoqValue_genType_Method_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Method_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqValue_genType_Method_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Method_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Method_paramsKey]*MoqValue_genType_Method_results
}

// MoqValue_genType_Method_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_Method_doFn func(i int)

// MoqValue_genType_Method_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Method_doReturnFn func(i int) reflect.Value

// MoqValue_genType_Method_results holds the results of the Value_genType type
type MoqValue_genType_Method_results struct {
	Params  MoqValue_genType_Method_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Method_doFn
		DoReturnFn MoqValue_genType_Method_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Method_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Method_fnRecorder struct {
	Params    MoqValue_genType_Method_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Method_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Method_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Method_anyParams struct {
	Recorder *MoqValue_genType_Method_fnRecorder
}

// MoqValue_genType_NumMethod_params holds the params of the Value_genType type
type MoqValue_genType_NumMethod_params struct{}

// MoqValue_genType_NumMethod_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_NumMethod_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_NumMethod_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_NumMethod_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_NumMethod_paramsKey]*MoqValue_genType_NumMethod_results
}

// MoqValue_genType_NumMethod_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_NumMethod_doFn func()

// MoqValue_genType_NumMethod_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_NumMethod_doReturnFn func() int

// MoqValue_genType_NumMethod_results holds the results of the Value_genType
// type
type MoqValue_genType_NumMethod_results struct {
	Params  MoqValue_genType_NumMethod_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_NumMethod_doFn
		DoReturnFn MoqValue_genType_NumMethod_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_NumMethod_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_NumMethod_fnRecorder struct {
	Params    MoqValue_genType_NumMethod_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_NumMethod_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_NumMethod_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_NumMethod_anyParams struct {
	Recorder *MoqValue_genType_NumMethod_fnRecorder
}

// MoqValue_genType_MethodByName_params holds the params of the Value_genType
// type
type MoqValue_genType_MethodByName_params struct{ Name string }

// MoqValue_genType_MethodByName_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_MethodByName_paramsKey struct {
	Params struct{ Name string }
	Hashes struct{ Name hash.Hash }
}

// MoqValue_genType_MethodByName_resultsByParams contains the results for a
// given set of parameters for the Value_genType type
type MoqValue_genType_MethodByName_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_MethodByName_paramsKey]*MoqValue_genType_MethodByName_results
}

// MoqValue_genType_MethodByName_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_MethodByName_doFn func(name string)

// MoqValue_genType_MethodByName_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_MethodByName_doReturnFn func(name string) reflect.Value

// MoqValue_genType_MethodByName_results holds the results of the Value_genType
// type
type MoqValue_genType_MethodByName_results struct {
	Params  MoqValue_genType_MethodByName_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MethodByName_doFn
		DoReturnFn MoqValue_genType_MethodByName_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_MethodByName_fnRecorder routes recorded function calls to
// the MoqValue_genType moq
type MoqValue_genType_MethodByName_fnRecorder struct {
	Params    MoqValue_genType_MethodByName_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_MethodByName_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_MethodByName_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_MethodByName_anyParams struct {
	Recorder *MoqValue_genType_MethodByName_fnRecorder
}

// MoqValue_genType_NumField_params holds the params of the Value_genType type
type MoqValue_genType_NumField_params struct{}

// MoqValue_genType_NumField_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_NumField_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_NumField_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_NumField_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_NumField_paramsKey]*MoqValue_genType_NumField_results
}

// MoqValue_genType_NumField_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_NumField_doFn func()

// MoqValue_genType_NumField_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_NumField_doReturnFn func() int

// MoqValue_genType_NumField_results holds the results of the Value_genType
// type
type MoqValue_genType_NumField_results struct {
	Params  MoqValue_genType_NumField_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_NumField_doFn
		DoReturnFn MoqValue_genType_NumField_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_NumField_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_NumField_fnRecorder struct {
	Params    MoqValue_genType_NumField_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_NumField_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_NumField_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_NumField_anyParams struct {
	Recorder *MoqValue_genType_NumField_fnRecorder
}

// MoqValue_genType_OverflowComplex_params holds the params of the
// Value_genType type
type MoqValue_genType_OverflowComplex_params struct{ X complex128 }

// MoqValue_genType_OverflowComplex_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_OverflowComplex_paramsKey struct {
	Params struct{ X complex128 }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_OverflowComplex_resultsByParams contains the results for a
// given set of parameters for the Value_genType type
type MoqValue_genType_OverflowComplex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_OverflowComplex_paramsKey]*MoqValue_genType_OverflowComplex_results
}

// MoqValue_genType_OverflowComplex_doFn defines the type of function needed
// when calling AndDo for the Value_genType type
type MoqValue_genType_OverflowComplex_doFn func(x complex128)

// MoqValue_genType_OverflowComplex_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Value_genType type
type MoqValue_genType_OverflowComplex_doReturnFn func(x complex128) bool

// MoqValue_genType_OverflowComplex_results holds the results of the
// Value_genType type
type MoqValue_genType_OverflowComplex_results struct {
	Params  MoqValue_genType_OverflowComplex_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowComplex_doFn
		DoReturnFn MoqValue_genType_OverflowComplex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_OverflowComplex_fnRecorder routes recorded function calls
// to the MoqValue_genType moq
type MoqValue_genType_OverflowComplex_fnRecorder struct {
	Params    MoqValue_genType_OverflowComplex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_OverflowComplex_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_OverflowComplex_anyParams isolates the any params functions
// of the Value_genType type
type MoqValue_genType_OverflowComplex_anyParams struct {
	Recorder *MoqValue_genType_OverflowComplex_fnRecorder
}

// MoqValue_genType_OverflowFloat_params holds the params of the Value_genType
// type
type MoqValue_genType_OverflowFloat_params struct{ X float64 }

// MoqValue_genType_OverflowFloat_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_OverflowFloat_paramsKey struct {
	Params struct{ X float64 }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_OverflowFloat_resultsByParams contains the results for a
// given set of parameters for the Value_genType type
type MoqValue_genType_OverflowFloat_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_OverflowFloat_paramsKey]*MoqValue_genType_OverflowFloat_results
}

// MoqValue_genType_OverflowFloat_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_OverflowFloat_doFn func(x float64)

// MoqValue_genType_OverflowFloat_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Value_genType type
type MoqValue_genType_OverflowFloat_doReturnFn func(x float64) bool

// MoqValue_genType_OverflowFloat_results holds the results of the
// Value_genType type
type MoqValue_genType_OverflowFloat_results struct {
	Params  MoqValue_genType_OverflowFloat_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowFloat_doFn
		DoReturnFn MoqValue_genType_OverflowFloat_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_OverflowFloat_fnRecorder routes recorded function calls to
// the MoqValue_genType moq
type MoqValue_genType_OverflowFloat_fnRecorder struct {
	Params    MoqValue_genType_OverflowFloat_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_OverflowFloat_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_OverflowFloat_anyParams isolates the any params functions
// of the Value_genType type
type MoqValue_genType_OverflowFloat_anyParams struct {
	Recorder *MoqValue_genType_OverflowFloat_fnRecorder
}

// MoqValue_genType_OverflowInt_params holds the params of the Value_genType
// type
type MoqValue_genType_OverflowInt_params struct{ X int64 }

// MoqValue_genType_OverflowInt_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_OverflowInt_paramsKey struct {
	Params struct{ X int64 }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_OverflowInt_resultsByParams contains the results for a
// given set of parameters for the Value_genType type
type MoqValue_genType_OverflowInt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_OverflowInt_paramsKey]*MoqValue_genType_OverflowInt_results
}

// MoqValue_genType_OverflowInt_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_OverflowInt_doFn func(x int64)

// MoqValue_genType_OverflowInt_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_OverflowInt_doReturnFn func(x int64) bool

// MoqValue_genType_OverflowInt_results holds the results of the Value_genType
// type
type MoqValue_genType_OverflowInt_results struct {
	Params  MoqValue_genType_OverflowInt_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowInt_doFn
		DoReturnFn MoqValue_genType_OverflowInt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_OverflowInt_fnRecorder routes recorded function calls to
// the MoqValue_genType moq
type MoqValue_genType_OverflowInt_fnRecorder struct {
	Params    MoqValue_genType_OverflowInt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_OverflowInt_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_OverflowInt_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_OverflowInt_anyParams struct {
	Recorder *MoqValue_genType_OverflowInt_fnRecorder
}

// MoqValue_genType_OverflowUint_params holds the params of the Value_genType
// type
type MoqValue_genType_OverflowUint_params struct{ X uint64 }

// MoqValue_genType_OverflowUint_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_OverflowUint_paramsKey struct {
	Params struct{ X uint64 }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_OverflowUint_resultsByParams contains the results for a
// given set of parameters for the Value_genType type
type MoqValue_genType_OverflowUint_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_OverflowUint_paramsKey]*MoqValue_genType_OverflowUint_results
}

// MoqValue_genType_OverflowUint_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_OverflowUint_doFn func(x uint64)

// MoqValue_genType_OverflowUint_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_OverflowUint_doReturnFn func(x uint64) bool

// MoqValue_genType_OverflowUint_results holds the results of the Value_genType
// type
type MoqValue_genType_OverflowUint_results struct {
	Params  MoqValue_genType_OverflowUint_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowUint_doFn
		DoReturnFn MoqValue_genType_OverflowUint_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_OverflowUint_fnRecorder routes recorded function calls to
// the MoqValue_genType moq
type MoqValue_genType_OverflowUint_fnRecorder struct {
	Params    MoqValue_genType_OverflowUint_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_OverflowUint_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_OverflowUint_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_OverflowUint_anyParams struct {
	Recorder *MoqValue_genType_OverflowUint_fnRecorder
}

// MoqValue_genType_Pointer_params holds the params of the Value_genType type
type MoqValue_genType_Pointer_params struct{}

// MoqValue_genType_Pointer_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Pointer_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Pointer_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_Pointer_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Pointer_paramsKey]*MoqValue_genType_Pointer_results
}

// MoqValue_genType_Pointer_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_Pointer_doFn func()

// MoqValue_genType_Pointer_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Pointer_doReturnFn func() uintptr

// MoqValue_genType_Pointer_results holds the results of the Value_genType type
type MoqValue_genType_Pointer_results struct {
	Params  MoqValue_genType_Pointer_params
	Results []struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Pointer_doFn
		DoReturnFn MoqValue_genType_Pointer_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Pointer_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Pointer_fnRecorder struct {
	Params    MoqValue_genType_Pointer_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Pointer_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Pointer_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Pointer_anyParams struct {
	Recorder *MoqValue_genType_Pointer_fnRecorder
}

// MoqValue_genType_Recv_params holds the params of the Value_genType type
type MoqValue_genType_Recv_params struct{}

// MoqValue_genType_Recv_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Recv_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Recv_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Recv_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Recv_paramsKey]*MoqValue_genType_Recv_results
}

// MoqValue_genType_Recv_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Recv_doFn func()

// MoqValue_genType_Recv_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Recv_doReturnFn func() (x reflect.Value, ok bool)

// MoqValue_genType_Recv_results holds the results of the Value_genType type
type MoqValue_genType_Recv_results struct {
	Params  MoqValue_genType_Recv_params
	Results []struct {
		Values *struct {
			X  reflect.Value
			Ok bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Recv_doFn
		DoReturnFn MoqValue_genType_Recv_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Recv_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Recv_fnRecorder struct {
	Params    MoqValue_genType_Recv_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Recv_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Recv_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Recv_anyParams struct {
	Recorder *MoqValue_genType_Recv_fnRecorder
}

// MoqValue_genType_Send_params holds the params of the Value_genType type
type MoqValue_genType_Send_params struct{ X reflect.Value }

// MoqValue_genType_Send_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Send_paramsKey struct {
	Params struct{ X reflect.Value }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_Send_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Send_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Send_paramsKey]*MoqValue_genType_Send_results
}

// MoqValue_genType_Send_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Send_doFn func(x reflect.Value)

// MoqValue_genType_Send_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Send_doReturnFn func(x reflect.Value)

// MoqValue_genType_Send_results holds the results of the Value_genType type
type MoqValue_genType_Send_results struct {
	Params  MoqValue_genType_Send_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_Send_doFn
		DoReturnFn MoqValue_genType_Send_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Send_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Send_fnRecorder struct {
	Params    MoqValue_genType_Send_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Send_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Send_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Send_anyParams struct {
	Recorder *MoqValue_genType_Send_fnRecorder
}

// MoqValue_genType_Set_params holds the params of the Value_genType type
type MoqValue_genType_Set_params struct{ X reflect.Value }

// MoqValue_genType_Set_paramsKey holds the map key params of the Value_genType
// type
type MoqValue_genType_Set_paramsKey struct {
	Params struct{ X reflect.Value }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_Set_resultsByParams contains the results for a given set of
// parameters for the Value_genType type
type MoqValue_genType_Set_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Set_paramsKey]*MoqValue_genType_Set_results
}

// MoqValue_genType_Set_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Set_doFn func(x reflect.Value)

// MoqValue_genType_Set_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Set_doReturnFn func(x reflect.Value)

// MoqValue_genType_Set_results holds the results of the Value_genType type
type MoqValue_genType_Set_results struct {
	Params  MoqValue_genType_Set_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_Set_doFn
		DoReturnFn MoqValue_genType_Set_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Set_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Set_fnRecorder struct {
	Params    MoqValue_genType_Set_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Set_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Set_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Set_anyParams struct {
	Recorder *MoqValue_genType_Set_fnRecorder
}

// MoqValue_genType_SetBool_params holds the params of the Value_genType type
type MoqValue_genType_SetBool_params struct{ X bool }

// MoqValue_genType_SetBool_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_SetBool_paramsKey struct {
	Params struct{ X bool }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_SetBool_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_SetBool_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_SetBool_paramsKey]*MoqValue_genType_SetBool_results
}

// MoqValue_genType_SetBool_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_SetBool_doFn func(x bool)

// MoqValue_genType_SetBool_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_SetBool_doReturnFn func(x bool)

// MoqValue_genType_SetBool_results holds the results of the Value_genType type
type MoqValue_genType_SetBool_results struct {
	Params  MoqValue_genType_SetBool_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetBool_doFn
		DoReturnFn MoqValue_genType_SetBool_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_SetBool_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_SetBool_fnRecorder struct {
	Params    MoqValue_genType_SetBool_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_SetBool_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_SetBool_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_SetBool_anyParams struct {
	Recorder *MoqValue_genType_SetBool_fnRecorder
}

// MoqValue_genType_SetBytes_params holds the params of the Value_genType type
type MoqValue_genType_SetBytes_params struct{ X []byte }

// MoqValue_genType_SetBytes_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_SetBytes_paramsKey struct {
	Params struct{}
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_SetBytes_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_SetBytes_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_SetBytes_paramsKey]*MoqValue_genType_SetBytes_results
}

// MoqValue_genType_SetBytes_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_SetBytes_doFn func(x []byte)

// MoqValue_genType_SetBytes_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_SetBytes_doReturnFn func(x []byte)

// MoqValue_genType_SetBytes_results holds the results of the Value_genType
// type
type MoqValue_genType_SetBytes_results struct {
	Params  MoqValue_genType_SetBytes_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetBytes_doFn
		DoReturnFn MoqValue_genType_SetBytes_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_SetBytes_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_SetBytes_fnRecorder struct {
	Params    MoqValue_genType_SetBytes_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_SetBytes_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_SetBytes_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_SetBytes_anyParams struct {
	Recorder *MoqValue_genType_SetBytes_fnRecorder
}

// MoqValue_genType_SetComplex_params holds the params of the Value_genType
// type
type MoqValue_genType_SetComplex_params struct{ X complex128 }

// MoqValue_genType_SetComplex_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_SetComplex_paramsKey struct {
	Params struct{ X complex128 }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_SetComplex_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_SetComplex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_SetComplex_paramsKey]*MoqValue_genType_SetComplex_results
}

// MoqValue_genType_SetComplex_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_SetComplex_doFn func(x complex128)

// MoqValue_genType_SetComplex_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_SetComplex_doReturnFn func(x complex128)

// MoqValue_genType_SetComplex_results holds the results of the Value_genType
// type
type MoqValue_genType_SetComplex_results struct {
	Params  MoqValue_genType_SetComplex_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetComplex_doFn
		DoReturnFn MoqValue_genType_SetComplex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_SetComplex_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_SetComplex_fnRecorder struct {
	Params    MoqValue_genType_SetComplex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_SetComplex_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_SetComplex_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_SetComplex_anyParams struct {
	Recorder *MoqValue_genType_SetComplex_fnRecorder
}

// MoqValue_genType_SetFloat_params holds the params of the Value_genType type
type MoqValue_genType_SetFloat_params struct{ X float64 }

// MoqValue_genType_SetFloat_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_SetFloat_paramsKey struct {
	Params struct{ X float64 }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_SetFloat_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_SetFloat_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_SetFloat_paramsKey]*MoqValue_genType_SetFloat_results
}

// MoqValue_genType_SetFloat_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_SetFloat_doFn func(x float64)

// MoqValue_genType_SetFloat_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_SetFloat_doReturnFn func(x float64)

// MoqValue_genType_SetFloat_results holds the results of the Value_genType
// type
type MoqValue_genType_SetFloat_results struct {
	Params  MoqValue_genType_SetFloat_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetFloat_doFn
		DoReturnFn MoqValue_genType_SetFloat_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_SetFloat_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_SetFloat_fnRecorder struct {
	Params    MoqValue_genType_SetFloat_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_SetFloat_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_SetFloat_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_SetFloat_anyParams struct {
	Recorder *MoqValue_genType_SetFloat_fnRecorder
}

// MoqValue_genType_SetInt_params holds the params of the Value_genType type
type MoqValue_genType_SetInt_params struct{ X int64 }

// MoqValue_genType_SetInt_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_SetInt_paramsKey struct {
	Params struct{ X int64 }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_SetInt_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_SetInt_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_SetInt_paramsKey]*MoqValue_genType_SetInt_results
}

// MoqValue_genType_SetInt_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_SetInt_doFn func(x int64)

// MoqValue_genType_SetInt_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_SetInt_doReturnFn func(x int64)

// MoqValue_genType_SetInt_results holds the results of the Value_genType type
type MoqValue_genType_SetInt_results struct {
	Params  MoqValue_genType_SetInt_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetInt_doFn
		DoReturnFn MoqValue_genType_SetInt_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_SetInt_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_SetInt_fnRecorder struct {
	Params    MoqValue_genType_SetInt_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_SetInt_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_SetInt_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_SetInt_anyParams struct {
	Recorder *MoqValue_genType_SetInt_fnRecorder
}

// MoqValue_genType_SetLen_params holds the params of the Value_genType type
type MoqValue_genType_SetLen_params struct{ N int }

// MoqValue_genType_SetLen_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_SetLen_paramsKey struct {
	Params struct{ N int }
	Hashes struct{ N hash.Hash }
}

// MoqValue_genType_SetLen_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_SetLen_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_SetLen_paramsKey]*MoqValue_genType_SetLen_results
}

// MoqValue_genType_SetLen_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_SetLen_doFn func(n int)

// MoqValue_genType_SetLen_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_SetLen_doReturnFn func(n int)

// MoqValue_genType_SetLen_results holds the results of the Value_genType type
type MoqValue_genType_SetLen_results struct {
	Params  MoqValue_genType_SetLen_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetLen_doFn
		DoReturnFn MoqValue_genType_SetLen_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_SetLen_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_SetLen_fnRecorder struct {
	Params    MoqValue_genType_SetLen_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_SetLen_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_SetLen_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_SetLen_anyParams struct {
	Recorder *MoqValue_genType_SetLen_fnRecorder
}

// MoqValue_genType_SetCap_params holds the params of the Value_genType type
type MoqValue_genType_SetCap_params struct{ N int }

// MoqValue_genType_SetCap_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_SetCap_paramsKey struct {
	Params struct{ N int }
	Hashes struct{ N hash.Hash }
}

// MoqValue_genType_SetCap_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_SetCap_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_SetCap_paramsKey]*MoqValue_genType_SetCap_results
}

// MoqValue_genType_SetCap_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_SetCap_doFn func(n int)

// MoqValue_genType_SetCap_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_SetCap_doReturnFn func(n int)

// MoqValue_genType_SetCap_results holds the results of the Value_genType type
type MoqValue_genType_SetCap_results struct {
	Params  MoqValue_genType_SetCap_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetCap_doFn
		DoReturnFn MoqValue_genType_SetCap_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_SetCap_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_SetCap_fnRecorder struct {
	Params    MoqValue_genType_SetCap_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_SetCap_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_SetCap_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_SetCap_anyParams struct {
	Recorder *MoqValue_genType_SetCap_fnRecorder
}

// MoqValue_genType_SetMapIndex_params holds the params of the Value_genType
// type
type MoqValue_genType_SetMapIndex_params struct{ Key, Elem reflect.Value }

// MoqValue_genType_SetMapIndex_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_SetMapIndex_paramsKey struct {
	Params struct{ Key, Elem reflect.Value }
	Hashes struct{ Key, Elem hash.Hash }
}

// MoqValue_genType_SetMapIndex_resultsByParams contains the results for a
// given set of parameters for the Value_genType type
type MoqValue_genType_SetMapIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_SetMapIndex_paramsKey]*MoqValue_genType_SetMapIndex_results
}

// MoqValue_genType_SetMapIndex_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_SetMapIndex_doFn func(key, elem reflect.Value)

// MoqValue_genType_SetMapIndex_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_SetMapIndex_doReturnFn func(key, elem reflect.Value)

// MoqValue_genType_SetMapIndex_results holds the results of the Value_genType
// type
type MoqValue_genType_SetMapIndex_results struct {
	Params  MoqValue_genType_SetMapIndex_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetMapIndex_doFn
		DoReturnFn MoqValue_genType_SetMapIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_SetMapIndex_fnRecorder routes recorded function calls to
// the MoqValue_genType moq
type MoqValue_genType_SetMapIndex_fnRecorder struct {
	Params    MoqValue_genType_SetMapIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_SetMapIndex_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_SetMapIndex_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_SetMapIndex_anyParams struct {
	Recorder *MoqValue_genType_SetMapIndex_fnRecorder
}

// MoqValue_genType_SetUint_params holds the params of the Value_genType type
type MoqValue_genType_SetUint_params struct{ X uint64 }

// MoqValue_genType_SetUint_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_SetUint_paramsKey struct {
	Params struct{ X uint64 }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_SetUint_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_SetUint_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_SetUint_paramsKey]*MoqValue_genType_SetUint_results
}

// MoqValue_genType_SetUint_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_SetUint_doFn func(x uint64)

// MoqValue_genType_SetUint_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_SetUint_doReturnFn func(x uint64)

// MoqValue_genType_SetUint_results holds the results of the Value_genType type
type MoqValue_genType_SetUint_results struct {
	Params  MoqValue_genType_SetUint_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetUint_doFn
		DoReturnFn MoqValue_genType_SetUint_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_SetUint_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_SetUint_fnRecorder struct {
	Params    MoqValue_genType_SetUint_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_SetUint_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_SetUint_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_SetUint_anyParams struct {
	Recorder *MoqValue_genType_SetUint_fnRecorder
}

// MoqValue_genType_SetPointer_params holds the params of the Value_genType
// type
type MoqValue_genType_SetPointer_params struct{ X unsafe.Pointer }

// MoqValue_genType_SetPointer_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_SetPointer_paramsKey struct {
	Params struct{ X unsafe.Pointer }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_SetPointer_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_SetPointer_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_SetPointer_paramsKey]*MoqValue_genType_SetPointer_results
}

// MoqValue_genType_SetPointer_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_SetPointer_doFn func(x unsafe.Pointer)

// MoqValue_genType_SetPointer_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_SetPointer_doReturnFn func(x unsafe.Pointer)

// MoqValue_genType_SetPointer_results holds the results of the Value_genType
// type
type MoqValue_genType_SetPointer_results struct {
	Params  MoqValue_genType_SetPointer_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetPointer_doFn
		DoReturnFn MoqValue_genType_SetPointer_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_SetPointer_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_SetPointer_fnRecorder struct {
	Params    MoqValue_genType_SetPointer_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_SetPointer_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_SetPointer_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_SetPointer_anyParams struct {
	Recorder *MoqValue_genType_SetPointer_fnRecorder
}

// MoqValue_genType_SetString_params holds the params of the Value_genType type
type MoqValue_genType_SetString_params struct{ X string }

// MoqValue_genType_SetString_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_SetString_paramsKey struct {
	Params struct{ X string }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_SetString_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_SetString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_SetString_paramsKey]*MoqValue_genType_SetString_results
}

// MoqValue_genType_SetString_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_SetString_doFn func(x string)

// MoqValue_genType_SetString_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_SetString_doReturnFn func(x string)

// MoqValue_genType_SetString_results holds the results of the Value_genType
// type
type MoqValue_genType_SetString_results struct {
	Params  MoqValue_genType_SetString_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetString_doFn
		DoReturnFn MoqValue_genType_SetString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_SetString_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_SetString_fnRecorder struct {
	Params    MoqValue_genType_SetString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_SetString_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_SetString_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_SetString_anyParams struct {
	Recorder *MoqValue_genType_SetString_fnRecorder
}

// MoqValue_genType_Slice_params holds the params of the Value_genType type
type MoqValue_genType_Slice_params struct{ Param1, J int }

// MoqValue_genType_Slice_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Slice_paramsKey struct {
	Params struct{ Param1, J int }
	Hashes struct{ Param1, J hash.Hash }
}

// MoqValue_genType_Slice_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Slice_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Slice_paramsKey]*MoqValue_genType_Slice_results
}

// MoqValue_genType_Slice_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Slice_doFn func(i, j int)

// MoqValue_genType_Slice_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Slice_doReturnFn func(i, j int) reflect.Value

// MoqValue_genType_Slice_results holds the results of the Value_genType type
type MoqValue_genType_Slice_results struct {
	Params  MoqValue_genType_Slice_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Slice_doFn
		DoReturnFn MoqValue_genType_Slice_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Slice_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Slice_fnRecorder struct {
	Params    MoqValue_genType_Slice_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Slice_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Slice_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Slice_anyParams struct {
	Recorder *MoqValue_genType_Slice_fnRecorder
}

// MoqValue_genType_Slice3_params holds the params of the Value_genType type
type MoqValue_genType_Slice3_params struct{ Param1, J, K int }

// MoqValue_genType_Slice3_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Slice3_paramsKey struct {
	Params struct{ Param1, J, K int }
	Hashes struct{ Param1, J, K hash.Hash }
}

// MoqValue_genType_Slice3_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Slice3_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Slice3_paramsKey]*MoqValue_genType_Slice3_results
}

// MoqValue_genType_Slice3_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_Slice3_doFn func(i, j, k int)

// MoqValue_genType_Slice3_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Slice3_doReturnFn func(i, j, k int) reflect.Value

// MoqValue_genType_Slice3_results holds the results of the Value_genType type
type MoqValue_genType_Slice3_results struct {
	Params  MoqValue_genType_Slice3_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Slice3_doFn
		DoReturnFn MoqValue_genType_Slice3_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Slice3_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Slice3_fnRecorder struct {
	Params    MoqValue_genType_Slice3_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Slice3_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Slice3_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Slice3_anyParams struct {
	Recorder *MoqValue_genType_Slice3_fnRecorder
}

// MoqValue_genType_String_params holds the params of the Value_genType type
type MoqValue_genType_String_params struct{}

// MoqValue_genType_String_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_String_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_String_paramsKey]*MoqValue_genType_String_results
}

// MoqValue_genType_String_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_String_doFn func()

// MoqValue_genType_String_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_String_doReturnFn func() string

// MoqValue_genType_String_results holds the results of the Value_genType type
type MoqValue_genType_String_results struct {
	Params  MoqValue_genType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqValue_genType_String_doFn
		DoReturnFn MoqValue_genType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_String_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_String_fnRecorder struct {
	Params    MoqValue_genType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_String_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_String_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_String_anyParams struct {
	Recorder *MoqValue_genType_String_fnRecorder
}

// MoqValue_genType_TryRecv_params holds the params of the Value_genType type
type MoqValue_genType_TryRecv_params struct{}

// MoqValue_genType_TryRecv_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_TryRecv_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_TryRecv_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_TryRecv_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_TryRecv_paramsKey]*MoqValue_genType_TryRecv_results
}

// MoqValue_genType_TryRecv_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_TryRecv_doFn func()

// MoqValue_genType_TryRecv_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_TryRecv_doReturnFn func() (x reflect.Value, ok bool)

// MoqValue_genType_TryRecv_results holds the results of the Value_genType type
type MoqValue_genType_TryRecv_results struct {
	Params  MoqValue_genType_TryRecv_params
	Results []struct {
		Values *struct {
			X  reflect.Value
			Ok bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_TryRecv_doFn
		DoReturnFn MoqValue_genType_TryRecv_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_TryRecv_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_TryRecv_fnRecorder struct {
	Params    MoqValue_genType_TryRecv_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_TryRecv_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_TryRecv_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_TryRecv_anyParams struct {
	Recorder *MoqValue_genType_TryRecv_fnRecorder
}

// MoqValue_genType_TrySend_params holds the params of the Value_genType type
type MoqValue_genType_TrySend_params struct{ X reflect.Value }

// MoqValue_genType_TrySend_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_TrySend_paramsKey struct {
	Params struct{ X reflect.Value }
	Hashes struct{ X hash.Hash }
}

// MoqValue_genType_TrySend_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_TrySend_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_TrySend_paramsKey]*MoqValue_genType_TrySend_results
}

// MoqValue_genType_TrySend_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_TrySend_doFn func(x reflect.Value)

// MoqValue_genType_TrySend_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_TrySend_doReturnFn func(x reflect.Value) bool

// MoqValue_genType_TrySend_results holds the results of the Value_genType type
type MoqValue_genType_TrySend_results struct {
	Params  MoqValue_genType_TrySend_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_TrySend_doFn
		DoReturnFn MoqValue_genType_TrySend_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_TrySend_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_TrySend_fnRecorder struct {
	Params    MoqValue_genType_TrySend_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_TrySend_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_TrySend_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_TrySend_anyParams struct {
	Recorder *MoqValue_genType_TrySend_fnRecorder
}

// MoqValue_genType_Type_params holds the params of the Value_genType type
type MoqValue_genType_Type_params struct{}

// MoqValue_genType_Type_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Type_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Type_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Type_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Type_paramsKey]*MoqValue_genType_Type_results
}

// MoqValue_genType_Type_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Type_doFn func()

// MoqValue_genType_Type_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Type_doReturnFn func() reflect.Type

// MoqValue_genType_Type_results holds the results of the Value_genType type
type MoqValue_genType_Type_results struct {
	Params  MoqValue_genType_Type_params
	Results []struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Type_doFn
		DoReturnFn MoqValue_genType_Type_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Type_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Type_fnRecorder struct {
	Params    MoqValue_genType_Type_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Type_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Type_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Type_anyParams struct {
	Recorder *MoqValue_genType_Type_fnRecorder
}

// MoqValue_genType_Uint_params holds the params of the Value_genType type
type MoqValue_genType_Uint_params struct{}

// MoqValue_genType_Uint_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Uint_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_Uint_resultsByParams contains the results for a given set
// of parameters for the Value_genType type
type MoqValue_genType_Uint_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Uint_paramsKey]*MoqValue_genType_Uint_results
}

// MoqValue_genType_Uint_doFn defines the type of function needed when calling
// AndDo for the Value_genType type
type MoqValue_genType_Uint_doFn func()

// MoqValue_genType_Uint_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Uint_doReturnFn func() uint64

// MoqValue_genType_Uint_results holds the results of the Value_genType type
type MoqValue_genType_Uint_results struct {
	Params  MoqValue_genType_Uint_params
	Results []struct {
		Values *struct {
			Result1 uint64
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Uint_doFn
		DoReturnFn MoqValue_genType_Uint_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Uint_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Uint_fnRecorder struct {
	Params    MoqValue_genType_Uint_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Uint_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Uint_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Uint_anyParams struct {
	Recorder *MoqValue_genType_Uint_fnRecorder
}

// MoqValue_genType_UnsafeAddr_params holds the params of the Value_genType
// type
type MoqValue_genType_UnsafeAddr_params struct{}

// MoqValue_genType_UnsafeAddr_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_UnsafeAddr_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqValue_genType_UnsafeAddr_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_UnsafeAddr_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_UnsafeAddr_paramsKey]*MoqValue_genType_UnsafeAddr_results
}

// MoqValue_genType_UnsafeAddr_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_UnsafeAddr_doFn func()

// MoqValue_genType_UnsafeAddr_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Value_genType type
type MoqValue_genType_UnsafeAddr_doReturnFn func() uintptr

// MoqValue_genType_UnsafeAddr_results holds the results of the Value_genType
// type
type MoqValue_genType_UnsafeAddr_results struct {
	Params  MoqValue_genType_UnsafeAddr_params
	Results []struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqValue_genType_UnsafeAddr_doFn
		DoReturnFn MoqValue_genType_UnsafeAddr_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_UnsafeAddr_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_UnsafeAddr_fnRecorder struct {
	Params    MoqValue_genType_UnsafeAddr_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_UnsafeAddr_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_UnsafeAddr_anyParams isolates the any params functions of
// the Value_genType type
type MoqValue_genType_UnsafeAddr_anyParams struct {
	Recorder *MoqValue_genType_UnsafeAddr_fnRecorder
}

// MoqValue_genType_Convert_params holds the params of the Value_genType type
type MoqValue_genType_Convert_params struct{ T reflect.Type }

// MoqValue_genType_Convert_paramsKey holds the map key params of the
// Value_genType type
type MoqValue_genType_Convert_paramsKey struct {
	Params struct{ T reflect.Type }
	Hashes struct{ T hash.Hash }
}

// MoqValue_genType_Convert_resultsByParams contains the results for a given
// set of parameters for the Value_genType type
type MoqValue_genType_Convert_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqValue_genType_Convert_paramsKey]*MoqValue_genType_Convert_results
}

// MoqValue_genType_Convert_doFn defines the type of function needed when
// calling AndDo for the Value_genType type
type MoqValue_genType_Convert_doFn func(t reflect.Type)

// MoqValue_genType_Convert_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Value_genType type
type MoqValue_genType_Convert_doReturnFn func(t reflect.Type) reflect.Value

// MoqValue_genType_Convert_results holds the results of the Value_genType type
type MoqValue_genType_Convert_results struct {
	Params  MoqValue_genType_Convert_params
	Results []struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Convert_doFn
		DoReturnFn MoqValue_genType_Convert_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqValue_genType_Convert_fnRecorder routes recorded function calls to the
// MoqValue_genType moq
type MoqValue_genType_Convert_fnRecorder struct {
	Params    MoqValue_genType_Convert_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqValue_genType_Convert_results
	Moq       *MoqValue_genType
}

// MoqValue_genType_Convert_anyParams isolates the any params functions of the
// Value_genType type
type MoqValue_genType_Convert_anyParams struct {
	Recorder *MoqValue_genType_Convert_fnRecorder
}

// NewMoqValue_genType creates a new moq of the Value_genType type
func NewMoqValue_genType(scene *moq.Scene, config *moq.Config) *MoqValue_genType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqValue_genType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqValue_genType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Addr    struct{}
				Bool    struct{}
				Bytes   struct{}
				CanAddr struct{}
				CanSet  struct{}
				Call    struct {
					In moq.ParamIndexing
				}
				CallSlice struct {
					In moq.ParamIndexing
				}
				Cap     struct{}
				Close   struct{}
				Complex struct{}
				Elem    struct{}
				Field   struct {
					Param1 moq.ParamIndexing
				}
				FieldByIndex struct {
					Index moq.ParamIndexing
				}
				FieldByName struct {
					Name moq.ParamIndexing
				}
				FieldByNameFunc struct {
					Match moq.ParamIndexing
				}
				Float struct{}
				Index struct {
					Param1 moq.ParamIndexing
				}
				Int           struct{}
				CanInterface  struct{}
				Interface     struct{}
				InterfaceData struct{}
				IsNil         struct{}
				IsValid       struct{}
				IsZero        struct{}
				Kind          struct{}
				Len           struct{}
				MapIndex      struct {
					Key moq.ParamIndexing
				}
				MapKeys  struct{}
				MapRange struct{}
				Method   struct {
					Param1 moq.ParamIndexing
				}
				NumMethod    struct{}
				MethodByName struct {
					Name moq.ParamIndexing
				}
				NumField        struct{}
				OverflowComplex struct {
					X moq.ParamIndexing
				}
				OverflowFloat struct {
					X moq.ParamIndexing
				}
				OverflowInt struct {
					X moq.ParamIndexing
				}
				OverflowUint struct {
					X moq.ParamIndexing
				}
				Pointer struct{}
				Recv    struct{}
				Send    struct {
					X moq.ParamIndexing
				}
				Set struct {
					X moq.ParamIndexing
				}
				SetBool struct {
					X moq.ParamIndexing
				}
				SetBytes struct {
					X moq.ParamIndexing
				}
				SetComplex struct {
					X moq.ParamIndexing
				}
				SetFloat struct {
					X moq.ParamIndexing
				}
				SetInt struct {
					X moq.ParamIndexing
				}
				SetLen struct {
					N moq.ParamIndexing
				}
				SetCap struct {
					N moq.ParamIndexing
				}
				SetMapIndex struct {
					Key  moq.ParamIndexing
					Elem moq.ParamIndexing
				}
				SetUint struct {
					X moq.ParamIndexing
				}
				SetPointer struct {
					X moq.ParamIndexing
				}
				SetString struct {
					X moq.ParamIndexing
				}
				Slice struct {
					Param1 moq.ParamIndexing
					J      moq.ParamIndexing
				}
				Slice3 struct {
					Param1 moq.ParamIndexing
					J      moq.ParamIndexing
					K      moq.ParamIndexing
				}
				String  struct{}
				TryRecv struct{}
				TrySend struct {
					X moq.ParamIndexing
				}
				Type       struct{}
				Uint       struct{}
				UnsafeAddr struct{}
				Convert    struct {
					T moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			Addr    struct{}
			Bool    struct{}
			Bytes   struct{}
			CanAddr struct{}
			CanSet  struct{}
			Call    struct {
				In moq.ParamIndexing
			}
			CallSlice struct {
				In moq.ParamIndexing
			}
			Cap     struct{}
			Close   struct{}
			Complex struct{}
			Elem    struct{}
			Field   struct {
				Param1 moq.ParamIndexing
			}
			FieldByIndex struct {
				Index moq.ParamIndexing
			}
			FieldByName struct {
				Name moq.ParamIndexing
			}
			FieldByNameFunc struct {
				Match moq.ParamIndexing
			}
			Float struct{}
			Index struct {
				Param1 moq.ParamIndexing
			}
			Int           struct{}
			CanInterface  struct{}
			Interface     struct{}
			InterfaceData struct{}
			IsNil         struct{}
			IsValid       struct{}
			IsZero        struct{}
			Kind          struct{}
			Len           struct{}
			MapIndex      struct {
				Key moq.ParamIndexing
			}
			MapKeys  struct{}
			MapRange struct{}
			Method   struct {
				Param1 moq.ParamIndexing
			}
			NumMethod    struct{}
			MethodByName struct {
				Name moq.ParamIndexing
			}
			NumField        struct{}
			OverflowComplex struct {
				X moq.ParamIndexing
			}
			OverflowFloat struct {
				X moq.ParamIndexing
			}
			OverflowInt struct {
				X moq.ParamIndexing
			}
			OverflowUint struct {
				X moq.ParamIndexing
			}
			Pointer struct{}
			Recv    struct{}
			Send    struct {
				X moq.ParamIndexing
			}
			Set struct {
				X moq.ParamIndexing
			}
			SetBool struct {
				X moq.ParamIndexing
			}
			SetBytes struct {
				X moq.ParamIndexing
			}
			SetComplex struct {
				X moq.ParamIndexing
			}
			SetFloat struct {
				X moq.ParamIndexing
			}
			SetInt struct {
				X moq.ParamIndexing
			}
			SetLen struct {
				N moq.ParamIndexing
			}
			SetCap struct {
				N moq.ParamIndexing
			}
			SetMapIndex struct {
				Key  moq.ParamIndexing
				Elem moq.ParamIndexing
			}
			SetUint struct {
				X moq.ParamIndexing
			}
			SetPointer struct {
				X moq.ParamIndexing
			}
			SetString struct {
				X moq.ParamIndexing
			}
			Slice struct {
				Param1 moq.ParamIndexing
				J      moq.ParamIndexing
			}
			Slice3 struct {
				Param1 moq.ParamIndexing
				J      moq.ParamIndexing
				K      moq.ParamIndexing
			}
			String  struct{}
			TryRecv struct{}
			TrySend struct {
				X moq.ParamIndexing
			}
			Type       struct{}
			Uint       struct{}
			UnsafeAddr struct{}
			Convert    struct {
				T moq.ParamIndexing
			}
		}{
			Addr:    struct{}{},
			Bool:    struct{}{},
			Bytes:   struct{}{},
			CanAddr: struct{}{},
			CanSet:  struct{}{},
			Call: struct {
				In moq.ParamIndexing
			}{
				In: moq.ParamIndexByHash,
			},
			CallSlice: struct {
				In moq.ParamIndexing
			}{
				In: moq.ParamIndexByHash,
			},
			Cap:     struct{}{},
			Close:   struct{}{},
			Complex: struct{}{},
			Elem:    struct{}{},
			Field: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			FieldByIndex: struct {
				Index moq.ParamIndexing
			}{
				Index: moq.ParamIndexByHash,
			},
			FieldByName: struct {
				Name moq.ParamIndexing
			}{
				Name: moq.ParamIndexByValue,
			},
			FieldByNameFunc: struct {
				Match moq.ParamIndexing
			}{
				Match: moq.ParamIndexByHash,
			},
			Float: struct{}{},
			Index: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			Int:           struct{}{},
			CanInterface:  struct{}{},
			Interface:     struct{}{},
			InterfaceData: struct{}{},
			IsNil:         struct{}{},
			IsValid:       struct{}{},
			IsZero:        struct{}{},
			Kind:          struct{}{},
			Len:           struct{}{},
			MapIndex: struct {
				Key moq.ParamIndexing
			}{
				Key: moq.ParamIndexByHash,
			},
			MapKeys:  struct{}{},
			MapRange: struct{}{},
			Method: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			NumMethod: struct{}{},
			MethodByName: struct {
				Name moq.ParamIndexing
			}{
				Name: moq.ParamIndexByValue,
			},
			NumField: struct{}{},
			OverflowComplex: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			OverflowFloat: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			OverflowInt: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			OverflowUint: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			Pointer: struct{}{},
			Recv:    struct{}{},
			Send: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Set: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			SetBool: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			SetBytes: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			SetComplex: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			SetFloat: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			SetInt: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			SetLen: struct {
				N moq.ParamIndexing
			}{
				N: moq.ParamIndexByValue,
			},
			SetCap: struct {
				N moq.ParamIndexing
			}{
				N: moq.ParamIndexByValue,
			},
			SetMapIndex: struct {
				Key  moq.ParamIndexing
				Elem moq.ParamIndexing
			}{
				Key:  moq.ParamIndexByHash,
				Elem: moq.ParamIndexByHash,
			},
			SetUint: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			SetPointer: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			SetString: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByValue,
			},
			Slice: struct {
				Param1 moq.ParamIndexing
				J      moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
				J:      moq.ParamIndexByValue,
			},
			Slice3: struct {
				Param1 moq.ParamIndexing
				J      moq.ParamIndexing
				K      moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
				J:      moq.ParamIndexByValue,
				K:      moq.ParamIndexByValue,
			},
			String:  struct{}{},
			TryRecv: struct{}{},
			TrySend: struct {
				X moq.ParamIndexing
			}{
				X: moq.ParamIndexByHash,
			},
			Type:       struct{}{},
			Uint:       struct{}{},
			UnsafeAddr: struct{}{},
			Convert: struct {
				T moq.ParamIndexing
			}{
				T: moq.ParamIndexByHash,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Value_genType type
func (m *MoqValue_genType) Mock() *MoqValue_genType_mock { return m.Moq }

func (m *MoqValue_genType_mock) Addr() (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Addr_params{}
	var results *MoqValue_genType_Addr_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Addr {
		paramsKey := m.Moq.ParamsKey_Addr(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Addr(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Addr(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Addr(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Bool() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Bool_params{}
	var results *MoqValue_genType_Bool_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Bool {
		paramsKey := m.Moq.ParamsKey_Bool(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Bool(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Bool(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Bool(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Bytes() (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Bytes_params{}
	var results *MoqValue_genType_Bytes_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Bytes {
		paramsKey := m.Moq.ParamsKey_Bytes(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Bytes(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Bytes(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Bytes(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) CanAddr() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_CanAddr_params{}
	var results *MoqValue_genType_CanAddr_results
	for _, resultsByParams := range m.Moq.ResultsByParams_CanAddr {
		paramsKey := m.Moq.ParamsKey_CanAddr(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_CanAddr(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_CanAddr(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_CanAddr(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) CanSet() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_CanSet_params{}
	var results *MoqValue_genType_CanSet_results
	for _, resultsByParams := range m.Moq.ResultsByParams_CanSet {
		paramsKey := m.Moq.ParamsKey_CanSet(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_CanSet(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_CanSet(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_CanSet(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Call(in []reflect.Value) (result1 []reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Call_params{
		In: in,
	}
	var results *MoqValue_genType_Call_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Call {
		paramsKey := m.Moq.ParamsKey_Call(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Call(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Call(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Call(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(in)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(in)
	}
	return
}

func (m *MoqValue_genType_mock) CallSlice(in []reflect.Value) (result1 []reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_CallSlice_params{
		In: in,
	}
	var results *MoqValue_genType_CallSlice_results
	for _, resultsByParams := range m.Moq.ResultsByParams_CallSlice {
		paramsKey := m.Moq.ParamsKey_CallSlice(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_CallSlice(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_CallSlice(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_CallSlice(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(in)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(in)
	}
	return
}

func (m *MoqValue_genType_mock) Cap() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Cap_params{}
	var results *MoqValue_genType_Cap_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Cap {
		paramsKey := m.Moq.ParamsKey_Cap(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Cap(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Cap(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Cap(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Close() {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Close_params{}
	var results *MoqValue_genType_Close_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Close {
		paramsKey := m.Moq.ParamsKey_Close(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Close(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Close(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Close(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Complex() (result1 complex128) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Complex_params{}
	var results *MoqValue_genType_Complex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Complex {
		paramsKey := m.Moq.ParamsKey_Complex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Complex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Complex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Complex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Elem() (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Elem_params{}
	var results *MoqValue_genType_Elem_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Elem {
		paramsKey := m.Moq.ParamsKey_Elem(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Elem(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Elem(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Elem(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Field(param1 int) (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Field_params{
		Param1: param1,
	}
	var results *MoqValue_genType_Field_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Field {
		paramsKey := m.Moq.ParamsKey_Field(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Field(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Field(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Field(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqValue_genType_mock) FieldByIndex(index []int) (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_FieldByIndex_params{
		Index: index,
	}
	var results *MoqValue_genType_FieldByIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FieldByIndex {
		paramsKey := m.Moq.ParamsKey_FieldByIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FieldByIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FieldByIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FieldByIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(index)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(index)
	}
	return
}

func (m *MoqValue_genType_mock) FieldByName(name string) (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_FieldByName_params{
		Name: name,
	}
	var results *MoqValue_genType_FieldByName_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FieldByName {
		paramsKey := m.Moq.ParamsKey_FieldByName(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FieldByName(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FieldByName(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FieldByName(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(name)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(name)
	}
	return
}

func (m *MoqValue_genType_mock) FieldByNameFunc(match func(string) bool) (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_FieldByNameFunc_params{
		Match: match,
	}
	var results *MoqValue_genType_FieldByNameFunc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FieldByNameFunc {
		paramsKey := m.Moq.ParamsKey_FieldByNameFunc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FieldByNameFunc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FieldByNameFunc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FieldByNameFunc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(match)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(match)
	}
	return
}

func (m *MoqValue_genType_mock) Float() (result1 float64) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Float_params{}
	var results *MoqValue_genType_Float_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Float {
		paramsKey := m.Moq.ParamsKey_Float(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Float(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Float(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Float(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Index(param1 int) (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Index_params{
		Param1: param1,
	}
	var results *MoqValue_genType_Index_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Index {
		paramsKey := m.Moq.ParamsKey_Index(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Index(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Index(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Index(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqValue_genType_mock) Int() (result1 int64) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Int_params{}
	var results *MoqValue_genType_Int_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Int {
		paramsKey := m.Moq.ParamsKey_Int(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Int(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Int(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Int(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) CanInterface() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_CanInterface_params{}
	var results *MoqValue_genType_CanInterface_results
	for _, resultsByParams := range m.Moq.ResultsByParams_CanInterface {
		paramsKey := m.Moq.ParamsKey_CanInterface(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_CanInterface(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_CanInterface(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_CanInterface(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Interface() (result1 interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Interface_params{}
	var results *MoqValue_genType_Interface_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Interface {
		paramsKey := m.Moq.ParamsKey_Interface(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Interface(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Interface(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Interface(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) InterfaceData() (result1 [2]uintptr) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_InterfaceData_params{}
	var results *MoqValue_genType_InterfaceData_results
	for _, resultsByParams := range m.Moq.ResultsByParams_InterfaceData {
		paramsKey := m.Moq.ParamsKey_InterfaceData(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_InterfaceData(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_InterfaceData(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_InterfaceData(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) IsNil() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_IsNil_params{}
	var results *MoqValue_genType_IsNil_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsNil {
		paramsKey := m.Moq.ParamsKey_IsNil(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsNil(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsNil(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsNil(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) IsValid() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_IsValid_params{}
	var results *MoqValue_genType_IsValid_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsValid {
		paramsKey := m.Moq.ParamsKey_IsValid(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsValid(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsValid(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsValid(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) IsZero() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_IsZero_params{}
	var results *MoqValue_genType_IsZero_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsZero {
		paramsKey := m.Moq.ParamsKey_IsZero(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsZero(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsZero(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsZero(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Kind() (result1 reflect.Kind) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Kind_params{}
	var results *MoqValue_genType_Kind_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Kind {
		paramsKey := m.Moq.ParamsKey_Kind(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Kind(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Kind(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Kind(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Len() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Len_params{}
	var results *MoqValue_genType_Len_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Len {
		paramsKey := m.Moq.ParamsKey_Len(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Len(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Len(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Len(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) MapIndex(key reflect.Value) (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_MapIndex_params{
		Key: key,
	}
	var results *MoqValue_genType_MapIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MapIndex {
		paramsKey := m.Moq.ParamsKey_MapIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MapIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MapIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MapIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(key)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(key)
	}
	return
}

func (m *MoqValue_genType_mock) MapKeys() (result1 []reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_MapKeys_params{}
	var results *MoqValue_genType_MapKeys_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MapKeys {
		paramsKey := m.Moq.ParamsKey_MapKeys(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MapKeys(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MapKeys(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MapKeys(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) MapRange() (result1 *reflect.MapIter) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_MapRange_params{}
	var results *MoqValue_genType_MapRange_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MapRange {
		paramsKey := m.Moq.ParamsKey_MapRange(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MapRange(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MapRange(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MapRange(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Method(param1 int) (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Method_params{
		Param1: param1,
	}
	var results *MoqValue_genType_Method_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Method {
		paramsKey := m.Moq.ParamsKey_Method(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Method(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Method(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Method(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqValue_genType_mock) NumMethod() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_NumMethod_params{}
	var results *MoqValue_genType_NumMethod_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumMethod {
		paramsKey := m.Moq.ParamsKey_NumMethod(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumMethod(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumMethod(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumMethod(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) MethodByName(name string) (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_MethodByName_params{
		Name: name,
	}
	var results *MoqValue_genType_MethodByName_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MethodByName {
		paramsKey := m.Moq.ParamsKey_MethodByName(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MethodByName(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MethodByName(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MethodByName(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(name)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(name)
	}
	return
}

func (m *MoqValue_genType_mock) NumField() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_NumField_params{}
	var results *MoqValue_genType_NumField_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumField {
		paramsKey := m.Moq.ParamsKey_NumField(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumField(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumField(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumField(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) OverflowComplex(x complex128) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_OverflowComplex_params{
		X: x,
	}
	var results *MoqValue_genType_OverflowComplex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_OverflowComplex {
		paramsKey := m.Moq.ParamsKey_OverflowComplex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_OverflowComplex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_OverflowComplex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_OverflowComplex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) OverflowFloat(x float64) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_OverflowFloat_params{
		X: x,
	}
	var results *MoqValue_genType_OverflowFloat_results
	for _, resultsByParams := range m.Moq.ResultsByParams_OverflowFloat {
		paramsKey := m.Moq.ParamsKey_OverflowFloat(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_OverflowFloat(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_OverflowFloat(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_OverflowFloat(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) OverflowInt(x int64) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_OverflowInt_params{
		X: x,
	}
	var results *MoqValue_genType_OverflowInt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_OverflowInt {
		paramsKey := m.Moq.ParamsKey_OverflowInt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_OverflowInt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_OverflowInt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_OverflowInt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) OverflowUint(x uint64) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_OverflowUint_params{
		X: x,
	}
	var results *MoqValue_genType_OverflowUint_results
	for _, resultsByParams := range m.Moq.ResultsByParams_OverflowUint {
		paramsKey := m.Moq.ParamsKey_OverflowUint(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_OverflowUint(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_OverflowUint(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_OverflowUint(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) Pointer() (result1 uintptr) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Pointer_params{}
	var results *MoqValue_genType_Pointer_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Pointer {
		paramsKey := m.Moq.ParamsKey_Pointer(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Pointer(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Pointer(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Pointer(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Recv() (x reflect.Value, ok bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Recv_params{}
	var results *MoqValue_genType_Recv_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Recv {
		paramsKey := m.Moq.ParamsKey_Recv(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Recv(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Recv(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Recv(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		x = result.Values.X
		ok = result.Values.Ok
	}
	if result.DoReturnFn != nil {
		x, ok = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Send(x reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Send_params{
		X: x,
	}
	var results *MoqValue_genType_Send_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Send {
		paramsKey := m.Moq.ParamsKey_Send(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Send(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Send(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Send(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) Set(x reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Set_params{
		X: x,
	}
	var results *MoqValue_genType_Set_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Set {
		paramsKey := m.Moq.ParamsKey_Set(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Set(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Set(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Set(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) SetBool(x bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_SetBool_params{
		X: x,
	}
	var results *MoqValue_genType_SetBool_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetBool {
		paramsKey := m.Moq.ParamsKey_SetBool(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetBool(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetBool(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetBool(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) SetBytes(x []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_SetBytes_params{
		X: x,
	}
	var results *MoqValue_genType_SetBytes_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetBytes {
		paramsKey := m.Moq.ParamsKey_SetBytes(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetBytes(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetBytes(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetBytes(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) SetComplex(x complex128) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_SetComplex_params{
		X: x,
	}
	var results *MoqValue_genType_SetComplex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetComplex {
		paramsKey := m.Moq.ParamsKey_SetComplex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetComplex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetComplex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetComplex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) SetFloat(x float64) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_SetFloat_params{
		X: x,
	}
	var results *MoqValue_genType_SetFloat_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetFloat {
		paramsKey := m.Moq.ParamsKey_SetFloat(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetFloat(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetFloat(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetFloat(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) SetInt(x int64) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_SetInt_params{
		X: x,
	}
	var results *MoqValue_genType_SetInt_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetInt {
		paramsKey := m.Moq.ParamsKey_SetInt(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetInt(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetInt(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetInt(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) SetLen(n int) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_SetLen_params{
		N: n,
	}
	var results *MoqValue_genType_SetLen_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetLen {
		paramsKey := m.Moq.ParamsKey_SetLen(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetLen(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetLen(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetLen(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(n)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(n)
	}
	return
}

func (m *MoqValue_genType_mock) SetCap(n int) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_SetCap_params{
		N: n,
	}
	var results *MoqValue_genType_SetCap_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetCap {
		paramsKey := m.Moq.ParamsKey_SetCap(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetCap(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetCap(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetCap(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(n)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(n)
	}
	return
}

func (m *MoqValue_genType_mock) SetMapIndex(key, elem reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_SetMapIndex_params{
		Key:  key,
		Elem: elem,
	}
	var results *MoqValue_genType_SetMapIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetMapIndex {
		paramsKey := m.Moq.ParamsKey_SetMapIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetMapIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetMapIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetMapIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(key, elem)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(key, elem)
	}
	return
}

func (m *MoqValue_genType_mock) SetUint(x uint64) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_SetUint_params{
		X: x,
	}
	var results *MoqValue_genType_SetUint_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetUint {
		paramsKey := m.Moq.ParamsKey_SetUint(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetUint(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetUint(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetUint(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) SetPointer(x unsafe.Pointer) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_SetPointer_params{
		X: x,
	}
	var results *MoqValue_genType_SetPointer_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetPointer {
		paramsKey := m.Moq.ParamsKey_SetPointer(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetPointer(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetPointer(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetPointer(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) SetString(x string) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_SetString_params{
		X: x,
	}
	var results *MoqValue_genType_SetString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SetString {
		paramsKey := m.Moq.ParamsKey_SetString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SetString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SetString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SetString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) Slice(param1, j int) (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Slice_params{
		Param1: param1,
		J:      j,
	}
	var results *MoqValue_genType_Slice_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Slice {
		paramsKey := m.Moq.ParamsKey_Slice(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Slice(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Slice(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Slice(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1, j)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1, j)
	}
	return
}

func (m *MoqValue_genType_mock) Slice3(param1, j, k int) (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Slice3_params{
		Param1: param1,
		J:      j,
		K:      k,
	}
	var results *MoqValue_genType_Slice3_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Slice3 {
		paramsKey := m.Moq.ParamsKey_Slice3(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Slice3(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Slice3(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Slice3(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1, j, k)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1, j, k)
	}
	return
}

func (m *MoqValue_genType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_String_params{}
	var results *MoqValue_genType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) TryRecv() (x reflect.Value, ok bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_TryRecv_params{}
	var results *MoqValue_genType_TryRecv_results
	for _, resultsByParams := range m.Moq.ResultsByParams_TryRecv {
		paramsKey := m.Moq.ParamsKey_TryRecv(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_TryRecv(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_TryRecv(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_TryRecv(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		x = result.Values.X
		ok = result.Values.Ok
	}
	if result.DoReturnFn != nil {
		x, ok = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) TrySend(x reflect.Value) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_TrySend_params{
		X: x,
	}
	var results *MoqValue_genType_TrySend_results
	for _, resultsByParams := range m.Moq.ResultsByParams_TrySend {
		paramsKey := m.Moq.ParamsKey_TrySend(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_TrySend(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_TrySend(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_TrySend(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(x)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(x)
	}
	return
}

func (m *MoqValue_genType_mock) Type() (result1 reflect.Type) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Type_params{}
	var results *MoqValue_genType_Type_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Type {
		paramsKey := m.Moq.ParamsKey_Type(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Type(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Type(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Type(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Uint() (result1 uint64) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Uint_params{}
	var results *MoqValue_genType_Uint_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Uint {
		paramsKey := m.Moq.ParamsKey_Uint(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Uint(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Uint(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Uint(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) UnsafeAddr() (result1 uintptr) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_UnsafeAddr_params{}
	var results *MoqValue_genType_UnsafeAddr_results
	for _, resultsByParams := range m.Moq.ResultsByParams_UnsafeAddr {
		paramsKey := m.Moq.ParamsKey_UnsafeAddr(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_UnsafeAddr(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_UnsafeAddr(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_UnsafeAddr(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqValue_genType_mock) Convert(t reflect.Type) (result1 reflect.Value) {
	m.Moq.Scene.T.Helper()
	params := MoqValue_genType_Convert_params{
		T: t,
	}
	var results *MoqValue_genType_Convert_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Convert {
		paramsKey := m.Moq.ParamsKey_Convert(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Convert(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Convert(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Convert(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(t)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(t)
	}
	return
}

// OnCall returns the recorder implementation of the Value_genType type
func (m *MoqValue_genType) OnCall() *MoqValue_genType_recorder {
	return &MoqValue_genType_recorder{
		Moq: m,
	}
}

func (m *MoqValue_genType_recorder) Addr() *MoqValue_genType_Addr_fnRecorder {
	return &MoqValue_genType_Addr_fnRecorder{
		Params:   MoqValue_genType_Addr_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Addr_fnRecorder) Any() *MoqValue_genType_Addr_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Addr(r.Params))
		return nil
	}
	return &MoqValue_genType_Addr_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Addr_fnRecorder) Seq() *MoqValue_genType_Addr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Addr(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Addr_fnRecorder) NoSeq() *MoqValue_genType_Addr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Addr(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Addr_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_Addr_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Addr_doFn
		DoReturnFn MoqValue_genType_Addr_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Addr_fnRecorder) AndDo(fn MoqValue_genType_Addr_doFn) *MoqValue_genType_Addr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Addr_fnRecorder) DoReturnResults(fn MoqValue_genType_Addr_doReturnFn) *MoqValue_genType_Addr_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Addr_doFn
		DoReturnFn MoqValue_genType_Addr_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Addr_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Addr_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Addr {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Addr_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Addr_paramsKey]*MoqValue_genType_Addr_results{},
		}
		r.Moq.ResultsByParams_Addr = append(r.Moq.ResultsByParams_Addr, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Addr) {
			copy(r.Moq.ResultsByParams_Addr[insertAt+1:], r.Moq.ResultsByParams_Addr[insertAt:0])
			r.Moq.ResultsByParams_Addr[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Addr(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Addr_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Addr_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Addr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Addr_doFn
				DoReturnFn MoqValue_genType_Addr_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Addr(params MoqValue_genType_Addr_params) string {
	return fmt.Sprintf("Addr()")
}

func (m *MoqValue_genType) ParamsKey_Addr(params MoqValue_genType_Addr_params, anyParams uint64) MoqValue_genType_Addr_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Addr_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Bool() *MoqValue_genType_Bool_fnRecorder {
	return &MoqValue_genType_Bool_fnRecorder{
		Params:   MoqValue_genType_Bool_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Bool_fnRecorder) Any() *MoqValue_genType_Bool_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bool(r.Params))
		return nil
	}
	return &MoqValue_genType_Bool_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Bool_fnRecorder) Seq() *MoqValue_genType_Bool_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bool(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Bool_fnRecorder) NoSeq() *MoqValue_genType_Bool_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bool(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Bool_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_Bool_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Bool_doFn
		DoReturnFn MoqValue_genType_Bool_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Bool_fnRecorder) AndDo(fn MoqValue_genType_Bool_doFn) *MoqValue_genType_Bool_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Bool_fnRecorder) DoReturnResults(fn MoqValue_genType_Bool_doReturnFn) *MoqValue_genType_Bool_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Bool_doFn
		DoReturnFn MoqValue_genType_Bool_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Bool_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Bool_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Bool {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Bool_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Bool_paramsKey]*MoqValue_genType_Bool_results{},
		}
		r.Moq.ResultsByParams_Bool = append(r.Moq.ResultsByParams_Bool, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Bool) {
			copy(r.Moq.ResultsByParams_Bool[insertAt+1:], r.Moq.ResultsByParams_Bool[insertAt:0])
			r.Moq.ResultsByParams_Bool[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Bool(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Bool_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Bool_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Bool_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Bool_doFn
				DoReturnFn MoqValue_genType_Bool_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Bool(params MoqValue_genType_Bool_params) string {
	return fmt.Sprintf("Bool()")
}

func (m *MoqValue_genType) ParamsKey_Bool(params MoqValue_genType_Bool_params, anyParams uint64) MoqValue_genType_Bool_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Bool_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Bytes() *MoqValue_genType_Bytes_fnRecorder {
	return &MoqValue_genType_Bytes_fnRecorder{
		Params:   MoqValue_genType_Bytes_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Bytes_fnRecorder) Any() *MoqValue_genType_Bytes_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bytes(r.Params))
		return nil
	}
	return &MoqValue_genType_Bytes_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Bytes_fnRecorder) Seq() *MoqValue_genType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bytes(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Bytes_fnRecorder) NoSeq() *MoqValue_genType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bytes(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Bytes_fnRecorder) ReturnResults(result1 []byte) *MoqValue_genType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Bytes_doFn
		DoReturnFn MoqValue_genType_Bytes_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Bytes_fnRecorder) AndDo(fn MoqValue_genType_Bytes_doFn) *MoqValue_genType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Bytes_fnRecorder) DoReturnResults(fn MoqValue_genType_Bytes_doReturnFn) *MoqValue_genType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Bytes_doFn
		DoReturnFn MoqValue_genType_Bytes_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Bytes_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Bytes_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Bytes {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Bytes_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Bytes_paramsKey]*MoqValue_genType_Bytes_results{},
		}
		r.Moq.ResultsByParams_Bytes = append(r.Moq.ResultsByParams_Bytes, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Bytes) {
			copy(r.Moq.ResultsByParams_Bytes[insertAt+1:], r.Moq.ResultsByParams_Bytes[insertAt:0])
			r.Moq.ResultsByParams_Bytes[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Bytes(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Bytes_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Bytes_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Bytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Bytes_doFn
				DoReturnFn MoqValue_genType_Bytes_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Bytes(params MoqValue_genType_Bytes_params) string {
	return fmt.Sprintf("Bytes()")
}

func (m *MoqValue_genType) ParamsKey_Bytes(params MoqValue_genType_Bytes_params, anyParams uint64) MoqValue_genType_Bytes_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Bytes_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) CanAddr() *MoqValue_genType_CanAddr_fnRecorder {
	return &MoqValue_genType_CanAddr_fnRecorder{
		Params:   MoqValue_genType_CanAddr_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_CanAddr_fnRecorder) Any() *MoqValue_genType_CanAddr_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CanAddr(r.Params))
		return nil
	}
	return &MoqValue_genType_CanAddr_anyParams{Recorder: r}
}

func (r *MoqValue_genType_CanAddr_fnRecorder) Seq() *MoqValue_genType_CanAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CanAddr(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_CanAddr_fnRecorder) NoSeq() *MoqValue_genType_CanAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CanAddr(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_CanAddr_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_CanAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CanAddr_doFn
		DoReturnFn MoqValue_genType_CanAddr_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_CanAddr_fnRecorder) AndDo(fn MoqValue_genType_CanAddr_doFn) *MoqValue_genType_CanAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_CanAddr_fnRecorder) DoReturnResults(fn MoqValue_genType_CanAddr_doReturnFn) *MoqValue_genType_CanAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CanAddr_doFn
		DoReturnFn MoqValue_genType_CanAddr_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_CanAddr_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_CanAddr_resultsByParams
	for n, res := range r.Moq.ResultsByParams_CanAddr {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_CanAddr_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_CanAddr_paramsKey]*MoqValue_genType_CanAddr_results{},
		}
		r.Moq.ResultsByParams_CanAddr = append(r.Moq.ResultsByParams_CanAddr, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_CanAddr) {
			copy(r.Moq.ResultsByParams_CanAddr[insertAt+1:], r.Moq.ResultsByParams_CanAddr[insertAt:0])
			r.Moq.ResultsByParams_CanAddr[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_CanAddr(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_CanAddr_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_CanAddr_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_CanAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_CanAddr_doFn
				DoReturnFn MoqValue_genType_CanAddr_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_CanAddr(params MoqValue_genType_CanAddr_params) string {
	return fmt.Sprintf("CanAddr()")
}

func (m *MoqValue_genType) ParamsKey_CanAddr(params MoqValue_genType_CanAddr_params, anyParams uint64) MoqValue_genType_CanAddr_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_CanAddr_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) CanSet() *MoqValue_genType_CanSet_fnRecorder {
	return &MoqValue_genType_CanSet_fnRecorder{
		Params:   MoqValue_genType_CanSet_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_CanSet_fnRecorder) Any() *MoqValue_genType_CanSet_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CanSet(r.Params))
		return nil
	}
	return &MoqValue_genType_CanSet_anyParams{Recorder: r}
}

func (r *MoqValue_genType_CanSet_fnRecorder) Seq() *MoqValue_genType_CanSet_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CanSet(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_CanSet_fnRecorder) NoSeq() *MoqValue_genType_CanSet_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CanSet(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_CanSet_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_CanSet_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CanSet_doFn
		DoReturnFn MoqValue_genType_CanSet_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_CanSet_fnRecorder) AndDo(fn MoqValue_genType_CanSet_doFn) *MoqValue_genType_CanSet_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_CanSet_fnRecorder) DoReturnResults(fn MoqValue_genType_CanSet_doReturnFn) *MoqValue_genType_CanSet_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CanSet_doFn
		DoReturnFn MoqValue_genType_CanSet_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_CanSet_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_CanSet_resultsByParams
	for n, res := range r.Moq.ResultsByParams_CanSet {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_CanSet_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_CanSet_paramsKey]*MoqValue_genType_CanSet_results{},
		}
		r.Moq.ResultsByParams_CanSet = append(r.Moq.ResultsByParams_CanSet, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_CanSet) {
			copy(r.Moq.ResultsByParams_CanSet[insertAt+1:], r.Moq.ResultsByParams_CanSet[insertAt:0])
			r.Moq.ResultsByParams_CanSet[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_CanSet(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_CanSet_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_CanSet_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_CanSet_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_CanSet_doFn
				DoReturnFn MoqValue_genType_CanSet_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_CanSet(params MoqValue_genType_CanSet_params) string {
	return fmt.Sprintf("CanSet()")
}

func (m *MoqValue_genType) ParamsKey_CanSet(params MoqValue_genType_CanSet_params, anyParams uint64) MoqValue_genType_CanSet_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_CanSet_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Call(in []reflect.Value) *MoqValue_genType_Call_fnRecorder {
	return &MoqValue_genType_Call_fnRecorder{
		Params: MoqValue_genType_Call_params{
			In: in,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Call_fnRecorder) Any() *MoqValue_genType_Call_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Call(r.Params))
		return nil
	}
	return &MoqValue_genType_Call_anyParams{Recorder: r}
}

func (a *MoqValue_genType_Call_anyParams) In() *MoqValue_genType_Call_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_Call_fnRecorder) Seq() *MoqValue_genType_Call_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Call(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Call_fnRecorder) NoSeq() *MoqValue_genType_Call_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Call(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Call_fnRecorder) ReturnResults(result1 []reflect.Value) *MoqValue_genType_Call_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Call_doFn
		DoReturnFn MoqValue_genType_Call_doReturnFn
	}{
		Values: &struct {
			Result1 []reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Call_fnRecorder) AndDo(fn MoqValue_genType_Call_doFn) *MoqValue_genType_Call_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Call_fnRecorder) DoReturnResults(fn MoqValue_genType_Call_doReturnFn) *MoqValue_genType_Call_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Call_doFn
		DoReturnFn MoqValue_genType_Call_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Call_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Call_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Call {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Call_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Call_paramsKey]*MoqValue_genType_Call_results{},
		}
		r.Moq.ResultsByParams_Call = append(r.Moq.ResultsByParams_Call, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Call) {
			copy(r.Moq.ResultsByParams_Call[insertAt+1:], r.Moq.ResultsByParams_Call[insertAt:0])
			r.Moq.ResultsByParams_Call[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Call(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Call_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Call_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Call_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Call_doFn
				DoReturnFn MoqValue_genType_Call_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Call(params MoqValue_genType_Call_params) string {
	return fmt.Sprintf("Call(%#v)", params.In)
}

func (m *MoqValue_genType) ParamsKey_Call(params MoqValue_genType_Call_params, anyParams uint64) MoqValue_genType_Call_paramsKey {
	m.Scene.T.Helper()
	var inUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Call.In == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The in parameter of the Call function can't be indexed by value")
		}
		inUsedHash = hash.DeepHash(params.In)
	}
	return MoqValue_genType_Call_paramsKey{
		Params: struct{}{},
		Hashes: struct{ In hash.Hash }{
			In: inUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) CallSlice(in []reflect.Value) *MoqValue_genType_CallSlice_fnRecorder {
	return &MoqValue_genType_CallSlice_fnRecorder{
		Params: MoqValue_genType_CallSlice_params{
			In: in,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_CallSlice_fnRecorder) Any() *MoqValue_genType_CallSlice_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CallSlice(r.Params))
		return nil
	}
	return &MoqValue_genType_CallSlice_anyParams{Recorder: r}
}

func (a *MoqValue_genType_CallSlice_anyParams) In() *MoqValue_genType_CallSlice_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_CallSlice_fnRecorder) Seq() *MoqValue_genType_CallSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CallSlice(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_CallSlice_fnRecorder) NoSeq() *MoqValue_genType_CallSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CallSlice(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_CallSlice_fnRecorder) ReturnResults(result1 []reflect.Value) *MoqValue_genType_CallSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CallSlice_doFn
		DoReturnFn MoqValue_genType_CallSlice_doReturnFn
	}{
		Values: &struct {
			Result1 []reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_CallSlice_fnRecorder) AndDo(fn MoqValue_genType_CallSlice_doFn) *MoqValue_genType_CallSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_CallSlice_fnRecorder) DoReturnResults(fn MoqValue_genType_CallSlice_doReturnFn) *MoqValue_genType_CallSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CallSlice_doFn
		DoReturnFn MoqValue_genType_CallSlice_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_CallSlice_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_CallSlice_resultsByParams
	for n, res := range r.Moq.ResultsByParams_CallSlice {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_CallSlice_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_CallSlice_paramsKey]*MoqValue_genType_CallSlice_results{},
		}
		r.Moq.ResultsByParams_CallSlice = append(r.Moq.ResultsByParams_CallSlice, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_CallSlice) {
			copy(r.Moq.ResultsByParams_CallSlice[insertAt+1:], r.Moq.ResultsByParams_CallSlice[insertAt:0])
			r.Moq.ResultsByParams_CallSlice[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_CallSlice(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_CallSlice_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_CallSlice_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_CallSlice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_CallSlice_doFn
				DoReturnFn MoqValue_genType_CallSlice_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_CallSlice(params MoqValue_genType_CallSlice_params) string {
	return fmt.Sprintf("CallSlice(%#v)", params.In)
}

func (m *MoqValue_genType) ParamsKey_CallSlice(params MoqValue_genType_CallSlice_params, anyParams uint64) MoqValue_genType_CallSlice_paramsKey {
	m.Scene.T.Helper()
	var inUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.CallSlice.In == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The in parameter of the CallSlice function can't be indexed by value")
		}
		inUsedHash = hash.DeepHash(params.In)
	}
	return MoqValue_genType_CallSlice_paramsKey{
		Params: struct{}{},
		Hashes: struct{ In hash.Hash }{
			In: inUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) Cap() *MoqValue_genType_Cap_fnRecorder {
	return &MoqValue_genType_Cap_fnRecorder{
		Params:   MoqValue_genType_Cap_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Cap_fnRecorder) Any() *MoqValue_genType_Cap_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cap(r.Params))
		return nil
	}
	return &MoqValue_genType_Cap_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Cap_fnRecorder) Seq() *MoqValue_genType_Cap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cap(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Cap_fnRecorder) NoSeq() *MoqValue_genType_Cap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Cap(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Cap_fnRecorder) ReturnResults(result1 int) *MoqValue_genType_Cap_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Cap_doFn
		DoReturnFn MoqValue_genType_Cap_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Cap_fnRecorder) AndDo(fn MoqValue_genType_Cap_doFn) *MoqValue_genType_Cap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Cap_fnRecorder) DoReturnResults(fn MoqValue_genType_Cap_doReturnFn) *MoqValue_genType_Cap_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Cap_doFn
		DoReturnFn MoqValue_genType_Cap_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Cap_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Cap_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Cap {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Cap_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Cap_paramsKey]*MoqValue_genType_Cap_results{},
		}
		r.Moq.ResultsByParams_Cap = append(r.Moq.ResultsByParams_Cap, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Cap) {
			copy(r.Moq.ResultsByParams_Cap[insertAt+1:], r.Moq.ResultsByParams_Cap[insertAt:0])
			r.Moq.ResultsByParams_Cap[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Cap(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Cap_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Cap_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Cap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Cap_doFn
				DoReturnFn MoqValue_genType_Cap_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Cap(params MoqValue_genType_Cap_params) string {
	return fmt.Sprintf("Cap()")
}

func (m *MoqValue_genType) ParamsKey_Cap(params MoqValue_genType_Cap_params, anyParams uint64) MoqValue_genType_Cap_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Cap_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Close() *MoqValue_genType_Close_fnRecorder {
	return &MoqValue_genType_Close_fnRecorder{
		Params:   MoqValue_genType_Close_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Close_fnRecorder) Any() *MoqValue_genType_Close_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Close(r.Params))
		return nil
	}
	return &MoqValue_genType_Close_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Close_fnRecorder) Seq() *MoqValue_genType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Close(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Close_fnRecorder) NoSeq() *MoqValue_genType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Close(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Close_fnRecorder) ReturnResults() *MoqValue_genType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_Close_doFn
		DoReturnFn MoqValue_genType_Close_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Close_fnRecorder) AndDo(fn MoqValue_genType_Close_doFn) *MoqValue_genType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Close_fnRecorder) DoReturnResults(fn MoqValue_genType_Close_doReturnFn) *MoqValue_genType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_Close_doFn
		DoReturnFn MoqValue_genType_Close_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Close_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Close_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Close {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Close_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Close_paramsKey]*MoqValue_genType_Close_results{},
		}
		r.Moq.ResultsByParams_Close = append(r.Moq.ResultsByParams_Close, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Close) {
			copy(r.Moq.ResultsByParams_Close[insertAt+1:], r.Moq.ResultsByParams_Close[insertAt:0])
			r.Moq.ResultsByParams_Close[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Close(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Close_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Close_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Close_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_Close_doFn
				DoReturnFn MoqValue_genType_Close_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Close(params MoqValue_genType_Close_params) string {
	return fmt.Sprintf("Close()")
}

func (m *MoqValue_genType) ParamsKey_Close(params MoqValue_genType_Close_params, anyParams uint64) MoqValue_genType_Close_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Close_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Complex() *MoqValue_genType_Complex_fnRecorder {
	return &MoqValue_genType_Complex_fnRecorder{
		Params:   MoqValue_genType_Complex_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Complex_fnRecorder) Any() *MoqValue_genType_Complex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Complex(r.Params))
		return nil
	}
	return &MoqValue_genType_Complex_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Complex_fnRecorder) Seq() *MoqValue_genType_Complex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Complex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Complex_fnRecorder) NoSeq() *MoqValue_genType_Complex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Complex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Complex_fnRecorder) ReturnResults(result1 complex128) *MoqValue_genType_Complex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 complex128
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Complex_doFn
		DoReturnFn MoqValue_genType_Complex_doReturnFn
	}{
		Values: &struct {
			Result1 complex128
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Complex_fnRecorder) AndDo(fn MoqValue_genType_Complex_doFn) *MoqValue_genType_Complex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Complex_fnRecorder) DoReturnResults(fn MoqValue_genType_Complex_doReturnFn) *MoqValue_genType_Complex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 complex128
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Complex_doFn
		DoReturnFn MoqValue_genType_Complex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Complex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Complex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Complex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Complex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Complex_paramsKey]*MoqValue_genType_Complex_results{},
		}
		r.Moq.ResultsByParams_Complex = append(r.Moq.ResultsByParams_Complex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Complex) {
			copy(r.Moq.ResultsByParams_Complex[insertAt+1:], r.Moq.ResultsByParams_Complex[insertAt:0])
			r.Moq.ResultsByParams_Complex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Complex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Complex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Complex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Complex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 complex128
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Complex_doFn
				DoReturnFn MoqValue_genType_Complex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Complex(params MoqValue_genType_Complex_params) string {
	return fmt.Sprintf("Complex()")
}

func (m *MoqValue_genType) ParamsKey_Complex(params MoqValue_genType_Complex_params, anyParams uint64) MoqValue_genType_Complex_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Complex_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Elem() *MoqValue_genType_Elem_fnRecorder {
	return &MoqValue_genType_Elem_fnRecorder{
		Params:   MoqValue_genType_Elem_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Elem_fnRecorder) Any() *MoqValue_genType_Elem_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Elem(r.Params))
		return nil
	}
	return &MoqValue_genType_Elem_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Elem_fnRecorder) Seq() *MoqValue_genType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Elem(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Elem_fnRecorder) NoSeq() *MoqValue_genType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Elem(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Elem_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Elem_doFn
		DoReturnFn MoqValue_genType_Elem_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Elem_fnRecorder) AndDo(fn MoqValue_genType_Elem_doFn) *MoqValue_genType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Elem_fnRecorder) DoReturnResults(fn MoqValue_genType_Elem_doReturnFn) *MoqValue_genType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Elem_doFn
		DoReturnFn MoqValue_genType_Elem_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Elem_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Elem_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Elem {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Elem_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Elem_paramsKey]*MoqValue_genType_Elem_results{},
		}
		r.Moq.ResultsByParams_Elem = append(r.Moq.ResultsByParams_Elem, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Elem) {
			copy(r.Moq.ResultsByParams_Elem[insertAt+1:], r.Moq.ResultsByParams_Elem[insertAt:0])
			r.Moq.ResultsByParams_Elem[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Elem(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Elem_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Elem_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Elem_doFn
				DoReturnFn MoqValue_genType_Elem_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Elem(params MoqValue_genType_Elem_params) string {
	return fmt.Sprintf("Elem()")
}

func (m *MoqValue_genType) ParamsKey_Elem(params MoqValue_genType_Elem_params, anyParams uint64) MoqValue_genType_Elem_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Elem_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Field(param1 int) *MoqValue_genType_Field_fnRecorder {
	return &MoqValue_genType_Field_fnRecorder{
		Params: MoqValue_genType_Field_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Field_fnRecorder) Any() *MoqValue_genType_Field_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Field(r.Params))
		return nil
	}
	return &MoqValue_genType_Field_anyParams{Recorder: r}
}

func (a *MoqValue_genType_Field_anyParams) Param1() *MoqValue_genType_Field_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_Field_fnRecorder) Seq() *MoqValue_genType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Field(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Field_fnRecorder) NoSeq() *MoqValue_genType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Field(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Field_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Field_doFn
		DoReturnFn MoqValue_genType_Field_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Field_fnRecorder) AndDo(fn MoqValue_genType_Field_doFn) *MoqValue_genType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Field_fnRecorder) DoReturnResults(fn MoqValue_genType_Field_doReturnFn) *MoqValue_genType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Field_doFn
		DoReturnFn MoqValue_genType_Field_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Field_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Field_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Field {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Field_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Field_paramsKey]*MoqValue_genType_Field_results{},
		}
		r.Moq.ResultsByParams_Field = append(r.Moq.ResultsByParams_Field, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Field) {
			copy(r.Moq.ResultsByParams_Field[insertAt+1:], r.Moq.ResultsByParams_Field[insertAt:0])
			r.Moq.ResultsByParams_Field[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Field(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Field_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Field_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Field_doFn
				DoReturnFn MoqValue_genType_Field_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Field(params MoqValue_genType_Field_params) string {
	return fmt.Sprintf("Field(%#v)", params.Param1)
}

func (m *MoqValue_genType) ParamsKey_Field(params MoqValue_genType_Field_params, anyParams uint64) MoqValue_genType_Field_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Field.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqValue_genType_Field_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) FieldByIndex(index []int) *MoqValue_genType_FieldByIndex_fnRecorder {
	return &MoqValue_genType_FieldByIndex_fnRecorder{
		Params: MoqValue_genType_FieldByIndex_params{
			Index: index,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_FieldByIndex_fnRecorder) Any() *MoqValue_genType_FieldByIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByIndex(r.Params))
		return nil
	}
	return &MoqValue_genType_FieldByIndex_anyParams{Recorder: r}
}

func (a *MoqValue_genType_FieldByIndex_anyParams) Index() *MoqValue_genType_FieldByIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_FieldByIndex_fnRecorder) Seq() *MoqValue_genType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_FieldByIndex_fnRecorder) NoSeq() *MoqValue_genType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_FieldByIndex_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_FieldByIndex_doFn
		DoReturnFn MoqValue_genType_FieldByIndex_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_FieldByIndex_fnRecorder) AndDo(fn MoqValue_genType_FieldByIndex_doFn) *MoqValue_genType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_FieldByIndex_fnRecorder) DoReturnResults(fn MoqValue_genType_FieldByIndex_doReturnFn) *MoqValue_genType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_FieldByIndex_doFn
		DoReturnFn MoqValue_genType_FieldByIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_FieldByIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_FieldByIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FieldByIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_FieldByIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_FieldByIndex_paramsKey]*MoqValue_genType_FieldByIndex_results{},
		}
		r.Moq.ResultsByParams_FieldByIndex = append(r.Moq.ResultsByParams_FieldByIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FieldByIndex) {
			copy(r.Moq.ResultsByParams_FieldByIndex[insertAt+1:], r.Moq.ResultsByParams_FieldByIndex[insertAt:0])
			r.Moq.ResultsByParams_FieldByIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FieldByIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_FieldByIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_FieldByIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_FieldByIndex_doFn
				DoReturnFn MoqValue_genType_FieldByIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_FieldByIndex(params MoqValue_genType_FieldByIndex_params) string {
	return fmt.Sprintf("FieldByIndex(%#v)", params.Index)
}

func (m *MoqValue_genType) ParamsKey_FieldByIndex(params MoqValue_genType_FieldByIndex_params, anyParams uint64) MoqValue_genType_FieldByIndex_paramsKey {
	m.Scene.T.Helper()
	var indexUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FieldByIndex.Index == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The index parameter of the FieldByIndex function can't be indexed by value")
		}
		indexUsedHash = hash.DeepHash(params.Index)
	}
	return MoqValue_genType_FieldByIndex_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Index hash.Hash }{
			Index: indexUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) FieldByName(name string) *MoqValue_genType_FieldByName_fnRecorder {
	return &MoqValue_genType_FieldByName_fnRecorder{
		Params: MoqValue_genType_FieldByName_params{
			Name: name,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_FieldByName_fnRecorder) Any() *MoqValue_genType_FieldByName_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByName(r.Params))
		return nil
	}
	return &MoqValue_genType_FieldByName_anyParams{Recorder: r}
}

func (a *MoqValue_genType_FieldByName_anyParams) Name() *MoqValue_genType_FieldByName_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_FieldByName_fnRecorder) Seq() *MoqValue_genType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByName(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_FieldByName_fnRecorder) NoSeq() *MoqValue_genType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByName(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_FieldByName_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_FieldByName_doFn
		DoReturnFn MoqValue_genType_FieldByName_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_FieldByName_fnRecorder) AndDo(fn MoqValue_genType_FieldByName_doFn) *MoqValue_genType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_FieldByName_fnRecorder) DoReturnResults(fn MoqValue_genType_FieldByName_doReturnFn) *MoqValue_genType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_FieldByName_doFn
		DoReturnFn MoqValue_genType_FieldByName_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_FieldByName_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_FieldByName_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FieldByName {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_FieldByName_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_FieldByName_paramsKey]*MoqValue_genType_FieldByName_results{},
		}
		r.Moq.ResultsByParams_FieldByName = append(r.Moq.ResultsByParams_FieldByName, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FieldByName) {
			copy(r.Moq.ResultsByParams_FieldByName[insertAt+1:], r.Moq.ResultsByParams_FieldByName[insertAt:0])
			r.Moq.ResultsByParams_FieldByName[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FieldByName(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_FieldByName_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_FieldByName_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_FieldByName_doFn
				DoReturnFn MoqValue_genType_FieldByName_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_FieldByName(params MoqValue_genType_FieldByName_params) string {
	return fmt.Sprintf("FieldByName(%#v)", params.Name)
}

func (m *MoqValue_genType) ParamsKey_FieldByName(params MoqValue_genType_FieldByName_params, anyParams uint64) MoqValue_genType_FieldByName_paramsKey {
	m.Scene.T.Helper()
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FieldByName.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	return MoqValue_genType_FieldByName_paramsKey{
		Params: struct{ Name string }{
			Name: nameUsed,
		},
		Hashes: struct{ Name hash.Hash }{
			Name: nameUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) FieldByNameFunc(match func(string) bool) *MoqValue_genType_FieldByNameFunc_fnRecorder {
	return &MoqValue_genType_FieldByNameFunc_fnRecorder{
		Params: MoqValue_genType_FieldByNameFunc_params{
			Match: match,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_FieldByNameFunc_fnRecorder) Any() *MoqValue_genType_FieldByNameFunc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByNameFunc(r.Params))
		return nil
	}
	return &MoqValue_genType_FieldByNameFunc_anyParams{Recorder: r}
}

func (a *MoqValue_genType_FieldByNameFunc_anyParams) Match() *MoqValue_genType_FieldByNameFunc_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_FieldByNameFunc_fnRecorder) Seq() *MoqValue_genType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByNameFunc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_FieldByNameFunc_fnRecorder) NoSeq() *MoqValue_genType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByNameFunc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_FieldByNameFunc_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_FieldByNameFunc_doFn
		DoReturnFn MoqValue_genType_FieldByNameFunc_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_FieldByNameFunc_fnRecorder) AndDo(fn MoqValue_genType_FieldByNameFunc_doFn) *MoqValue_genType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_FieldByNameFunc_fnRecorder) DoReturnResults(fn MoqValue_genType_FieldByNameFunc_doReturnFn) *MoqValue_genType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_FieldByNameFunc_doFn
		DoReturnFn MoqValue_genType_FieldByNameFunc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_FieldByNameFunc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_FieldByNameFunc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FieldByNameFunc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_FieldByNameFunc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_FieldByNameFunc_paramsKey]*MoqValue_genType_FieldByNameFunc_results{},
		}
		r.Moq.ResultsByParams_FieldByNameFunc = append(r.Moq.ResultsByParams_FieldByNameFunc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FieldByNameFunc) {
			copy(r.Moq.ResultsByParams_FieldByNameFunc[insertAt+1:], r.Moq.ResultsByParams_FieldByNameFunc[insertAt:0])
			r.Moq.ResultsByParams_FieldByNameFunc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FieldByNameFunc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_FieldByNameFunc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_FieldByNameFunc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_FieldByNameFunc_doFn
				DoReturnFn MoqValue_genType_FieldByNameFunc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_FieldByNameFunc(params MoqValue_genType_FieldByNameFunc_params) string {
	return fmt.Sprintf("FieldByNameFunc(%#v)", moq.FnString(params.Match))
}

func (m *MoqValue_genType) ParamsKey_FieldByNameFunc(params MoqValue_genType_FieldByNameFunc_params, anyParams uint64) MoqValue_genType_FieldByNameFunc_paramsKey {
	m.Scene.T.Helper()
	var matchUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FieldByNameFunc.Match == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The match parameter of the FieldByNameFunc function can't be indexed by value")
		}
		matchUsedHash = hash.DeepHash(params.Match)
	}
	return MoqValue_genType_FieldByNameFunc_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Match hash.Hash }{
			Match: matchUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) Float() *MoqValue_genType_Float_fnRecorder {
	return &MoqValue_genType_Float_fnRecorder{
		Params:   MoqValue_genType_Float_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Float_fnRecorder) Any() *MoqValue_genType_Float_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float(r.Params))
		return nil
	}
	return &MoqValue_genType_Float_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Float_fnRecorder) Seq() *MoqValue_genType_Float_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Float_fnRecorder) NoSeq() *MoqValue_genType_Float_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Float(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Float_fnRecorder) ReturnResults(result1 float64) *MoqValue_genType_Float_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 float64
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Float_doFn
		DoReturnFn MoqValue_genType_Float_doReturnFn
	}{
		Values: &struct {
			Result1 float64
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Float_fnRecorder) AndDo(fn MoqValue_genType_Float_doFn) *MoqValue_genType_Float_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Float_fnRecorder) DoReturnResults(fn MoqValue_genType_Float_doReturnFn) *MoqValue_genType_Float_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 float64
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Float_doFn
		DoReturnFn MoqValue_genType_Float_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Float_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Float_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Float {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Float_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Float_paramsKey]*MoqValue_genType_Float_results{},
		}
		r.Moq.ResultsByParams_Float = append(r.Moq.ResultsByParams_Float, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Float) {
			copy(r.Moq.ResultsByParams_Float[insertAt+1:], r.Moq.ResultsByParams_Float[insertAt:0])
			r.Moq.ResultsByParams_Float[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Float(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Float_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Float_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Float_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 float64
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Float_doFn
				DoReturnFn MoqValue_genType_Float_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Float(params MoqValue_genType_Float_params) string {
	return fmt.Sprintf("Float()")
}

func (m *MoqValue_genType) ParamsKey_Float(params MoqValue_genType_Float_params, anyParams uint64) MoqValue_genType_Float_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Float_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Index(param1 int) *MoqValue_genType_Index_fnRecorder {
	return &MoqValue_genType_Index_fnRecorder{
		Params: MoqValue_genType_Index_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Index_fnRecorder) Any() *MoqValue_genType_Index_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Index(r.Params))
		return nil
	}
	return &MoqValue_genType_Index_anyParams{Recorder: r}
}

func (a *MoqValue_genType_Index_anyParams) Param1() *MoqValue_genType_Index_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_Index_fnRecorder) Seq() *MoqValue_genType_Index_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Index(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Index_fnRecorder) NoSeq() *MoqValue_genType_Index_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Index(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Index_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_Index_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Index_doFn
		DoReturnFn MoqValue_genType_Index_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Index_fnRecorder) AndDo(fn MoqValue_genType_Index_doFn) *MoqValue_genType_Index_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Index_fnRecorder) DoReturnResults(fn MoqValue_genType_Index_doReturnFn) *MoqValue_genType_Index_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Index_doFn
		DoReturnFn MoqValue_genType_Index_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Index_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Index_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Index {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Index_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Index_paramsKey]*MoqValue_genType_Index_results{},
		}
		r.Moq.ResultsByParams_Index = append(r.Moq.ResultsByParams_Index, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Index) {
			copy(r.Moq.ResultsByParams_Index[insertAt+1:], r.Moq.ResultsByParams_Index[insertAt:0])
			r.Moq.ResultsByParams_Index[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Index(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Index_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Index_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Index_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Index_doFn
				DoReturnFn MoqValue_genType_Index_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Index(params MoqValue_genType_Index_params) string {
	return fmt.Sprintf("Index(%#v)", params.Param1)
}

func (m *MoqValue_genType) ParamsKey_Index(params MoqValue_genType_Index_params, anyParams uint64) MoqValue_genType_Index_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Index.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqValue_genType_Index_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) Int() *MoqValue_genType_Int_fnRecorder {
	return &MoqValue_genType_Int_fnRecorder{
		Params:   MoqValue_genType_Int_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Int_fnRecorder) Any() *MoqValue_genType_Int_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int(r.Params))
		return nil
	}
	return &MoqValue_genType_Int_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Int_fnRecorder) Seq() *MoqValue_genType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Int_fnRecorder) NoSeq() *MoqValue_genType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Int(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Int_fnRecorder) ReturnResults(result1 int64) *MoqValue_genType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Int_doFn
		DoReturnFn MoqValue_genType_Int_doReturnFn
	}{
		Values: &struct {
			Result1 int64
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Int_fnRecorder) AndDo(fn MoqValue_genType_Int_doFn) *MoqValue_genType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Int_fnRecorder) DoReturnResults(fn MoqValue_genType_Int_doReturnFn) *MoqValue_genType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Int_doFn
		DoReturnFn MoqValue_genType_Int_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Int_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Int_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Int {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Int_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Int_paramsKey]*MoqValue_genType_Int_results{},
		}
		r.Moq.ResultsByParams_Int = append(r.Moq.ResultsByParams_Int, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Int) {
			copy(r.Moq.ResultsByParams_Int[insertAt+1:], r.Moq.ResultsByParams_Int[insertAt:0])
			r.Moq.ResultsByParams_Int[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Int(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Int_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Int_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Int_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int64
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Int_doFn
				DoReturnFn MoqValue_genType_Int_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Int(params MoqValue_genType_Int_params) string {
	return fmt.Sprintf("Int()")
}

func (m *MoqValue_genType) ParamsKey_Int(params MoqValue_genType_Int_params, anyParams uint64) MoqValue_genType_Int_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Int_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) CanInterface() *MoqValue_genType_CanInterface_fnRecorder {
	return &MoqValue_genType_CanInterface_fnRecorder{
		Params:   MoqValue_genType_CanInterface_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_CanInterface_fnRecorder) Any() *MoqValue_genType_CanInterface_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CanInterface(r.Params))
		return nil
	}
	return &MoqValue_genType_CanInterface_anyParams{Recorder: r}
}

func (r *MoqValue_genType_CanInterface_fnRecorder) Seq() *MoqValue_genType_CanInterface_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CanInterface(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_CanInterface_fnRecorder) NoSeq() *MoqValue_genType_CanInterface_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_CanInterface(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_CanInterface_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_CanInterface_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CanInterface_doFn
		DoReturnFn MoqValue_genType_CanInterface_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_CanInterface_fnRecorder) AndDo(fn MoqValue_genType_CanInterface_doFn) *MoqValue_genType_CanInterface_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_CanInterface_fnRecorder) DoReturnResults(fn MoqValue_genType_CanInterface_doReturnFn) *MoqValue_genType_CanInterface_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_CanInterface_doFn
		DoReturnFn MoqValue_genType_CanInterface_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_CanInterface_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_CanInterface_resultsByParams
	for n, res := range r.Moq.ResultsByParams_CanInterface {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_CanInterface_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_CanInterface_paramsKey]*MoqValue_genType_CanInterface_results{},
		}
		r.Moq.ResultsByParams_CanInterface = append(r.Moq.ResultsByParams_CanInterface, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_CanInterface) {
			copy(r.Moq.ResultsByParams_CanInterface[insertAt+1:], r.Moq.ResultsByParams_CanInterface[insertAt:0])
			r.Moq.ResultsByParams_CanInterface[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_CanInterface(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_CanInterface_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_CanInterface_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_CanInterface_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_CanInterface_doFn
				DoReturnFn MoqValue_genType_CanInterface_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_CanInterface(params MoqValue_genType_CanInterface_params) string {
	return fmt.Sprintf("CanInterface()")
}

func (m *MoqValue_genType) ParamsKey_CanInterface(params MoqValue_genType_CanInterface_params, anyParams uint64) MoqValue_genType_CanInterface_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_CanInterface_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Interface() *MoqValue_genType_Interface_fnRecorder {
	return &MoqValue_genType_Interface_fnRecorder{
		Params:   MoqValue_genType_Interface_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Interface_fnRecorder) Any() *MoqValue_genType_Interface_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Interface(r.Params))
		return nil
	}
	return &MoqValue_genType_Interface_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Interface_fnRecorder) Seq() *MoqValue_genType_Interface_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Interface(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Interface_fnRecorder) NoSeq() *MoqValue_genType_Interface_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Interface(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Interface_fnRecorder) ReturnResults(result1 interface{}) *MoqValue_genType_Interface_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Result1 interface{} }
		Sequence   uint32
		DoFn       MoqValue_genType_Interface_doFn
		DoReturnFn MoqValue_genType_Interface_doReturnFn
	}{
		Values: &struct{ Result1 interface{} }{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Interface_fnRecorder) AndDo(fn MoqValue_genType_Interface_doFn) *MoqValue_genType_Interface_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Interface_fnRecorder) DoReturnResults(fn MoqValue_genType_Interface_doReturnFn) *MoqValue_genType_Interface_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Result1 interface{} }
		Sequence   uint32
		DoFn       MoqValue_genType_Interface_doFn
		DoReturnFn MoqValue_genType_Interface_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Interface_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Interface_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Interface {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Interface_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Interface_paramsKey]*MoqValue_genType_Interface_results{},
		}
		r.Moq.ResultsByParams_Interface = append(r.Moq.ResultsByParams_Interface, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Interface) {
			copy(r.Moq.ResultsByParams_Interface[insertAt+1:], r.Moq.ResultsByParams_Interface[insertAt:0])
			r.Moq.ResultsByParams_Interface[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Interface(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Interface_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Interface_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Interface_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Result1 interface{} }
				Sequence   uint32
				DoFn       MoqValue_genType_Interface_doFn
				DoReturnFn MoqValue_genType_Interface_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Interface(params MoqValue_genType_Interface_params) string {
	return fmt.Sprintf("Interface()")
}

func (m *MoqValue_genType) ParamsKey_Interface(params MoqValue_genType_Interface_params, anyParams uint64) MoqValue_genType_Interface_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Interface_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) InterfaceData() *MoqValue_genType_InterfaceData_fnRecorder {
	return &MoqValue_genType_InterfaceData_fnRecorder{
		Params:   MoqValue_genType_InterfaceData_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_InterfaceData_fnRecorder) Any() *MoqValue_genType_InterfaceData_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_InterfaceData(r.Params))
		return nil
	}
	return &MoqValue_genType_InterfaceData_anyParams{Recorder: r}
}

func (r *MoqValue_genType_InterfaceData_fnRecorder) Seq() *MoqValue_genType_InterfaceData_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_InterfaceData(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_InterfaceData_fnRecorder) NoSeq() *MoqValue_genType_InterfaceData_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_InterfaceData(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_InterfaceData_fnRecorder) ReturnResults(result1 [2]uintptr) *MoqValue_genType_InterfaceData_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [2]uintptr
		}
		Sequence   uint32
		DoFn       MoqValue_genType_InterfaceData_doFn
		DoReturnFn MoqValue_genType_InterfaceData_doReturnFn
	}{
		Values: &struct {
			Result1 [2]uintptr
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_InterfaceData_fnRecorder) AndDo(fn MoqValue_genType_InterfaceData_doFn) *MoqValue_genType_InterfaceData_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_InterfaceData_fnRecorder) DoReturnResults(fn MoqValue_genType_InterfaceData_doReturnFn) *MoqValue_genType_InterfaceData_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [2]uintptr
		}
		Sequence   uint32
		DoFn       MoqValue_genType_InterfaceData_doFn
		DoReturnFn MoqValue_genType_InterfaceData_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_InterfaceData_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_InterfaceData_resultsByParams
	for n, res := range r.Moq.ResultsByParams_InterfaceData {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_InterfaceData_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_InterfaceData_paramsKey]*MoqValue_genType_InterfaceData_results{},
		}
		r.Moq.ResultsByParams_InterfaceData = append(r.Moq.ResultsByParams_InterfaceData, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_InterfaceData) {
			copy(r.Moq.ResultsByParams_InterfaceData[insertAt+1:], r.Moq.ResultsByParams_InterfaceData[insertAt:0])
			r.Moq.ResultsByParams_InterfaceData[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_InterfaceData(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_InterfaceData_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_InterfaceData_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_InterfaceData_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 [2]uintptr
				}
				Sequence   uint32
				DoFn       MoqValue_genType_InterfaceData_doFn
				DoReturnFn MoqValue_genType_InterfaceData_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_InterfaceData(params MoqValue_genType_InterfaceData_params) string {
	return fmt.Sprintf("InterfaceData()")
}

func (m *MoqValue_genType) ParamsKey_InterfaceData(params MoqValue_genType_InterfaceData_params, anyParams uint64) MoqValue_genType_InterfaceData_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_InterfaceData_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) IsNil() *MoqValue_genType_IsNil_fnRecorder {
	return &MoqValue_genType_IsNil_fnRecorder{
		Params:   MoqValue_genType_IsNil_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_IsNil_fnRecorder) Any() *MoqValue_genType_IsNil_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsNil(r.Params))
		return nil
	}
	return &MoqValue_genType_IsNil_anyParams{Recorder: r}
}

func (r *MoqValue_genType_IsNil_fnRecorder) Seq() *MoqValue_genType_IsNil_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsNil(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_IsNil_fnRecorder) NoSeq() *MoqValue_genType_IsNil_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsNil(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_IsNil_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_IsNil_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_IsNil_doFn
		DoReturnFn MoqValue_genType_IsNil_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_IsNil_fnRecorder) AndDo(fn MoqValue_genType_IsNil_doFn) *MoqValue_genType_IsNil_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_IsNil_fnRecorder) DoReturnResults(fn MoqValue_genType_IsNil_doReturnFn) *MoqValue_genType_IsNil_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_IsNil_doFn
		DoReturnFn MoqValue_genType_IsNil_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_IsNil_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_IsNil_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsNil {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_IsNil_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_IsNil_paramsKey]*MoqValue_genType_IsNil_results{},
		}
		r.Moq.ResultsByParams_IsNil = append(r.Moq.ResultsByParams_IsNil, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsNil) {
			copy(r.Moq.ResultsByParams_IsNil[insertAt+1:], r.Moq.ResultsByParams_IsNil[insertAt:0])
			r.Moq.ResultsByParams_IsNil[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsNil(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_IsNil_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_IsNil_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_IsNil_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_IsNil_doFn
				DoReturnFn MoqValue_genType_IsNil_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_IsNil(params MoqValue_genType_IsNil_params) string {
	return fmt.Sprintf("IsNil()")
}

func (m *MoqValue_genType) ParamsKey_IsNil(params MoqValue_genType_IsNil_params, anyParams uint64) MoqValue_genType_IsNil_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_IsNil_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) IsValid() *MoqValue_genType_IsValid_fnRecorder {
	return &MoqValue_genType_IsValid_fnRecorder{
		Params:   MoqValue_genType_IsValid_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_IsValid_fnRecorder) Any() *MoqValue_genType_IsValid_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsValid(r.Params))
		return nil
	}
	return &MoqValue_genType_IsValid_anyParams{Recorder: r}
}

func (r *MoqValue_genType_IsValid_fnRecorder) Seq() *MoqValue_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsValid(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_IsValid_fnRecorder) NoSeq() *MoqValue_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsValid(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_IsValid_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_IsValid_doFn
		DoReturnFn MoqValue_genType_IsValid_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_IsValid_fnRecorder) AndDo(fn MoqValue_genType_IsValid_doFn) *MoqValue_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_IsValid_fnRecorder) DoReturnResults(fn MoqValue_genType_IsValid_doReturnFn) *MoqValue_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_IsValid_doFn
		DoReturnFn MoqValue_genType_IsValid_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_IsValid_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_IsValid_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsValid {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_IsValid_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_IsValid_paramsKey]*MoqValue_genType_IsValid_results{},
		}
		r.Moq.ResultsByParams_IsValid = append(r.Moq.ResultsByParams_IsValid, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsValid) {
			copy(r.Moq.ResultsByParams_IsValid[insertAt+1:], r.Moq.ResultsByParams_IsValid[insertAt:0])
			r.Moq.ResultsByParams_IsValid[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsValid(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_IsValid_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_IsValid_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_IsValid_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_IsValid_doFn
				DoReturnFn MoqValue_genType_IsValid_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_IsValid(params MoqValue_genType_IsValid_params) string {
	return fmt.Sprintf("IsValid()")
}

func (m *MoqValue_genType) ParamsKey_IsValid(params MoqValue_genType_IsValid_params, anyParams uint64) MoqValue_genType_IsValid_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_IsValid_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) IsZero() *MoqValue_genType_IsZero_fnRecorder {
	return &MoqValue_genType_IsZero_fnRecorder{
		Params:   MoqValue_genType_IsZero_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_IsZero_fnRecorder) Any() *MoqValue_genType_IsZero_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsZero(r.Params))
		return nil
	}
	return &MoqValue_genType_IsZero_anyParams{Recorder: r}
}

func (r *MoqValue_genType_IsZero_fnRecorder) Seq() *MoqValue_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsZero(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_IsZero_fnRecorder) NoSeq() *MoqValue_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsZero(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_IsZero_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_IsZero_doFn
		DoReturnFn MoqValue_genType_IsZero_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_IsZero_fnRecorder) AndDo(fn MoqValue_genType_IsZero_doFn) *MoqValue_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_IsZero_fnRecorder) DoReturnResults(fn MoqValue_genType_IsZero_doReturnFn) *MoqValue_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_IsZero_doFn
		DoReturnFn MoqValue_genType_IsZero_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_IsZero_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_IsZero_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsZero {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_IsZero_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_IsZero_paramsKey]*MoqValue_genType_IsZero_results{},
		}
		r.Moq.ResultsByParams_IsZero = append(r.Moq.ResultsByParams_IsZero, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsZero) {
			copy(r.Moq.ResultsByParams_IsZero[insertAt+1:], r.Moq.ResultsByParams_IsZero[insertAt:0])
			r.Moq.ResultsByParams_IsZero[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsZero(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_IsZero_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_IsZero_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_IsZero_doFn
				DoReturnFn MoqValue_genType_IsZero_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_IsZero(params MoqValue_genType_IsZero_params) string {
	return fmt.Sprintf("IsZero()")
}

func (m *MoqValue_genType) ParamsKey_IsZero(params MoqValue_genType_IsZero_params, anyParams uint64) MoqValue_genType_IsZero_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_IsZero_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Kind() *MoqValue_genType_Kind_fnRecorder {
	return &MoqValue_genType_Kind_fnRecorder{
		Params:   MoqValue_genType_Kind_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Kind_fnRecorder) Any() *MoqValue_genType_Kind_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Kind(r.Params))
		return nil
	}
	return &MoqValue_genType_Kind_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Kind_fnRecorder) Seq() *MoqValue_genType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Kind(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Kind_fnRecorder) NoSeq() *MoqValue_genType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Kind(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Kind_fnRecorder) ReturnResults(result1 reflect.Kind) *MoqValue_genType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Kind
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Kind_doFn
		DoReturnFn MoqValue_genType_Kind_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Kind
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Kind_fnRecorder) AndDo(fn MoqValue_genType_Kind_doFn) *MoqValue_genType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Kind_fnRecorder) DoReturnResults(fn MoqValue_genType_Kind_doReturnFn) *MoqValue_genType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Kind
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Kind_doFn
		DoReturnFn MoqValue_genType_Kind_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Kind_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Kind_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Kind {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Kind_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Kind_paramsKey]*MoqValue_genType_Kind_results{},
		}
		r.Moq.ResultsByParams_Kind = append(r.Moq.ResultsByParams_Kind, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Kind) {
			copy(r.Moq.ResultsByParams_Kind[insertAt+1:], r.Moq.ResultsByParams_Kind[insertAt:0])
			r.Moq.ResultsByParams_Kind[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Kind(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Kind_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Kind_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Kind
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Kind_doFn
				DoReturnFn MoqValue_genType_Kind_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Kind(params MoqValue_genType_Kind_params) string {
	return fmt.Sprintf("Kind()")
}

func (m *MoqValue_genType) ParamsKey_Kind(params MoqValue_genType_Kind_params, anyParams uint64) MoqValue_genType_Kind_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Kind_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Len() *MoqValue_genType_Len_fnRecorder {
	return &MoqValue_genType_Len_fnRecorder{
		Params:   MoqValue_genType_Len_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Len_fnRecorder) Any() *MoqValue_genType_Len_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	return &MoqValue_genType_Len_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Len_fnRecorder) Seq() *MoqValue_genType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Len_fnRecorder) NoSeq() *MoqValue_genType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Len_fnRecorder) ReturnResults(result1 int) *MoqValue_genType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Len_doFn
		DoReturnFn MoqValue_genType_Len_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Len_fnRecorder) AndDo(fn MoqValue_genType_Len_doFn) *MoqValue_genType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Len_fnRecorder) DoReturnResults(fn MoqValue_genType_Len_doReturnFn) *MoqValue_genType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Len_doFn
		DoReturnFn MoqValue_genType_Len_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Len_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Len_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Len {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Len_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Len_paramsKey]*MoqValue_genType_Len_results{},
		}
		r.Moq.ResultsByParams_Len = append(r.Moq.ResultsByParams_Len, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Len) {
			copy(r.Moq.ResultsByParams_Len[insertAt+1:], r.Moq.ResultsByParams_Len[insertAt:0])
			r.Moq.ResultsByParams_Len[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Len(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Len_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Len_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Len_doFn
				DoReturnFn MoqValue_genType_Len_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Len(params MoqValue_genType_Len_params) string {
	return fmt.Sprintf("Len()")
}

func (m *MoqValue_genType) ParamsKey_Len(params MoqValue_genType_Len_params, anyParams uint64) MoqValue_genType_Len_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Len_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) MapIndex(key reflect.Value) *MoqValue_genType_MapIndex_fnRecorder {
	return &MoqValue_genType_MapIndex_fnRecorder{
		Params: MoqValue_genType_MapIndex_params{
			Key: key,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_MapIndex_fnRecorder) Any() *MoqValue_genType_MapIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MapIndex(r.Params))
		return nil
	}
	return &MoqValue_genType_MapIndex_anyParams{Recorder: r}
}

func (a *MoqValue_genType_MapIndex_anyParams) Key() *MoqValue_genType_MapIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_MapIndex_fnRecorder) Seq() *MoqValue_genType_MapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MapIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_MapIndex_fnRecorder) NoSeq() *MoqValue_genType_MapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MapIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_MapIndex_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_MapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MapIndex_doFn
		DoReturnFn MoqValue_genType_MapIndex_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_MapIndex_fnRecorder) AndDo(fn MoqValue_genType_MapIndex_doFn) *MoqValue_genType_MapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_MapIndex_fnRecorder) DoReturnResults(fn MoqValue_genType_MapIndex_doReturnFn) *MoqValue_genType_MapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MapIndex_doFn
		DoReturnFn MoqValue_genType_MapIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_MapIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_MapIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MapIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_MapIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_MapIndex_paramsKey]*MoqValue_genType_MapIndex_results{},
		}
		r.Moq.ResultsByParams_MapIndex = append(r.Moq.ResultsByParams_MapIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MapIndex) {
			copy(r.Moq.ResultsByParams_MapIndex[insertAt+1:], r.Moq.ResultsByParams_MapIndex[insertAt:0])
			r.Moq.ResultsByParams_MapIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MapIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_MapIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_MapIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_MapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_MapIndex_doFn
				DoReturnFn MoqValue_genType_MapIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_MapIndex(params MoqValue_genType_MapIndex_params) string {
	return fmt.Sprintf("MapIndex(%#v)", params.Key)
}

func (m *MoqValue_genType) ParamsKey_MapIndex(params MoqValue_genType_MapIndex_params, anyParams uint64) MoqValue_genType_MapIndex_paramsKey {
	m.Scene.T.Helper()
	var keyUsed reflect.Value
	var keyUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MapIndex.Key == moq.ParamIndexByValue {
			keyUsed = params.Key
		} else {
			keyUsedHash = hash.DeepHash(params.Key)
		}
	}
	return MoqValue_genType_MapIndex_paramsKey{
		Params: struct{ Key reflect.Value }{
			Key: keyUsed,
		},
		Hashes: struct{ Key hash.Hash }{
			Key: keyUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) MapKeys() *MoqValue_genType_MapKeys_fnRecorder {
	return &MoqValue_genType_MapKeys_fnRecorder{
		Params:   MoqValue_genType_MapKeys_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_MapKeys_fnRecorder) Any() *MoqValue_genType_MapKeys_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MapKeys(r.Params))
		return nil
	}
	return &MoqValue_genType_MapKeys_anyParams{Recorder: r}
}

func (r *MoqValue_genType_MapKeys_fnRecorder) Seq() *MoqValue_genType_MapKeys_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MapKeys(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_MapKeys_fnRecorder) NoSeq() *MoqValue_genType_MapKeys_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MapKeys(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_MapKeys_fnRecorder) ReturnResults(result1 []reflect.Value) *MoqValue_genType_MapKeys_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MapKeys_doFn
		DoReturnFn MoqValue_genType_MapKeys_doReturnFn
	}{
		Values: &struct {
			Result1 []reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_MapKeys_fnRecorder) AndDo(fn MoqValue_genType_MapKeys_doFn) *MoqValue_genType_MapKeys_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_MapKeys_fnRecorder) DoReturnResults(fn MoqValue_genType_MapKeys_doReturnFn) *MoqValue_genType_MapKeys_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MapKeys_doFn
		DoReturnFn MoqValue_genType_MapKeys_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_MapKeys_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_MapKeys_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MapKeys {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_MapKeys_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_MapKeys_paramsKey]*MoqValue_genType_MapKeys_results{},
		}
		r.Moq.ResultsByParams_MapKeys = append(r.Moq.ResultsByParams_MapKeys, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MapKeys) {
			copy(r.Moq.ResultsByParams_MapKeys[insertAt+1:], r.Moq.ResultsByParams_MapKeys[insertAt:0])
			r.Moq.ResultsByParams_MapKeys[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MapKeys(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_MapKeys_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_MapKeys_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_MapKeys_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_MapKeys_doFn
				DoReturnFn MoqValue_genType_MapKeys_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_MapKeys(params MoqValue_genType_MapKeys_params) string {
	return fmt.Sprintf("MapKeys()")
}

func (m *MoqValue_genType) ParamsKey_MapKeys(params MoqValue_genType_MapKeys_params, anyParams uint64) MoqValue_genType_MapKeys_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_MapKeys_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) MapRange() *MoqValue_genType_MapRange_fnRecorder {
	return &MoqValue_genType_MapRange_fnRecorder{
		Params:   MoqValue_genType_MapRange_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_MapRange_fnRecorder) Any() *MoqValue_genType_MapRange_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MapRange(r.Params))
		return nil
	}
	return &MoqValue_genType_MapRange_anyParams{Recorder: r}
}

func (r *MoqValue_genType_MapRange_fnRecorder) Seq() *MoqValue_genType_MapRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MapRange(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_MapRange_fnRecorder) NoSeq() *MoqValue_genType_MapRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MapRange(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_MapRange_fnRecorder) ReturnResults(result1 *reflect.MapIter) *MoqValue_genType_MapRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *reflect.MapIter
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MapRange_doFn
		DoReturnFn MoqValue_genType_MapRange_doReturnFn
	}{
		Values: &struct {
			Result1 *reflect.MapIter
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_MapRange_fnRecorder) AndDo(fn MoqValue_genType_MapRange_doFn) *MoqValue_genType_MapRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_MapRange_fnRecorder) DoReturnResults(fn MoqValue_genType_MapRange_doReturnFn) *MoqValue_genType_MapRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *reflect.MapIter
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MapRange_doFn
		DoReturnFn MoqValue_genType_MapRange_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_MapRange_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_MapRange_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MapRange {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_MapRange_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_MapRange_paramsKey]*MoqValue_genType_MapRange_results{},
		}
		r.Moq.ResultsByParams_MapRange = append(r.Moq.ResultsByParams_MapRange, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MapRange) {
			copy(r.Moq.ResultsByParams_MapRange[insertAt+1:], r.Moq.ResultsByParams_MapRange[insertAt:0])
			r.Moq.ResultsByParams_MapRange[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MapRange(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_MapRange_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_MapRange_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_MapRange_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *reflect.MapIter
				}
				Sequence   uint32
				DoFn       MoqValue_genType_MapRange_doFn
				DoReturnFn MoqValue_genType_MapRange_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_MapRange(params MoqValue_genType_MapRange_params) string {
	return fmt.Sprintf("MapRange()")
}

func (m *MoqValue_genType) ParamsKey_MapRange(params MoqValue_genType_MapRange_params, anyParams uint64) MoqValue_genType_MapRange_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_MapRange_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Method(param1 int) *MoqValue_genType_Method_fnRecorder {
	return &MoqValue_genType_Method_fnRecorder{
		Params: MoqValue_genType_Method_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Method_fnRecorder) Any() *MoqValue_genType_Method_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	return &MoqValue_genType_Method_anyParams{Recorder: r}
}

func (a *MoqValue_genType_Method_anyParams) Param1() *MoqValue_genType_Method_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_Method_fnRecorder) Seq() *MoqValue_genType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Method_fnRecorder) NoSeq() *MoqValue_genType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Method_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Method_doFn
		DoReturnFn MoqValue_genType_Method_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Method_fnRecorder) AndDo(fn MoqValue_genType_Method_doFn) *MoqValue_genType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Method_fnRecorder) DoReturnResults(fn MoqValue_genType_Method_doReturnFn) *MoqValue_genType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Method_doFn
		DoReturnFn MoqValue_genType_Method_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Method_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Method_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Method {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Method_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Method_paramsKey]*MoqValue_genType_Method_results{},
		}
		r.Moq.ResultsByParams_Method = append(r.Moq.ResultsByParams_Method, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Method) {
			copy(r.Moq.ResultsByParams_Method[insertAt+1:], r.Moq.ResultsByParams_Method[insertAt:0])
			r.Moq.ResultsByParams_Method[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Method(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Method_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Method_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Method_doFn
				DoReturnFn MoqValue_genType_Method_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Method(params MoqValue_genType_Method_params) string {
	return fmt.Sprintf("Method(%#v)", params.Param1)
}

func (m *MoqValue_genType) ParamsKey_Method(params MoqValue_genType_Method_params, anyParams uint64) MoqValue_genType_Method_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Method.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqValue_genType_Method_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) NumMethod() *MoqValue_genType_NumMethod_fnRecorder {
	return &MoqValue_genType_NumMethod_fnRecorder{
		Params:   MoqValue_genType_NumMethod_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_NumMethod_fnRecorder) Any() *MoqValue_genType_NumMethod_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethod(r.Params))
		return nil
	}
	return &MoqValue_genType_NumMethod_anyParams{Recorder: r}
}

func (r *MoqValue_genType_NumMethod_fnRecorder) Seq() *MoqValue_genType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethod(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_NumMethod_fnRecorder) NoSeq() *MoqValue_genType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethod(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_NumMethod_fnRecorder) ReturnResults(result1 int) *MoqValue_genType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_NumMethod_doFn
		DoReturnFn MoqValue_genType_NumMethod_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_NumMethod_fnRecorder) AndDo(fn MoqValue_genType_NumMethod_doFn) *MoqValue_genType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_NumMethod_fnRecorder) DoReturnResults(fn MoqValue_genType_NumMethod_doReturnFn) *MoqValue_genType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_NumMethod_doFn
		DoReturnFn MoqValue_genType_NumMethod_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_NumMethod_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_NumMethod_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumMethod {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_NumMethod_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_NumMethod_paramsKey]*MoqValue_genType_NumMethod_results{},
		}
		r.Moq.ResultsByParams_NumMethod = append(r.Moq.ResultsByParams_NumMethod, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumMethod) {
			copy(r.Moq.ResultsByParams_NumMethod[insertAt+1:], r.Moq.ResultsByParams_NumMethod[insertAt:0])
			r.Moq.ResultsByParams_NumMethod[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumMethod(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_NumMethod_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_NumMethod_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqValue_genType_NumMethod_doFn
				DoReturnFn MoqValue_genType_NumMethod_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_NumMethod(params MoqValue_genType_NumMethod_params) string {
	return fmt.Sprintf("NumMethod()")
}

func (m *MoqValue_genType) ParamsKey_NumMethod(params MoqValue_genType_NumMethod_params, anyParams uint64) MoqValue_genType_NumMethod_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_NumMethod_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) MethodByName(name string) *MoqValue_genType_MethodByName_fnRecorder {
	return &MoqValue_genType_MethodByName_fnRecorder{
		Params: MoqValue_genType_MethodByName_params{
			Name: name,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_MethodByName_fnRecorder) Any() *MoqValue_genType_MethodByName_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MethodByName(r.Params))
		return nil
	}
	return &MoqValue_genType_MethodByName_anyParams{Recorder: r}
}

func (a *MoqValue_genType_MethodByName_anyParams) Name() *MoqValue_genType_MethodByName_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_MethodByName_fnRecorder) Seq() *MoqValue_genType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MethodByName(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_MethodByName_fnRecorder) NoSeq() *MoqValue_genType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MethodByName(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_MethodByName_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MethodByName_doFn
		DoReturnFn MoqValue_genType_MethodByName_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_MethodByName_fnRecorder) AndDo(fn MoqValue_genType_MethodByName_doFn) *MoqValue_genType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_MethodByName_fnRecorder) DoReturnResults(fn MoqValue_genType_MethodByName_doReturnFn) *MoqValue_genType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_MethodByName_doFn
		DoReturnFn MoqValue_genType_MethodByName_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_MethodByName_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_MethodByName_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MethodByName {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_MethodByName_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_MethodByName_paramsKey]*MoqValue_genType_MethodByName_results{},
		}
		r.Moq.ResultsByParams_MethodByName = append(r.Moq.ResultsByParams_MethodByName, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MethodByName) {
			copy(r.Moq.ResultsByParams_MethodByName[insertAt+1:], r.Moq.ResultsByParams_MethodByName[insertAt:0])
			r.Moq.ResultsByParams_MethodByName[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MethodByName(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_MethodByName_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_MethodByName_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_MethodByName_doFn
				DoReturnFn MoqValue_genType_MethodByName_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_MethodByName(params MoqValue_genType_MethodByName_params) string {
	return fmt.Sprintf("MethodByName(%#v)", params.Name)
}

func (m *MoqValue_genType) ParamsKey_MethodByName(params MoqValue_genType_MethodByName_params, anyParams uint64) MoqValue_genType_MethodByName_paramsKey {
	m.Scene.T.Helper()
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MethodByName.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	return MoqValue_genType_MethodByName_paramsKey{
		Params: struct{ Name string }{
			Name: nameUsed,
		},
		Hashes: struct{ Name hash.Hash }{
			Name: nameUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) NumField() *MoqValue_genType_NumField_fnRecorder {
	return &MoqValue_genType_NumField_fnRecorder{
		Params:   MoqValue_genType_NumField_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_NumField_fnRecorder) Any() *MoqValue_genType_NumField_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumField(r.Params))
		return nil
	}
	return &MoqValue_genType_NumField_anyParams{Recorder: r}
}

func (r *MoqValue_genType_NumField_fnRecorder) Seq() *MoqValue_genType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumField(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_NumField_fnRecorder) NoSeq() *MoqValue_genType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumField(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_NumField_fnRecorder) ReturnResults(result1 int) *MoqValue_genType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_NumField_doFn
		DoReturnFn MoqValue_genType_NumField_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_NumField_fnRecorder) AndDo(fn MoqValue_genType_NumField_doFn) *MoqValue_genType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_NumField_fnRecorder) DoReturnResults(fn MoqValue_genType_NumField_doReturnFn) *MoqValue_genType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqValue_genType_NumField_doFn
		DoReturnFn MoqValue_genType_NumField_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_NumField_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_NumField_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumField {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_NumField_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_NumField_paramsKey]*MoqValue_genType_NumField_results{},
		}
		r.Moq.ResultsByParams_NumField = append(r.Moq.ResultsByParams_NumField, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumField) {
			copy(r.Moq.ResultsByParams_NumField[insertAt+1:], r.Moq.ResultsByParams_NumField[insertAt:0])
			r.Moq.ResultsByParams_NumField[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumField(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_NumField_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_NumField_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqValue_genType_NumField_doFn
				DoReturnFn MoqValue_genType_NumField_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_NumField(params MoqValue_genType_NumField_params) string {
	return fmt.Sprintf("NumField()")
}

func (m *MoqValue_genType) ParamsKey_NumField(params MoqValue_genType_NumField_params, anyParams uint64) MoqValue_genType_NumField_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_NumField_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) OverflowComplex(x complex128) *MoqValue_genType_OverflowComplex_fnRecorder {
	return &MoqValue_genType_OverflowComplex_fnRecorder{
		Params: MoqValue_genType_OverflowComplex_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_OverflowComplex_fnRecorder) Any() *MoqValue_genType_OverflowComplex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowComplex(r.Params))
		return nil
	}
	return &MoqValue_genType_OverflowComplex_anyParams{Recorder: r}
}

func (a *MoqValue_genType_OverflowComplex_anyParams) X() *MoqValue_genType_OverflowComplex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_OverflowComplex_fnRecorder) Seq() *MoqValue_genType_OverflowComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowComplex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_OverflowComplex_fnRecorder) NoSeq() *MoqValue_genType_OverflowComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowComplex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_OverflowComplex_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_OverflowComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowComplex_doFn
		DoReturnFn MoqValue_genType_OverflowComplex_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_OverflowComplex_fnRecorder) AndDo(fn MoqValue_genType_OverflowComplex_doFn) *MoqValue_genType_OverflowComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_OverflowComplex_fnRecorder) DoReturnResults(fn MoqValue_genType_OverflowComplex_doReturnFn) *MoqValue_genType_OverflowComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowComplex_doFn
		DoReturnFn MoqValue_genType_OverflowComplex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_OverflowComplex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_OverflowComplex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_OverflowComplex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_OverflowComplex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_OverflowComplex_paramsKey]*MoqValue_genType_OverflowComplex_results{},
		}
		r.Moq.ResultsByParams_OverflowComplex = append(r.Moq.ResultsByParams_OverflowComplex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_OverflowComplex) {
			copy(r.Moq.ResultsByParams_OverflowComplex[insertAt+1:], r.Moq.ResultsByParams_OverflowComplex[insertAt:0])
			r.Moq.ResultsByParams_OverflowComplex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_OverflowComplex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_OverflowComplex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_OverflowComplex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_OverflowComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_OverflowComplex_doFn
				DoReturnFn MoqValue_genType_OverflowComplex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_OverflowComplex(params MoqValue_genType_OverflowComplex_params) string {
	return fmt.Sprintf("OverflowComplex(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_OverflowComplex(params MoqValue_genType_OverflowComplex_params, anyParams uint64) MoqValue_genType_OverflowComplex_paramsKey {
	m.Scene.T.Helper()
	var xUsed complex128
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.OverflowComplex.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_OverflowComplex_paramsKey{
		Params: struct{ X complex128 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) OverflowFloat(x float64) *MoqValue_genType_OverflowFloat_fnRecorder {
	return &MoqValue_genType_OverflowFloat_fnRecorder{
		Params: MoqValue_genType_OverflowFloat_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_OverflowFloat_fnRecorder) Any() *MoqValue_genType_OverflowFloat_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowFloat(r.Params))
		return nil
	}
	return &MoqValue_genType_OverflowFloat_anyParams{Recorder: r}
}

func (a *MoqValue_genType_OverflowFloat_anyParams) X() *MoqValue_genType_OverflowFloat_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_OverflowFloat_fnRecorder) Seq() *MoqValue_genType_OverflowFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowFloat(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_OverflowFloat_fnRecorder) NoSeq() *MoqValue_genType_OverflowFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowFloat(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_OverflowFloat_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_OverflowFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowFloat_doFn
		DoReturnFn MoqValue_genType_OverflowFloat_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_OverflowFloat_fnRecorder) AndDo(fn MoqValue_genType_OverflowFloat_doFn) *MoqValue_genType_OverflowFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_OverflowFloat_fnRecorder) DoReturnResults(fn MoqValue_genType_OverflowFloat_doReturnFn) *MoqValue_genType_OverflowFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowFloat_doFn
		DoReturnFn MoqValue_genType_OverflowFloat_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_OverflowFloat_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_OverflowFloat_resultsByParams
	for n, res := range r.Moq.ResultsByParams_OverflowFloat {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_OverflowFloat_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_OverflowFloat_paramsKey]*MoqValue_genType_OverflowFloat_results{},
		}
		r.Moq.ResultsByParams_OverflowFloat = append(r.Moq.ResultsByParams_OverflowFloat, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_OverflowFloat) {
			copy(r.Moq.ResultsByParams_OverflowFloat[insertAt+1:], r.Moq.ResultsByParams_OverflowFloat[insertAt:0])
			r.Moq.ResultsByParams_OverflowFloat[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_OverflowFloat(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_OverflowFloat_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_OverflowFloat_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_OverflowFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_OverflowFloat_doFn
				DoReturnFn MoqValue_genType_OverflowFloat_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_OverflowFloat(params MoqValue_genType_OverflowFloat_params) string {
	return fmt.Sprintf("OverflowFloat(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_OverflowFloat(params MoqValue_genType_OverflowFloat_params, anyParams uint64) MoqValue_genType_OverflowFloat_paramsKey {
	m.Scene.T.Helper()
	var xUsed float64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.OverflowFloat.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_OverflowFloat_paramsKey{
		Params: struct{ X float64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) OverflowInt(x int64) *MoqValue_genType_OverflowInt_fnRecorder {
	return &MoqValue_genType_OverflowInt_fnRecorder{
		Params: MoqValue_genType_OverflowInt_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_OverflowInt_fnRecorder) Any() *MoqValue_genType_OverflowInt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowInt(r.Params))
		return nil
	}
	return &MoqValue_genType_OverflowInt_anyParams{Recorder: r}
}

func (a *MoqValue_genType_OverflowInt_anyParams) X() *MoqValue_genType_OverflowInt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_OverflowInt_fnRecorder) Seq() *MoqValue_genType_OverflowInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowInt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_OverflowInt_fnRecorder) NoSeq() *MoqValue_genType_OverflowInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowInt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_OverflowInt_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_OverflowInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowInt_doFn
		DoReturnFn MoqValue_genType_OverflowInt_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_OverflowInt_fnRecorder) AndDo(fn MoqValue_genType_OverflowInt_doFn) *MoqValue_genType_OverflowInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_OverflowInt_fnRecorder) DoReturnResults(fn MoqValue_genType_OverflowInt_doReturnFn) *MoqValue_genType_OverflowInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowInt_doFn
		DoReturnFn MoqValue_genType_OverflowInt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_OverflowInt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_OverflowInt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_OverflowInt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_OverflowInt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_OverflowInt_paramsKey]*MoqValue_genType_OverflowInt_results{},
		}
		r.Moq.ResultsByParams_OverflowInt = append(r.Moq.ResultsByParams_OverflowInt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_OverflowInt) {
			copy(r.Moq.ResultsByParams_OverflowInt[insertAt+1:], r.Moq.ResultsByParams_OverflowInt[insertAt:0])
			r.Moq.ResultsByParams_OverflowInt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_OverflowInt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_OverflowInt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_OverflowInt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_OverflowInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_OverflowInt_doFn
				DoReturnFn MoqValue_genType_OverflowInt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_OverflowInt(params MoqValue_genType_OverflowInt_params) string {
	return fmt.Sprintf("OverflowInt(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_OverflowInt(params MoqValue_genType_OverflowInt_params, anyParams uint64) MoqValue_genType_OverflowInt_paramsKey {
	m.Scene.T.Helper()
	var xUsed int64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.OverflowInt.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_OverflowInt_paramsKey{
		Params: struct{ X int64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) OverflowUint(x uint64) *MoqValue_genType_OverflowUint_fnRecorder {
	return &MoqValue_genType_OverflowUint_fnRecorder{
		Params: MoqValue_genType_OverflowUint_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_OverflowUint_fnRecorder) Any() *MoqValue_genType_OverflowUint_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowUint(r.Params))
		return nil
	}
	return &MoqValue_genType_OverflowUint_anyParams{Recorder: r}
}

func (a *MoqValue_genType_OverflowUint_anyParams) X() *MoqValue_genType_OverflowUint_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_OverflowUint_fnRecorder) Seq() *MoqValue_genType_OverflowUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowUint(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_OverflowUint_fnRecorder) NoSeq() *MoqValue_genType_OverflowUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_OverflowUint(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_OverflowUint_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_OverflowUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowUint_doFn
		DoReturnFn MoqValue_genType_OverflowUint_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_OverflowUint_fnRecorder) AndDo(fn MoqValue_genType_OverflowUint_doFn) *MoqValue_genType_OverflowUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_OverflowUint_fnRecorder) DoReturnResults(fn MoqValue_genType_OverflowUint_doReturnFn) *MoqValue_genType_OverflowUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_OverflowUint_doFn
		DoReturnFn MoqValue_genType_OverflowUint_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_OverflowUint_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_OverflowUint_resultsByParams
	for n, res := range r.Moq.ResultsByParams_OverflowUint {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_OverflowUint_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_OverflowUint_paramsKey]*MoqValue_genType_OverflowUint_results{},
		}
		r.Moq.ResultsByParams_OverflowUint = append(r.Moq.ResultsByParams_OverflowUint, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_OverflowUint) {
			copy(r.Moq.ResultsByParams_OverflowUint[insertAt+1:], r.Moq.ResultsByParams_OverflowUint[insertAt:0])
			r.Moq.ResultsByParams_OverflowUint[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_OverflowUint(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_OverflowUint_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_OverflowUint_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_OverflowUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_OverflowUint_doFn
				DoReturnFn MoqValue_genType_OverflowUint_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_OverflowUint(params MoqValue_genType_OverflowUint_params) string {
	return fmt.Sprintf("OverflowUint(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_OverflowUint(params MoqValue_genType_OverflowUint_params, anyParams uint64) MoqValue_genType_OverflowUint_paramsKey {
	m.Scene.T.Helper()
	var xUsed uint64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.OverflowUint.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_OverflowUint_paramsKey{
		Params: struct{ X uint64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) Pointer() *MoqValue_genType_Pointer_fnRecorder {
	return &MoqValue_genType_Pointer_fnRecorder{
		Params:   MoqValue_genType_Pointer_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Pointer_fnRecorder) Any() *MoqValue_genType_Pointer_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Pointer(r.Params))
		return nil
	}
	return &MoqValue_genType_Pointer_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Pointer_fnRecorder) Seq() *MoqValue_genType_Pointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Pointer(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Pointer_fnRecorder) NoSeq() *MoqValue_genType_Pointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Pointer(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Pointer_fnRecorder) ReturnResults(result1 uintptr) *MoqValue_genType_Pointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Pointer_doFn
		DoReturnFn MoqValue_genType_Pointer_doReturnFn
	}{
		Values: &struct {
			Result1 uintptr
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Pointer_fnRecorder) AndDo(fn MoqValue_genType_Pointer_doFn) *MoqValue_genType_Pointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Pointer_fnRecorder) DoReturnResults(fn MoqValue_genType_Pointer_doReturnFn) *MoqValue_genType_Pointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Pointer_doFn
		DoReturnFn MoqValue_genType_Pointer_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Pointer_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Pointer_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Pointer {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Pointer_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Pointer_paramsKey]*MoqValue_genType_Pointer_results{},
		}
		r.Moq.ResultsByParams_Pointer = append(r.Moq.ResultsByParams_Pointer, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Pointer) {
			copy(r.Moq.ResultsByParams_Pointer[insertAt+1:], r.Moq.ResultsByParams_Pointer[insertAt:0])
			r.Moq.ResultsByParams_Pointer[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Pointer(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Pointer_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Pointer_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Pointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 uintptr
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Pointer_doFn
				DoReturnFn MoqValue_genType_Pointer_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Pointer(params MoqValue_genType_Pointer_params) string {
	return fmt.Sprintf("Pointer()")
}

func (m *MoqValue_genType) ParamsKey_Pointer(params MoqValue_genType_Pointer_params, anyParams uint64) MoqValue_genType_Pointer_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Pointer_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Recv() *MoqValue_genType_Recv_fnRecorder {
	return &MoqValue_genType_Recv_fnRecorder{
		Params:   MoqValue_genType_Recv_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Recv_fnRecorder) Any() *MoqValue_genType_Recv_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Recv(r.Params))
		return nil
	}
	return &MoqValue_genType_Recv_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Recv_fnRecorder) Seq() *MoqValue_genType_Recv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Recv(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Recv_fnRecorder) NoSeq() *MoqValue_genType_Recv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Recv(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Recv_fnRecorder) ReturnResults(x reflect.Value, ok bool) *MoqValue_genType_Recv_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			X  reflect.Value
			Ok bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Recv_doFn
		DoReturnFn MoqValue_genType_Recv_doReturnFn
	}{
		Values: &struct {
			X  reflect.Value
			Ok bool
		}{
			X:  x,
			Ok: ok,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Recv_fnRecorder) AndDo(fn MoqValue_genType_Recv_doFn) *MoqValue_genType_Recv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Recv_fnRecorder) DoReturnResults(fn MoqValue_genType_Recv_doReturnFn) *MoqValue_genType_Recv_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			X  reflect.Value
			Ok bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Recv_doFn
		DoReturnFn MoqValue_genType_Recv_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Recv_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Recv_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Recv {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Recv_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Recv_paramsKey]*MoqValue_genType_Recv_results{},
		}
		r.Moq.ResultsByParams_Recv = append(r.Moq.ResultsByParams_Recv, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Recv) {
			copy(r.Moq.ResultsByParams_Recv[insertAt+1:], r.Moq.ResultsByParams_Recv[insertAt:0])
			r.Moq.ResultsByParams_Recv[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Recv(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Recv_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Recv_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Recv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					X  reflect.Value
					Ok bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Recv_doFn
				DoReturnFn MoqValue_genType_Recv_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Recv(params MoqValue_genType_Recv_params) string {
	return fmt.Sprintf("Recv()")
}

func (m *MoqValue_genType) ParamsKey_Recv(params MoqValue_genType_Recv_params, anyParams uint64) MoqValue_genType_Recv_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Recv_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Send(x reflect.Value) *MoqValue_genType_Send_fnRecorder {
	return &MoqValue_genType_Send_fnRecorder{
		Params: MoqValue_genType_Send_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Send_fnRecorder) Any() *MoqValue_genType_Send_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Send(r.Params))
		return nil
	}
	return &MoqValue_genType_Send_anyParams{Recorder: r}
}

func (a *MoqValue_genType_Send_anyParams) X() *MoqValue_genType_Send_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_Send_fnRecorder) Seq() *MoqValue_genType_Send_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Send(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Send_fnRecorder) NoSeq() *MoqValue_genType_Send_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Send(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Send_fnRecorder) ReturnResults() *MoqValue_genType_Send_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_Send_doFn
		DoReturnFn MoqValue_genType_Send_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Send_fnRecorder) AndDo(fn MoqValue_genType_Send_doFn) *MoqValue_genType_Send_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Send_fnRecorder) DoReturnResults(fn MoqValue_genType_Send_doReturnFn) *MoqValue_genType_Send_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_Send_doFn
		DoReturnFn MoqValue_genType_Send_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Send_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Send_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Send {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Send_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Send_paramsKey]*MoqValue_genType_Send_results{},
		}
		r.Moq.ResultsByParams_Send = append(r.Moq.ResultsByParams_Send, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Send) {
			copy(r.Moq.ResultsByParams_Send[insertAt+1:], r.Moq.ResultsByParams_Send[insertAt:0])
			r.Moq.ResultsByParams_Send[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Send(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Send_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Send_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Send_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_Send_doFn
				DoReturnFn MoqValue_genType_Send_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Send(params MoqValue_genType_Send_params) string {
	return fmt.Sprintf("Send(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_Send(params MoqValue_genType_Send_params, anyParams uint64) MoqValue_genType_Send_paramsKey {
	m.Scene.T.Helper()
	var xUsed reflect.Value
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Send.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_Send_paramsKey{
		Params: struct{ X reflect.Value }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) Set(x reflect.Value) *MoqValue_genType_Set_fnRecorder {
	return &MoqValue_genType_Set_fnRecorder{
		Params: MoqValue_genType_Set_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Set_fnRecorder) Any() *MoqValue_genType_Set_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	return &MoqValue_genType_Set_anyParams{Recorder: r}
}

func (a *MoqValue_genType_Set_anyParams) X() *MoqValue_genType_Set_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_Set_fnRecorder) Seq() *MoqValue_genType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Set_fnRecorder) NoSeq() *MoqValue_genType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Set(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Set_fnRecorder) ReturnResults() *MoqValue_genType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_Set_doFn
		DoReturnFn MoqValue_genType_Set_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Set_fnRecorder) AndDo(fn MoqValue_genType_Set_doFn) *MoqValue_genType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Set_fnRecorder) DoReturnResults(fn MoqValue_genType_Set_doReturnFn) *MoqValue_genType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_Set_doFn
		DoReturnFn MoqValue_genType_Set_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Set_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Set_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Set {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Set_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Set_paramsKey]*MoqValue_genType_Set_results{},
		}
		r.Moq.ResultsByParams_Set = append(r.Moq.ResultsByParams_Set, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Set) {
			copy(r.Moq.ResultsByParams_Set[insertAt+1:], r.Moq.ResultsByParams_Set[insertAt:0])
			r.Moq.ResultsByParams_Set[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Set(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Set_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Set_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Set_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_Set_doFn
				DoReturnFn MoqValue_genType_Set_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Set(params MoqValue_genType_Set_params) string {
	return fmt.Sprintf("Set(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_Set(params MoqValue_genType_Set_params, anyParams uint64) MoqValue_genType_Set_paramsKey {
	m.Scene.T.Helper()
	var xUsed reflect.Value
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Set.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_Set_paramsKey{
		Params: struct{ X reflect.Value }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) SetBool(x bool) *MoqValue_genType_SetBool_fnRecorder {
	return &MoqValue_genType_SetBool_fnRecorder{
		Params: MoqValue_genType_SetBool_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_SetBool_fnRecorder) Any() *MoqValue_genType_SetBool_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBool(r.Params))
		return nil
	}
	return &MoqValue_genType_SetBool_anyParams{Recorder: r}
}

func (a *MoqValue_genType_SetBool_anyParams) X() *MoqValue_genType_SetBool_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_SetBool_fnRecorder) Seq() *MoqValue_genType_SetBool_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBool(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_SetBool_fnRecorder) NoSeq() *MoqValue_genType_SetBool_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBool(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_SetBool_fnRecorder) ReturnResults() *MoqValue_genType_SetBool_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetBool_doFn
		DoReturnFn MoqValue_genType_SetBool_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_SetBool_fnRecorder) AndDo(fn MoqValue_genType_SetBool_doFn) *MoqValue_genType_SetBool_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_SetBool_fnRecorder) DoReturnResults(fn MoqValue_genType_SetBool_doReturnFn) *MoqValue_genType_SetBool_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetBool_doFn
		DoReturnFn MoqValue_genType_SetBool_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_SetBool_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_SetBool_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetBool {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_SetBool_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_SetBool_paramsKey]*MoqValue_genType_SetBool_results{},
		}
		r.Moq.ResultsByParams_SetBool = append(r.Moq.ResultsByParams_SetBool, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetBool) {
			copy(r.Moq.ResultsByParams_SetBool[insertAt+1:], r.Moq.ResultsByParams_SetBool[insertAt:0])
			r.Moq.ResultsByParams_SetBool[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetBool(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_SetBool_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_SetBool_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_SetBool_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_SetBool_doFn
				DoReturnFn MoqValue_genType_SetBool_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_SetBool(params MoqValue_genType_SetBool_params) string {
	return fmt.Sprintf("SetBool(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_SetBool(params MoqValue_genType_SetBool_params, anyParams uint64) MoqValue_genType_SetBool_paramsKey {
	m.Scene.T.Helper()
	var xUsed bool
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetBool.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_SetBool_paramsKey{
		Params: struct{ X bool }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) SetBytes(x []byte) *MoqValue_genType_SetBytes_fnRecorder {
	return &MoqValue_genType_SetBytes_fnRecorder{
		Params: MoqValue_genType_SetBytes_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_SetBytes_fnRecorder) Any() *MoqValue_genType_SetBytes_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBytes(r.Params))
		return nil
	}
	return &MoqValue_genType_SetBytes_anyParams{Recorder: r}
}

func (a *MoqValue_genType_SetBytes_anyParams) X() *MoqValue_genType_SetBytes_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_SetBytes_fnRecorder) Seq() *MoqValue_genType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBytes(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_SetBytes_fnRecorder) NoSeq() *MoqValue_genType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetBytes(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_SetBytes_fnRecorder) ReturnResults() *MoqValue_genType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetBytes_doFn
		DoReturnFn MoqValue_genType_SetBytes_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_SetBytes_fnRecorder) AndDo(fn MoqValue_genType_SetBytes_doFn) *MoqValue_genType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_SetBytes_fnRecorder) DoReturnResults(fn MoqValue_genType_SetBytes_doReturnFn) *MoqValue_genType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetBytes_doFn
		DoReturnFn MoqValue_genType_SetBytes_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_SetBytes_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_SetBytes_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetBytes {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_SetBytes_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_SetBytes_paramsKey]*MoqValue_genType_SetBytes_results{},
		}
		r.Moq.ResultsByParams_SetBytes = append(r.Moq.ResultsByParams_SetBytes, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetBytes) {
			copy(r.Moq.ResultsByParams_SetBytes[insertAt+1:], r.Moq.ResultsByParams_SetBytes[insertAt:0])
			r.Moq.ResultsByParams_SetBytes[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetBytes(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_SetBytes_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_SetBytes_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_SetBytes_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_SetBytes_doFn
				DoReturnFn MoqValue_genType_SetBytes_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_SetBytes(params MoqValue_genType_SetBytes_params) string {
	return fmt.Sprintf("SetBytes(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_SetBytes(params MoqValue_genType_SetBytes_params, anyParams uint64) MoqValue_genType_SetBytes_paramsKey {
	m.Scene.T.Helper()
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetBytes.X == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The x parameter of the SetBytes function can't be indexed by value")
		}
		xUsedHash = hash.DeepHash(params.X)
	}
	return MoqValue_genType_SetBytes_paramsKey{
		Params: struct{}{},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) SetComplex(x complex128) *MoqValue_genType_SetComplex_fnRecorder {
	return &MoqValue_genType_SetComplex_fnRecorder{
		Params: MoqValue_genType_SetComplex_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_SetComplex_fnRecorder) Any() *MoqValue_genType_SetComplex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetComplex(r.Params))
		return nil
	}
	return &MoqValue_genType_SetComplex_anyParams{Recorder: r}
}

func (a *MoqValue_genType_SetComplex_anyParams) X() *MoqValue_genType_SetComplex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_SetComplex_fnRecorder) Seq() *MoqValue_genType_SetComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetComplex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_SetComplex_fnRecorder) NoSeq() *MoqValue_genType_SetComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetComplex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_SetComplex_fnRecorder) ReturnResults() *MoqValue_genType_SetComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetComplex_doFn
		DoReturnFn MoqValue_genType_SetComplex_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_SetComplex_fnRecorder) AndDo(fn MoqValue_genType_SetComplex_doFn) *MoqValue_genType_SetComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_SetComplex_fnRecorder) DoReturnResults(fn MoqValue_genType_SetComplex_doReturnFn) *MoqValue_genType_SetComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetComplex_doFn
		DoReturnFn MoqValue_genType_SetComplex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_SetComplex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_SetComplex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetComplex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_SetComplex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_SetComplex_paramsKey]*MoqValue_genType_SetComplex_results{},
		}
		r.Moq.ResultsByParams_SetComplex = append(r.Moq.ResultsByParams_SetComplex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetComplex) {
			copy(r.Moq.ResultsByParams_SetComplex[insertAt+1:], r.Moq.ResultsByParams_SetComplex[insertAt:0])
			r.Moq.ResultsByParams_SetComplex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetComplex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_SetComplex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_SetComplex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_SetComplex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_SetComplex_doFn
				DoReturnFn MoqValue_genType_SetComplex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_SetComplex(params MoqValue_genType_SetComplex_params) string {
	return fmt.Sprintf("SetComplex(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_SetComplex(params MoqValue_genType_SetComplex_params, anyParams uint64) MoqValue_genType_SetComplex_paramsKey {
	m.Scene.T.Helper()
	var xUsed complex128
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetComplex.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_SetComplex_paramsKey{
		Params: struct{ X complex128 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) SetFloat(x float64) *MoqValue_genType_SetFloat_fnRecorder {
	return &MoqValue_genType_SetFloat_fnRecorder{
		Params: MoqValue_genType_SetFloat_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_SetFloat_fnRecorder) Any() *MoqValue_genType_SetFloat_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFloat(r.Params))
		return nil
	}
	return &MoqValue_genType_SetFloat_anyParams{Recorder: r}
}

func (a *MoqValue_genType_SetFloat_anyParams) X() *MoqValue_genType_SetFloat_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_SetFloat_fnRecorder) Seq() *MoqValue_genType_SetFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFloat(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_SetFloat_fnRecorder) NoSeq() *MoqValue_genType_SetFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetFloat(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_SetFloat_fnRecorder) ReturnResults() *MoqValue_genType_SetFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetFloat_doFn
		DoReturnFn MoqValue_genType_SetFloat_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_SetFloat_fnRecorder) AndDo(fn MoqValue_genType_SetFloat_doFn) *MoqValue_genType_SetFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_SetFloat_fnRecorder) DoReturnResults(fn MoqValue_genType_SetFloat_doReturnFn) *MoqValue_genType_SetFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetFloat_doFn
		DoReturnFn MoqValue_genType_SetFloat_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_SetFloat_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_SetFloat_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetFloat {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_SetFloat_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_SetFloat_paramsKey]*MoqValue_genType_SetFloat_results{},
		}
		r.Moq.ResultsByParams_SetFloat = append(r.Moq.ResultsByParams_SetFloat, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetFloat) {
			copy(r.Moq.ResultsByParams_SetFloat[insertAt+1:], r.Moq.ResultsByParams_SetFloat[insertAt:0])
			r.Moq.ResultsByParams_SetFloat[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetFloat(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_SetFloat_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_SetFloat_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_SetFloat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_SetFloat_doFn
				DoReturnFn MoqValue_genType_SetFloat_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_SetFloat(params MoqValue_genType_SetFloat_params) string {
	return fmt.Sprintf("SetFloat(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_SetFloat(params MoqValue_genType_SetFloat_params, anyParams uint64) MoqValue_genType_SetFloat_paramsKey {
	m.Scene.T.Helper()
	var xUsed float64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetFloat.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_SetFloat_paramsKey{
		Params: struct{ X float64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) SetInt(x int64) *MoqValue_genType_SetInt_fnRecorder {
	return &MoqValue_genType_SetInt_fnRecorder{
		Params: MoqValue_genType_SetInt_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_SetInt_fnRecorder) Any() *MoqValue_genType_SetInt_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt(r.Params))
		return nil
	}
	return &MoqValue_genType_SetInt_anyParams{Recorder: r}
}

func (a *MoqValue_genType_SetInt_anyParams) X() *MoqValue_genType_SetInt_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_SetInt_fnRecorder) Seq() *MoqValue_genType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_SetInt_fnRecorder) NoSeq() *MoqValue_genType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetInt(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_SetInt_fnRecorder) ReturnResults() *MoqValue_genType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetInt_doFn
		DoReturnFn MoqValue_genType_SetInt_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_SetInt_fnRecorder) AndDo(fn MoqValue_genType_SetInt_doFn) *MoqValue_genType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_SetInt_fnRecorder) DoReturnResults(fn MoqValue_genType_SetInt_doReturnFn) *MoqValue_genType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetInt_doFn
		DoReturnFn MoqValue_genType_SetInt_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_SetInt_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_SetInt_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetInt {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_SetInt_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_SetInt_paramsKey]*MoqValue_genType_SetInt_results{},
		}
		r.Moq.ResultsByParams_SetInt = append(r.Moq.ResultsByParams_SetInt, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetInt) {
			copy(r.Moq.ResultsByParams_SetInt[insertAt+1:], r.Moq.ResultsByParams_SetInt[insertAt:0])
			r.Moq.ResultsByParams_SetInt[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetInt(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_SetInt_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_SetInt_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_SetInt_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_SetInt_doFn
				DoReturnFn MoqValue_genType_SetInt_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_SetInt(params MoqValue_genType_SetInt_params) string {
	return fmt.Sprintf("SetInt(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_SetInt(params MoqValue_genType_SetInt_params, anyParams uint64) MoqValue_genType_SetInt_paramsKey {
	m.Scene.T.Helper()
	var xUsed int64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetInt.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_SetInt_paramsKey{
		Params: struct{ X int64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) SetLen(n int) *MoqValue_genType_SetLen_fnRecorder {
	return &MoqValue_genType_SetLen_fnRecorder{
		Params: MoqValue_genType_SetLen_params{
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_SetLen_fnRecorder) Any() *MoqValue_genType_SetLen_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLen(r.Params))
		return nil
	}
	return &MoqValue_genType_SetLen_anyParams{Recorder: r}
}

func (a *MoqValue_genType_SetLen_anyParams) N() *MoqValue_genType_SetLen_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_SetLen_fnRecorder) Seq() *MoqValue_genType_SetLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLen(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_SetLen_fnRecorder) NoSeq() *MoqValue_genType_SetLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetLen(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_SetLen_fnRecorder) ReturnResults() *MoqValue_genType_SetLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetLen_doFn
		DoReturnFn MoqValue_genType_SetLen_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_SetLen_fnRecorder) AndDo(fn MoqValue_genType_SetLen_doFn) *MoqValue_genType_SetLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_SetLen_fnRecorder) DoReturnResults(fn MoqValue_genType_SetLen_doReturnFn) *MoqValue_genType_SetLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetLen_doFn
		DoReturnFn MoqValue_genType_SetLen_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_SetLen_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_SetLen_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetLen {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_SetLen_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_SetLen_paramsKey]*MoqValue_genType_SetLen_results{},
		}
		r.Moq.ResultsByParams_SetLen = append(r.Moq.ResultsByParams_SetLen, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetLen) {
			copy(r.Moq.ResultsByParams_SetLen[insertAt+1:], r.Moq.ResultsByParams_SetLen[insertAt:0])
			r.Moq.ResultsByParams_SetLen[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetLen(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_SetLen_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_SetLen_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_SetLen_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_SetLen_doFn
				DoReturnFn MoqValue_genType_SetLen_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_SetLen(params MoqValue_genType_SetLen_params) string {
	return fmt.Sprintf("SetLen(%#v)", params.N)
}

func (m *MoqValue_genType) ParamsKey_SetLen(params MoqValue_genType_SetLen_params, anyParams uint64) MoqValue_genType_SetLen_paramsKey {
	m.Scene.T.Helper()
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetLen.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqValue_genType_SetLen_paramsKey{
		Params: struct{ N int }{
			N: nUsed,
		},
		Hashes: struct{ N hash.Hash }{
			N: nUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) SetCap(n int) *MoqValue_genType_SetCap_fnRecorder {
	return &MoqValue_genType_SetCap_fnRecorder{
		Params: MoqValue_genType_SetCap_params{
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_SetCap_fnRecorder) Any() *MoqValue_genType_SetCap_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetCap(r.Params))
		return nil
	}
	return &MoqValue_genType_SetCap_anyParams{Recorder: r}
}

func (a *MoqValue_genType_SetCap_anyParams) N() *MoqValue_genType_SetCap_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_SetCap_fnRecorder) Seq() *MoqValue_genType_SetCap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetCap(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_SetCap_fnRecorder) NoSeq() *MoqValue_genType_SetCap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetCap(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_SetCap_fnRecorder) ReturnResults() *MoqValue_genType_SetCap_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetCap_doFn
		DoReturnFn MoqValue_genType_SetCap_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_SetCap_fnRecorder) AndDo(fn MoqValue_genType_SetCap_doFn) *MoqValue_genType_SetCap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_SetCap_fnRecorder) DoReturnResults(fn MoqValue_genType_SetCap_doReturnFn) *MoqValue_genType_SetCap_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetCap_doFn
		DoReturnFn MoqValue_genType_SetCap_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_SetCap_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_SetCap_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetCap {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_SetCap_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_SetCap_paramsKey]*MoqValue_genType_SetCap_results{},
		}
		r.Moq.ResultsByParams_SetCap = append(r.Moq.ResultsByParams_SetCap, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetCap) {
			copy(r.Moq.ResultsByParams_SetCap[insertAt+1:], r.Moq.ResultsByParams_SetCap[insertAt:0])
			r.Moq.ResultsByParams_SetCap[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetCap(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_SetCap_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_SetCap_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_SetCap_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_SetCap_doFn
				DoReturnFn MoqValue_genType_SetCap_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_SetCap(params MoqValue_genType_SetCap_params) string {
	return fmt.Sprintf("SetCap(%#v)", params.N)
}

func (m *MoqValue_genType) ParamsKey_SetCap(params MoqValue_genType_SetCap_params, anyParams uint64) MoqValue_genType_SetCap_paramsKey {
	m.Scene.T.Helper()
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetCap.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqValue_genType_SetCap_paramsKey{
		Params: struct{ N int }{
			N: nUsed,
		},
		Hashes: struct{ N hash.Hash }{
			N: nUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) SetMapIndex(key, elem reflect.Value) *MoqValue_genType_SetMapIndex_fnRecorder {
	return &MoqValue_genType_SetMapIndex_fnRecorder{
		Params: MoqValue_genType_SetMapIndex_params{
			Key:  key,
			Elem: elem,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_SetMapIndex_fnRecorder) Any() *MoqValue_genType_SetMapIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetMapIndex(r.Params))
		return nil
	}
	return &MoqValue_genType_SetMapIndex_anyParams{Recorder: r}
}

func (a *MoqValue_genType_SetMapIndex_anyParams) Key() *MoqValue_genType_SetMapIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqValue_genType_SetMapIndex_anyParams) Elem() *MoqValue_genType_SetMapIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqValue_genType_SetMapIndex_fnRecorder) Seq() *MoqValue_genType_SetMapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetMapIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_SetMapIndex_fnRecorder) NoSeq() *MoqValue_genType_SetMapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetMapIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_SetMapIndex_fnRecorder) ReturnResults() *MoqValue_genType_SetMapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetMapIndex_doFn
		DoReturnFn MoqValue_genType_SetMapIndex_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_SetMapIndex_fnRecorder) AndDo(fn MoqValue_genType_SetMapIndex_doFn) *MoqValue_genType_SetMapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_SetMapIndex_fnRecorder) DoReturnResults(fn MoqValue_genType_SetMapIndex_doReturnFn) *MoqValue_genType_SetMapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetMapIndex_doFn
		DoReturnFn MoqValue_genType_SetMapIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_SetMapIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_SetMapIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetMapIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_SetMapIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_SetMapIndex_paramsKey]*MoqValue_genType_SetMapIndex_results{},
		}
		r.Moq.ResultsByParams_SetMapIndex = append(r.Moq.ResultsByParams_SetMapIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetMapIndex) {
			copy(r.Moq.ResultsByParams_SetMapIndex[insertAt+1:], r.Moq.ResultsByParams_SetMapIndex[insertAt:0])
			r.Moq.ResultsByParams_SetMapIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetMapIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_SetMapIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_SetMapIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_SetMapIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_SetMapIndex_doFn
				DoReturnFn MoqValue_genType_SetMapIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_SetMapIndex(params MoqValue_genType_SetMapIndex_params) string {
	return fmt.Sprintf("SetMapIndex(%#v, %#v)", params.Key, params.Elem)
}

func (m *MoqValue_genType) ParamsKey_SetMapIndex(params MoqValue_genType_SetMapIndex_params, anyParams uint64) MoqValue_genType_SetMapIndex_paramsKey {
	m.Scene.T.Helper()
	var keyUsed reflect.Value
	var keyUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetMapIndex.Key == moq.ParamIndexByValue {
			keyUsed = params.Key
		} else {
			keyUsedHash = hash.DeepHash(params.Key)
		}
	}
	var elemUsed reflect.Value
	var elemUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.SetMapIndex.Elem == moq.ParamIndexByValue {
			elemUsed = params.Elem
		} else {
			elemUsedHash = hash.DeepHash(params.Elem)
		}
	}
	return MoqValue_genType_SetMapIndex_paramsKey{
		Params: struct{ Key, Elem reflect.Value }{
			Key:  keyUsed,
			Elem: elemUsed,
		},
		Hashes: struct{ Key, Elem hash.Hash }{
			Key:  keyUsedHash,
			Elem: elemUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) SetUint(x uint64) *MoqValue_genType_SetUint_fnRecorder {
	return &MoqValue_genType_SetUint_fnRecorder{
		Params: MoqValue_genType_SetUint_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_SetUint_fnRecorder) Any() *MoqValue_genType_SetUint_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint(r.Params))
		return nil
	}
	return &MoqValue_genType_SetUint_anyParams{Recorder: r}
}

func (a *MoqValue_genType_SetUint_anyParams) X() *MoqValue_genType_SetUint_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_SetUint_fnRecorder) Seq() *MoqValue_genType_SetUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_SetUint_fnRecorder) NoSeq() *MoqValue_genType_SetUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetUint(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_SetUint_fnRecorder) ReturnResults() *MoqValue_genType_SetUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetUint_doFn
		DoReturnFn MoqValue_genType_SetUint_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_SetUint_fnRecorder) AndDo(fn MoqValue_genType_SetUint_doFn) *MoqValue_genType_SetUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_SetUint_fnRecorder) DoReturnResults(fn MoqValue_genType_SetUint_doReturnFn) *MoqValue_genType_SetUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetUint_doFn
		DoReturnFn MoqValue_genType_SetUint_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_SetUint_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_SetUint_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetUint {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_SetUint_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_SetUint_paramsKey]*MoqValue_genType_SetUint_results{},
		}
		r.Moq.ResultsByParams_SetUint = append(r.Moq.ResultsByParams_SetUint, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetUint) {
			copy(r.Moq.ResultsByParams_SetUint[insertAt+1:], r.Moq.ResultsByParams_SetUint[insertAt:0])
			r.Moq.ResultsByParams_SetUint[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetUint(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_SetUint_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_SetUint_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_SetUint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_SetUint_doFn
				DoReturnFn MoqValue_genType_SetUint_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_SetUint(params MoqValue_genType_SetUint_params) string {
	return fmt.Sprintf("SetUint(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_SetUint(params MoqValue_genType_SetUint_params, anyParams uint64) MoqValue_genType_SetUint_paramsKey {
	m.Scene.T.Helper()
	var xUsed uint64
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetUint.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_SetUint_paramsKey{
		Params: struct{ X uint64 }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) SetPointer(x unsafe.Pointer) *MoqValue_genType_SetPointer_fnRecorder {
	return &MoqValue_genType_SetPointer_fnRecorder{
		Params: MoqValue_genType_SetPointer_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_SetPointer_fnRecorder) Any() *MoqValue_genType_SetPointer_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetPointer(r.Params))
		return nil
	}
	return &MoqValue_genType_SetPointer_anyParams{Recorder: r}
}

func (a *MoqValue_genType_SetPointer_anyParams) X() *MoqValue_genType_SetPointer_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_SetPointer_fnRecorder) Seq() *MoqValue_genType_SetPointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetPointer(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_SetPointer_fnRecorder) NoSeq() *MoqValue_genType_SetPointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetPointer(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_SetPointer_fnRecorder) ReturnResults() *MoqValue_genType_SetPointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetPointer_doFn
		DoReturnFn MoqValue_genType_SetPointer_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_SetPointer_fnRecorder) AndDo(fn MoqValue_genType_SetPointer_doFn) *MoqValue_genType_SetPointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_SetPointer_fnRecorder) DoReturnResults(fn MoqValue_genType_SetPointer_doReturnFn) *MoqValue_genType_SetPointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetPointer_doFn
		DoReturnFn MoqValue_genType_SetPointer_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_SetPointer_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_SetPointer_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetPointer {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_SetPointer_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_SetPointer_paramsKey]*MoqValue_genType_SetPointer_results{},
		}
		r.Moq.ResultsByParams_SetPointer = append(r.Moq.ResultsByParams_SetPointer, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetPointer) {
			copy(r.Moq.ResultsByParams_SetPointer[insertAt+1:], r.Moq.ResultsByParams_SetPointer[insertAt:0])
			r.Moq.ResultsByParams_SetPointer[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetPointer(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_SetPointer_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_SetPointer_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_SetPointer_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_SetPointer_doFn
				DoReturnFn MoqValue_genType_SetPointer_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_SetPointer(params MoqValue_genType_SetPointer_params) string {
	return fmt.Sprintf("SetPointer(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_SetPointer(params MoqValue_genType_SetPointer_params, anyParams uint64) MoqValue_genType_SetPointer_paramsKey {
	m.Scene.T.Helper()
	var xUsed unsafe.Pointer
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetPointer.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_SetPointer_paramsKey{
		Params: struct{ X unsafe.Pointer }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) SetString(x string) *MoqValue_genType_SetString_fnRecorder {
	return &MoqValue_genType_SetString_fnRecorder{
		Params: MoqValue_genType_SetString_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_SetString_fnRecorder) Any() *MoqValue_genType_SetString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	return &MoqValue_genType_SetString_anyParams{Recorder: r}
}

func (a *MoqValue_genType_SetString_anyParams) X() *MoqValue_genType_SetString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_SetString_fnRecorder) Seq() *MoqValue_genType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_SetString_fnRecorder) NoSeq() *MoqValue_genType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SetString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_SetString_fnRecorder) ReturnResults() *MoqValue_genType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetString_doFn
		DoReturnFn MoqValue_genType_SetString_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_SetString_fnRecorder) AndDo(fn MoqValue_genType_SetString_doFn) *MoqValue_genType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_SetString_fnRecorder) DoReturnResults(fn MoqValue_genType_SetString_doReturnFn) *MoqValue_genType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqValue_genType_SetString_doFn
		DoReturnFn MoqValue_genType_SetString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_SetString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_SetString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SetString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_SetString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_SetString_paramsKey]*MoqValue_genType_SetString_results{},
		}
		r.Moq.ResultsByParams_SetString = append(r.Moq.ResultsByParams_SetString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SetString) {
			copy(r.Moq.ResultsByParams_SetString[insertAt+1:], r.Moq.ResultsByParams_SetString[insertAt:0])
			r.Moq.ResultsByParams_SetString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SetString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_SetString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_SetString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_SetString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqValue_genType_SetString_doFn
				DoReturnFn MoqValue_genType_SetString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_SetString(params MoqValue_genType_SetString_params) string {
	return fmt.Sprintf("SetString(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_SetString(params MoqValue_genType_SetString_params, anyParams uint64) MoqValue_genType_SetString_paramsKey {
	m.Scene.T.Helper()
	var xUsed string
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SetString.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_SetString_paramsKey{
		Params: struct{ X string }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) Slice(param1, j int) *MoqValue_genType_Slice_fnRecorder {
	return &MoqValue_genType_Slice_fnRecorder{
		Params: MoqValue_genType_Slice_params{
			Param1: param1,
			J:      j,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Slice_fnRecorder) Any() *MoqValue_genType_Slice_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Slice(r.Params))
		return nil
	}
	return &MoqValue_genType_Slice_anyParams{Recorder: r}
}

func (a *MoqValue_genType_Slice_anyParams) Param1() *MoqValue_genType_Slice_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqValue_genType_Slice_anyParams) J() *MoqValue_genType_Slice_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqValue_genType_Slice_fnRecorder) Seq() *MoqValue_genType_Slice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Slice(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Slice_fnRecorder) NoSeq() *MoqValue_genType_Slice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Slice(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Slice_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_Slice_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Slice_doFn
		DoReturnFn MoqValue_genType_Slice_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Slice_fnRecorder) AndDo(fn MoqValue_genType_Slice_doFn) *MoqValue_genType_Slice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Slice_fnRecorder) DoReturnResults(fn MoqValue_genType_Slice_doReturnFn) *MoqValue_genType_Slice_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Slice_doFn
		DoReturnFn MoqValue_genType_Slice_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Slice_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Slice_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Slice {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Slice_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Slice_paramsKey]*MoqValue_genType_Slice_results{},
		}
		r.Moq.ResultsByParams_Slice = append(r.Moq.ResultsByParams_Slice, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Slice) {
			copy(r.Moq.ResultsByParams_Slice[insertAt+1:], r.Moq.ResultsByParams_Slice[insertAt:0])
			r.Moq.ResultsByParams_Slice[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Slice(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Slice_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Slice_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Slice_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Slice_doFn
				DoReturnFn MoqValue_genType_Slice_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Slice(params MoqValue_genType_Slice_params) string {
	return fmt.Sprintf("Slice(%#v, %#v)", params.Param1, params.J)
}

func (m *MoqValue_genType) ParamsKey_Slice(params MoqValue_genType_Slice_params, anyParams uint64) MoqValue_genType_Slice_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Slice.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	var jUsed int
	var jUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Slice.J == moq.ParamIndexByValue {
			jUsed = params.J
		} else {
			jUsedHash = hash.DeepHash(params.J)
		}
	}
	return MoqValue_genType_Slice_paramsKey{
		Params: struct{ Param1, J int }{
			Param1: param1Used,
			J:      jUsed,
		},
		Hashes: struct{ Param1, J hash.Hash }{
			Param1: param1UsedHash,
			J:      jUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) Slice3(param1, j, k int) *MoqValue_genType_Slice3_fnRecorder {
	return &MoqValue_genType_Slice3_fnRecorder{
		Params: MoqValue_genType_Slice3_params{
			Param1: param1,
			J:      j,
			K:      k,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Slice3_fnRecorder) Any() *MoqValue_genType_Slice3_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Slice3(r.Params))
		return nil
	}
	return &MoqValue_genType_Slice3_anyParams{Recorder: r}
}

func (a *MoqValue_genType_Slice3_anyParams) Param1() *MoqValue_genType_Slice3_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqValue_genType_Slice3_anyParams) J() *MoqValue_genType_Slice3_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqValue_genType_Slice3_anyParams) K() *MoqValue_genType_Slice3_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqValue_genType_Slice3_fnRecorder) Seq() *MoqValue_genType_Slice3_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Slice3(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Slice3_fnRecorder) NoSeq() *MoqValue_genType_Slice3_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Slice3(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Slice3_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_Slice3_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Slice3_doFn
		DoReturnFn MoqValue_genType_Slice3_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Slice3_fnRecorder) AndDo(fn MoqValue_genType_Slice3_doFn) *MoqValue_genType_Slice3_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Slice3_fnRecorder) DoReturnResults(fn MoqValue_genType_Slice3_doReturnFn) *MoqValue_genType_Slice3_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Slice3_doFn
		DoReturnFn MoqValue_genType_Slice3_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Slice3_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Slice3_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Slice3 {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Slice3_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Slice3_paramsKey]*MoqValue_genType_Slice3_results{},
		}
		r.Moq.ResultsByParams_Slice3 = append(r.Moq.ResultsByParams_Slice3, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Slice3) {
			copy(r.Moq.ResultsByParams_Slice3[insertAt+1:], r.Moq.ResultsByParams_Slice3[insertAt:0])
			r.Moq.ResultsByParams_Slice3[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Slice3(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Slice3_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Slice3_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Slice3_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Slice3_doFn
				DoReturnFn MoqValue_genType_Slice3_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Slice3(params MoqValue_genType_Slice3_params) string {
	return fmt.Sprintf("Slice3(%#v, %#v, %#v)", params.Param1, params.J, params.K)
}

func (m *MoqValue_genType) ParamsKey_Slice3(params MoqValue_genType_Slice3_params, anyParams uint64) MoqValue_genType_Slice3_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Slice3.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	var jUsed int
	var jUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Slice3.J == moq.ParamIndexByValue {
			jUsed = params.J
		} else {
			jUsedHash = hash.DeepHash(params.J)
		}
	}
	var kUsed int
	var kUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.Slice3.K == moq.ParamIndexByValue {
			kUsed = params.K
		} else {
			kUsedHash = hash.DeepHash(params.K)
		}
	}
	return MoqValue_genType_Slice3_paramsKey{
		Params: struct{ Param1, J, K int }{
			Param1: param1Used,
			J:      jUsed,
			K:      kUsed,
		},
		Hashes: struct{ Param1, J, K hash.Hash }{
			Param1: param1UsedHash,
			J:      jUsedHash,
			K:      kUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) String() *MoqValue_genType_String_fnRecorder {
	return &MoqValue_genType_String_fnRecorder{
		Params:   MoqValue_genType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_String_fnRecorder) Any() *MoqValue_genType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqValue_genType_String_anyParams{Recorder: r}
}

func (r *MoqValue_genType_String_fnRecorder) Seq() *MoqValue_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_String_fnRecorder) NoSeq() *MoqValue_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_String_fnRecorder) ReturnResults(result1 string) *MoqValue_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqValue_genType_String_doFn
		DoReturnFn MoqValue_genType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_String_fnRecorder) AndDo(fn MoqValue_genType_String_doFn) *MoqValue_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_String_fnRecorder) DoReturnResults(fn MoqValue_genType_String_doReturnFn) *MoqValue_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqValue_genType_String_doFn
		DoReturnFn MoqValue_genType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_String_paramsKey]*MoqValue_genType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqValue_genType_String_doFn
				DoReturnFn MoqValue_genType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_String(params MoqValue_genType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqValue_genType) ParamsKey_String(params MoqValue_genType_String_params, anyParams uint64) MoqValue_genType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) TryRecv() *MoqValue_genType_TryRecv_fnRecorder {
	return &MoqValue_genType_TryRecv_fnRecorder{
		Params:   MoqValue_genType_TryRecv_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_TryRecv_fnRecorder) Any() *MoqValue_genType_TryRecv_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TryRecv(r.Params))
		return nil
	}
	return &MoqValue_genType_TryRecv_anyParams{Recorder: r}
}

func (r *MoqValue_genType_TryRecv_fnRecorder) Seq() *MoqValue_genType_TryRecv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TryRecv(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_TryRecv_fnRecorder) NoSeq() *MoqValue_genType_TryRecv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TryRecv(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_TryRecv_fnRecorder) ReturnResults(x reflect.Value, ok bool) *MoqValue_genType_TryRecv_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			X  reflect.Value
			Ok bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_TryRecv_doFn
		DoReturnFn MoqValue_genType_TryRecv_doReturnFn
	}{
		Values: &struct {
			X  reflect.Value
			Ok bool
		}{
			X:  x,
			Ok: ok,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_TryRecv_fnRecorder) AndDo(fn MoqValue_genType_TryRecv_doFn) *MoqValue_genType_TryRecv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_TryRecv_fnRecorder) DoReturnResults(fn MoqValue_genType_TryRecv_doReturnFn) *MoqValue_genType_TryRecv_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			X  reflect.Value
			Ok bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_TryRecv_doFn
		DoReturnFn MoqValue_genType_TryRecv_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_TryRecv_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_TryRecv_resultsByParams
	for n, res := range r.Moq.ResultsByParams_TryRecv {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_TryRecv_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_TryRecv_paramsKey]*MoqValue_genType_TryRecv_results{},
		}
		r.Moq.ResultsByParams_TryRecv = append(r.Moq.ResultsByParams_TryRecv, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_TryRecv) {
			copy(r.Moq.ResultsByParams_TryRecv[insertAt+1:], r.Moq.ResultsByParams_TryRecv[insertAt:0])
			r.Moq.ResultsByParams_TryRecv[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_TryRecv(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_TryRecv_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_TryRecv_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_TryRecv_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					X  reflect.Value
					Ok bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_TryRecv_doFn
				DoReturnFn MoqValue_genType_TryRecv_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_TryRecv(params MoqValue_genType_TryRecv_params) string {
	return fmt.Sprintf("TryRecv()")
}

func (m *MoqValue_genType) ParamsKey_TryRecv(params MoqValue_genType_TryRecv_params, anyParams uint64) MoqValue_genType_TryRecv_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_TryRecv_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) TrySend(x reflect.Value) *MoqValue_genType_TrySend_fnRecorder {
	return &MoqValue_genType_TrySend_fnRecorder{
		Params: MoqValue_genType_TrySend_params{
			X: x,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_TrySend_fnRecorder) Any() *MoqValue_genType_TrySend_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TrySend(r.Params))
		return nil
	}
	return &MoqValue_genType_TrySend_anyParams{Recorder: r}
}

func (a *MoqValue_genType_TrySend_anyParams) X() *MoqValue_genType_TrySend_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_TrySend_fnRecorder) Seq() *MoqValue_genType_TrySend_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TrySend(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_TrySend_fnRecorder) NoSeq() *MoqValue_genType_TrySend_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TrySend(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_TrySend_fnRecorder) ReturnResults(result1 bool) *MoqValue_genType_TrySend_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_TrySend_doFn
		DoReturnFn MoqValue_genType_TrySend_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_TrySend_fnRecorder) AndDo(fn MoqValue_genType_TrySend_doFn) *MoqValue_genType_TrySend_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_TrySend_fnRecorder) DoReturnResults(fn MoqValue_genType_TrySend_doReturnFn) *MoqValue_genType_TrySend_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqValue_genType_TrySend_doFn
		DoReturnFn MoqValue_genType_TrySend_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_TrySend_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_TrySend_resultsByParams
	for n, res := range r.Moq.ResultsByParams_TrySend {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_TrySend_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_TrySend_paramsKey]*MoqValue_genType_TrySend_results{},
		}
		r.Moq.ResultsByParams_TrySend = append(r.Moq.ResultsByParams_TrySend, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_TrySend) {
			copy(r.Moq.ResultsByParams_TrySend[insertAt+1:], r.Moq.ResultsByParams_TrySend[insertAt:0])
			r.Moq.ResultsByParams_TrySend[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_TrySend(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_TrySend_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_TrySend_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_TrySend_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqValue_genType_TrySend_doFn
				DoReturnFn MoqValue_genType_TrySend_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_TrySend(params MoqValue_genType_TrySend_params) string {
	return fmt.Sprintf("TrySend(%#v)", params.X)
}

func (m *MoqValue_genType) ParamsKey_TrySend(params MoqValue_genType_TrySend_params, anyParams uint64) MoqValue_genType_TrySend_paramsKey {
	m.Scene.T.Helper()
	var xUsed reflect.Value
	var xUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.TrySend.X == moq.ParamIndexByValue {
			xUsed = params.X
		} else {
			xUsedHash = hash.DeepHash(params.X)
		}
	}
	return MoqValue_genType_TrySend_paramsKey{
		Params: struct{ X reflect.Value }{
			X: xUsed,
		},
		Hashes: struct{ X hash.Hash }{
			X: xUsedHash,
		},
	}
}

func (m *MoqValue_genType_recorder) Type() *MoqValue_genType_Type_fnRecorder {
	return &MoqValue_genType_Type_fnRecorder{
		Params:   MoqValue_genType_Type_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Type_fnRecorder) Any() *MoqValue_genType_Type_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Type(r.Params))
		return nil
	}
	return &MoqValue_genType_Type_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Type_fnRecorder) Seq() *MoqValue_genType_Type_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Type(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Type_fnRecorder) NoSeq() *MoqValue_genType_Type_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Type(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Type_fnRecorder) ReturnResults(result1 reflect.Type) *MoqValue_genType_Type_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Type_doFn
		DoReturnFn MoqValue_genType_Type_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Type
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Type_fnRecorder) AndDo(fn MoqValue_genType_Type_doFn) *MoqValue_genType_Type_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Type_fnRecorder) DoReturnResults(fn MoqValue_genType_Type_doReturnFn) *MoqValue_genType_Type_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Type_doFn
		DoReturnFn MoqValue_genType_Type_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Type_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Type_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Type {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Type_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Type_paramsKey]*MoqValue_genType_Type_results{},
		}
		r.Moq.ResultsByParams_Type = append(r.Moq.ResultsByParams_Type, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Type) {
			copy(r.Moq.ResultsByParams_Type[insertAt+1:], r.Moq.ResultsByParams_Type[insertAt:0])
			r.Moq.ResultsByParams_Type[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Type(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Type_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Type_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Type_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Type
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Type_doFn
				DoReturnFn MoqValue_genType_Type_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Type(params MoqValue_genType_Type_params) string {
	return fmt.Sprintf("Type()")
}

func (m *MoqValue_genType) ParamsKey_Type(params MoqValue_genType_Type_params, anyParams uint64) MoqValue_genType_Type_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Type_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Uint() *MoqValue_genType_Uint_fnRecorder {
	return &MoqValue_genType_Uint_fnRecorder{
		Params:   MoqValue_genType_Uint_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Uint_fnRecorder) Any() *MoqValue_genType_Uint_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Uint(r.Params))
		return nil
	}
	return &MoqValue_genType_Uint_anyParams{Recorder: r}
}

func (r *MoqValue_genType_Uint_fnRecorder) Seq() *MoqValue_genType_Uint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Uint(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Uint_fnRecorder) NoSeq() *MoqValue_genType_Uint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Uint(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Uint_fnRecorder) ReturnResults(result1 uint64) *MoqValue_genType_Uint_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint64
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Uint_doFn
		DoReturnFn MoqValue_genType_Uint_doReturnFn
	}{
		Values: &struct {
			Result1 uint64
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Uint_fnRecorder) AndDo(fn MoqValue_genType_Uint_doFn) *MoqValue_genType_Uint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Uint_fnRecorder) DoReturnResults(fn MoqValue_genType_Uint_doReturnFn) *MoqValue_genType_Uint_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uint64
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Uint_doFn
		DoReturnFn MoqValue_genType_Uint_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Uint_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Uint_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Uint {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Uint_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Uint_paramsKey]*MoqValue_genType_Uint_results{},
		}
		r.Moq.ResultsByParams_Uint = append(r.Moq.ResultsByParams_Uint, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Uint) {
			copy(r.Moq.ResultsByParams_Uint[insertAt+1:], r.Moq.ResultsByParams_Uint[insertAt:0])
			r.Moq.ResultsByParams_Uint[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Uint(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Uint_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Uint_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Uint_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 uint64
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Uint_doFn
				DoReturnFn MoqValue_genType_Uint_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Uint(params MoqValue_genType_Uint_params) string {
	return fmt.Sprintf("Uint()")
}

func (m *MoqValue_genType) ParamsKey_Uint(params MoqValue_genType_Uint_params, anyParams uint64) MoqValue_genType_Uint_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_Uint_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) UnsafeAddr() *MoqValue_genType_UnsafeAddr_fnRecorder {
	return &MoqValue_genType_UnsafeAddr_fnRecorder{
		Params:   MoqValue_genType_UnsafeAddr_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_UnsafeAddr_fnRecorder) Any() *MoqValue_genType_UnsafeAddr_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnsafeAddr(r.Params))
		return nil
	}
	return &MoqValue_genType_UnsafeAddr_anyParams{Recorder: r}
}

func (r *MoqValue_genType_UnsafeAddr_fnRecorder) Seq() *MoqValue_genType_UnsafeAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnsafeAddr(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_UnsafeAddr_fnRecorder) NoSeq() *MoqValue_genType_UnsafeAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnsafeAddr(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_UnsafeAddr_fnRecorder) ReturnResults(result1 uintptr) *MoqValue_genType_UnsafeAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqValue_genType_UnsafeAddr_doFn
		DoReturnFn MoqValue_genType_UnsafeAddr_doReturnFn
	}{
		Values: &struct {
			Result1 uintptr
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_UnsafeAddr_fnRecorder) AndDo(fn MoqValue_genType_UnsafeAddr_doFn) *MoqValue_genType_UnsafeAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_UnsafeAddr_fnRecorder) DoReturnResults(fn MoqValue_genType_UnsafeAddr_doReturnFn) *MoqValue_genType_UnsafeAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqValue_genType_UnsafeAddr_doFn
		DoReturnFn MoqValue_genType_UnsafeAddr_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_UnsafeAddr_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_UnsafeAddr_resultsByParams
	for n, res := range r.Moq.ResultsByParams_UnsafeAddr {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_UnsafeAddr_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_UnsafeAddr_paramsKey]*MoqValue_genType_UnsafeAddr_results{},
		}
		r.Moq.ResultsByParams_UnsafeAddr = append(r.Moq.ResultsByParams_UnsafeAddr, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_UnsafeAddr) {
			copy(r.Moq.ResultsByParams_UnsafeAddr[insertAt+1:], r.Moq.ResultsByParams_UnsafeAddr[insertAt:0])
			r.Moq.ResultsByParams_UnsafeAddr[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_UnsafeAddr(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_UnsafeAddr_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_UnsafeAddr_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_UnsafeAddr_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 uintptr
				}
				Sequence   uint32
				DoFn       MoqValue_genType_UnsafeAddr_doFn
				DoReturnFn MoqValue_genType_UnsafeAddr_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_UnsafeAddr(params MoqValue_genType_UnsafeAddr_params) string {
	return fmt.Sprintf("UnsafeAddr()")
}

func (m *MoqValue_genType) ParamsKey_UnsafeAddr(params MoqValue_genType_UnsafeAddr_params, anyParams uint64) MoqValue_genType_UnsafeAddr_paramsKey {
	m.Scene.T.Helper()
	return MoqValue_genType_UnsafeAddr_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqValue_genType_recorder) Convert(t reflect.Type) *MoqValue_genType_Convert_fnRecorder {
	return &MoqValue_genType_Convert_fnRecorder{
		Params: MoqValue_genType_Convert_params{
			T: t,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqValue_genType_Convert_fnRecorder) Any() *MoqValue_genType_Convert_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Convert(r.Params))
		return nil
	}
	return &MoqValue_genType_Convert_anyParams{Recorder: r}
}

func (a *MoqValue_genType_Convert_anyParams) T() *MoqValue_genType_Convert_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqValue_genType_Convert_fnRecorder) Seq() *MoqValue_genType_Convert_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Convert(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqValue_genType_Convert_fnRecorder) NoSeq() *MoqValue_genType_Convert_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Convert(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqValue_genType_Convert_fnRecorder) ReturnResults(result1 reflect.Value) *MoqValue_genType_Convert_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Convert_doFn
		DoReturnFn MoqValue_genType_Convert_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Value
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqValue_genType_Convert_fnRecorder) AndDo(fn MoqValue_genType_Convert_doFn) *MoqValue_genType_Convert_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqValue_genType_Convert_fnRecorder) DoReturnResults(fn MoqValue_genType_Convert_doReturnFn) *MoqValue_genType_Convert_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Value
		}
		Sequence   uint32
		DoFn       MoqValue_genType_Convert_doFn
		DoReturnFn MoqValue_genType_Convert_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqValue_genType_Convert_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqValue_genType_Convert_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Convert {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqValue_genType_Convert_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqValue_genType_Convert_paramsKey]*MoqValue_genType_Convert_results{},
		}
		r.Moq.ResultsByParams_Convert = append(r.Moq.ResultsByParams_Convert, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Convert) {
			copy(r.Moq.ResultsByParams_Convert[insertAt+1:], r.Moq.ResultsByParams_Convert[insertAt:0])
			r.Moq.ResultsByParams_Convert[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Convert(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqValue_genType_Convert_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqValue_genType_Convert_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqValue_genType_Convert_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Value
				}
				Sequence   uint32
				DoFn       MoqValue_genType_Convert_doFn
				DoReturnFn MoqValue_genType_Convert_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqValue_genType) PrettyParams_Convert(params MoqValue_genType_Convert_params) string {
	return fmt.Sprintf("Convert(%#v)", params.T)
}

func (m *MoqValue_genType) ParamsKey_Convert(params MoqValue_genType_Convert_params, anyParams uint64) MoqValue_genType_Convert_paramsKey {
	m.Scene.T.Helper()
	var tUsed reflect.Type
	var tUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Convert.T == moq.ParamIndexByValue {
			tUsed = params.T
		} else {
			tUsedHash = hash.DeepHash(params.T)
		}
	}
	return MoqValue_genType_Convert_paramsKey{
		Params: struct{ T reflect.Type }{
			T: tUsed,
		},
		Hashes: struct{ T hash.Hash }{
			T: tUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqValue_genType) Reset() {
	m.ResultsByParams_Addr = nil
	m.ResultsByParams_Bool = nil
	m.ResultsByParams_Bytes = nil
	m.ResultsByParams_CanAddr = nil
	m.ResultsByParams_CanSet = nil
	m.ResultsByParams_Call = nil
	m.ResultsByParams_CallSlice = nil
	m.ResultsByParams_Cap = nil
	m.ResultsByParams_Close = nil
	m.ResultsByParams_Complex = nil
	m.ResultsByParams_Elem = nil
	m.ResultsByParams_Field = nil
	m.ResultsByParams_FieldByIndex = nil
	m.ResultsByParams_FieldByName = nil
	m.ResultsByParams_FieldByNameFunc = nil
	m.ResultsByParams_Float = nil
	m.ResultsByParams_Index = nil
	m.ResultsByParams_Int = nil
	m.ResultsByParams_CanInterface = nil
	m.ResultsByParams_Interface = nil
	m.ResultsByParams_InterfaceData = nil
	m.ResultsByParams_IsNil = nil
	m.ResultsByParams_IsValid = nil
	m.ResultsByParams_IsZero = nil
	m.ResultsByParams_Kind = nil
	m.ResultsByParams_Len = nil
	m.ResultsByParams_MapIndex = nil
	m.ResultsByParams_MapKeys = nil
	m.ResultsByParams_MapRange = nil
	m.ResultsByParams_Method = nil
	m.ResultsByParams_NumMethod = nil
	m.ResultsByParams_MethodByName = nil
	m.ResultsByParams_NumField = nil
	m.ResultsByParams_OverflowComplex = nil
	m.ResultsByParams_OverflowFloat = nil
	m.ResultsByParams_OverflowInt = nil
	m.ResultsByParams_OverflowUint = nil
	m.ResultsByParams_Pointer = nil
	m.ResultsByParams_Recv = nil
	m.ResultsByParams_Send = nil
	m.ResultsByParams_Set = nil
	m.ResultsByParams_SetBool = nil
	m.ResultsByParams_SetBytes = nil
	m.ResultsByParams_SetComplex = nil
	m.ResultsByParams_SetFloat = nil
	m.ResultsByParams_SetInt = nil
	m.ResultsByParams_SetLen = nil
	m.ResultsByParams_SetCap = nil
	m.ResultsByParams_SetMapIndex = nil
	m.ResultsByParams_SetUint = nil
	m.ResultsByParams_SetPointer = nil
	m.ResultsByParams_SetString = nil
	m.ResultsByParams_Slice = nil
	m.ResultsByParams_Slice3 = nil
	m.ResultsByParams_String = nil
	m.ResultsByParams_TryRecv = nil
	m.ResultsByParams_TrySend = nil
	m.ResultsByParams_Type = nil
	m.ResultsByParams_Uint = nil
	m.ResultsByParams_UnsafeAddr = nil
	m.ResultsByParams_Convert = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqValue_genType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Addr {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Addr(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Bool {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Bool(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Bytes {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Bytes(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_CanAddr {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_CanAddr(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_CanSet {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_CanSet(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Call {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Call(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_CallSlice {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_CallSlice(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Cap {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Cap(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Close {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Close(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Complex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Complex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Elem {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Elem(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Field {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Field(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FieldByIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FieldByIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FieldByName {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FieldByName(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FieldByNameFunc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FieldByNameFunc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Float {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Float(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Index {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Index(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Int {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Int(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_CanInterface {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_CanInterface(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Interface {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Interface(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_InterfaceData {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_InterfaceData(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsNil {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsNil(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsValid {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsValid(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsZero {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsZero(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Kind {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Kind(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Len {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Len(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MapIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MapIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MapKeys {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MapKeys(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MapRange {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MapRange(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Method {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Method(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_NumMethod {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumMethod(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MethodByName {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MethodByName(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_NumField {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumField(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_OverflowComplex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_OverflowComplex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_OverflowFloat {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_OverflowFloat(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_OverflowInt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_OverflowInt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_OverflowUint {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_OverflowUint(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Pointer {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Pointer(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Recv {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Recv(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Send {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Send(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Set {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Set(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetBool {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetBool(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetBytes {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetBytes(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetComplex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetComplex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetFloat {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetFloat(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetInt {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetInt(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetLen {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetLen(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetCap {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetCap(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetMapIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetMapIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetUint {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetUint(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetPointer {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetPointer(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SetString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SetString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Slice {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Slice(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Slice3 {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Slice3(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_TryRecv {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_TryRecv(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_TrySend {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_TrySend(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Type {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Type(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Uint {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Uint(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_UnsafeAddr {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_UnsafeAddr(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Convert {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Convert(results.Params))
			}
		}
	}
}
