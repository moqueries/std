// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package reflect

import (
	"fmt"
	"math/bits"
	"reflect"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that Type_reduced is mocked completely
var _ Type_reduced = (*MoqType_mock)(nil)

// Type_reduced is the fabricated implementation type of this mock (emitted
// when the original interface contains non-exported methods)
type Type_reduced interface {
	// Methods applicable to all types.

	// Align returns the alignment in bytes of a value of
	// this type when allocated in memory.
	Align() int

	// FieldAlign returns the alignment in bytes of a value of
	// this type when used as a field in a struct.
	FieldAlign() int

	// Method returns the i'th method in the type's method set.
	// It panics if i is not in the range [0, NumMethod()).
	//
	// For a non-interface type T or *T, the returned Method's Type and Func
	// fields describe a function whose first argument is the receiver,
	// and only exported methods are accessible.
	//
	// For an interface type, the returned Method's Type field gives the
	// method signature, without a receiver, and the Func field is nil.
	//
	// Methods are sorted in lexicographic order.
	Method(int) reflect.Method

	// MethodByName returns the method with that name in the type's
	// method set and a boolean indicating if the method was found.
	//
	// For a non-interface type T or *T, the returned Method's Type and Func
	// fields describe a function whose first argument is the receiver.
	//
	// For an interface type, the returned Method's Type field gives the
	// method signature, without a receiver, and the Func field is nil.
	MethodByName(string) (reflect.Method, bool)

	// NumMethod returns the number of methods accessible using Method.
	//
	// Note that NumMethod counts unexported methods only for interface types.
	NumMethod() int

	// Name returns the type's name within its package for a defined type.
	// For other (non-defined) types it returns the empty string.
	Name() string

	// PkgPath returns a defined type's package path, that is, the import path
	// that uniquely identifies the package, such as "encoding/base64".
	// If the type was predeclared (string, error) or not defined (*T, struct{},
	// []int, or A where A is an alias for a non-defined type), the package path
	// will be the empty string.
	PkgPath() string

	// Size returns the number of bytes needed to store
	// a value of the given type; it is analogous to unsafe.Sizeof.
	Size() uintptr

	// String returns a string representation of the type.
	// The string representation may use shortened package names
	// (e.g., base64 instead of "encoding/base64") and is not
	// guaranteed to be unique among types. To test for type identity,
	// compare the Types directly.
	String() string

	// Kind returns the specific kind of this type.
	Kind() reflect.Kind

	// Implements reports whether the type implements the interface type u.
	Implements(u reflect.Type) bool

	// AssignableTo reports whether a value of the type is assignable to type u.
	AssignableTo(u reflect.Type) bool

	// ConvertibleTo reports whether a value of the type is convertible to type u.
	// Even if ConvertibleTo returns true, the conversion may still panic.
	// For example, a slice of type []T is convertible to *[N]T,
	// but the conversion will panic if its length is less than N.
	ConvertibleTo(u reflect.Type) bool

	// Comparable reports whether values of this type are comparable.
	// Even if Comparable returns true, the comparison may still panic.
	// For example, values of interface type are comparable,
	// but the comparison will panic if their dynamic type is not comparable.
	Comparable() bool

	// Methods applicable only to some types, depending on Kind.
	// The methods allowed for each kind are:
	//
	//	Int*, Uint*, Float*, Complex*: Bits
	//	Array: Elem, Len
	//	Chan: ChanDir, Elem
	//	Func: In, NumIn, Out, NumOut, IsVariadic.
	//	Map: Key, Elem
	//	Ptr: Elem
	//	Slice: Elem
	//	Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField

	// Bits returns the size of the type in bits.
	// It panics if the type's Kind is not one of the
	// sized or unsized Int, Uint, Float, or Complex kinds.
	Bits() int

	// ChanDir returns a channel type's direction.
	// It panics if the type's Kind is not Chan.
	ChanDir() reflect.ChanDir

	// IsVariadic reports whether a function type's final input parameter
	// is a "..." parameter. If so, t.In(t.NumIn() - 1) returns the parameter's
	// implicit actual type []T.
	//
	// For concreteness, if t represents func(x int, y ... float64), then
	//
	//	t.NumIn() == 2
	//	t.In(0) is the reflect.Type for "int"
	//	t.In(1) is the reflect.Type for "[]float64"
	//	t.IsVariadic() == true
	//
	// IsVariadic panics if the type's Kind is not Func.
	IsVariadic() bool

	// Elem returns a type's element type.
	// It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.
	Elem() reflect.Type

	// Field returns a struct type's i'th field.
	// It panics if the type's Kind is not Struct.
	// It panics if i is not in the range [0, NumField()).
	Field(i int) reflect.StructField

	// FieldByIndex returns the nested field corresponding
	// to the index sequence. It is equivalent to calling Field
	// successively for each index i.
	// It panics if the type's Kind is not Struct.
	FieldByIndex(index []int) reflect.StructField

	// FieldByName returns the struct field with the given name
	// and a boolean indicating if the field was found.
	FieldByName(name string) (reflect.StructField, bool)

	// FieldByNameFunc returns the struct field with a name
	// that satisfies the match function and a boolean indicating if
	// the field was found.
	//
	// FieldByNameFunc considers the fields in the struct itself
	// and then the fields in any embedded structs, in breadth first order,
	// stopping at the shallowest nesting depth containing one or more
	// fields satisfying the match function. If multiple fields at that depth
	// satisfy the match function, they cancel each other
	// and FieldByNameFunc returns no match.
	// This behavior mirrors Go's handling of name lookup in
	// structs containing embedded fields.
	FieldByNameFunc(match func(string) bool) (reflect.StructField, bool)

	// In returns the type of a function type's i'th input parameter.
	// It panics if the type's Kind is not Func.
	// It panics if i is not in the range [0, NumIn()).
	In(i int) reflect.Type

	// Key returns a map type's key type.
	// It panics if the type's Kind is not Map.
	Key() reflect.Type

	// Len returns an array type's length.
	// It panics if the type's Kind is not Array.
	Len() int

	// NumField returns a struct type's field count.
	// It panics if the type's Kind is not Struct.
	NumField() int

	// NumIn returns a function type's input parameter count.
	// It panics if the type's Kind is not Func.
	NumIn() int

	// NumOut returns a function type's output parameter count.
	// It panics if the type's Kind is not Func.
	NumOut() int

	// Out returns the type of a function type's i'th output parameter.
	// It panics if the type's Kind is not Func.
	// It panics if i is not in the range [0, NumOut()).
	Out(i int) reflect.Type
}

// MoqType holds the state of a moq of the Type_reduced type
type MoqType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqType_mock

	ResultsByParams_Align           []MoqType_Align_resultsByParams
	ResultsByParams_FieldAlign      []MoqType_FieldAlign_resultsByParams
	ResultsByParams_Method          []MoqType_Method_resultsByParams
	ResultsByParams_MethodByName    []MoqType_MethodByName_resultsByParams
	ResultsByParams_NumMethod       []MoqType_NumMethod_resultsByParams
	ResultsByParams_Name            []MoqType_Name_resultsByParams
	ResultsByParams_PkgPath         []MoqType_PkgPath_resultsByParams
	ResultsByParams_Size            []MoqType_Size_resultsByParams
	ResultsByParams_String          []MoqType_String_resultsByParams
	ResultsByParams_Kind            []MoqType_Kind_resultsByParams
	ResultsByParams_Implements      []MoqType_Implements_resultsByParams
	ResultsByParams_AssignableTo    []MoqType_AssignableTo_resultsByParams
	ResultsByParams_ConvertibleTo   []MoqType_ConvertibleTo_resultsByParams
	ResultsByParams_Comparable      []MoqType_Comparable_resultsByParams
	ResultsByParams_Bits            []MoqType_Bits_resultsByParams
	ResultsByParams_ChanDir         []MoqType_ChanDir_resultsByParams
	ResultsByParams_IsVariadic      []MoqType_IsVariadic_resultsByParams
	ResultsByParams_Elem            []MoqType_Elem_resultsByParams
	ResultsByParams_Field           []MoqType_Field_resultsByParams
	ResultsByParams_FieldByIndex    []MoqType_FieldByIndex_resultsByParams
	ResultsByParams_FieldByName     []MoqType_FieldByName_resultsByParams
	ResultsByParams_FieldByNameFunc []MoqType_FieldByNameFunc_resultsByParams
	ResultsByParams_In              []MoqType_In_resultsByParams
	ResultsByParams_Key             []MoqType_Key_resultsByParams
	ResultsByParams_Len             []MoqType_Len_resultsByParams
	ResultsByParams_NumField        []MoqType_NumField_resultsByParams
	ResultsByParams_NumIn           []MoqType_NumIn_resultsByParams
	ResultsByParams_NumOut          []MoqType_NumOut_resultsByParams
	ResultsByParams_Out             []MoqType_Out_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Align      struct{}
			FieldAlign struct{}
			Method     struct {
				Param1 moq.ParamIndexing
			}
			MethodByName struct {
				Param1 moq.ParamIndexing
			}
			NumMethod  struct{}
			Name       struct{}
			PkgPath    struct{}
			Size       struct{}
			String     struct{}
			Kind       struct{}
			Implements struct {
				U moq.ParamIndexing
			}
			AssignableTo struct {
				U moq.ParamIndexing
			}
			ConvertibleTo struct {
				U moq.ParamIndexing
			}
			Comparable struct{}
			Bits       struct{}
			ChanDir    struct{}
			IsVariadic struct{}
			Elem       struct{}
			Field      struct {
				Param1 moq.ParamIndexing
			}
			FieldByIndex struct {
				Index moq.ParamIndexing
			}
			FieldByName struct {
				Name moq.ParamIndexing
			}
			FieldByNameFunc struct {
				Match moq.ParamIndexing
			}
			In struct {
				Param1 moq.ParamIndexing
			}
			Key      struct{}
			Len      struct{}
			NumField struct{}
			NumIn    struct{}
			NumOut   struct{}
			Out      struct {
				Param1 moq.ParamIndexing
			}
		}
	}
	// MoqType_mock isolates the mock interface of the Type type
}

type MoqType_mock struct {
	Moq *MoqType
}

// MoqType_recorder isolates the recorder interface of the Type type
type MoqType_recorder struct {
	Moq *MoqType
}

// MoqType_Align_params holds the params of the Type type
type MoqType_Align_params struct{}

// MoqType_Align_paramsKey holds the map key params of the Type type
type MoqType_Align_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_Align_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Align_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Align_paramsKey]*MoqType_Align_results
}

// MoqType_Align_doFn defines the type of function needed when calling AndDo
// for the Type type
type MoqType_Align_doFn func()

// MoqType_Align_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_Align_doReturnFn func() int

// MoqType_Align_results holds the results of the Type type
type MoqType_Align_results struct {
	Params  MoqType_Align_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_Align_doFn
		DoReturnFn MoqType_Align_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Align_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_Align_fnRecorder struct {
	Params    MoqType_Align_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Align_results
	Moq       *MoqType
}

// MoqType_Align_anyParams isolates the any params functions of the Type type
type MoqType_Align_anyParams struct {
	Recorder *MoqType_Align_fnRecorder
}

// MoqType_FieldAlign_params holds the params of the Type type
type MoqType_FieldAlign_params struct{}

// MoqType_FieldAlign_paramsKey holds the map key params of the Type type
type MoqType_FieldAlign_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_FieldAlign_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_FieldAlign_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_FieldAlign_paramsKey]*MoqType_FieldAlign_results
}

// MoqType_FieldAlign_doFn defines the type of function needed when calling
// AndDo for the Type type
type MoqType_FieldAlign_doFn func()

// MoqType_FieldAlign_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Type type
type MoqType_FieldAlign_doReturnFn func() int

// MoqType_FieldAlign_results holds the results of the Type type
type MoqType_FieldAlign_results struct {
	Params  MoqType_FieldAlign_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_FieldAlign_doFn
		DoReturnFn MoqType_FieldAlign_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_FieldAlign_fnRecorder routes recorded function calls to the MoqType
// moq
type MoqType_FieldAlign_fnRecorder struct {
	Params    MoqType_FieldAlign_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_FieldAlign_results
	Moq       *MoqType
}

// MoqType_FieldAlign_anyParams isolates the any params functions of the Type
// type
type MoqType_FieldAlign_anyParams struct {
	Recorder *MoqType_FieldAlign_fnRecorder
}

// MoqType_Method_params holds the params of the Type type
type MoqType_Method_params struct{ Param1 int }

// MoqType_Method_paramsKey holds the map key params of the Type type
type MoqType_Method_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqType_Method_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Method_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Method_paramsKey]*MoqType_Method_results
}

// MoqType_Method_doFn defines the type of function needed when calling AndDo
// for the Type type
type MoqType_Method_doFn func(int)

// MoqType_Method_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_Method_doReturnFn func(int) reflect.Method

// MoqType_Method_results holds the results of the Type type
type MoqType_Method_results struct {
	Params  MoqType_Method_params
	Results []struct {
		Values *struct {
			Result1 reflect.Method
		}
		Sequence   uint32
		DoFn       MoqType_Method_doFn
		DoReturnFn MoqType_Method_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Method_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_Method_fnRecorder struct {
	Params    MoqType_Method_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Method_results
	Moq       *MoqType
}

// MoqType_Method_anyParams isolates the any params functions of the Type type
type MoqType_Method_anyParams struct {
	Recorder *MoqType_Method_fnRecorder
}

// MoqType_MethodByName_params holds the params of the Type type
type MoqType_MethodByName_params struct{ Param1 string }

// MoqType_MethodByName_paramsKey holds the map key params of the Type type
type MoqType_MethodByName_paramsKey struct {
	Params struct{ Param1 string }
	Hashes struct{ Param1 hash.Hash }
}

// MoqType_MethodByName_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_MethodByName_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_MethodByName_paramsKey]*MoqType_MethodByName_results
}

// MoqType_MethodByName_doFn defines the type of function needed when calling
// AndDo for the Type type
type MoqType_MethodByName_doFn func(string)

// MoqType_MethodByName_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Type type
type MoqType_MethodByName_doReturnFn func(string) (reflect.Method, bool)

// MoqType_MethodByName_results holds the results of the Type type
type MoqType_MethodByName_results struct {
	Params  MoqType_MethodByName_params
	Results []struct {
		Values *struct {
			Result1 reflect.Method
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqType_MethodByName_doFn
		DoReturnFn MoqType_MethodByName_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_MethodByName_fnRecorder routes recorded function calls to the
// MoqType moq
type MoqType_MethodByName_fnRecorder struct {
	Params    MoqType_MethodByName_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_MethodByName_results
	Moq       *MoqType
}

// MoqType_MethodByName_anyParams isolates the any params functions of the Type
// type
type MoqType_MethodByName_anyParams struct {
	Recorder *MoqType_MethodByName_fnRecorder
}

// MoqType_NumMethod_params holds the params of the Type type
type MoqType_NumMethod_params struct{}

// MoqType_NumMethod_paramsKey holds the map key params of the Type type
type MoqType_NumMethod_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_NumMethod_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_NumMethod_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_NumMethod_paramsKey]*MoqType_NumMethod_results
}

// MoqType_NumMethod_doFn defines the type of function needed when calling
// AndDo for the Type type
type MoqType_NumMethod_doFn func()

// MoqType_NumMethod_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Type type
type MoqType_NumMethod_doReturnFn func() int

// MoqType_NumMethod_results holds the results of the Type type
type MoqType_NumMethod_results struct {
	Params  MoqType_NumMethod_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumMethod_doFn
		DoReturnFn MoqType_NumMethod_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_NumMethod_fnRecorder routes recorded function calls to the MoqType
// moq
type MoqType_NumMethod_fnRecorder struct {
	Params    MoqType_NumMethod_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_NumMethod_results
	Moq       *MoqType
}

// MoqType_NumMethod_anyParams isolates the any params functions of the Type
// type
type MoqType_NumMethod_anyParams struct {
	Recorder *MoqType_NumMethod_fnRecorder
}

// MoqType_Name_params holds the params of the Type type
type MoqType_Name_params struct{}

// MoqType_Name_paramsKey holds the map key params of the Type type
type MoqType_Name_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_Name_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Name_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Name_paramsKey]*MoqType_Name_results
}

// MoqType_Name_doFn defines the type of function needed when calling AndDo for
// the Type type
type MoqType_Name_doFn func()

// MoqType_Name_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_Name_doReturnFn func() string

// MoqType_Name_results holds the results of the Type type
type MoqType_Name_results struct {
	Params  MoqType_Name_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqType_Name_doFn
		DoReturnFn MoqType_Name_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Name_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_Name_fnRecorder struct {
	Params    MoqType_Name_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Name_results
	Moq       *MoqType
}

// MoqType_Name_anyParams isolates the any params functions of the Type type
type MoqType_Name_anyParams struct {
	Recorder *MoqType_Name_fnRecorder
}

// MoqType_PkgPath_params holds the params of the Type type
type MoqType_PkgPath_params struct{}

// MoqType_PkgPath_paramsKey holds the map key params of the Type type
type MoqType_PkgPath_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_PkgPath_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_PkgPath_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_PkgPath_paramsKey]*MoqType_PkgPath_results
}

// MoqType_PkgPath_doFn defines the type of function needed when calling AndDo
// for the Type type
type MoqType_PkgPath_doFn func()

// MoqType_PkgPath_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_PkgPath_doReturnFn func() string

// MoqType_PkgPath_results holds the results of the Type type
type MoqType_PkgPath_results struct {
	Params  MoqType_PkgPath_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqType_PkgPath_doFn
		DoReturnFn MoqType_PkgPath_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_PkgPath_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_PkgPath_fnRecorder struct {
	Params    MoqType_PkgPath_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_PkgPath_results
	Moq       *MoqType
}

// MoqType_PkgPath_anyParams isolates the any params functions of the Type type
type MoqType_PkgPath_anyParams struct {
	Recorder *MoqType_PkgPath_fnRecorder
}

// MoqType_Size_params holds the params of the Type type
type MoqType_Size_params struct{}

// MoqType_Size_paramsKey holds the map key params of the Type type
type MoqType_Size_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_Size_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Size_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Size_paramsKey]*MoqType_Size_results
}

// MoqType_Size_doFn defines the type of function needed when calling AndDo for
// the Type type
type MoqType_Size_doFn func()

// MoqType_Size_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_Size_doReturnFn func() uintptr

// MoqType_Size_results holds the results of the Type type
type MoqType_Size_results struct {
	Params  MoqType_Size_params
	Results []struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqType_Size_doFn
		DoReturnFn MoqType_Size_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Size_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_Size_fnRecorder struct {
	Params    MoqType_Size_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Size_results
	Moq       *MoqType
}

// MoqType_Size_anyParams isolates the any params functions of the Type type
type MoqType_Size_anyParams struct {
	Recorder *MoqType_Size_fnRecorder
}

// MoqType_String_params holds the params of the Type type
type MoqType_String_params struct{}

// MoqType_String_paramsKey holds the map key params of the Type type
type MoqType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_String_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_String_paramsKey]*MoqType_String_results
}

// MoqType_String_doFn defines the type of function needed when calling AndDo
// for the Type type
type MoqType_String_doFn func()

// MoqType_String_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_String_doReturnFn func() string

// MoqType_String_results holds the results of the Type type
type MoqType_String_results struct {
	Params  MoqType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqType_String_doFn
		DoReturnFn MoqType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_String_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_String_fnRecorder struct {
	Params    MoqType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_String_results
	Moq       *MoqType
}

// MoqType_String_anyParams isolates the any params functions of the Type type
type MoqType_String_anyParams struct {
	Recorder *MoqType_String_fnRecorder
}

// MoqType_Kind_params holds the params of the Type type
type MoqType_Kind_params struct{}

// MoqType_Kind_paramsKey holds the map key params of the Type type
type MoqType_Kind_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_Kind_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Kind_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Kind_paramsKey]*MoqType_Kind_results
}

// MoqType_Kind_doFn defines the type of function needed when calling AndDo for
// the Type type
type MoqType_Kind_doFn func()

// MoqType_Kind_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_Kind_doReturnFn func() reflect.Kind

// MoqType_Kind_results holds the results of the Type type
type MoqType_Kind_results struct {
	Params  MoqType_Kind_params
	Results []struct {
		Values *struct {
			Result1 reflect.Kind
		}
		Sequence   uint32
		DoFn       MoqType_Kind_doFn
		DoReturnFn MoqType_Kind_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Kind_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_Kind_fnRecorder struct {
	Params    MoqType_Kind_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Kind_results
	Moq       *MoqType
}

// MoqType_Kind_anyParams isolates the any params functions of the Type type
type MoqType_Kind_anyParams struct {
	Recorder *MoqType_Kind_fnRecorder
}

// MoqType_Implements_params holds the params of the Type type
type MoqType_Implements_params struct{ U reflect.Type }

// MoqType_Implements_paramsKey holds the map key params of the Type type
type MoqType_Implements_paramsKey struct {
	Params struct{ U reflect.Type }
	Hashes struct{ U hash.Hash }
}

// MoqType_Implements_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Implements_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Implements_paramsKey]*MoqType_Implements_results
}

// MoqType_Implements_doFn defines the type of function needed when calling
// AndDo for the Type type
type MoqType_Implements_doFn func(u reflect.Type)

// MoqType_Implements_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Type type
type MoqType_Implements_doReturnFn func(u reflect.Type) bool

// MoqType_Implements_results holds the results of the Type type
type MoqType_Implements_results struct {
	Params  MoqType_Implements_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_Implements_doFn
		DoReturnFn MoqType_Implements_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Implements_fnRecorder routes recorded function calls to the MoqType
// moq
type MoqType_Implements_fnRecorder struct {
	Params    MoqType_Implements_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Implements_results
	Moq       *MoqType
}

// MoqType_Implements_anyParams isolates the any params functions of the Type
// type
type MoqType_Implements_anyParams struct {
	Recorder *MoqType_Implements_fnRecorder
}

// MoqType_AssignableTo_params holds the params of the Type type
type MoqType_AssignableTo_params struct{ U reflect.Type }

// MoqType_AssignableTo_paramsKey holds the map key params of the Type type
type MoqType_AssignableTo_paramsKey struct {
	Params struct{ U reflect.Type }
	Hashes struct{ U hash.Hash }
}

// MoqType_AssignableTo_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_AssignableTo_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_AssignableTo_paramsKey]*MoqType_AssignableTo_results
}

// MoqType_AssignableTo_doFn defines the type of function needed when calling
// AndDo for the Type type
type MoqType_AssignableTo_doFn func(u reflect.Type)

// MoqType_AssignableTo_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Type type
type MoqType_AssignableTo_doReturnFn func(u reflect.Type) bool

// MoqType_AssignableTo_results holds the results of the Type type
type MoqType_AssignableTo_results struct {
	Params  MoqType_AssignableTo_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_AssignableTo_doFn
		DoReturnFn MoqType_AssignableTo_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_AssignableTo_fnRecorder routes recorded function calls to the
// MoqType moq
type MoqType_AssignableTo_fnRecorder struct {
	Params    MoqType_AssignableTo_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_AssignableTo_results
	Moq       *MoqType
}

// MoqType_AssignableTo_anyParams isolates the any params functions of the Type
// type
type MoqType_AssignableTo_anyParams struct {
	Recorder *MoqType_AssignableTo_fnRecorder
}

// MoqType_ConvertibleTo_params holds the params of the Type type
type MoqType_ConvertibleTo_params struct{ U reflect.Type }

// MoqType_ConvertibleTo_paramsKey holds the map key params of the Type type
type MoqType_ConvertibleTo_paramsKey struct {
	Params struct{ U reflect.Type }
	Hashes struct{ U hash.Hash }
}

// MoqType_ConvertibleTo_resultsByParams contains the results for a given set
// of parameters for the Type type
type MoqType_ConvertibleTo_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_ConvertibleTo_paramsKey]*MoqType_ConvertibleTo_results
}

// MoqType_ConvertibleTo_doFn defines the type of function needed when calling
// AndDo for the Type type
type MoqType_ConvertibleTo_doFn func(u reflect.Type)

// MoqType_ConvertibleTo_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Type type
type MoqType_ConvertibleTo_doReturnFn func(u reflect.Type) bool

// MoqType_ConvertibleTo_results holds the results of the Type type
type MoqType_ConvertibleTo_results struct {
	Params  MoqType_ConvertibleTo_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_ConvertibleTo_doFn
		DoReturnFn MoqType_ConvertibleTo_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_ConvertibleTo_fnRecorder routes recorded function calls to the
// MoqType moq
type MoqType_ConvertibleTo_fnRecorder struct {
	Params    MoqType_ConvertibleTo_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_ConvertibleTo_results
	Moq       *MoqType
}

// MoqType_ConvertibleTo_anyParams isolates the any params functions of the
// Type type
type MoqType_ConvertibleTo_anyParams struct {
	Recorder *MoqType_ConvertibleTo_fnRecorder
}

// MoqType_Comparable_params holds the params of the Type type
type MoqType_Comparable_params struct{}

// MoqType_Comparable_paramsKey holds the map key params of the Type type
type MoqType_Comparable_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_Comparable_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Comparable_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Comparable_paramsKey]*MoqType_Comparable_results
}

// MoqType_Comparable_doFn defines the type of function needed when calling
// AndDo for the Type type
type MoqType_Comparable_doFn func()

// MoqType_Comparable_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Type type
type MoqType_Comparable_doReturnFn func() bool

// MoqType_Comparable_results holds the results of the Type type
type MoqType_Comparable_results struct {
	Params  MoqType_Comparable_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_Comparable_doFn
		DoReturnFn MoqType_Comparable_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Comparable_fnRecorder routes recorded function calls to the MoqType
// moq
type MoqType_Comparable_fnRecorder struct {
	Params    MoqType_Comparable_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Comparable_results
	Moq       *MoqType
}

// MoqType_Comparable_anyParams isolates the any params functions of the Type
// type
type MoqType_Comparable_anyParams struct {
	Recorder *MoqType_Comparable_fnRecorder
}

// MoqType_Bits_params holds the params of the Type type
type MoqType_Bits_params struct{}

// MoqType_Bits_paramsKey holds the map key params of the Type type
type MoqType_Bits_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_Bits_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Bits_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Bits_paramsKey]*MoqType_Bits_results
}

// MoqType_Bits_doFn defines the type of function needed when calling AndDo for
// the Type type
type MoqType_Bits_doFn func()

// MoqType_Bits_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_Bits_doReturnFn func() int

// MoqType_Bits_results holds the results of the Type type
type MoqType_Bits_results struct {
	Params  MoqType_Bits_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_Bits_doFn
		DoReturnFn MoqType_Bits_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Bits_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_Bits_fnRecorder struct {
	Params    MoqType_Bits_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Bits_results
	Moq       *MoqType
}

// MoqType_Bits_anyParams isolates the any params functions of the Type type
type MoqType_Bits_anyParams struct {
	Recorder *MoqType_Bits_fnRecorder
}

// MoqType_ChanDir_params holds the params of the Type type
type MoqType_ChanDir_params struct{}

// MoqType_ChanDir_paramsKey holds the map key params of the Type type
type MoqType_ChanDir_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_ChanDir_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_ChanDir_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_ChanDir_paramsKey]*MoqType_ChanDir_results
}

// MoqType_ChanDir_doFn defines the type of function needed when calling AndDo
// for the Type type
type MoqType_ChanDir_doFn func()

// MoqType_ChanDir_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_ChanDir_doReturnFn func() reflect.ChanDir

// MoqType_ChanDir_results holds the results of the Type type
type MoqType_ChanDir_results struct {
	Params  MoqType_ChanDir_params
	Results []struct {
		Values *struct {
			Result1 reflect.ChanDir
		}
		Sequence   uint32
		DoFn       MoqType_ChanDir_doFn
		DoReturnFn MoqType_ChanDir_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_ChanDir_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_ChanDir_fnRecorder struct {
	Params    MoqType_ChanDir_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_ChanDir_results
	Moq       *MoqType
}

// MoqType_ChanDir_anyParams isolates the any params functions of the Type type
type MoqType_ChanDir_anyParams struct {
	Recorder *MoqType_ChanDir_fnRecorder
}

// MoqType_IsVariadic_params holds the params of the Type type
type MoqType_IsVariadic_params struct{}

// MoqType_IsVariadic_paramsKey holds the map key params of the Type type
type MoqType_IsVariadic_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_IsVariadic_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_IsVariadic_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_IsVariadic_paramsKey]*MoqType_IsVariadic_results
}

// MoqType_IsVariadic_doFn defines the type of function needed when calling
// AndDo for the Type type
type MoqType_IsVariadic_doFn func()

// MoqType_IsVariadic_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Type type
type MoqType_IsVariadic_doReturnFn func() bool

// MoqType_IsVariadic_results holds the results of the Type type
type MoqType_IsVariadic_results struct {
	Params  MoqType_IsVariadic_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_IsVariadic_doFn
		DoReturnFn MoqType_IsVariadic_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_IsVariadic_fnRecorder routes recorded function calls to the MoqType
// moq
type MoqType_IsVariadic_fnRecorder struct {
	Params    MoqType_IsVariadic_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_IsVariadic_results
	Moq       *MoqType
}

// MoqType_IsVariadic_anyParams isolates the any params functions of the Type
// type
type MoqType_IsVariadic_anyParams struct {
	Recorder *MoqType_IsVariadic_fnRecorder
}

// MoqType_Elem_params holds the params of the Type type
type MoqType_Elem_params struct{}

// MoqType_Elem_paramsKey holds the map key params of the Type type
type MoqType_Elem_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_Elem_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Elem_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Elem_paramsKey]*MoqType_Elem_results
}

// MoqType_Elem_doFn defines the type of function needed when calling AndDo for
// the Type type
type MoqType_Elem_doFn func()

// MoqType_Elem_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_Elem_doReturnFn func() reflect.Type

// MoqType_Elem_results holds the results of the Type type
type MoqType_Elem_results struct {
	Params  MoqType_Elem_params
	Results []struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_Elem_doFn
		DoReturnFn MoqType_Elem_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Elem_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_Elem_fnRecorder struct {
	Params    MoqType_Elem_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Elem_results
	Moq       *MoqType
}

// MoqType_Elem_anyParams isolates the any params functions of the Type type
type MoqType_Elem_anyParams struct {
	Recorder *MoqType_Elem_fnRecorder
}

// MoqType_Field_params holds the params of the Type type
type MoqType_Field_params struct{ Param1 int }

// MoqType_Field_paramsKey holds the map key params of the Type type
type MoqType_Field_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqType_Field_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Field_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Field_paramsKey]*MoqType_Field_results
}

// MoqType_Field_doFn defines the type of function needed when calling AndDo
// for the Type type
type MoqType_Field_doFn func(i int)

// MoqType_Field_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_Field_doReturnFn func(i int) reflect.StructField

// MoqType_Field_results holds the results of the Type type
type MoqType_Field_results struct {
	Params  MoqType_Field_params
	Results []struct {
		Values *struct {
			Result1 reflect.StructField
		}
		Sequence   uint32
		DoFn       MoqType_Field_doFn
		DoReturnFn MoqType_Field_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Field_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_Field_fnRecorder struct {
	Params    MoqType_Field_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Field_results
	Moq       *MoqType
}

// MoqType_Field_anyParams isolates the any params functions of the Type type
type MoqType_Field_anyParams struct {
	Recorder *MoqType_Field_fnRecorder
}

// MoqType_FieldByIndex_params holds the params of the Type type
type MoqType_FieldByIndex_params struct{ Index []int }

// MoqType_FieldByIndex_paramsKey holds the map key params of the Type type
type MoqType_FieldByIndex_paramsKey struct {
	Params struct{}
	Hashes struct{ Index hash.Hash }
}

// MoqType_FieldByIndex_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_FieldByIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_FieldByIndex_paramsKey]*MoqType_FieldByIndex_results
}

// MoqType_FieldByIndex_doFn defines the type of function needed when calling
// AndDo for the Type type
type MoqType_FieldByIndex_doFn func(index []int)

// MoqType_FieldByIndex_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Type type
type MoqType_FieldByIndex_doReturnFn func(index []int) reflect.StructField

// MoqType_FieldByIndex_results holds the results of the Type type
type MoqType_FieldByIndex_results struct {
	Params  MoqType_FieldByIndex_params
	Results []struct {
		Values *struct {
			Result1 reflect.StructField
		}
		Sequence   uint32
		DoFn       MoqType_FieldByIndex_doFn
		DoReturnFn MoqType_FieldByIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_FieldByIndex_fnRecorder routes recorded function calls to the
// MoqType moq
type MoqType_FieldByIndex_fnRecorder struct {
	Params    MoqType_FieldByIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_FieldByIndex_results
	Moq       *MoqType
}

// MoqType_FieldByIndex_anyParams isolates the any params functions of the Type
// type
type MoqType_FieldByIndex_anyParams struct {
	Recorder *MoqType_FieldByIndex_fnRecorder
}

// MoqType_FieldByName_params holds the params of the Type type
type MoqType_FieldByName_params struct{ Name string }

// MoqType_FieldByName_paramsKey holds the map key params of the Type type
type MoqType_FieldByName_paramsKey struct {
	Params struct{ Name string }
	Hashes struct{ Name hash.Hash }
}

// MoqType_FieldByName_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_FieldByName_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_FieldByName_paramsKey]*MoqType_FieldByName_results
}

// MoqType_FieldByName_doFn defines the type of function needed when calling
// AndDo for the Type type
type MoqType_FieldByName_doFn func(name string)

// MoqType_FieldByName_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Type type
type MoqType_FieldByName_doReturnFn func(name string) (reflect.StructField, bool)

// MoqType_FieldByName_results holds the results of the Type type
type MoqType_FieldByName_results struct {
	Params  MoqType_FieldByName_params
	Results []struct {
		Values *struct {
			Result1 reflect.StructField
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqType_FieldByName_doFn
		DoReturnFn MoqType_FieldByName_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_FieldByName_fnRecorder routes recorded function calls to the MoqType
// moq
type MoqType_FieldByName_fnRecorder struct {
	Params    MoqType_FieldByName_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_FieldByName_results
	Moq       *MoqType
}

// MoqType_FieldByName_anyParams isolates the any params functions of the Type
// type
type MoqType_FieldByName_anyParams struct {
	Recorder *MoqType_FieldByName_fnRecorder
}

// MoqType_FieldByNameFunc_params holds the params of the Type type
type MoqType_FieldByNameFunc_params struct{ Match func(string) bool }

// MoqType_FieldByNameFunc_paramsKey holds the map key params of the Type type
type MoqType_FieldByNameFunc_paramsKey struct {
	Params struct{}
	Hashes struct{ Match hash.Hash }
}

// MoqType_FieldByNameFunc_resultsByParams contains the results for a given set
// of parameters for the Type type
type MoqType_FieldByNameFunc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_FieldByNameFunc_paramsKey]*MoqType_FieldByNameFunc_results
}

// MoqType_FieldByNameFunc_doFn defines the type of function needed when
// calling AndDo for the Type type
type MoqType_FieldByNameFunc_doFn func(match func(string) bool)

// MoqType_FieldByNameFunc_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Type type
type MoqType_FieldByNameFunc_doReturnFn func(match func(string) bool) (reflect.StructField, bool)

// MoqType_FieldByNameFunc_results holds the results of the Type type
type MoqType_FieldByNameFunc_results struct {
	Params  MoqType_FieldByNameFunc_params
	Results []struct {
		Values *struct {
			Result1 reflect.StructField
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqType_FieldByNameFunc_doFn
		DoReturnFn MoqType_FieldByNameFunc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_FieldByNameFunc_fnRecorder routes recorded function calls to the
// MoqType moq
type MoqType_FieldByNameFunc_fnRecorder struct {
	Params    MoqType_FieldByNameFunc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_FieldByNameFunc_results
	Moq       *MoqType
}

// MoqType_FieldByNameFunc_anyParams isolates the any params functions of the
// Type type
type MoqType_FieldByNameFunc_anyParams struct {
	Recorder *MoqType_FieldByNameFunc_fnRecorder
}

// MoqType_In_params holds the params of the Type type
type MoqType_In_params struct{ Param1 int }

// MoqType_In_paramsKey holds the map key params of the Type type
type MoqType_In_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqType_In_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_In_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_In_paramsKey]*MoqType_In_results
}

// MoqType_In_doFn defines the type of function needed when calling AndDo for
// the Type type
type MoqType_In_doFn func(i int)

// MoqType_In_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_In_doReturnFn func(i int) reflect.Type

// MoqType_In_results holds the results of the Type type
type MoqType_In_results struct {
	Params  MoqType_In_params
	Results []struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_In_doFn
		DoReturnFn MoqType_In_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_In_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_In_fnRecorder struct {
	Params    MoqType_In_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_In_results
	Moq       *MoqType
}

// MoqType_In_anyParams isolates the any params functions of the Type type
type MoqType_In_anyParams struct {
	Recorder *MoqType_In_fnRecorder
}

// MoqType_Key_params holds the params of the Type type
type MoqType_Key_params struct{}

// MoqType_Key_paramsKey holds the map key params of the Type type
type MoqType_Key_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_Key_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Key_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Key_paramsKey]*MoqType_Key_results
}

// MoqType_Key_doFn defines the type of function needed when calling AndDo for
// the Type type
type MoqType_Key_doFn func()

// MoqType_Key_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_Key_doReturnFn func() reflect.Type

// MoqType_Key_results holds the results of the Type type
type MoqType_Key_results struct {
	Params  MoqType_Key_params
	Results []struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_Key_doFn
		DoReturnFn MoqType_Key_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Key_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_Key_fnRecorder struct {
	Params    MoqType_Key_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Key_results
	Moq       *MoqType
}

// MoqType_Key_anyParams isolates the any params functions of the Type type
type MoqType_Key_anyParams struct {
	Recorder *MoqType_Key_fnRecorder
}

// MoqType_Len_params holds the params of the Type type
type MoqType_Len_params struct{}

// MoqType_Len_paramsKey holds the map key params of the Type type
type MoqType_Len_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_Len_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Len_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Len_paramsKey]*MoqType_Len_results
}

// MoqType_Len_doFn defines the type of function needed when calling AndDo for
// the Type type
type MoqType_Len_doFn func()

// MoqType_Len_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_Len_doReturnFn func() int

// MoqType_Len_results holds the results of the Type type
type MoqType_Len_results struct {
	Params  MoqType_Len_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_Len_doFn
		DoReturnFn MoqType_Len_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Len_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_Len_fnRecorder struct {
	Params    MoqType_Len_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Len_results
	Moq       *MoqType
}

// MoqType_Len_anyParams isolates the any params functions of the Type type
type MoqType_Len_anyParams struct {
	Recorder *MoqType_Len_fnRecorder
}

// MoqType_NumField_params holds the params of the Type type
type MoqType_NumField_params struct{}

// MoqType_NumField_paramsKey holds the map key params of the Type type
type MoqType_NumField_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_NumField_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_NumField_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_NumField_paramsKey]*MoqType_NumField_results
}

// MoqType_NumField_doFn defines the type of function needed when calling AndDo
// for the Type type
type MoqType_NumField_doFn func()

// MoqType_NumField_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_NumField_doReturnFn func() int

// MoqType_NumField_results holds the results of the Type type
type MoqType_NumField_results struct {
	Params  MoqType_NumField_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumField_doFn
		DoReturnFn MoqType_NumField_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_NumField_fnRecorder routes recorded function calls to the MoqType
// moq
type MoqType_NumField_fnRecorder struct {
	Params    MoqType_NumField_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_NumField_results
	Moq       *MoqType
}

// MoqType_NumField_anyParams isolates the any params functions of the Type
// type
type MoqType_NumField_anyParams struct {
	Recorder *MoqType_NumField_fnRecorder
}

// MoqType_NumIn_params holds the params of the Type type
type MoqType_NumIn_params struct{}

// MoqType_NumIn_paramsKey holds the map key params of the Type type
type MoqType_NumIn_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_NumIn_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_NumIn_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_NumIn_paramsKey]*MoqType_NumIn_results
}

// MoqType_NumIn_doFn defines the type of function needed when calling AndDo
// for the Type type
type MoqType_NumIn_doFn func()

// MoqType_NumIn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_NumIn_doReturnFn func() int

// MoqType_NumIn_results holds the results of the Type type
type MoqType_NumIn_results struct {
	Params  MoqType_NumIn_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumIn_doFn
		DoReturnFn MoqType_NumIn_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_NumIn_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_NumIn_fnRecorder struct {
	Params    MoqType_NumIn_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_NumIn_results
	Moq       *MoqType
}

// MoqType_NumIn_anyParams isolates the any params functions of the Type type
type MoqType_NumIn_anyParams struct {
	Recorder *MoqType_NumIn_fnRecorder
}

// MoqType_NumOut_params holds the params of the Type type
type MoqType_NumOut_params struct{}

// MoqType_NumOut_paramsKey holds the map key params of the Type type
type MoqType_NumOut_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqType_NumOut_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_NumOut_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_NumOut_paramsKey]*MoqType_NumOut_results
}

// MoqType_NumOut_doFn defines the type of function needed when calling AndDo
// for the Type type
type MoqType_NumOut_doFn func()

// MoqType_NumOut_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_NumOut_doReturnFn func() int

// MoqType_NumOut_results holds the results of the Type type
type MoqType_NumOut_results struct {
	Params  MoqType_NumOut_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumOut_doFn
		DoReturnFn MoqType_NumOut_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_NumOut_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_NumOut_fnRecorder struct {
	Params    MoqType_NumOut_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_NumOut_results
	Moq       *MoqType
}

// MoqType_NumOut_anyParams isolates the any params functions of the Type type
type MoqType_NumOut_anyParams struct {
	Recorder *MoqType_NumOut_fnRecorder
}

// MoqType_Out_params holds the params of the Type type
type MoqType_Out_params struct{ Param1 int }

// MoqType_Out_paramsKey holds the map key params of the Type type
type MoqType_Out_paramsKey struct {
	Params struct{ Param1 int }
	Hashes struct{ Param1 hash.Hash }
}

// MoqType_Out_resultsByParams contains the results for a given set of
// parameters for the Type type
type MoqType_Out_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqType_Out_paramsKey]*MoqType_Out_results
}

// MoqType_Out_doFn defines the type of function needed when calling AndDo for
// the Type type
type MoqType_Out_doFn func(i int)

// MoqType_Out_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Type type
type MoqType_Out_doReturnFn func(i int) reflect.Type

// MoqType_Out_results holds the results of the Type type
type MoqType_Out_results struct {
	Params  MoqType_Out_params
	Results []struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_Out_doFn
		DoReturnFn MoqType_Out_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqType_Out_fnRecorder routes recorded function calls to the MoqType moq
type MoqType_Out_fnRecorder struct {
	Params    MoqType_Out_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqType_Out_results
	Moq       *MoqType
}

// MoqType_Out_anyParams isolates the any params functions of the Type type
type MoqType_Out_anyParams struct {
	Recorder *MoqType_Out_fnRecorder
}

// NewMoqType creates a new moq of the Type type
func NewMoqType(scene *moq.Scene, config *moq.Config) *MoqType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Align      struct{}
				FieldAlign struct{}
				Method     struct {
					Param1 moq.ParamIndexing
				}
				MethodByName struct {
					Param1 moq.ParamIndexing
				}
				NumMethod  struct{}
				Name       struct{}
				PkgPath    struct{}
				Size       struct{}
				String     struct{}
				Kind       struct{}
				Implements struct {
					U moq.ParamIndexing
				}
				AssignableTo struct {
					U moq.ParamIndexing
				}
				ConvertibleTo struct {
					U moq.ParamIndexing
				}
				Comparable struct{}
				Bits       struct{}
				ChanDir    struct{}
				IsVariadic struct{}
				Elem       struct{}
				Field      struct {
					Param1 moq.ParamIndexing
				}
				FieldByIndex struct {
					Index moq.ParamIndexing
				}
				FieldByName struct {
					Name moq.ParamIndexing
				}
				FieldByNameFunc struct {
					Match moq.ParamIndexing
				}
				In struct {
					Param1 moq.ParamIndexing
				}
				Key      struct{}
				Len      struct{}
				NumField struct{}
				NumIn    struct{}
				NumOut   struct{}
				Out      struct {
					Param1 moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			Align      struct{}
			FieldAlign struct{}
			Method     struct {
				Param1 moq.ParamIndexing
			}
			MethodByName struct {
				Param1 moq.ParamIndexing
			}
			NumMethod  struct{}
			Name       struct{}
			PkgPath    struct{}
			Size       struct{}
			String     struct{}
			Kind       struct{}
			Implements struct {
				U moq.ParamIndexing
			}
			AssignableTo struct {
				U moq.ParamIndexing
			}
			ConvertibleTo struct {
				U moq.ParamIndexing
			}
			Comparable struct{}
			Bits       struct{}
			ChanDir    struct{}
			IsVariadic struct{}
			Elem       struct{}
			Field      struct {
				Param1 moq.ParamIndexing
			}
			FieldByIndex struct {
				Index moq.ParamIndexing
			}
			FieldByName struct {
				Name moq.ParamIndexing
			}
			FieldByNameFunc struct {
				Match moq.ParamIndexing
			}
			In struct {
				Param1 moq.ParamIndexing
			}
			Key      struct{}
			Len      struct{}
			NumField struct{}
			NumIn    struct{}
			NumOut   struct{}
			Out      struct {
				Param1 moq.ParamIndexing
			}
		}{
			Align:      struct{}{},
			FieldAlign: struct{}{},
			Method: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			MethodByName: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			NumMethod: struct{}{},
			Name:      struct{}{},
			PkgPath:   struct{}{},
			Size:      struct{}{},
			String:    struct{}{},
			Kind:      struct{}{},
			Implements: struct {
				U moq.ParamIndexing
			}{
				U: moq.ParamIndexByHash,
			},
			AssignableTo: struct {
				U moq.ParamIndexing
			}{
				U: moq.ParamIndexByHash,
			},
			ConvertibleTo: struct {
				U moq.ParamIndexing
			}{
				U: moq.ParamIndexByHash,
			},
			Comparable: struct{}{},
			Bits:       struct{}{},
			ChanDir:    struct{}{},
			IsVariadic: struct{}{},
			Elem:       struct{}{},
			Field: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			FieldByIndex: struct {
				Index moq.ParamIndexing
			}{
				Index: moq.ParamIndexByHash,
			},
			FieldByName: struct {
				Name moq.ParamIndexing
			}{
				Name: moq.ParamIndexByValue,
			},
			FieldByNameFunc: struct {
				Match moq.ParamIndexing
			}{
				Match: moq.ParamIndexByHash,
			},
			In: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
			Key:      struct{}{},
			Len:      struct{}{},
			NumField: struct{}{},
			NumIn:    struct{}{},
			NumOut:   struct{}{},
			Out: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Type type
func (m *MoqType) Mock() *MoqType_mock { return m.Moq }

func (m *MoqType_mock) Align() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Align_params{}
	var results *MoqType_Align_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Align {
		paramsKey := m.Moq.ParamsKey_Align(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Align(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Align(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Align(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) FieldAlign() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqType_FieldAlign_params{}
	var results *MoqType_FieldAlign_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FieldAlign {
		paramsKey := m.Moq.ParamsKey_FieldAlign(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FieldAlign(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FieldAlign(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FieldAlign(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) Method(param1 int) (result1 reflect.Method) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Method_params{
		Param1: param1,
	}
	var results *MoqType_Method_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Method {
		paramsKey := m.Moq.ParamsKey_Method(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Method(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Method(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Method(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqType_mock) MethodByName(param1 string) (result1 reflect.Method, result2 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqType_MethodByName_params{
		Param1: param1,
	}
	var results *MoqType_MethodByName_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MethodByName {
		paramsKey := m.Moq.ParamsKey_MethodByName(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MethodByName(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MethodByName(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MethodByName(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqType_mock) NumMethod() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqType_NumMethod_params{}
	var results *MoqType_NumMethod_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumMethod {
		paramsKey := m.Moq.ParamsKey_NumMethod(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumMethod(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumMethod(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumMethod(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) Name() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Name_params{}
	var results *MoqType_Name_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Name {
		paramsKey := m.Moq.ParamsKey_Name(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Name(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Name(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Name(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) PkgPath() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqType_PkgPath_params{}
	var results *MoqType_PkgPath_results
	for _, resultsByParams := range m.Moq.ResultsByParams_PkgPath {
		paramsKey := m.Moq.ParamsKey_PkgPath(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_PkgPath(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_PkgPath(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_PkgPath(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) Size() (result1 uintptr) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Size_params{}
	var results *MoqType_Size_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Size {
		paramsKey := m.Moq.ParamsKey_Size(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Size(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Size(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Size(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqType_String_params{}
	var results *MoqType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) Kind() (result1 reflect.Kind) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Kind_params{}
	var results *MoqType_Kind_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Kind {
		paramsKey := m.Moq.ParamsKey_Kind(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Kind(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Kind(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Kind(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) Implements(u reflect.Type) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Implements_params{
		U: u,
	}
	var results *MoqType_Implements_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Implements {
		paramsKey := m.Moq.ParamsKey_Implements(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Implements(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Implements(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Implements(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(u)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(u)
	}
	return
}

func (m *MoqType_mock) AssignableTo(u reflect.Type) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqType_AssignableTo_params{
		U: u,
	}
	var results *MoqType_AssignableTo_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AssignableTo {
		paramsKey := m.Moq.ParamsKey_AssignableTo(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AssignableTo(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AssignableTo(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AssignableTo(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(u)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(u)
	}
	return
}

func (m *MoqType_mock) ConvertibleTo(u reflect.Type) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqType_ConvertibleTo_params{
		U: u,
	}
	var results *MoqType_ConvertibleTo_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ConvertibleTo {
		paramsKey := m.Moq.ParamsKey_ConvertibleTo(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ConvertibleTo(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ConvertibleTo(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ConvertibleTo(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(u)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(u)
	}
	return
}

func (m *MoqType_mock) Comparable() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Comparable_params{}
	var results *MoqType_Comparable_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Comparable {
		paramsKey := m.Moq.ParamsKey_Comparable(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Comparable(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Comparable(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Comparable(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) Bits() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Bits_params{}
	var results *MoqType_Bits_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Bits {
		paramsKey := m.Moq.ParamsKey_Bits(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Bits(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Bits(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Bits(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) ChanDir() (result1 reflect.ChanDir) {
	m.Moq.Scene.T.Helper()
	params := MoqType_ChanDir_params{}
	var results *MoqType_ChanDir_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ChanDir {
		paramsKey := m.Moq.ParamsKey_ChanDir(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ChanDir(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ChanDir(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ChanDir(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) IsVariadic() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqType_IsVariadic_params{}
	var results *MoqType_IsVariadic_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsVariadic {
		paramsKey := m.Moq.ParamsKey_IsVariadic(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsVariadic(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsVariadic(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsVariadic(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) Elem() (result1 reflect.Type) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Elem_params{}
	var results *MoqType_Elem_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Elem {
		paramsKey := m.Moq.ParamsKey_Elem(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Elem(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Elem(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Elem(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) Field(param1 int) (result1 reflect.StructField) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Field_params{
		Param1: param1,
	}
	var results *MoqType_Field_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Field {
		paramsKey := m.Moq.ParamsKey_Field(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Field(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Field(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Field(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqType_mock) FieldByIndex(index []int) (result1 reflect.StructField) {
	m.Moq.Scene.T.Helper()
	params := MoqType_FieldByIndex_params{
		Index: index,
	}
	var results *MoqType_FieldByIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FieldByIndex {
		paramsKey := m.Moq.ParamsKey_FieldByIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FieldByIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FieldByIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FieldByIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(index)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(index)
	}
	return
}

func (m *MoqType_mock) FieldByName(name string) (result1 reflect.StructField, result2 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqType_FieldByName_params{
		Name: name,
	}
	var results *MoqType_FieldByName_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FieldByName {
		paramsKey := m.Moq.ParamsKey_FieldByName(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FieldByName(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FieldByName(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FieldByName(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(name)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(name)
	}
	return
}

func (m *MoqType_mock) FieldByNameFunc(match func(string) bool) (result1 reflect.StructField, result2 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqType_FieldByNameFunc_params{
		Match: match,
	}
	var results *MoqType_FieldByNameFunc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FieldByNameFunc {
		paramsKey := m.Moq.ParamsKey_FieldByNameFunc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FieldByNameFunc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FieldByNameFunc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FieldByNameFunc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(match)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn(match)
	}
	return
}

func (m *MoqType_mock) In(param1 int) (result1 reflect.Type) {
	m.Moq.Scene.T.Helper()
	params := MoqType_In_params{
		Param1: param1,
	}
	var results *MoqType_In_results
	for _, resultsByParams := range m.Moq.ResultsByParams_In {
		paramsKey := m.Moq.ParamsKey_In(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_In(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_In(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_In(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqType_mock) Key() (result1 reflect.Type) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Key_params{}
	var results *MoqType_Key_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Key {
		paramsKey := m.Moq.ParamsKey_Key(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Key(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Key(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Key(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) Len() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Len_params{}
	var results *MoqType_Len_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Len {
		paramsKey := m.Moq.ParamsKey_Len(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Len(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Len(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Len(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) NumField() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqType_NumField_params{}
	var results *MoqType_NumField_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumField {
		paramsKey := m.Moq.ParamsKey_NumField(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumField(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumField(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumField(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) NumIn() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqType_NumIn_params{}
	var results *MoqType_NumIn_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumIn {
		paramsKey := m.Moq.ParamsKey_NumIn(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumIn(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumIn(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumIn(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) NumOut() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqType_NumOut_params{}
	var results *MoqType_NumOut_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumOut {
		paramsKey := m.Moq.ParamsKey_NumOut(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumOut(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumOut(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumOut(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqType_mock) Out(param1 int) (result1 reflect.Type) {
	m.Moq.Scene.T.Helper()
	params := MoqType_Out_params{
		Param1: param1,
	}
	var results *MoqType_Out_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Out {
		paramsKey := m.Moq.ParamsKey_Out(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Out(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Out(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Out(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

// OnCall returns the recorder implementation of the Type type
func (m *MoqType) OnCall() *MoqType_recorder {
	return &MoqType_recorder{
		Moq: m,
	}
}

func (m *MoqType_recorder) Align() *MoqType_Align_fnRecorder {
	return &MoqType_Align_fnRecorder{
		Params:   MoqType_Align_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Align_fnRecorder) Any() *MoqType_Align_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Align(r.Params))
		return nil
	}
	return &MoqType_Align_anyParams{Recorder: r}
}

func (r *MoqType_Align_fnRecorder) Seq() *MoqType_Align_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Align(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Align_fnRecorder) NoSeq() *MoqType_Align_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Align(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Align_fnRecorder) ReturnResults(result1 int) *MoqType_Align_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_Align_doFn
		DoReturnFn MoqType_Align_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Align_fnRecorder) AndDo(fn MoqType_Align_doFn) *MoqType_Align_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Align_fnRecorder) DoReturnResults(fn MoqType_Align_doReturnFn) *MoqType_Align_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_Align_doFn
		DoReturnFn MoqType_Align_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Align_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Align_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Align {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Align_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Align_paramsKey]*MoqType_Align_results{},
		}
		r.Moq.ResultsByParams_Align = append(r.Moq.ResultsByParams_Align, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Align) {
			copy(r.Moq.ResultsByParams_Align[insertAt+1:], r.Moq.ResultsByParams_Align[insertAt:0])
			r.Moq.ResultsByParams_Align[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Align(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Align_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Align_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Align_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqType_Align_doFn
				DoReturnFn MoqType_Align_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Align(params MoqType_Align_params) string {
	return fmt.Sprintf("Align()")
}

func (m *MoqType) ParamsKey_Align(params MoqType_Align_params, anyParams uint64) MoqType_Align_paramsKey {
	m.Scene.T.Helper()
	return MoqType_Align_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) FieldAlign() *MoqType_FieldAlign_fnRecorder {
	return &MoqType_FieldAlign_fnRecorder{
		Params:   MoqType_FieldAlign_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_FieldAlign_fnRecorder) Any() *MoqType_FieldAlign_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldAlign(r.Params))
		return nil
	}
	return &MoqType_FieldAlign_anyParams{Recorder: r}
}

func (r *MoqType_FieldAlign_fnRecorder) Seq() *MoqType_FieldAlign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldAlign(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_FieldAlign_fnRecorder) NoSeq() *MoqType_FieldAlign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldAlign(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_FieldAlign_fnRecorder) ReturnResults(result1 int) *MoqType_FieldAlign_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_FieldAlign_doFn
		DoReturnFn MoqType_FieldAlign_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_FieldAlign_fnRecorder) AndDo(fn MoqType_FieldAlign_doFn) *MoqType_FieldAlign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_FieldAlign_fnRecorder) DoReturnResults(fn MoqType_FieldAlign_doReturnFn) *MoqType_FieldAlign_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_FieldAlign_doFn
		DoReturnFn MoqType_FieldAlign_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_FieldAlign_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_FieldAlign_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FieldAlign {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_FieldAlign_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_FieldAlign_paramsKey]*MoqType_FieldAlign_results{},
		}
		r.Moq.ResultsByParams_FieldAlign = append(r.Moq.ResultsByParams_FieldAlign, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FieldAlign) {
			copy(r.Moq.ResultsByParams_FieldAlign[insertAt+1:], r.Moq.ResultsByParams_FieldAlign[insertAt:0])
			r.Moq.ResultsByParams_FieldAlign[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FieldAlign(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_FieldAlign_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_FieldAlign_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_FieldAlign_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqType_FieldAlign_doFn
				DoReturnFn MoqType_FieldAlign_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_FieldAlign(params MoqType_FieldAlign_params) string {
	return fmt.Sprintf("FieldAlign()")
}

func (m *MoqType) ParamsKey_FieldAlign(params MoqType_FieldAlign_params, anyParams uint64) MoqType_FieldAlign_paramsKey {
	m.Scene.T.Helper()
	return MoqType_FieldAlign_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) Method(param1 int) *MoqType_Method_fnRecorder {
	return &MoqType_Method_fnRecorder{
		Params: MoqType_Method_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Method_fnRecorder) Any() *MoqType_Method_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	return &MoqType_Method_anyParams{Recorder: r}
}

func (a *MoqType_Method_anyParams) Param1() *MoqType_Method_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqType_Method_fnRecorder) Seq() *MoqType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Method_fnRecorder) NoSeq() *MoqType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Method(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Method_fnRecorder) ReturnResults(result1 reflect.Method) *MoqType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Method
		}
		Sequence   uint32
		DoFn       MoqType_Method_doFn
		DoReturnFn MoqType_Method_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Method
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Method_fnRecorder) AndDo(fn MoqType_Method_doFn) *MoqType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Method_fnRecorder) DoReturnResults(fn MoqType_Method_doReturnFn) *MoqType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Method
		}
		Sequence   uint32
		DoFn       MoqType_Method_doFn
		DoReturnFn MoqType_Method_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Method_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Method_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Method {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Method_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Method_paramsKey]*MoqType_Method_results{},
		}
		r.Moq.ResultsByParams_Method = append(r.Moq.ResultsByParams_Method, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Method) {
			copy(r.Moq.ResultsByParams_Method[insertAt+1:], r.Moq.ResultsByParams_Method[insertAt:0])
			r.Moq.ResultsByParams_Method[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Method(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Method_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Method_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Method_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Method
				}
				Sequence   uint32
				DoFn       MoqType_Method_doFn
				DoReturnFn MoqType_Method_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Method(params MoqType_Method_params) string {
	return fmt.Sprintf("Method(%#v)", params.Param1)
}

func (m *MoqType) ParamsKey_Method(params MoqType_Method_params, anyParams uint64) MoqType_Method_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Method.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqType_Method_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqType_recorder) MethodByName(param1 string) *MoqType_MethodByName_fnRecorder {
	return &MoqType_MethodByName_fnRecorder{
		Params: MoqType_MethodByName_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_MethodByName_fnRecorder) Any() *MoqType_MethodByName_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MethodByName(r.Params))
		return nil
	}
	return &MoqType_MethodByName_anyParams{Recorder: r}
}

func (a *MoqType_MethodByName_anyParams) Param1() *MoqType_MethodByName_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqType_MethodByName_fnRecorder) Seq() *MoqType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MethodByName(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_MethodByName_fnRecorder) NoSeq() *MoqType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MethodByName(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_MethodByName_fnRecorder) ReturnResults(result1 reflect.Method, result2 bool) *MoqType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Method
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqType_MethodByName_doFn
		DoReturnFn MoqType_MethodByName_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Method
			Result2 bool
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_MethodByName_fnRecorder) AndDo(fn MoqType_MethodByName_doFn) *MoqType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_MethodByName_fnRecorder) DoReturnResults(fn MoqType_MethodByName_doReturnFn) *MoqType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Method
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqType_MethodByName_doFn
		DoReturnFn MoqType_MethodByName_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_MethodByName_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_MethodByName_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MethodByName {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_MethodByName_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_MethodByName_paramsKey]*MoqType_MethodByName_results{},
		}
		r.Moq.ResultsByParams_MethodByName = append(r.Moq.ResultsByParams_MethodByName, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MethodByName) {
			copy(r.Moq.ResultsByParams_MethodByName[insertAt+1:], r.Moq.ResultsByParams_MethodByName[insertAt:0])
			r.Moq.ResultsByParams_MethodByName[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MethodByName(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_MethodByName_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_MethodByName_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_MethodByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Method
					Result2 bool
				}
				Sequence   uint32
				DoFn       MoqType_MethodByName_doFn
				DoReturnFn MoqType_MethodByName_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_MethodByName(params MoqType_MethodByName_params) string {
	return fmt.Sprintf("MethodByName(%#v)", params.Param1)
}

func (m *MoqType) ParamsKey_MethodByName(params MoqType_MethodByName_params, anyParams uint64) MoqType_MethodByName_paramsKey {
	m.Scene.T.Helper()
	var param1Used string
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MethodByName.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqType_MethodByName_paramsKey{
		Params: struct{ Param1 string }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqType_recorder) NumMethod() *MoqType_NumMethod_fnRecorder {
	return &MoqType_NumMethod_fnRecorder{
		Params:   MoqType_NumMethod_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_NumMethod_fnRecorder) Any() *MoqType_NumMethod_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethod(r.Params))
		return nil
	}
	return &MoqType_NumMethod_anyParams{Recorder: r}
}

func (r *MoqType_NumMethod_fnRecorder) Seq() *MoqType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethod(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_NumMethod_fnRecorder) NoSeq() *MoqType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumMethod(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_NumMethod_fnRecorder) ReturnResults(result1 int) *MoqType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumMethod_doFn
		DoReturnFn MoqType_NumMethod_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_NumMethod_fnRecorder) AndDo(fn MoqType_NumMethod_doFn) *MoqType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_NumMethod_fnRecorder) DoReturnResults(fn MoqType_NumMethod_doReturnFn) *MoqType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumMethod_doFn
		DoReturnFn MoqType_NumMethod_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_NumMethod_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_NumMethod_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumMethod {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_NumMethod_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_NumMethod_paramsKey]*MoqType_NumMethod_results{},
		}
		r.Moq.ResultsByParams_NumMethod = append(r.Moq.ResultsByParams_NumMethod, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumMethod) {
			copy(r.Moq.ResultsByParams_NumMethod[insertAt+1:], r.Moq.ResultsByParams_NumMethod[insertAt:0])
			r.Moq.ResultsByParams_NumMethod[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumMethod(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_NumMethod_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_NumMethod_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_NumMethod_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqType_NumMethod_doFn
				DoReturnFn MoqType_NumMethod_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_NumMethod(params MoqType_NumMethod_params) string {
	return fmt.Sprintf("NumMethod()")
}

func (m *MoqType) ParamsKey_NumMethod(params MoqType_NumMethod_params, anyParams uint64) MoqType_NumMethod_paramsKey {
	m.Scene.T.Helper()
	return MoqType_NumMethod_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) Name() *MoqType_Name_fnRecorder {
	return &MoqType_Name_fnRecorder{
		Params:   MoqType_Name_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Name_fnRecorder) Any() *MoqType_Name_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	return &MoqType_Name_anyParams{Recorder: r}
}

func (r *MoqType_Name_fnRecorder) Seq() *MoqType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Name_fnRecorder) NoSeq() *MoqType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Name(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Name_fnRecorder) ReturnResults(result1 string) *MoqType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqType_Name_doFn
		DoReturnFn MoqType_Name_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Name_fnRecorder) AndDo(fn MoqType_Name_doFn) *MoqType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Name_fnRecorder) DoReturnResults(fn MoqType_Name_doReturnFn) *MoqType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqType_Name_doFn
		DoReturnFn MoqType_Name_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Name_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Name_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Name {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Name_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Name_paramsKey]*MoqType_Name_results{},
		}
		r.Moq.ResultsByParams_Name = append(r.Moq.ResultsByParams_Name, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Name) {
			copy(r.Moq.ResultsByParams_Name[insertAt+1:], r.Moq.ResultsByParams_Name[insertAt:0])
			r.Moq.ResultsByParams_Name[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Name(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Name_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Name_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Name_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqType_Name_doFn
				DoReturnFn MoqType_Name_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Name(params MoqType_Name_params) string { return fmt.Sprintf("Name()") }

func (m *MoqType) ParamsKey_Name(params MoqType_Name_params, anyParams uint64) MoqType_Name_paramsKey {
	m.Scene.T.Helper()
	return MoqType_Name_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) PkgPath() *MoqType_PkgPath_fnRecorder {
	return &MoqType_PkgPath_fnRecorder{
		Params:   MoqType_PkgPath_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_PkgPath_fnRecorder) Any() *MoqType_PkgPath_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PkgPath(r.Params))
		return nil
	}
	return &MoqType_PkgPath_anyParams{Recorder: r}
}

func (r *MoqType_PkgPath_fnRecorder) Seq() *MoqType_PkgPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PkgPath(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_PkgPath_fnRecorder) NoSeq() *MoqType_PkgPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PkgPath(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_PkgPath_fnRecorder) ReturnResults(result1 string) *MoqType_PkgPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqType_PkgPath_doFn
		DoReturnFn MoqType_PkgPath_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_PkgPath_fnRecorder) AndDo(fn MoqType_PkgPath_doFn) *MoqType_PkgPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_PkgPath_fnRecorder) DoReturnResults(fn MoqType_PkgPath_doReturnFn) *MoqType_PkgPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqType_PkgPath_doFn
		DoReturnFn MoqType_PkgPath_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_PkgPath_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_PkgPath_resultsByParams
	for n, res := range r.Moq.ResultsByParams_PkgPath {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_PkgPath_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_PkgPath_paramsKey]*MoqType_PkgPath_results{},
		}
		r.Moq.ResultsByParams_PkgPath = append(r.Moq.ResultsByParams_PkgPath, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_PkgPath) {
			copy(r.Moq.ResultsByParams_PkgPath[insertAt+1:], r.Moq.ResultsByParams_PkgPath[insertAt:0])
			r.Moq.ResultsByParams_PkgPath[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_PkgPath(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_PkgPath_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_PkgPath_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_PkgPath_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqType_PkgPath_doFn
				DoReturnFn MoqType_PkgPath_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_PkgPath(params MoqType_PkgPath_params) string {
	return fmt.Sprintf("PkgPath()")
}

func (m *MoqType) ParamsKey_PkgPath(params MoqType_PkgPath_params, anyParams uint64) MoqType_PkgPath_paramsKey {
	m.Scene.T.Helper()
	return MoqType_PkgPath_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) Size() *MoqType_Size_fnRecorder {
	return &MoqType_Size_fnRecorder{
		Params:   MoqType_Size_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Size_fnRecorder) Any() *MoqType_Size_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	return &MoqType_Size_anyParams{Recorder: r}
}

func (r *MoqType_Size_fnRecorder) Seq() *MoqType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Size_fnRecorder) NoSeq() *MoqType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Size(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Size_fnRecorder) ReturnResults(result1 uintptr) *MoqType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqType_Size_doFn
		DoReturnFn MoqType_Size_doReturnFn
	}{
		Values: &struct {
			Result1 uintptr
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Size_fnRecorder) AndDo(fn MoqType_Size_doFn) *MoqType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Size_fnRecorder) DoReturnResults(fn MoqType_Size_doReturnFn) *MoqType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 uintptr
		}
		Sequence   uint32
		DoFn       MoqType_Size_doFn
		DoReturnFn MoqType_Size_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Size_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Size_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Size {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Size_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Size_paramsKey]*MoqType_Size_results{},
		}
		r.Moq.ResultsByParams_Size = append(r.Moq.ResultsByParams_Size, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Size) {
			copy(r.Moq.ResultsByParams_Size[insertAt+1:], r.Moq.ResultsByParams_Size[insertAt:0])
			r.Moq.ResultsByParams_Size[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Size(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Size_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Size_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Size_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 uintptr
				}
				Sequence   uint32
				DoFn       MoqType_Size_doFn
				DoReturnFn MoqType_Size_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Size(params MoqType_Size_params) string { return fmt.Sprintf("Size()") }

func (m *MoqType) ParamsKey_Size(params MoqType_Size_params, anyParams uint64) MoqType_Size_paramsKey {
	m.Scene.T.Helper()
	return MoqType_Size_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) String() *MoqType_String_fnRecorder {
	return &MoqType_String_fnRecorder{
		Params:   MoqType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_String_fnRecorder) Any() *MoqType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqType_String_anyParams{Recorder: r}
}

func (r *MoqType_String_fnRecorder) Seq() *MoqType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_String_fnRecorder) NoSeq() *MoqType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_String_fnRecorder) ReturnResults(result1 string) *MoqType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqType_String_doFn
		DoReturnFn MoqType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_String_fnRecorder) AndDo(fn MoqType_String_doFn) *MoqType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_String_fnRecorder) DoReturnResults(fn MoqType_String_doReturnFn) *MoqType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqType_String_doFn
		DoReturnFn MoqType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_String_paramsKey]*MoqType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqType_String_doFn
				DoReturnFn MoqType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_String(params MoqType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqType) ParamsKey_String(params MoqType_String_params, anyParams uint64) MoqType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) Kind() *MoqType_Kind_fnRecorder {
	return &MoqType_Kind_fnRecorder{
		Params:   MoqType_Kind_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Kind_fnRecorder) Any() *MoqType_Kind_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Kind(r.Params))
		return nil
	}
	return &MoqType_Kind_anyParams{Recorder: r}
}

func (r *MoqType_Kind_fnRecorder) Seq() *MoqType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Kind(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Kind_fnRecorder) NoSeq() *MoqType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Kind(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Kind_fnRecorder) ReturnResults(result1 reflect.Kind) *MoqType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Kind
		}
		Sequence   uint32
		DoFn       MoqType_Kind_doFn
		DoReturnFn MoqType_Kind_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Kind
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Kind_fnRecorder) AndDo(fn MoqType_Kind_doFn) *MoqType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Kind_fnRecorder) DoReturnResults(fn MoqType_Kind_doReturnFn) *MoqType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Kind
		}
		Sequence   uint32
		DoFn       MoqType_Kind_doFn
		DoReturnFn MoqType_Kind_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Kind_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Kind_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Kind {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Kind_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Kind_paramsKey]*MoqType_Kind_results{},
		}
		r.Moq.ResultsByParams_Kind = append(r.Moq.ResultsByParams_Kind, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Kind) {
			copy(r.Moq.ResultsByParams_Kind[insertAt+1:], r.Moq.ResultsByParams_Kind[insertAt:0])
			r.Moq.ResultsByParams_Kind[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Kind(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Kind_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Kind_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Kind_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Kind
				}
				Sequence   uint32
				DoFn       MoqType_Kind_doFn
				DoReturnFn MoqType_Kind_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Kind(params MoqType_Kind_params) string { return fmt.Sprintf("Kind()") }

func (m *MoqType) ParamsKey_Kind(params MoqType_Kind_params, anyParams uint64) MoqType_Kind_paramsKey {
	m.Scene.T.Helper()
	return MoqType_Kind_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) Implements(u reflect.Type) *MoqType_Implements_fnRecorder {
	return &MoqType_Implements_fnRecorder{
		Params: MoqType_Implements_params{
			U: u,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Implements_fnRecorder) Any() *MoqType_Implements_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Implements(r.Params))
		return nil
	}
	return &MoqType_Implements_anyParams{Recorder: r}
}

func (a *MoqType_Implements_anyParams) U() *MoqType_Implements_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqType_Implements_fnRecorder) Seq() *MoqType_Implements_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Implements(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Implements_fnRecorder) NoSeq() *MoqType_Implements_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Implements(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Implements_fnRecorder) ReturnResults(result1 bool) *MoqType_Implements_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_Implements_doFn
		DoReturnFn MoqType_Implements_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Implements_fnRecorder) AndDo(fn MoqType_Implements_doFn) *MoqType_Implements_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Implements_fnRecorder) DoReturnResults(fn MoqType_Implements_doReturnFn) *MoqType_Implements_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_Implements_doFn
		DoReturnFn MoqType_Implements_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Implements_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Implements_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Implements {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Implements_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Implements_paramsKey]*MoqType_Implements_results{},
		}
		r.Moq.ResultsByParams_Implements = append(r.Moq.ResultsByParams_Implements, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Implements) {
			copy(r.Moq.ResultsByParams_Implements[insertAt+1:], r.Moq.ResultsByParams_Implements[insertAt:0])
			r.Moq.ResultsByParams_Implements[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Implements(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Implements_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Implements_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Implements_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqType_Implements_doFn
				DoReturnFn MoqType_Implements_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Implements(params MoqType_Implements_params) string {
	return fmt.Sprintf("Implements(%#v)", params.U)
}

func (m *MoqType) ParamsKey_Implements(params MoqType_Implements_params, anyParams uint64) MoqType_Implements_paramsKey {
	m.Scene.T.Helper()
	var uUsed reflect.Type
	var uUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Implements.U == moq.ParamIndexByValue {
			uUsed = params.U
		} else {
			uUsedHash = hash.DeepHash(params.U)
		}
	}
	return MoqType_Implements_paramsKey{
		Params: struct{ U reflect.Type }{
			U: uUsed,
		},
		Hashes: struct{ U hash.Hash }{
			U: uUsedHash,
		},
	}
}

func (m *MoqType_recorder) AssignableTo(u reflect.Type) *MoqType_AssignableTo_fnRecorder {
	return &MoqType_AssignableTo_fnRecorder{
		Params: MoqType_AssignableTo_params{
			U: u,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_AssignableTo_fnRecorder) Any() *MoqType_AssignableTo_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AssignableTo(r.Params))
		return nil
	}
	return &MoqType_AssignableTo_anyParams{Recorder: r}
}

func (a *MoqType_AssignableTo_anyParams) U() *MoqType_AssignableTo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqType_AssignableTo_fnRecorder) Seq() *MoqType_AssignableTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AssignableTo(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_AssignableTo_fnRecorder) NoSeq() *MoqType_AssignableTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AssignableTo(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_AssignableTo_fnRecorder) ReturnResults(result1 bool) *MoqType_AssignableTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_AssignableTo_doFn
		DoReturnFn MoqType_AssignableTo_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_AssignableTo_fnRecorder) AndDo(fn MoqType_AssignableTo_doFn) *MoqType_AssignableTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_AssignableTo_fnRecorder) DoReturnResults(fn MoqType_AssignableTo_doReturnFn) *MoqType_AssignableTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_AssignableTo_doFn
		DoReturnFn MoqType_AssignableTo_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_AssignableTo_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_AssignableTo_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AssignableTo {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_AssignableTo_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_AssignableTo_paramsKey]*MoqType_AssignableTo_results{},
		}
		r.Moq.ResultsByParams_AssignableTo = append(r.Moq.ResultsByParams_AssignableTo, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AssignableTo) {
			copy(r.Moq.ResultsByParams_AssignableTo[insertAt+1:], r.Moq.ResultsByParams_AssignableTo[insertAt:0])
			r.Moq.ResultsByParams_AssignableTo[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AssignableTo(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_AssignableTo_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_AssignableTo_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_AssignableTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqType_AssignableTo_doFn
				DoReturnFn MoqType_AssignableTo_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_AssignableTo(params MoqType_AssignableTo_params) string {
	return fmt.Sprintf("AssignableTo(%#v)", params.U)
}

func (m *MoqType) ParamsKey_AssignableTo(params MoqType_AssignableTo_params, anyParams uint64) MoqType_AssignableTo_paramsKey {
	m.Scene.T.Helper()
	var uUsed reflect.Type
	var uUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.AssignableTo.U == moq.ParamIndexByValue {
			uUsed = params.U
		} else {
			uUsedHash = hash.DeepHash(params.U)
		}
	}
	return MoqType_AssignableTo_paramsKey{
		Params: struct{ U reflect.Type }{
			U: uUsed,
		},
		Hashes: struct{ U hash.Hash }{
			U: uUsedHash,
		},
	}
}

func (m *MoqType_recorder) ConvertibleTo(u reflect.Type) *MoqType_ConvertibleTo_fnRecorder {
	return &MoqType_ConvertibleTo_fnRecorder{
		Params: MoqType_ConvertibleTo_params{
			U: u,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_ConvertibleTo_fnRecorder) Any() *MoqType_ConvertibleTo_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ConvertibleTo(r.Params))
		return nil
	}
	return &MoqType_ConvertibleTo_anyParams{Recorder: r}
}

func (a *MoqType_ConvertibleTo_anyParams) U() *MoqType_ConvertibleTo_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqType_ConvertibleTo_fnRecorder) Seq() *MoqType_ConvertibleTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ConvertibleTo(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_ConvertibleTo_fnRecorder) NoSeq() *MoqType_ConvertibleTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ConvertibleTo(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_ConvertibleTo_fnRecorder) ReturnResults(result1 bool) *MoqType_ConvertibleTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_ConvertibleTo_doFn
		DoReturnFn MoqType_ConvertibleTo_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_ConvertibleTo_fnRecorder) AndDo(fn MoqType_ConvertibleTo_doFn) *MoqType_ConvertibleTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_ConvertibleTo_fnRecorder) DoReturnResults(fn MoqType_ConvertibleTo_doReturnFn) *MoqType_ConvertibleTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_ConvertibleTo_doFn
		DoReturnFn MoqType_ConvertibleTo_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_ConvertibleTo_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_ConvertibleTo_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ConvertibleTo {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_ConvertibleTo_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_ConvertibleTo_paramsKey]*MoqType_ConvertibleTo_results{},
		}
		r.Moq.ResultsByParams_ConvertibleTo = append(r.Moq.ResultsByParams_ConvertibleTo, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ConvertibleTo) {
			copy(r.Moq.ResultsByParams_ConvertibleTo[insertAt+1:], r.Moq.ResultsByParams_ConvertibleTo[insertAt:0])
			r.Moq.ResultsByParams_ConvertibleTo[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ConvertibleTo(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_ConvertibleTo_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_ConvertibleTo_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_ConvertibleTo_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqType_ConvertibleTo_doFn
				DoReturnFn MoqType_ConvertibleTo_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_ConvertibleTo(params MoqType_ConvertibleTo_params) string {
	return fmt.Sprintf("ConvertibleTo(%#v)", params.U)
}

func (m *MoqType) ParamsKey_ConvertibleTo(params MoqType_ConvertibleTo_params, anyParams uint64) MoqType_ConvertibleTo_paramsKey {
	m.Scene.T.Helper()
	var uUsed reflect.Type
	var uUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ConvertibleTo.U == moq.ParamIndexByValue {
			uUsed = params.U
		} else {
			uUsedHash = hash.DeepHash(params.U)
		}
	}
	return MoqType_ConvertibleTo_paramsKey{
		Params: struct{ U reflect.Type }{
			U: uUsed,
		},
		Hashes: struct{ U hash.Hash }{
			U: uUsedHash,
		},
	}
}

func (m *MoqType_recorder) Comparable() *MoqType_Comparable_fnRecorder {
	return &MoqType_Comparable_fnRecorder{
		Params:   MoqType_Comparable_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Comparable_fnRecorder) Any() *MoqType_Comparable_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Comparable(r.Params))
		return nil
	}
	return &MoqType_Comparable_anyParams{Recorder: r}
}

func (r *MoqType_Comparable_fnRecorder) Seq() *MoqType_Comparable_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Comparable(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Comparable_fnRecorder) NoSeq() *MoqType_Comparable_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Comparable(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Comparable_fnRecorder) ReturnResults(result1 bool) *MoqType_Comparable_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_Comparable_doFn
		DoReturnFn MoqType_Comparable_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Comparable_fnRecorder) AndDo(fn MoqType_Comparable_doFn) *MoqType_Comparable_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Comparable_fnRecorder) DoReturnResults(fn MoqType_Comparable_doReturnFn) *MoqType_Comparable_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_Comparable_doFn
		DoReturnFn MoqType_Comparable_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Comparable_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Comparable_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Comparable {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Comparable_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Comparable_paramsKey]*MoqType_Comparable_results{},
		}
		r.Moq.ResultsByParams_Comparable = append(r.Moq.ResultsByParams_Comparable, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Comparable) {
			copy(r.Moq.ResultsByParams_Comparable[insertAt+1:], r.Moq.ResultsByParams_Comparable[insertAt:0])
			r.Moq.ResultsByParams_Comparable[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Comparable(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Comparable_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Comparable_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Comparable_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqType_Comparable_doFn
				DoReturnFn MoqType_Comparable_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Comparable(params MoqType_Comparable_params) string {
	return fmt.Sprintf("Comparable()")
}

func (m *MoqType) ParamsKey_Comparable(params MoqType_Comparable_params, anyParams uint64) MoqType_Comparable_paramsKey {
	m.Scene.T.Helper()
	return MoqType_Comparable_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) Bits() *MoqType_Bits_fnRecorder {
	return &MoqType_Bits_fnRecorder{
		Params:   MoqType_Bits_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Bits_fnRecorder) Any() *MoqType_Bits_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bits(r.Params))
		return nil
	}
	return &MoqType_Bits_anyParams{Recorder: r}
}

func (r *MoqType_Bits_fnRecorder) Seq() *MoqType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bits(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Bits_fnRecorder) NoSeq() *MoqType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Bits(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Bits_fnRecorder) ReturnResults(result1 int) *MoqType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_Bits_doFn
		DoReturnFn MoqType_Bits_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Bits_fnRecorder) AndDo(fn MoqType_Bits_doFn) *MoqType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Bits_fnRecorder) DoReturnResults(fn MoqType_Bits_doReturnFn) *MoqType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_Bits_doFn
		DoReturnFn MoqType_Bits_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Bits_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Bits_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Bits {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Bits_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Bits_paramsKey]*MoqType_Bits_results{},
		}
		r.Moq.ResultsByParams_Bits = append(r.Moq.ResultsByParams_Bits, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Bits) {
			copy(r.Moq.ResultsByParams_Bits[insertAt+1:], r.Moq.ResultsByParams_Bits[insertAt:0])
			r.Moq.ResultsByParams_Bits[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Bits(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Bits_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Bits_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Bits_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqType_Bits_doFn
				DoReturnFn MoqType_Bits_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Bits(params MoqType_Bits_params) string { return fmt.Sprintf("Bits()") }

func (m *MoqType) ParamsKey_Bits(params MoqType_Bits_params, anyParams uint64) MoqType_Bits_paramsKey {
	m.Scene.T.Helper()
	return MoqType_Bits_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) ChanDir() *MoqType_ChanDir_fnRecorder {
	return &MoqType_ChanDir_fnRecorder{
		Params:   MoqType_ChanDir_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_ChanDir_fnRecorder) Any() *MoqType_ChanDir_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ChanDir(r.Params))
		return nil
	}
	return &MoqType_ChanDir_anyParams{Recorder: r}
}

func (r *MoqType_ChanDir_fnRecorder) Seq() *MoqType_ChanDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ChanDir(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_ChanDir_fnRecorder) NoSeq() *MoqType_ChanDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ChanDir(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_ChanDir_fnRecorder) ReturnResults(result1 reflect.ChanDir) *MoqType_ChanDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.ChanDir
		}
		Sequence   uint32
		DoFn       MoqType_ChanDir_doFn
		DoReturnFn MoqType_ChanDir_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.ChanDir
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_ChanDir_fnRecorder) AndDo(fn MoqType_ChanDir_doFn) *MoqType_ChanDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_ChanDir_fnRecorder) DoReturnResults(fn MoqType_ChanDir_doReturnFn) *MoqType_ChanDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.ChanDir
		}
		Sequence   uint32
		DoFn       MoqType_ChanDir_doFn
		DoReturnFn MoqType_ChanDir_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_ChanDir_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_ChanDir_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ChanDir {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_ChanDir_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_ChanDir_paramsKey]*MoqType_ChanDir_results{},
		}
		r.Moq.ResultsByParams_ChanDir = append(r.Moq.ResultsByParams_ChanDir, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ChanDir) {
			copy(r.Moq.ResultsByParams_ChanDir[insertAt+1:], r.Moq.ResultsByParams_ChanDir[insertAt:0])
			r.Moq.ResultsByParams_ChanDir[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ChanDir(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_ChanDir_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_ChanDir_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_ChanDir_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.ChanDir
				}
				Sequence   uint32
				DoFn       MoqType_ChanDir_doFn
				DoReturnFn MoqType_ChanDir_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_ChanDir(params MoqType_ChanDir_params) string {
	return fmt.Sprintf("ChanDir()")
}

func (m *MoqType) ParamsKey_ChanDir(params MoqType_ChanDir_params, anyParams uint64) MoqType_ChanDir_paramsKey {
	m.Scene.T.Helper()
	return MoqType_ChanDir_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) IsVariadic() *MoqType_IsVariadic_fnRecorder {
	return &MoqType_IsVariadic_fnRecorder{
		Params:   MoqType_IsVariadic_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_IsVariadic_fnRecorder) Any() *MoqType_IsVariadic_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsVariadic(r.Params))
		return nil
	}
	return &MoqType_IsVariadic_anyParams{Recorder: r}
}

func (r *MoqType_IsVariadic_fnRecorder) Seq() *MoqType_IsVariadic_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsVariadic(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_IsVariadic_fnRecorder) NoSeq() *MoqType_IsVariadic_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsVariadic(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_IsVariadic_fnRecorder) ReturnResults(result1 bool) *MoqType_IsVariadic_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_IsVariadic_doFn
		DoReturnFn MoqType_IsVariadic_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_IsVariadic_fnRecorder) AndDo(fn MoqType_IsVariadic_doFn) *MoqType_IsVariadic_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_IsVariadic_fnRecorder) DoReturnResults(fn MoqType_IsVariadic_doReturnFn) *MoqType_IsVariadic_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqType_IsVariadic_doFn
		DoReturnFn MoqType_IsVariadic_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_IsVariadic_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_IsVariadic_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsVariadic {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_IsVariadic_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_IsVariadic_paramsKey]*MoqType_IsVariadic_results{},
		}
		r.Moq.ResultsByParams_IsVariadic = append(r.Moq.ResultsByParams_IsVariadic, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsVariadic) {
			copy(r.Moq.ResultsByParams_IsVariadic[insertAt+1:], r.Moq.ResultsByParams_IsVariadic[insertAt:0])
			r.Moq.ResultsByParams_IsVariadic[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsVariadic(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_IsVariadic_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_IsVariadic_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_IsVariadic_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqType_IsVariadic_doFn
				DoReturnFn MoqType_IsVariadic_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_IsVariadic(params MoqType_IsVariadic_params) string {
	return fmt.Sprintf("IsVariadic()")
}

func (m *MoqType) ParamsKey_IsVariadic(params MoqType_IsVariadic_params, anyParams uint64) MoqType_IsVariadic_paramsKey {
	m.Scene.T.Helper()
	return MoqType_IsVariadic_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) Elem() *MoqType_Elem_fnRecorder {
	return &MoqType_Elem_fnRecorder{
		Params:   MoqType_Elem_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Elem_fnRecorder) Any() *MoqType_Elem_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Elem(r.Params))
		return nil
	}
	return &MoqType_Elem_anyParams{Recorder: r}
}

func (r *MoqType_Elem_fnRecorder) Seq() *MoqType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Elem(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Elem_fnRecorder) NoSeq() *MoqType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Elem(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Elem_fnRecorder) ReturnResults(result1 reflect.Type) *MoqType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_Elem_doFn
		DoReturnFn MoqType_Elem_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Type
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Elem_fnRecorder) AndDo(fn MoqType_Elem_doFn) *MoqType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Elem_fnRecorder) DoReturnResults(fn MoqType_Elem_doReturnFn) *MoqType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_Elem_doFn
		DoReturnFn MoqType_Elem_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Elem_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Elem_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Elem {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Elem_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Elem_paramsKey]*MoqType_Elem_results{},
		}
		r.Moq.ResultsByParams_Elem = append(r.Moq.ResultsByParams_Elem, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Elem) {
			copy(r.Moq.ResultsByParams_Elem[insertAt+1:], r.Moq.ResultsByParams_Elem[insertAt:0])
			r.Moq.ResultsByParams_Elem[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Elem(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Elem_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Elem_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Elem_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Type
				}
				Sequence   uint32
				DoFn       MoqType_Elem_doFn
				DoReturnFn MoqType_Elem_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Elem(params MoqType_Elem_params) string { return fmt.Sprintf("Elem()") }

func (m *MoqType) ParamsKey_Elem(params MoqType_Elem_params, anyParams uint64) MoqType_Elem_paramsKey {
	m.Scene.T.Helper()
	return MoqType_Elem_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) Field(param1 int) *MoqType_Field_fnRecorder {
	return &MoqType_Field_fnRecorder{
		Params: MoqType_Field_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Field_fnRecorder) Any() *MoqType_Field_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Field(r.Params))
		return nil
	}
	return &MoqType_Field_anyParams{Recorder: r}
}

func (a *MoqType_Field_anyParams) Param1() *MoqType_Field_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqType_Field_fnRecorder) Seq() *MoqType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Field(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Field_fnRecorder) NoSeq() *MoqType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Field(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Field_fnRecorder) ReturnResults(result1 reflect.StructField) *MoqType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.StructField
		}
		Sequence   uint32
		DoFn       MoqType_Field_doFn
		DoReturnFn MoqType_Field_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.StructField
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Field_fnRecorder) AndDo(fn MoqType_Field_doFn) *MoqType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Field_fnRecorder) DoReturnResults(fn MoqType_Field_doReturnFn) *MoqType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.StructField
		}
		Sequence   uint32
		DoFn       MoqType_Field_doFn
		DoReturnFn MoqType_Field_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Field_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Field_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Field {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Field_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Field_paramsKey]*MoqType_Field_results{},
		}
		r.Moq.ResultsByParams_Field = append(r.Moq.ResultsByParams_Field, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Field) {
			copy(r.Moq.ResultsByParams_Field[insertAt+1:], r.Moq.ResultsByParams_Field[insertAt:0])
			r.Moq.ResultsByParams_Field[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Field(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Field_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Field_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Field_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.StructField
				}
				Sequence   uint32
				DoFn       MoqType_Field_doFn
				DoReturnFn MoqType_Field_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Field(params MoqType_Field_params) string {
	return fmt.Sprintf("Field(%#v)", params.Param1)
}

func (m *MoqType) ParamsKey_Field(params MoqType_Field_params, anyParams uint64) MoqType_Field_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Field.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqType_Field_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqType_recorder) FieldByIndex(index []int) *MoqType_FieldByIndex_fnRecorder {
	return &MoqType_FieldByIndex_fnRecorder{
		Params: MoqType_FieldByIndex_params{
			Index: index,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_FieldByIndex_fnRecorder) Any() *MoqType_FieldByIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByIndex(r.Params))
		return nil
	}
	return &MoqType_FieldByIndex_anyParams{Recorder: r}
}

func (a *MoqType_FieldByIndex_anyParams) Index() *MoqType_FieldByIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqType_FieldByIndex_fnRecorder) Seq() *MoqType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_FieldByIndex_fnRecorder) NoSeq() *MoqType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_FieldByIndex_fnRecorder) ReturnResults(result1 reflect.StructField) *MoqType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.StructField
		}
		Sequence   uint32
		DoFn       MoqType_FieldByIndex_doFn
		DoReturnFn MoqType_FieldByIndex_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.StructField
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_FieldByIndex_fnRecorder) AndDo(fn MoqType_FieldByIndex_doFn) *MoqType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_FieldByIndex_fnRecorder) DoReturnResults(fn MoqType_FieldByIndex_doReturnFn) *MoqType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.StructField
		}
		Sequence   uint32
		DoFn       MoqType_FieldByIndex_doFn
		DoReturnFn MoqType_FieldByIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_FieldByIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_FieldByIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FieldByIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_FieldByIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_FieldByIndex_paramsKey]*MoqType_FieldByIndex_results{},
		}
		r.Moq.ResultsByParams_FieldByIndex = append(r.Moq.ResultsByParams_FieldByIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FieldByIndex) {
			copy(r.Moq.ResultsByParams_FieldByIndex[insertAt+1:], r.Moq.ResultsByParams_FieldByIndex[insertAt:0])
			r.Moq.ResultsByParams_FieldByIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FieldByIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_FieldByIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_FieldByIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_FieldByIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.StructField
				}
				Sequence   uint32
				DoFn       MoqType_FieldByIndex_doFn
				DoReturnFn MoqType_FieldByIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_FieldByIndex(params MoqType_FieldByIndex_params) string {
	return fmt.Sprintf("FieldByIndex(%#v)", params.Index)
}

func (m *MoqType) ParamsKey_FieldByIndex(params MoqType_FieldByIndex_params, anyParams uint64) MoqType_FieldByIndex_paramsKey {
	m.Scene.T.Helper()
	var indexUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FieldByIndex.Index == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The index parameter of the FieldByIndex function can't be indexed by value")
		}
		indexUsedHash = hash.DeepHash(params.Index)
	}
	return MoqType_FieldByIndex_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Index hash.Hash }{
			Index: indexUsedHash,
		},
	}
}

func (m *MoqType_recorder) FieldByName(name string) *MoqType_FieldByName_fnRecorder {
	return &MoqType_FieldByName_fnRecorder{
		Params: MoqType_FieldByName_params{
			Name: name,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_FieldByName_fnRecorder) Any() *MoqType_FieldByName_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByName(r.Params))
		return nil
	}
	return &MoqType_FieldByName_anyParams{Recorder: r}
}

func (a *MoqType_FieldByName_anyParams) Name() *MoqType_FieldByName_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqType_FieldByName_fnRecorder) Seq() *MoqType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByName(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_FieldByName_fnRecorder) NoSeq() *MoqType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByName(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_FieldByName_fnRecorder) ReturnResults(result1 reflect.StructField, result2 bool) *MoqType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.StructField
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqType_FieldByName_doFn
		DoReturnFn MoqType_FieldByName_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.StructField
			Result2 bool
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_FieldByName_fnRecorder) AndDo(fn MoqType_FieldByName_doFn) *MoqType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_FieldByName_fnRecorder) DoReturnResults(fn MoqType_FieldByName_doReturnFn) *MoqType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.StructField
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqType_FieldByName_doFn
		DoReturnFn MoqType_FieldByName_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_FieldByName_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_FieldByName_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FieldByName {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_FieldByName_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_FieldByName_paramsKey]*MoqType_FieldByName_results{},
		}
		r.Moq.ResultsByParams_FieldByName = append(r.Moq.ResultsByParams_FieldByName, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FieldByName) {
			copy(r.Moq.ResultsByParams_FieldByName[insertAt+1:], r.Moq.ResultsByParams_FieldByName[insertAt:0])
			r.Moq.ResultsByParams_FieldByName[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FieldByName(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_FieldByName_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_FieldByName_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_FieldByName_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.StructField
					Result2 bool
				}
				Sequence   uint32
				DoFn       MoqType_FieldByName_doFn
				DoReturnFn MoqType_FieldByName_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_FieldByName(params MoqType_FieldByName_params) string {
	return fmt.Sprintf("FieldByName(%#v)", params.Name)
}

func (m *MoqType) ParamsKey_FieldByName(params MoqType_FieldByName_params, anyParams uint64) MoqType_FieldByName_paramsKey {
	m.Scene.T.Helper()
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FieldByName.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	return MoqType_FieldByName_paramsKey{
		Params: struct{ Name string }{
			Name: nameUsed,
		},
		Hashes: struct{ Name hash.Hash }{
			Name: nameUsedHash,
		},
	}
}

func (m *MoqType_recorder) FieldByNameFunc(match func(string) bool) *MoqType_FieldByNameFunc_fnRecorder {
	return &MoqType_FieldByNameFunc_fnRecorder{
		Params: MoqType_FieldByNameFunc_params{
			Match: match,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_FieldByNameFunc_fnRecorder) Any() *MoqType_FieldByNameFunc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByNameFunc(r.Params))
		return nil
	}
	return &MoqType_FieldByNameFunc_anyParams{Recorder: r}
}

func (a *MoqType_FieldByNameFunc_anyParams) Match() *MoqType_FieldByNameFunc_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqType_FieldByNameFunc_fnRecorder) Seq() *MoqType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByNameFunc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_FieldByNameFunc_fnRecorder) NoSeq() *MoqType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FieldByNameFunc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_FieldByNameFunc_fnRecorder) ReturnResults(result1 reflect.StructField, result2 bool) *MoqType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.StructField
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqType_FieldByNameFunc_doFn
		DoReturnFn MoqType_FieldByNameFunc_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.StructField
			Result2 bool
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_FieldByNameFunc_fnRecorder) AndDo(fn MoqType_FieldByNameFunc_doFn) *MoqType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_FieldByNameFunc_fnRecorder) DoReturnResults(fn MoqType_FieldByNameFunc_doReturnFn) *MoqType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.StructField
			Result2 bool
		}
		Sequence   uint32
		DoFn       MoqType_FieldByNameFunc_doFn
		DoReturnFn MoqType_FieldByNameFunc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_FieldByNameFunc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_FieldByNameFunc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FieldByNameFunc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_FieldByNameFunc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_FieldByNameFunc_paramsKey]*MoqType_FieldByNameFunc_results{},
		}
		r.Moq.ResultsByParams_FieldByNameFunc = append(r.Moq.ResultsByParams_FieldByNameFunc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FieldByNameFunc) {
			copy(r.Moq.ResultsByParams_FieldByNameFunc[insertAt+1:], r.Moq.ResultsByParams_FieldByNameFunc[insertAt:0])
			r.Moq.ResultsByParams_FieldByNameFunc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FieldByNameFunc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_FieldByNameFunc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_FieldByNameFunc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_FieldByNameFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.StructField
					Result2 bool
				}
				Sequence   uint32
				DoFn       MoqType_FieldByNameFunc_doFn
				DoReturnFn MoqType_FieldByNameFunc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_FieldByNameFunc(params MoqType_FieldByNameFunc_params) string {
	return fmt.Sprintf("FieldByNameFunc(%#v)", moq.FnString(params.Match))
}

func (m *MoqType) ParamsKey_FieldByNameFunc(params MoqType_FieldByNameFunc_params, anyParams uint64) MoqType_FieldByNameFunc_paramsKey {
	m.Scene.T.Helper()
	var matchUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FieldByNameFunc.Match == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The match parameter of the FieldByNameFunc function can't be indexed by value")
		}
		matchUsedHash = hash.DeepHash(params.Match)
	}
	return MoqType_FieldByNameFunc_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Match hash.Hash }{
			Match: matchUsedHash,
		},
	}
}

func (m *MoqType_recorder) In(param1 int) *MoqType_In_fnRecorder {
	return &MoqType_In_fnRecorder{
		Params: MoqType_In_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_In_fnRecorder) Any() *MoqType_In_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_In(r.Params))
		return nil
	}
	return &MoqType_In_anyParams{Recorder: r}
}

func (a *MoqType_In_anyParams) Param1() *MoqType_In_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqType_In_fnRecorder) Seq() *MoqType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_In(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_In_fnRecorder) NoSeq() *MoqType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_In(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_In_fnRecorder) ReturnResults(result1 reflect.Type) *MoqType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_In_doFn
		DoReturnFn MoqType_In_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Type
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_In_fnRecorder) AndDo(fn MoqType_In_doFn) *MoqType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_In_fnRecorder) DoReturnResults(fn MoqType_In_doReturnFn) *MoqType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_In_doFn
		DoReturnFn MoqType_In_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_In_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_In_resultsByParams
	for n, res := range r.Moq.ResultsByParams_In {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_In_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_In_paramsKey]*MoqType_In_results{},
		}
		r.Moq.ResultsByParams_In = append(r.Moq.ResultsByParams_In, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_In) {
			copy(r.Moq.ResultsByParams_In[insertAt+1:], r.Moq.ResultsByParams_In[insertAt:0])
			r.Moq.ResultsByParams_In[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_In(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_In_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_In_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Type
				}
				Sequence   uint32
				DoFn       MoqType_In_doFn
				DoReturnFn MoqType_In_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_In(params MoqType_In_params) string {
	return fmt.Sprintf("In(%#v)", params.Param1)
}

func (m *MoqType) ParamsKey_In(params MoqType_In_params, anyParams uint64) MoqType_In_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.In.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqType_In_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqType_recorder) Key() *MoqType_Key_fnRecorder {
	return &MoqType_Key_fnRecorder{
		Params:   MoqType_Key_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Key_fnRecorder) Any() *MoqType_Key_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Key(r.Params))
		return nil
	}
	return &MoqType_Key_anyParams{Recorder: r}
}

func (r *MoqType_Key_fnRecorder) Seq() *MoqType_Key_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Key(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Key_fnRecorder) NoSeq() *MoqType_Key_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Key(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Key_fnRecorder) ReturnResults(result1 reflect.Type) *MoqType_Key_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_Key_doFn
		DoReturnFn MoqType_Key_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Type
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Key_fnRecorder) AndDo(fn MoqType_Key_doFn) *MoqType_Key_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Key_fnRecorder) DoReturnResults(fn MoqType_Key_doReturnFn) *MoqType_Key_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_Key_doFn
		DoReturnFn MoqType_Key_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Key_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Key_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Key {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Key_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Key_paramsKey]*MoqType_Key_results{},
		}
		r.Moq.ResultsByParams_Key = append(r.Moq.ResultsByParams_Key, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Key) {
			copy(r.Moq.ResultsByParams_Key[insertAt+1:], r.Moq.ResultsByParams_Key[insertAt:0])
			r.Moq.ResultsByParams_Key[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Key(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Key_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Key_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Key_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Type
				}
				Sequence   uint32
				DoFn       MoqType_Key_doFn
				DoReturnFn MoqType_Key_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Key(params MoqType_Key_params) string { return fmt.Sprintf("Key()") }

func (m *MoqType) ParamsKey_Key(params MoqType_Key_params, anyParams uint64) MoqType_Key_paramsKey {
	m.Scene.T.Helper()
	return MoqType_Key_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) Len() *MoqType_Len_fnRecorder {
	return &MoqType_Len_fnRecorder{
		Params:   MoqType_Len_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Len_fnRecorder) Any() *MoqType_Len_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	return &MoqType_Len_anyParams{Recorder: r}
}

func (r *MoqType_Len_fnRecorder) Seq() *MoqType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Len_fnRecorder) NoSeq() *MoqType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Len_fnRecorder) ReturnResults(result1 int) *MoqType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_Len_doFn
		DoReturnFn MoqType_Len_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Len_fnRecorder) AndDo(fn MoqType_Len_doFn) *MoqType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Len_fnRecorder) DoReturnResults(fn MoqType_Len_doReturnFn) *MoqType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_Len_doFn
		DoReturnFn MoqType_Len_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Len_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Len_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Len {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Len_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Len_paramsKey]*MoqType_Len_results{},
		}
		r.Moq.ResultsByParams_Len = append(r.Moq.ResultsByParams_Len, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Len) {
			copy(r.Moq.ResultsByParams_Len[insertAt+1:], r.Moq.ResultsByParams_Len[insertAt:0])
			r.Moq.ResultsByParams_Len[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Len(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Len_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Len_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqType_Len_doFn
				DoReturnFn MoqType_Len_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Len(params MoqType_Len_params) string { return fmt.Sprintf("Len()") }

func (m *MoqType) ParamsKey_Len(params MoqType_Len_params, anyParams uint64) MoqType_Len_paramsKey {
	m.Scene.T.Helper()
	return MoqType_Len_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) NumField() *MoqType_NumField_fnRecorder {
	return &MoqType_NumField_fnRecorder{
		Params:   MoqType_NumField_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_NumField_fnRecorder) Any() *MoqType_NumField_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumField(r.Params))
		return nil
	}
	return &MoqType_NumField_anyParams{Recorder: r}
}

func (r *MoqType_NumField_fnRecorder) Seq() *MoqType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumField(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_NumField_fnRecorder) NoSeq() *MoqType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumField(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_NumField_fnRecorder) ReturnResults(result1 int) *MoqType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumField_doFn
		DoReturnFn MoqType_NumField_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_NumField_fnRecorder) AndDo(fn MoqType_NumField_doFn) *MoqType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_NumField_fnRecorder) DoReturnResults(fn MoqType_NumField_doReturnFn) *MoqType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumField_doFn
		DoReturnFn MoqType_NumField_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_NumField_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_NumField_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumField {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_NumField_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_NumField_paramsKey]*MoqType_NumField_results{},
		}
		r.Moq.ResultsByParams_NumField = append(r.Moq.ResultsByParams_NumField, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumField) {
			copy(r.Moq.ResultsByParams_NumField[insertAt+1:], r.Moq.ResultsByParams_NumField[insertAt:0])
			r.Moq.ResultsByParams_NumField[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumField(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_NumField_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_NumField_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_NumField_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqType_NumField_doFn
				DoReturnFn MoqType_NumField_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_NumField(params MoqType_NumField_params) string {
	return fmt.Sprintf("NumField()")
}

func (m *MoqType) ParamsKey_NumField(params MoqType_NumField_params, anyParams uint64) MoqType_NumField_paramsKey {
	m.Scene.T.Helper()
	return MoqType_NumField_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) NumIn() *MoqType_NumIn_fnRecorder {
	return &MoqType_NumIn_fnRecorder{
		Params:   MoqType_NumIn_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_NumIn_fnRecorder) Any() *MoqType_NumIn_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumIn(r.Params))
		return nil
	}
	return &MoqType_NumIn_anyParams{Recorder: r}
}

func (r *MoqType_NumIn_fnRecorder) Seq() *MoqType_NumIn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumIn(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_NumIn_fnRecorder) NoSeq() *MoqType_NumIn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumIn(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_NumIn_fnRecorder) ReturnResults(result1 int) *MoqType_NumIn_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumIn_doFn
		DoReturnFn MoqType_NumIn_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_NumIn_fnRecorder) AndDo(fn MoqType_NumIn_doFn) *MoqType_NumIn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_NumIn_fnRecorder) DoReturnResults(fn MoqType_NumIn_doReturnFn) *MoqType_NumIn_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumIn_doFn
		DoReturnFn MoqType_NumIn_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_NumIn_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_NumIn_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumIn {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_NumIn_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_NumIn_paramsKey]*MoqType_NumIn_results{},
		}
		r.Moq.ResultsByParams_NumIn = append(r.Moq.ResultsByParams_NumIn, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumIn) {
			copy(r.Moq.ResultsByParams_NumIn[insertAt+1:], r.Moq.ResultsByParams_NumIn[insertAt:0])
			r.Moq.ResultsByParams_NumIn[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumIn(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_NumIn_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_NumIn_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_NumIn_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqType_NumIn_doFn
				DoReturnFn MoqType_NumIn_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_NumIn(params MoqType_NumIn_params) string {
	return fmt.Sprintf("NumIn()")
}

func (m *MoqType) ParamsKey_NumIn(params MoqType_NumIn_params, anyParams uint64) MoqType_NumIn_paramsKey {
	m.Scene.T.Helper()
	return MoqType_NumIn_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) NumOut() *MoqType_NumOut_fnRecorder {
	return &MoqType_NumOut_fnRecorder{
		Params:   MoqType_NumOut_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_NumOut_fnRecorder) Any() *MoqType_NumOut_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumOut(r.Params))
		return nil
	}
	return &MoqType_NumOut_anyParams{Recorder: r}
}

func (r *MoqType_NumOut_fnRecorder) Seq() *MoqType_NumOut_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumOut(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_NumOut_fnRecorder) NoSeq() *MoqType_NumOut_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumOut(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_NumOut_fnRecorder) ReturnResults(result1 int) *MoqType_NumOut_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumOut_doFn
		DoReturnFn MoqType_NumOut_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_NumOut_fnRecorder) AndDo(fn MoqType_NumOut_doFn) *MoqType_NumOut_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_NumOut_fnRecorder) DoReturnResults(fn MoqType_NumOut_doReturnFn) *MoqType_NumOut_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqType_NumOut_doFn
		DoReturnFn MoqType_NumOut_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_NumOut_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_NumOut_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumOut {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_NumOut_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_NumOut_paramsKey]*MoqType_NumOut_results{},
		}
		r.Moq.ResultsByParams_NumOut = append(r.Moq.ResultsByParams_NumOut, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumOut) {
			copy(r.Moq.ResultsByParams_NumOut[insertAt+1:], r.Moq.ResultsByParams_NumOut[insertAt:0])
			r.Moq.ResultsByParams_NumOut[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumOut(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_NumOut_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_NumOut_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_NumOut_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqType_NumOut_doFn
				DoReturnFn MoqType_NumOut_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_NumOut(params MoqType_NumOut_params) string {
	return fmt.Sprintf("NumOut()")
}

func (m *MoqType) ParamsKey_NumOut(params MoqType_NumOut_params, anyParams uint64) MoqType_NumOut_paramsKey {
	m.Scene.T.Helper()
	return MoqType_NumOut_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqType_recorder) Out(param1 int) *MoqType_Out_fnRecorder {
	return &MoqType_Out_fnRecorder{
		Params: MoqType_Out_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqType_Out_fnRecorder) Any() *MoqType_Out_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Out(r.Params))
		return nil
	}
	return &MoqType_Out_anyParams{Recorder: r}
}

func (a *MoqType_Out_anyParams) Param1() *MoqType_Out_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqType_Out_fnRecorder) Seq() *MoqType_Out_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Out(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqType_Out_fnRecorder) NoSeq() *MoqType_Out_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Out(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqType_Out_fnRecorder) ReturnResults(result1 reflect.Type) *MoqType_Out_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_Out_doFn
		DoReturnFn MoqType_Out_doReturnFn
	}{
		Values: &struct {
			Result1 reflect.Type
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqType_Out_fnRecorder) AndDo(fn MoqType_Out_doFn) *MoqType_Out_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqType_Out_fnRecorder) DoReturnResults(fn MoqType_Out_doReturnFn) *MoqType_Out_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 reflect.Type
		}
		Sequence   uint32
		DoFn       MoqType_Out_doFn
		DoReturnFn MoqType_Out_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqType_Out_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqType_Out_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Out {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqType_Out_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqType_Out_paramsKey]*MoqType_Out_results{},
		}
		r.Moq.ResultsByParams_Out = append(r.Moq.ResultsByParams_Out, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Out) {
			copy(r.Moq.ResultsByParams_Out[insertAt+1:], r.Moq.ResultsByParams_Out[insertAt:0])
			r.Moq.ResultsByParams_Out[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Out(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqType_Out_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqType_Out_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqType_Out_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 reflect.Type
				}
				Sequence   uint32
				DoFn       MoqType_Out_doFn
				DoReturnFn MoqType_Out_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqType) PrettyParams_Out(params MoqType_Out_params) string {
	return fmt.Sprintf("Out(%#v)", params.Param1)
}

func (m *MoqType) ParamsKey_Out(params MoqType_Out_params, anyParams uint64) MoqType_Out_paramsKey {
	m.Scene.T.Helper()
	var param1Used int
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Out.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqType_Out_paramsKey{
		Params: struct{ Param1 int }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqType) Reset() {
	m.ResultsByParams_Align = nil
	m.ResultsByParams_FieldAlign = nil
	m.ResultsByParams_Method = nil
	m.ResultsByParams_MethodByName = nil
	m.ResultsByParams_NumMethod = nil
	m.ResultsByParams_Name = nil
	m.ResultsByParams_PkgPath = nil
	m.ResultsByParams_Size = nil
	m.ResultsByParams_String = nil
	m.ResultsByParams_Kind = nil
	m.ResultsByParams_Implements = nil
	m.ResultsByParams_AssignableTo = nil
	m.ResultsByParams_ConvertibleTo = nil
	m.ResultsByParams_Comparable = nil
	m.ResultsByParams_Bits = nil
	m.ResultsByParams_ChanDir = nil
	m.ResultsByParams_IsVariadic = nil
	m.ResultsByParams_Elem = nil
	m.ResultsByParams_Field = nil
	m.ResultsByParams_FieldByIndex = nil
	m.ResultsByParams_FieldByName = nil
	m.ResultsByParams_FieldByNameFunc = nil
	m.ResultsByParams_In = nil
	m.ResultsByParams_Key = nil
	m.ResultsByParams_Len = nil
	m.ResultsByParams_NumField = nil
	m.ResultsByParams_NumIn = nil
	m.ResultsByParams_NumOut = nil
	m.ResultsByParams_Out = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Align {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Align(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FieldAlign {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FieldAlign(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Method {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Method(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MethodByName {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MethodByName(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_NumMethod {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumMethod(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Name {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Name(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_PkgPath {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_PkgPath(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Size {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Size(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Kind {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Kind(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Implements {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Implements(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AssignableTo {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AssignableTo(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ConvertibleTo {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ConvertibleTo(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Comparable {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Comparable(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Bits {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Bits(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ChanDir {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ChanDir(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsVariadic {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsVariadic(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Elem {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Elem(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Field {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Field(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FieldByIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FieldByIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FieldByName {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FieldByName(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FieldByNameFunc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FieldByNameFunc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_In {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_In(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Key {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Key(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Len {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Len(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_NumField {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumField(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_NumIn {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumIn(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_NumOut {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumOut(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Out {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Out(results.Params))
			}
		}
	}
}
