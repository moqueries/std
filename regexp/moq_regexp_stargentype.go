// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package regexp

import (
	"fmt"
	"io"
	"math/bits"
	"regexp"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that regexp.Regexp_starGenType is
// mocked completely
var _ Regexp_starGenType = (*MoqRegexp_starGenType_mock)(nil)

// Regexp_starGenType is the fabricated implementation type of this mock
// (emitted when mocking a collections of methods directly and not from an
// interface type)
type Regexp_starGenType interface {
	String() string
	Copy() *regexp.Regexp
	Longest()
	NumSubexp() int
	SubexpNames() []string
	SubexpIndex(name string) int
	LiteralPrefix() (prefix string, complete bool)
	MatchReader(r io.RuneReader) bool
	MatchString(s string) bool
	Match(b []byte) bool
	ReplaceAllString(src, repl string) string
	ReplaceAllLiteralString(src, repl string) string
	ReplaceAllStringFunc(src string, repl func(string) string) string
	ReplaceAll(src, repl []byte) []byte
	ReplaceAllLiteral(src, repl []byte) []byte
	ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte
	Find(b []byte) []byte
	FindIndex(b []byte) (loc []int)
	FindString(s string) string
	FindStringIndex(s string) (loc []int)
	FindReaderIndex(r io.RuneReader) (loc []int)
	FindSubmatch(b []byte) [][]byte
	Expand(dst []byte, template []byte, src []byte, match []int) []byte
	ExpandString(dst []byte, template string, src string, match []int) []byte
	FindSubmatchIndex(b []byte) []int
	FindStringSubmatch(s string) []string
	FindStringSubmatchIndex(s string) []int
	FindReaderSubmatchIndex(r io.RuneReader) []int
	FindAll(b []byte, n int) [][]byte
	FindAllIndex(b []byte, n int) [][]int
	FindAllString(s string, n int) []string
	FindAllStringIndex(s string, n int) [][]int
	FindAllSubmatch(b []byte, n int) [][][]byte
	FindAllSubmatchIndex(b []byte, n int) [][]int
	FindAllStringSubmatch(s string, n int) [][]string
	FindAllStringSubmatchIndex(s string, n int) [][]int
	Split(s string, n int) []string
}

// MoqRegexp_starGenType holds the state of a moq of the Regexp_starGenType
// type
type MoqRegexp_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqRegexp_starGenType_mock

	ResultsByParams_String                     []MoqRegexp_starGenType_String_resultsByParams
	ResultsByParams_Copy                       []MoqRegexp_starGenType_Copy_resultsByParams
	ResultsByParams_Longest                    []MoqRegexp_starGenType_Longest_resultsByParams
	ResultsByParams_NumSubexp                  []MoqRegexp_starGenType_NumSubexp_resultsByParams
	ResultsByParams_SubexpNames                []MoqRegexp_starGenType_SubexpNames_resultsByParams
	ResultsByParams_SubexpIndex                []MoqRegexp_starGenType_SubexpIndex_resultsByParams
	ResultsByParams_LiteralPrefix              []MoqRegexp_starGenType_LiteralPrefix_resultsByParams
	ResultsByParams_MatchReader                []MoqRegexp_starGenType_MatchReader_resultsByParams
	ResultsByParams_MatchString                []MoqRegexp_starGenType_MatchString_resultsByParams
	ResultsByParams_Match                      []MoqRegexp_starGenType_Match_resultsByParams
	ResultsByParams_ReplaceAllString           []MoqRegexp_starGenType_ReplaceAllString_resultsByParams
	ResultsByParams_ReplaceAllLiteralString    []MoqRegexp_starGenType_ReplaceAllLiteralString_resultsByParams
	ResultsByParams_ReplaceAllStringFunc       []MoqRegexp_starGenType_ReplaceAllStringFunc_resultsByParams
	ResultsByParams_ReplaceAll                 []MoqRegexp_starGenType_ReplaceAll_resultsByParams
	ResultsByParams_ReplaceAllLiteral          []MoqRegexp_starGenType_ReplaceAllLiteral_resultsByParams
	ResultsByParams_ReplaceAllFunc             []MoqRegexp_starGenType_ReplaceAllFunc_resultsByParams
	ResultsByParams_Find                       []MoqRegexp_starGenType_Find_resultsByParams
	ResultsByParams_FindIndex                  []MoqRegexp_starGenType_FindIndex_resultsByParams
	ResultsByParams_FindString                 []MoqRegexp_starGenType_FindString_resultsByParams
	ResultsByParams_FindStringIndex            []MoqRegexp_starGenType_FindStringIndex_resultsByParams
	ResultsByParams_FindReaderIndex            []MoqRegexp_starGenType_FindReaderIndex_resultsByParams
	ResultsByParams_FindSubmatch               []MoqRegexp_starGenType_FindSubmatch_resultsByParams
	ResultsByParams_Expand                     []MoqRegexp_starGenType_Expand_resultsByParams
	ResultsByParams_ExpandString               []MoqRegexp_starGenType_ExpandString_resultsByParams
	ResultsByParams_FindSubmatchIndex          []MoqRegexp_starGenType_FindSubmatchIndex_resultsByParams
	ResultsByParams_FindStringSubmatch         []MoqRegexp_starGenType_FindStringSubmatch_resultsByParams
	ResultsByParams_FindStringSubmatchIndex    []MoqRegexp_starGenType_FindStringSubmatchIndex_resultsByParams
	ResultsByParams_FindReaderSubmatchIndex    []MoqRegexp_starGenType_FindReaderSubmatchIndex_resultsByParams
	ResultsByParams_FindAll                    []MoqRegexp_starGenType_FindAll_resultsByParams
	ResultsByParams_FindAllIndex               []MoqRegexp_starGenType_FindAllIndex_resultsByParams
	ResultsByParams_FindAllString              []MoqRegexp_starGenType_FindAllString_resultsByParams
	ResultsByParams_FindAllStringIndex         []MoqRegexp_starGenType_FindAllStringIndex_resultsByParams
	ResultsByParams_FindAllSubmatch            []MoqRegexp_starGenType_FindAllSubmatch_resultsByParams
	ResultsByParams_FindAllSubmatchIndex       []MoqRegexp_starGenType_FindAllSubmatchIndex_resultsByParams
	ResultsByParams_FindAllStringSubmatch      []MoqRegexp_starGenType_FindAllStringSubmatch_resultsByParams
	ResultsByParams_FindAllStringSubmatchIndex []MoqRegexp_starGenType_FindAllStringSubmatchIndex_resultsByParams
	ResultsByParams_Split                      []MoqRegexp_starGenType_Split_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			String      struct{}
			Copy        struct{}
			Longest     struct{}
			NumSubexp   struct{}
			SubexpNames struct{}
			SubexpIndex struct {
				Name moq.ParamIndexing
			}
			LiteralPrefix struct{}
			MatchReader   struct {
				Param1 moq.ParamIndexing
			}
			MatchString struct {
				S moq.ParamIndexing
			}
			Match struct {
				B moq.ParamIndexing
			}
			ReplaceAllString struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			ReplaceAllLiteralString struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			ReplaceAllStringFunc struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			ReplaceAll struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			ReplaceAllLiteral struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			ReplaceAllFunc struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			Find struct {
				B moq.ParamIndexing
			}
			FindIndex struct {
				B moq.ParamIndexing
			}
			FindString struct {
				S moq.ParamIndexing
			}
			FindStringIndex struct {
				S moq.ParamIndexing
			}
			FindReaderIndex struct {
				Param1 moq.ParamIndexing
			}
			FindSubmatch struct {
				B moq.ParamIndexing
			}
			Expand struct {
				Dst      moq.ParamIndexing
				Template moq.ParamIndexing
				Src      moq.ParamIndexing
				Match    moq.ParamIndexing
			}
			ExpandString struct {
				Dst      moq.ParamIndexing
				Template moq.ParamIndexing
				Src      moq.ParamIndexing
				Match    moq.ParamIndexing
			}
			FindSubmatchIndex struct {
				B moq.ParamIndexing
			}
			FindStringSubmatch struct {
				S moq.ParamIndexing
			}
			FindStringSubmatchIndex struct {
				S moq.ParamIndexing
			}
			FindReaderSubmatchIndex struct {
				Param1 moq.ParamIndexing
			}
			FindAll struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllIndex struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllString struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllStringIndex struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllSubmatch struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllSubmatchIndex struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllStringSubmatch struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllStringSubmatchIndex struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}
			Split struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}
		}
	}
	// MoqRegexp_starGenType_mock isolates the mock interface of the
}

// Regexp_starGenType type
type MoqRegexp_starGenType_mock struct {
	Moq *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_recorder isolates the recorder interface of the
// Regexp_starGenType type
type MoqRegexp_starGenType_recorder struct {
	Moq *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_String_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_String_params struct{}

// MoqRegexp_starGenType_String_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRegexp_starGenType_String_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_String_paramsKey]*MoqRegexp_starGenType_String_results
}

// MoqRegexp_starGenType_String_doFn defines the type of function needed when
// calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_String_doFn func()

// MoqRegexp_starGenType_String_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_String_doReturnFn func() string

// MoqRegexp_starGenType_String_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_String_results struct {
	Params  MoqRegexp_starGenType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_String_doFn
		DoReturnFn MoqRegexp_starGenType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_String_fnRecorder routes recorded function calls to
// the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_String_fnRecorder struct {
	Params    MoqRegexp_starGenType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_String_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_String_anyParams isolates the any params functions of
// the Regexp_starGenType type
type MoqRegexp_starGenType_String_anyParams struct {
	Recorder *MoqRegexp_starGenType_String_fnRecorder
}

// MoqRegexp_starGenType_Copy_params holds the params of the Regexp_starGenType
// type
type MoqRegexp_starGenType_Copy_params struct{}

// MoqRegexp_starGenType_Copy_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Copy_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRegexp_starGenType_Copy_resultsByParams contains the results for a given
// set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_Copy_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_Copy_paramsKey]*MoqRegexp_starGenType_Copy_results
}

// MoqRegexp_starGenType_Copy_doFn defines the type of function needed when
// calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_Copy_doFn func()

// MoqRegexp_starGenType_Copy_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_Copy_doReturnFn func() *regexp.Regexp

// MoqRegexp_starGenType_Copy_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Copy_results struct {
	Params  MoqRegexp_starGenType_Copy_params
	Results []struct {
		Values *struct {
			Result1 *regexp.Regexp
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Copy_doFn
		DoReturnFn MoqRegexp_starGenType_Copy_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_Copy_fnRecorder routes recorded function calls to the
// MoqRegexp_starGenType moq
type MoqRegexp_starGenType_Copy_fnRecorder struct {
	Params    MoqRegexp_starGenType_Copy_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_Copy_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_Copy_anyParams isolates the any params functions of
// the Regexp_starGenType type
type MoqRegexp_starGenType_Copy_anyParams struct {
	Recorder *MoqRegexp_starGenType_Copy_fnRecorder
}

// MoqRegexp_starGenType_Longest_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Longest_params struct{}

// MoqRegexp_starGenType_Longest_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Longest_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRegexp_starGenType_Longest_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_Longest_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_Longest_paramsKey]*MoqRegexp_starGenType_Longest_results
}

// MoqRegexp_starGenType_Longest_doFn defines the type of function needed when
// calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_Longest_doFn func()

// MoqRegexp_starGenType_Longest_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_Longest_doReturnFn func()

// MoqRegexp_starGenType_Longest_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Longest_results struct {
	Params  MoqRegexp_starGenType_Longest_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Longest_doFn
		DoReturnFn MoqRegexp_starGenType_Longest_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_Longest_fnRecorder routes recorded function calls to
// the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_Longest_fnRecorder struct {
	Params    MoqRegexp_starGenType_Longest_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_Longest_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_Longest_anyParams isolates the any params functions of
// the Regexp_starGenType type
type MoqRegexp_starGenType_Longest_anyParams struct {
	Recorder *MoqRegexp_starGenType_Longest_fnRecorder
}

// MoqRegexp_starGenType_NumSubexp_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_NumSubexp_params struct{}

// MoqRegexp_starGenType_NumSubexp_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_NumSubexp_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRegexp_starGenType_NumSubexp_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_NumSubexp_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_NumSubexp_paramsKey]*MoqRegexp_starGenType_NumSubexp_results
}

// MoqRegexp_starGenType_NumSubexp_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_NumSubexp_doFn func()

// MoqRegexp_starGenType_NumSubexp_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_NumSubexp_doReturnFn func() int

// MoqRegexp_starGenType_NumSubexp_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_NumSubexp_results struct {
	Params  MoqRegexp_starGenType_NumSubexp_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_NumSubexp_doFn
		DoReturnFn MoqRegexp_starGenType_NumSubexp_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_NumSubexp_fnRecorder routes recorded function calls to
// the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_NumSubexp_fnRecorder struct {
	Params    MoqRegexp_starGenType_NumSubexp_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_NumSubexp_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_NumSubexp_anyParams isolates the any params functions
// of the Regexp_starGenType type
type MoqRegexp_starGenType_NumSubexp_anyParams struct {
	Recorder *MoqRegexp_starGenType_NumSubexp_fnRecorder
}

// MoqRegexp_starGenType_SubexpNames_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_SubexpNames_params struct{}

// MoqRegexp_starGenType_SubexpNames_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_SubexpNames_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRegexp_starGenType_SubexpNames_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_SubexpNames_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_SubexpNames_paramsKey]*MoqRegexp_starGenType_SubexpNames_results
}

// MoqRegexp_starGenType_SubexpNames_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_SubexpNames_doFn func()

// MoqRegexp_starGenType_SubexpNames_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_SubexpNames_doReturnFn func() []string

// MoqRegexp_starGenType_SubexpNames_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_SubexpNames_results struct {
	Params  MoqRegexp_starGenType_SubexpNames_params
	Results []struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_SubexpNames_doFn
		DoReturnFn MoqRegexp_starGenType_SubexpNames_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_SubexpNames_fnRecorder routes recorded function calls
// to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_SubexpNames_fnRecorder struct {
	Params    MoqRegexp_starGenType_SubexpNames_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_SubexpNames_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_SubexpNames_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_SubexpNames_anyParams struct {
	Recorder *MoqRegexp_starGenType_SubexpNames_fnRecorder
}

// MoqRegexp_starGenType_SubexpIndex_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_SubexpIndex_params struct{ Name string }

// MoqRegexp_starGenType_SubexpIndex_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_SubexpIndex_paramsKey struct {
	Params struct{ Name string }
	Hashes struct{ Name hash.Hash }
}

// MoqRegexp_starGenType_SubexpIndex_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_SubexpIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_SubexpIndex_paramsKey]*MoqRegexp_starGenType_SubexpIndex_results
}

// MoqRegexp_starGenType_SubexpIndex_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_SubexpIndex_doFn func(name string)

// MoqRegexp_starGenType_SubexpIndex_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_SubexpIndex_doReturnFn func(name string) int

// MoqRegexp_starGenType_SubexpIndex_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_SubexpIndex_results struct {
	Params  MoqRegexp_starGenType_SubexpIndex_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_SubexpIndex_doFn
		DoReturnFn MoqRegexp_starGenType_SubexpIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_SubexpIndex_fnRecorder routes recorded function calls
// to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_SubexpIndex_fnRecorder struct {
	Params    MoqRegexp_starGenType_SubexpIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_SubexpIndex_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_SubexpIndex_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_SubexpIndex_anyParams struct {
	Recorder *MoqRegexp_starGenType_SubexpIndex_fnRecorder
}

// MoqRegexp_starGenType_LiteralPrefix_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_LiteralPrefix_params struct{}

// MoqRegexp_starGenType_LiteralPrefix_paramsKey holds the map key params of
// the Regexp_starGenType type
type MoqRegexp_starGenType_LiteralPrefix_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqRegexp_starGenType_LiteralPrefix_resultsByParams contains the results for
// a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_LiteralPrefix_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_LiteralPrefix_paramsKey]*MoqRegexp_starGenType_LiteralPrefix_results
}

// MoqRegexp_starGenType_LiteralPrefix_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_LiteralPrefix_doFn func()

// MoqRegexp_starGenType_LiteralPrefix_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_LiteralPrefix_doReturnFn func() (prefix string, complete bool)

// MoqRegexp_starGenType_LiteralPrefix_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_LiteralPrefix_results struct {
	Params  MoqRegexp_starGenType_LiteralPrefix_params
	Results []struct {
		Values *struct {
			Prefix   string
			Complete bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_LiteralPrefix_doFn
		DoReturnFn MoqRegexp_starGenType_LiteralPrefix_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_LiteralPrefix_fnRecorder routes recorded function
// calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_LiteralPrefix_fnRecorder struct {
	Params    MoqRegexp_starGenType_LiteralPrefix_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_LiteralPrefix_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_LiteralPrefix_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_LiteralPrefix_anyParams struct {
	Recorder *MoqRegexp_starGenType_LiteralPrefix_fnRecorder
}

// MoqRegexp_starGenType_MatchReader_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_MatchReader_params struct{ Param1 io.RuneReader }

// MoqRegexp_starGenType_MatchReader_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_MatchReader_paramsKey struct {
	Params struct{ Param1 io.RuneReader }
	Hashes struct{ Param1 hash.Hash }
}

// MoqRegexp_starGenType_MatchReader_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_MatchReader_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_MatchReader_paramsKey]*MoqRegexp_starGenType_MatchReader_results
}

// MoqRegexp_starGenType_MatchReader_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_MatchReader_doFn func(r io.RuneReader)

// MoqRegexp_starGenType_MatchReader_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_MatchReader_doReturnFn func(r io.RuneReader) bool

// MoqRegexp_starGenType_MatchReader_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_MatchReader_results struct {
	Params  MoqRegexp_starGenType_MatchReader_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_MatchReader_doFn
		DoReturnFn MoqRegexp_starGenType_MatchReader_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_MatchReader_fnRecorder routes recorded function calls
// to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_MatchReader_fnRecorder struct {
	Params    MoqRegexp_starGenType_MatchReader_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_MatchReader_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_MatchReader_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_MatchReader_anyParams struct {
	Recorder *MoqRegexp_starGenType_MatchReader_fnRecorder
}

// MoqRegexp_starGenType_MatchString_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_MatchString_params struct{ S string }

// MoqRegexp_starGenType_MatchString_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_MatchString_paramsKey struct {
	Params struct{ S string }
	Hashes struct{ S hash.Hash }
}

// MoqRegexp_starGenType_MatchString_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_MatchString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_MatchString_paramsKey]*MoqRegexp_starGenType_MatchString_results
}

// MoqRegexp_starGenType_MatchString_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_MatchString_doFn func(s string)

// MoqRegexp_starGenType_MatchString_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_MatchString_doReturnFn func(s string) bool

// MoqRegexp_starGenType_MatchString_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_MatchString_results struct {
	Params  MoqRegexp_starGenType_MatchString_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_MatchString_doFn
		DoReturnFn MoqRegexp_starGenType_MatchString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_MatchString_fnRecorder routes recorded function calls
// to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_MatchString_fnRecorder struct {
	Params    MoqRegexp_starGenType_MatchString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_MatchString_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_MatchString_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_MatchString_anyParams struct {
	Recorder *MoqRegexp_starGenType_MatchString_fnRecorder
}

// MoqRegexp_starGenType_Match_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Match_params struct{ B []byte }

// MoqRegexp_starGenType_Match_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Match_paramsKey struct {
	Params struct{}
	Hashes struct{ B hash.Hash }
}

// MoqRegexp_starGenType_Match_resultsByParams contains the results for a given
// set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_Match_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_Match_paramsKey]*MoqRegexp_starGenType_Match_results
}

// MoqRegexp_starGenType_Match_doFn defines the type of function needed when
// calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_Match_doFn func(b []byte)

// MoqRegexp_starGenType_Match_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_Match_doReturnFn func(b []byte) bool

// MoqRegexp_starGenType_Match_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Match_results struct {
	Params  MoqRegexp_starGenType_Match_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Match_doFn
		DoReturnFn MoqRegexp_starGenType_Match_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_Match_fnRecorder routes recorded function calls to the
// MoqRegexp_starGenType moq
type MoqRegexp_starGenType_Match_fnRecorder struct {
	Params    MoqRegexp_starGenType_Match_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_Match_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_Match_anyParams isolates the any params functions of
// the Regexp_starGenType type
type MoqRegexp_starGenType_Match_anyParams struct {
	Recorder *MoqRegexp_starGenType_Match_fnRecorder
}

// MoqRegexp_starGenType_ReplaceAllString_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllString_params struct{ Src, Repl string }

// MoqRegexp_starGenType_ReplaceAllString_paramsKey holds the map key params of
// the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllString_paramsKey struct {
	Params struct{ Src, Repl string }
	Hashes struct{ Src, Repl hash.Hash }
}

// MoqRegexp_starGenType_ReplaceAllString_resultsByParams contains the results
// for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_ReplaceAllString_paramsKey]*MoqRegexp_starGenType_ReplaceAllString_results
}

// MoqRegexp_starGenType_ReplaceAllString_doFn defines the type of function
// needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllString_doFn func(src, repl string)

// MoqRegexp_starGenType_ReplaceAllString_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllString_doReturnFn func(src, repl string) string

// MoqRegexp_starGenType_ReplaceAllString_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllString_results struct {
	Params  MoqRegexp_starGenType_ReplaceAllString_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllString_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_ReplaceAllString_fnRecorder routes recorded function
// calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_ReplaceAllString_fnRecorder struct {
	Params    MoqRegexp_starGenType_ReplaceAllString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_ReplaceAllString_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_ReplaceAllString_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllString_anyParams struct {
	Recorder *MoqRegexp_starGenType_ReplaceAllString_fnRecorder
}

// MoqRegexp_starGenType_ReplaceAllLiteralString_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteralString_params struct{ Src, Repl string }

// MoqRegexp_starGenType_ReplaceAllLiteralString_paramsKey holds the map key
// params of the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteralString_paramsKey struct {
	Params struct{ Src, Repl string }
	Hashes struct{ Src, Repl hash.Hash }
}

// MoqRegexp_starGenType_ReplaceAllLiteralString_resultsByParams contains the
// results for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteralString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_ReplaceAllLiteralString_paramsKey]*MoqRegexp_starGenType_ReplaceAllLiteralString_results
}

// MoqRegexp_starGenType_ReplaceAllLiteralString_doFn defines the type of
// function needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteralString_doFn func(src, repl string)

// MoqRegexp_starGenType_ReplaceAllLiteralString_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteralString_doReturnFn func(src, repl string) string

// MoqRegexp_starGenType_ReplaceAllLiteralString_results holds the results of
// the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteralString_results struct {
	Params  MoqRegexp_starGenType_ReplaceAllLiteralString_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllLiteralString_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllLiteralString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder routes recorded
// function calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder struct {
	Params    MoqRegexp_starGenType_ReplaceAllLiteralString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_ReplaceAllLiteralString_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_ReplaceAllLiteralString_anyParams isolates the any
// params functions of the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteralString_anyParams struct {
	Recorder *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder
}

// MoqRegexp_starGenType_ReplaceAllStringFunc_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllStringFunc_params struct {
	Src  string
	Repl func(string) string
}

// MoqRegexp_starGenType_ReplaceAllStringFunc_paramsKey holds the map key
// params of the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllStringFunc_paramsKey struct {
	Params struct{ Src string }
	Hashes struct {
		Src  hash.Hash
		Repl hash.Hash
	}
}

// MoqRegexp_starGenType_ReplaceAllStringFunc_resultsByParams contains the
// results for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllStringFunc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_ReplaceAllStringFunc_paramsKey]*MoqRegexp_starGenType_ReplaceAllStringFunc_results
}

// MoqRegexp_starGenType_ReplaceAllStringFunc_doFn defines the type of function
// needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllStringFunc_doFn func(src string, repl func(string) string)

// MoqRegexp_starGenType_ReplaceAllStringFunc_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllStringFunc_doReturnFn func(src string, repl func(string) string) string

// MoqRegexp_starGenType_ReplaceAllStringFunc_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllStringFunc_results struct {
	Params  MoqRegexp_starGenType_ReplaceAllStringFunc_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllStringFunc_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllStringFunc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder routes recorded
// function calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder struct {
	Params    MoqRegexp_starGenType_ReplaceAllStringFunc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_ReplaceAllStringFunc_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_ReplaceAllStringFunc_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllStringFunc_anyParams struct {
	Recorder *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder
}

// MoqRegexp_starGenType_ReplaceAll_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAll_params struct{ Src, Repl []byte }

// MoqRegexp_starGenType_ReplaceAll_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAll_paramsKey struct {
	Params struct{}
	Hashes struct{ Src, Repl hash.Hash }
}

// MoqRegexp_starGenType_ReplaceAll_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAll_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_ReplaceAll_paramsKey]*MoqRegexp_starGenType_ReplaceAll_results
}

// MoqRegexp_starGenType_ReplaceAll_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAll_doFn func(src, repl []byte)

// MoqRegexp_starGenType_ReplaceAll_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAll_doReturnFn func(src, repl []byte) []byte

// MoqRegexp_starGenType_ReplaceAll_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAll_results struct {
	Params  MoqRegexp_starGenType_ReplaceAll_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAll_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAll_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_ReplaceAll_fnRecorder routes recorded function calls
// to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_ReplaceAll_fnRecorder struct {
	Params    MoqRegexp_starGenType_ReplaceAll_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_ReplaceAll_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_ReplaceAll_anyParams isolates the any params functions
// of the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAll_anyParams struct {
	Recorder *MoqRegexp_starGenType_ReplaceAll_fnRecorder
}

// MoqRegexp_starGenType_ReplaceAllLiteral_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteral_params struct{ Src, Repl []byte }

// MoqRegexp_starGenType_ReplaceAllLiteral_paramsKey holds the map key params
// of the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteral_paramsKey struct {
	Params struct{}
	Hashes struct{ Src, Repl hash.Hash }
}

// MoqRegexp_starGenType_ReplaceAllLiteral_resultsByParams contains the results
// for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteral_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_ReplaceAllLiteral_paramsKey]*MoqRegexp_starGenType_ReplaceAllLiteral_results
}

// MoqRegexp_starGenType_ReplaceAllLiteral_doFn defines the type of function
// needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteral_doFn func(src, repl []byte)

// MoqRegexp_starGenType_ReplaceAllLiteral_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteral_doReturnFn func(src, repl []byte) []byte

// MoqRegexp_starGenType_ReplaceAllLiteral_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteral_results struct {
	Params  MoqRegexp_starGenType_ReplaceAllLiteral_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllLiteral_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllLiteral_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder routes recorded function
// calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder struct {
	Params    MoqRegexp_starGenType_ReplaceAllLiteral_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_ReplaceAllLiteral_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_ReplaceAllLiteral_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllLiteral_anyParams struct {
	Recorder *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder
}

// MoqRegexp_starGenType_ReplaceAllFunc_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllFunc_params struct {
	Src  []byte
	Repl func([]byte) []byte
}

// MoqRegexp_starGenType_ReplaceAllFunc_paramsKey holds the map key params of
// the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllFunc_paramsKey struct {
	Params struct{}
	Hashes struct {
		Src  hash.Hash
		Repl hash.Hash
	}
}

// MoqRegexp_starGenType_ReplaceAllFunc_resultsByParams contains the results
// for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllFunc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_ReplaceAllFunc_paramsKey]*MoqRegexp_starGenType_ReplaceAllFunc_results
}

// MoqRegexp_starGenType_ReplaceAllFunc_doFn defines the type of function
// needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllFunc_doFn func(src []byte, repl func([]byte) []byte)

// MoqRegexp_starGenType_ReplaceAllFunc_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllFunc_doReturnFn func(src []byte, repl func([]byte) []byte) []byte

// MoqRegexp_starGenType_ReplaceAllFunc_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllFunc_results struct {
	Params  MoqRegexp_starGenType_ReplaceAllFunc_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllFunc_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllFunc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder routes recorded function
// calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder struct {
	Params    MoqRegexp_starGenType_ReplaceAllFunc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_ReplaceAllFunc_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_ReplaceAllFunc_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_ReplaceAllFunc_anyParams struct {
	Recorder *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder
}

// MoqRegexp_starGenType_Find_params holds the params of the Regexp_starGenType
// type
type MoqRegexp_starGenType_Find_params struct{ B []byte }

// MoqRegexp_starGenType_Find_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Find_paramsKey struct {
	Params struct{}
	Hashes struct{ B hash.Hash }
}

// MoqRegexp_starGenType_Find_resultsByParams contains the results for a given
// set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_Find_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_Find_paramsKey]*MoqRegexp_starGenType_Find_results
}

// MoqRegexp_starGenType_Find_doFn defines the type of function needed when
// calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_Find_doFn func(b []byte)

// MoqRegexp_starGenType_Find_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_Find_doReturnFn func(b []byte) []byte

// MoqRegexp_starGenType_Find_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Find_results struct {
	Params  MoqRegexp_starGenType_Find_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Find_doFn
		DoReturnFn MoqRegexp_starGenType_Find_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_Find_fnRecorder routes recorded function calls to the
// MoqRegexp_starGenType moq
type MoqRegexp_starGenType_Find_fnRecorder struct {
	Params    MoqRegexp_starGenType_Find_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_Find_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_Find_anyParams isolates the any params functions of
// the Regexp_starGenType type
type MoqRegexp_starGenType_Find_anyParams struct {
	Recorder *MoqRegexp_starGenType_Find_fnRecorder
}

// MoqRegexp_starGenType_FindIndex_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindIndex_params struct{ B []byte }

// MoqRegexp_starGenType_FindIndex_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindIndex_paramsKey struct {
	Params struct{}
	Hashes struct{ B hash.Hash }
}

// MoqRegexp_starGenType_FindIndex_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindIndex_paramsKey]*MoqRegexp_starGenType_FindIndex_results
}

// MoqRegexp_starGenType_FindIndex_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindIndex_doFn func(b []byte)

// MoqRegexp_starGenType_FindIndex_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindIndex_doReturnFn func(b []byte) (loc []int)

// MoqRegexp_starGenType_FindIndex_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindIndex_results struct {
	Params  MoqRegexp_starGenType_FindIndex_params
	Results []struct {
		Values     *struct{ Loc []int }
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindIndex_fnRecorder routes recorded function calls to
// the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindIndex_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindIndex_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindIndex_anyParams isolates the any params functions
// of the Regexp_starGenType type
type MoqRegexp_starGenType_FindIndex_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindIndex_fnRecorder
}

// MoqRegexp_starGenType_FindString_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindString_params struct{ S string }

// MoqRegexp_starGenType_FindString_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindString_paramsKey struct {
	Params struct{ S string }
	Hashes struct{ S hash.Hash }
}

// MoqRegexp_starGenType_FindString_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindString_paramsKey]*MoqRegexp_starGenType_FindString_results
}

// MoqRegexp_starGenType_FindString_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindString_doFn func(s string)

// MoqRegexp_starGenType_FindString_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindString_doReturnFn func(s string) string

// MoqRegexp_starGenType_FindString_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindString_results struct {
	Params  MoqRegexp_starGenType_FindString_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindString_doFn
		DoReturnFn MoqRegexp_starGenType_FindString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindString_fnRecorder routes recorded function calls
// to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindString_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindString_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindString_anyParams isolates the any params functions
// of the Regexp_starGenType type
type MoqRegexp_starGenType_FindString_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindString_fnRecorder
}

// MoqRegexp_starGenType_FindStringIndex_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindStringIndex_params struct{ S string }

// MoqRegexp_starGenType_FindStringIndex_paramsKey holds the map key params of
// the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringIndex_paramsKey struct {
	Params struct{ S string }
	Hashes struct{ S hash.Hash }
}

// MoqRegexp_starGenType_FindStringIndex_resultsByParams contains the results
// for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindStringIndex_paramsKey]*MoqRegexp_starGenType_FindStringIndex_results
}

// MoqRegexp_starGenType_FindStringIndex_doFn defines the type of function
// needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringIndex_doFn func(s string)

// MoqRegexp_starGenType_FindStringIndex_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringIndex_doReturnFn func(s string) (loc []int)

// MoqRegexp_starGenType_FindStringIndex_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindStringIndex_results struct {
	Params  MoqRegexp_starGenType_FindStringIndex_params
	Results []struct {
		Values     *struct{ Loc []int }
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindStringIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindStringIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindStringIndex_fnRecorder routes recorded function
// calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindStringIndex_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindStringIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindStringIndex_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindStringIndex_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringIndex_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindStringIndex_fnRecorder
}

// MoqRegexp_starGenType_FindReaderIndex_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderIndex_params struct{ Param1 io.RuneReader }

// MoqRegexp_starGenType_FindReaderIndex_paramsKey holds the map key params of
// the Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderIndex_paramsKey struct {
	Params struct{ Param1 io.RuneReader }
	Hashes struct{ Param1 hash.Hash }
}

// MoqRegexp_starGenType_FindReaderIndex_resultsByParams contains the results
// for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindReaderIndex_paramsKey]*MoqRegexp_starGenType_FindReaderIndex_results
}

// MoqRegexp_starGenType_FindReaderIndex_doFn defines the type of function
// needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderIndex_doFn func(r io.RuneReader)

// MoqRegexp_starGenType_FindReaderIndex_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderIndex_doReturnFn func(r io.RuneReader) (loc []int)

// MoqRegexp_starGenType_FindReaderIndex_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderIndex_results struct {
	Params  MoqRegexp_starGenType_FindReaderIndex_params
	Results []struct {
		Values     *struct{ Loc []int }
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindReaderIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindReaderIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindReaderIndex_fnRecorder routes recorded function
// calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindReaderIndex_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindReaderIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindReaderIndex_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindReaderIndex_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderIndex_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindReaderIndex_fnRecorder
}

// MoqRegexp_starGenType_FindSubmatch_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatch_params struct{ B []byte }

// MoqRegexp_starGenType_FindSubmatch_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatch_paramsKey struct {
	Params struct{}
	Hashes struct{ B hash.Hash }
}

// MoqRegexp_starGenType_FindSubmatch_resultsByParams contains the results for
// a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatch_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindSubmatch_paramsKey]*MoqRegexp_starGenType_FindSubmatch_results
}

// MoqRegexp_starGenType_FindSubmatch_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatch_doFn func(b []byte)

// MoqRegexp_starGenType_FindSubmatch_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatch_doReturnFn func(b []byte) [][]byte

// MoqRegexp_starGenType_FindSubmatch_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatch_results struct {
	Params  MoqRegexp_starGenType_FindSubmatch_params
	Results []struct {
		Values *struct {
			Result1 [][]byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindSubmatch_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindSubmatch_fnRecorder routes recorded function calls
// to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindSubmatch_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindSubmatch_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindSubmatch_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindSubmatch_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatch_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindSubmatch_fnRecorder
}

// MoqRegexp_starGenType_Expand_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Expand_params struct {
	Dst      []byte
	Template []byte
	Src      []byte
	Match    []int
}

// MoqRegexp_starGenType_Expand_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Expand_paramsKey struct {
	Params struct{}
	Hashes struct {
		Dst      hash.Hash
		Template hash.Hash
		Src      hash.Hash
		Match    hash.Hash
	}
}

// MoqRegexp_starGenType_Expand_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_Expand_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_Expand_paramsKey]*MoqRegexp_starGenType_Expand_results
}

// MoqRegexp_starGenType_Expand_doFn defines the type of function needed when
// calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_Expand_doFn func(dst []byte, template []byte, src []byte, match []int)

// MoqRegexp_starGenType_Expand_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_Expand_doReturnFn func(dst []byte, template []byte, src []byte, match []int) []byte

// MoqRegexp_starGenType_Expand_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Expand_results struct {
	Params  MoqRegexp_starGenType_Expand_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Expand_doFn
		DoReturnFn MoqRegexp_starGenType_Expand_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_Expand_fnRecorder routes recorded function calls to
// the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_Expand_fnRecorder struct {
	Params    MoqRegexp_starGenType_Expand_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_Expand_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_Expand_anyParams isolates the any params functions of
// the Regexp_starGenType type
type MoqRegexp_starGenType_Expand_anyParams struct {
	Recorder *MoqRegexp_starGenType_Expand_fnRecorder
}

// MoqRegexp_starGenType_ExpandString_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ExpandString_params struct {
	Dst      []byte
	Template string
	Src      string
	Match    []int
}

// MoqRegexp_starGenType_ExpandString_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ExpandString_paramsKey struct {
	Params struct {
		Template string
		Src      string
	}
	Hashes struct {
		Dst      hash.Hash
		Template hash.Hash
		Src      hash.Hash
		Match    hash.Hash
	}
}

// MoqRegexp_starGenType_ExpandString_resultsByParams contains the results for
// a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_ExpandString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_ExpandString_paramsKey]*MoqRegexp_starGenType_ExpandString_results
}

// MoqRegexp_starGenType_ExpandString_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_ExpandString_doFn func(dst []byte, template string, src string, match []int)

// MoqRegexp_starGenType_ExpandString_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_ExpandString_doReturnFn func(dst []byte, template string, src string, match []int) []byte

// MoqRegexp_starGenType_ExpandString_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_ExpandString_results struct {
	Params  MoqRegexp_starGenType_ExpandString_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ExpandString_doFn
		DoReturnFn MoqRegexp_starGenType_ExpandString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_ExpandString_fnRecorder routes recorded function calls
// to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_ExpandString_fnRecorder struct {
	Params    MoqRegexp_starGenType_ExpandString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_ExpandString_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_ExpandString_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_ExpandString_anyParams struct {
	Recorder *MoqRegexp_starGenType_ExpandString_fnRecorder
}

// MoqRegexp_starGenType_FindSubmatchIndex_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatchIndex_params struct{ B []byte }

// MoqRegexp_starGenType_FindSubmatchIndex_paramsKey holds the map key params
// of the Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatchIndex_paramsKey struct {
	Params struct{}
	Hashes struct{ B hash.Hash }
}

// MoqRegexp_starGenType_FindSubmatchIndex_resultsByParams contains the results
// for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatchIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindSubmatchIndex_paramsKey]*MoqRegexp_starGenType_FindSubmatchIndex_results
}

// MoqRegexp_starGenType_FindSubmatchIndex_doFn defines the type of function
// needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatchIndex_doFn func(b []byte)

// MoqRegexp_starGenType_FindSubmatchIndex_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatchIndex_doReturnFn func(b []byte) []int

// MoqRegexp_starGenType_FindSubmatchIndex_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatchIndex_results struct {
	Params  MoqRegexp_starGenType_FindSubmatchIndex_params
	Results []struct {
		Values *struct {
			Result1 []int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindSubmatchIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder routes recorded function
// calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindSubmatchIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindSubmatchIndex_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindSubmatchIndex_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindSubmatchIndex_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder
}

// MoqRegexp_starGenType_FindStringSubmatch_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatch_params struct{ S string }

// MoqRegexp_starGenType_FindStringSubmatch_paramsKey holds the map key params
// of the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatch_paramsKey struct {
	Params struct{ S string }
	Hashes struct{ S hash.Hash }
}

// MoqRegexp_starGenType_FindStringSubmatch_resultsByParams contains the
// results for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatch_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindStringSubmatch_paramsKey]*MoqRegexp_starGenType_FindStringSubmatch_results
}

// MoqRegexp_starGenType_FindStringSubmatch_doFn defines the type of function
// needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatch_doFn func(s string)

// MoqRegexp_starGenType_FindStringSubmatch_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatch_doReturnFn func(s string) []string

// MoqRegexp_starGenType_FindStringSubmatch_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatch_results struct {
	Params  MoqRegexp_starGenType_FindStringSubmatch_params
	Results []struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindStringSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindStringSubmatch_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindStringSubmatch_fnRecorder routes recorded function
// calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindStringSubmatch_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindStringSubmatch_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindStringSubmatch_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindStringSubmatch_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatch_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder
}

// MoqRegexp_starGenType_FindStringSubmatchIndex_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatchIndex_params struct{ S string }

// MoqRegexp_starGenType_FindStringSubmatchIndex_paramsKey holds the map key
// params of the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatchIndex_paramsKey struct {
	Params struct{ S string }
	Hashes struct{ S hash.Hash }
}

// MoqRegexp_starGenType_FindStringSubmatchIndex_resultsByParams contains the
// results for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatchIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindStringSubmatchIndex_paramsKey]*MoqRegexp_starGenType_FindStringSubmatchIndex_results
}

// MoqRegexp_starGenType_FindStringSubmatchIndex_doFn defines the type of
// function needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatchIndex_doFn func(s string)

// MoqRegexp_starGenType_FindStringSubmatchIndex_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatchIndex_doReturnFn func(s string) []int

// MoqRegexp_starGenType_FindStringSubmatchIndex_results holds the results of
// the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatchIndex_results struct {
	Params  MoqRegexp_starGenType_FindStringSubmatchIndex_params
	Results []struct {
		Values *struct {
			Result1 []int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindStringSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindStringSubmatchIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder routes recorded
// function calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindStringSubmatchIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindStringSubmatchIndex_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindStringSubmatchIndex_anyParams isolates the any
// params functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindStringSubmatchIndex_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder
}

// MoqRegexp_starGenType_FindReaderSubmatchIndex_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderSubmatchIndex_params struct{ Param1 io.RuneReader }

// MoqRegexp_starGenType_FindReaderSubmatchIndex_paramsKey holds the map key
// params of the Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderSubmatchIndex_paramsKey struct {
	Params struct{ Param1 io.RuneReader }
	Hashes struct{ Param1 hash.Hash }
}

// MoqRegexp_starGenType_FindReaderSubmatchIndex_resultsByParams contains the
// results for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderSubmatchIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindReaderSubmatchIndex_paramsKey]*MoqRegexp_starGenType_FindReaderSubmatchIndex_results
}

// MoqRegexp_starGenType_FindReaderSubmatchIndex_doFn defines the type of
// function needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderSubmatchIndex_doFn func(r io.RuneReader)

// MoqRegexp_starGenType_FindReaderSubmatchIndex_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderSubmatchIndex_doReturnFn func(r io.RuneReader) []int

// MoqRegexp_starGenType_FindReaderSubmatchIndex_results holds the results of
// the Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderSubmatchIndex_results struct {
	Params  MoqRegexp_starGenType_FindReaderSubmatchIndex_params
	Results []struct {
		Values *struct {
			Result1 []int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindReaderSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindReaderSubmatchIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder routes recorded
// function calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindReaderSubmatchIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindReaderSubmatchIndex_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindReaderSubmatchIndex_anyParams isolates the any
// params functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindReaderSubmatchIndex_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder
}

// MoqRegexp_starGenType_FindAll_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAll_params struct {
	B []byte
	N int
}

// MoqRegexp_starGenType_FindAll_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAll_paramsKey struct {
	Params struct{ N int }
	Hashes struct {
		B hash.Hash
		N hash.Hash
	}
}

// MoqRegexp_starGenType_FindAll_resultsByParams contains the results for a
// given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAll_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindAll_paramsKey]*MoqRegexp_starGenType_FindAll_results
}

// MoqRegexp_starGenType_FindAll_doFn defines the type of function needed when
// calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAll_doFn func(b []byte, n int)

// MoqRegexp_starGenType_FindAll_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAll_doReturnFn func(b []byte, n int) [][]byte

// MoqRegexp_starGenType_FindAll_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAll_results struct {
	Params  MoqRegexp_starGenType_FindAll_params
	Results []struct {
		Values *struct {
			Result1 [][]byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAll_doFn
		DoReturnFn MoqRegexp_starGenType_FindAll_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindAll_fnRecorder routes recorded function calls to
// the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindAll_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindAll_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindAll_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindAll_anyParams isolates the any params functions of
// the Regexp_starGenType type
type MoqRegexp_starGenType_FindAll_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindAll_fnRecorder
}

// MoqRegexp_starGenType_FindAllIndex_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllIndex_params struct {
	B []byte
	N int
}

// MoqRegexp_starGenType_FindAllIndex_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllIndex_paramsKey struct {
	Params struct{ N int }
	Hashes struct {
		B hash.Hash
		N hash.Hash
	}
}

// MoqRegexp_starGenType_FindAllIndex_resultsByParams contains the results for
// a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindAllIndex_paramsKey]*MoqRegexp_starGenType_FindAllIndex_results
}

// MoqRegexp_starGenType_FindAllIndex_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllIndex_doFn func(b []byte, n int)

// MoqRegexp_starGenType_FindAllIndex_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllIndex_doReturnFn func(b []byte, n int) [][]int

// MoqRegexp_starGenType_FindAllIndex_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllIndex_results struct {
	Params  MoqRegexp_starGenType_FindAllIndex_params
	Results []struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindAllIndex_fnRecorder routes recorded function calls
// to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindAllIndex_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindAllIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindAllIndex_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindAllIndex_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllIndex_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindAllIndex_fnRecorder
}

// MoqRegexp_starGenType_FindAllString_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllString_params struct {
	S string
	N int
}

// MoqRegexp_starGenType_FindAllString_paramsKey holds the map key params of
// the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllString_paramsKey struct {
	Params struct {
		S string
		N int
	}
	Hashes struct {
		S hash.Hash
		N hash.Hash
	}
}

// MoqRegexp_starGenType_FindAllString_resultsByParams contains the results for
// a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllString_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindAllString_paramsKey]*MoqRegexp_starGenType_FindAllString_results
}

// MoqRegexp_starGenType_FindAllString_doFn defines the type of function needed
// when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllString_doFn func(s string, n int)

// MoqRegexp_starGenType_FindAllString_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllString_doReturnFn func(s string, n int) []string

// MoqRegexp_starGenType_FindAllString_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllString_results struct {
	Params  MoqRegexp_starGenType_FindAllString_params
	Results []struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllString_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllString_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindAllString_fnRecorder routes recorded function
// calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindAllString_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindAllString_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindAllString_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindAllString_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllString_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindAllString_fnRecorder
}

// MoqRegexp_starGenType_FindAllStringIndex_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringIndex_params struct {
	S string
	N int
}

// MoqRegexp_starGenType_FindAllStringIndex_paramsKey holds the map key params
// of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringIndex_paramsKey struct {
	Params struct {
		S string
		N int
	}
	Hashes struct {
		S hash.Hash
		N hash.Hash
	}
}

// MoqRegexp_starGenType_FindAllStringIndex_resultsByParams contains the
// results for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindAllStringIndex_paramsKey]*MoqRegexp_starGenType_FindAllStringIndex_results
}

// MoqRegexp_starGenType_FindAllStringIndex_doFn defines the type of function
// needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringIndex_doFn func(s string, n int)

// MoqRegexp_starGenType_FindAllStringIndex_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringIndex_doReturnFn func(s string, n int) [][]int

// MoqRegexp_starGenType_FindAllStringIndex_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringIndex_results struct {
	Params  MoqRegexp_starGenType_FindAllStringIndex_params
	Results []struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllStringIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllStringIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindAllStringIndex_fnRecorder routes recorded function
// calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindAllStringIndex_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindAllStringIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindAllStringIndex_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindAllStringIndex_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringIndex_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder
}

// MoqRegexp_starGenType_FindAllSubmatch_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatch_params struct {
	B []byte
	N int
}

// MoqRegexp_starGenType_FindAllSubmatch_paramsKey holds the map key params of
// the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatch_paramsKey struct {
	Params struct{ N int }
	Hashes struct {
		B hash.Hash
		N hash.Hash
	}
}

// MoqRegexp_starGenType_FindAllSubmatch_resultsByParams contains the results
// for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatch_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindAllSubmatch_paramsKey]*MoqRegexp_starGenType_FindAllSubmatch_results
}

// MoqRegexp_starGenType_FindAllSubmatch_doFn defines the type of function
// needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatch_doFn func(b []byte, n int)

// MoqRegexp_starGenType_FindAllSubmatch_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatch_doReturnFn func(b []byte, n int) [][][]byte

// MoqRegexp_starGenType_FindAllSubmatch_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatch_results struct {
	Params  MoqRegexp_starGenType_FindAllSubmatch_params
	Results []struct {
		Values *struct {
			Result1 [][][]byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllSubmatch_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindAllSubmatch_fnRecorder routes recorded function
// calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindAllSubmatch_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindAllSubmatch_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindAllSubmatch_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindAllSubmatch_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatch_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder
}

// MoqRegexp_starGenType_FindAllSubmatchIndex_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatchIndex_params struct {
	B []byte
	N int
}

// MoqRegexp_starGenType_FindAllSubmatchIndex_paramsKey holds the map key
// params of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatchIndex_paramsKey struct {
	Params struct{ N int }
	Hashes struct {
		B hash.Hash
		N hash.Hash
	}
}

// MoqRegexp_starGenType_FindAllSubmatchIndex_resultsByParams contains the
// results for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatchIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindAllSubmatchIndex_paramsKey]*MoqRegexp_starGenType_FindAllSubmatchIndex_results
}

// MoqRegexp_starGenType_FindAllSubmatchIndex_doFn defines the type of function
// needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatchIndex_doFn func(b []byte, n int)

// MoqRegexp_starGenType_FindAllSubmatchIndex_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatchIndex_doReturnFn func(b []byte, n int) [][]int

// MoqRegexp_starGenType_FindAllSubmatchIndex_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatchIndex_results struct {
	Params  MoqRegexp_starGenType_FindAllSubmatchIndex_params
	Results []struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllSubmatchIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder routes recorded
// function calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindAllSubmatchIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindAllSubmatchIndex_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindAllSubmatchIndex_anyParams isolates the any params
// functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllSubmatchIndex_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder
}

// MoqRegexp_starGenType_FindAllStringSubmatch_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatch_params struct {
	S string
	N int
}

// MoqRegexp_starGenType_FindAllStringSubmatch_paramsKey holds the map key
// params of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatch_paramsKey struct {
	Params struct {
		S string
		N int
	}
	Hashes struct {
		S hash.Hash
		N hash.Hash
	}
}

// MoqRegexp_starGenType_FindAllStringSubmatch_resultsByParams contains the
// results for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatch_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindAllStringSubmatch_paramsKey]*MoqRegexp_starGenType_FindAllStringSubmatch_results
}

// MoqRegexp_starGenType_FindAllStringSubmatch_doFn defines the type of
// function needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatch_doFn func(s string, n int)

// MoqRegexp_starGenType_FindAllStringSubmatch_doReturnFn defines the type of
// function needed when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatch_doReturnFn func(s string, n int) [][]string

// MoqRegexp_starGenType_FindAllStringSubmatch_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatch_results struct {
	Params  MoqRegexp_starGenType_FindAllStringSubmatch_params
	Results []struct {
		Values *struct {
			Result1 [][]string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllStringSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllStringSubmatch_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder routes recorded
// function calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindAllStringSubmatch_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindAllStringSubmatch_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindAllStringSubmatch_anyParams isolates the any
// params functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatch_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder
}

// MoqRegexp_starGenType_FindAllStringSubmatchIndex_params holds the params of
// the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatchIndex_params struct {
	S string
	N int
}

// MoqRegexp_starGenType_FindAllStringSubmatchIndex_paramsKey holds the map key
// params of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatchIndex_paramsKey struct {
	Params struct {
		S string
		N int
	}
	Hashes struct {
		S hash.Hash
		N hash.Hash
	}
}

// MoqRegexp_starGenType_FindAllStringSubmatchIndex_resultsByParams contains
// the results for a given set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatchIndex_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_FindAllStringSubmatchIndex_paramsKey]*MoqRegexp_starGenType_FindAllStringSubmatchIndex_results
}

// MoqRegexp_starGenType_FindAllStringSubmatchIndex_doFn defines the type of
// function needed when calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatchIndex_doFn func(s string, n int)

// MoqRegexp_starGenType_FindAllStringSubmatchIndex_doReturnFn defines the type
// of function needed when calling DoReturnResults for the Regexp_starGenType
// type
type MoqRegexp_starGenType_FindAllStringSubmatchIndex_doReturnFn func(s string, n int) [][]int

// MoqRegexp_starGenType_FindAllStringSubmatchIndex_results holds the results
// of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatchIndex_results struct {
	Params  MoqRegexp_starGenType_FindAllStringSubmatchIndex_params
	Results []struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllStringSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllStringSubmatchIndex_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder routes recorded
// function calls to the MoqRegexp_starGenType moq
type MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder struct {
	Params    MoqRegexp_starGenType_FindAllStringSubmatchIndex_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_FindAllStringSubmatchIndex_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_FindAllStringSubmatchIndex_anyParams isolates the any
// params functions of the Regexp_starGenType type
type MoqRegexp_starGenType_FindAllStringSubmatchIndex_anyParams struct {
	Recorder *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder
}

// MoqRegexp_starGenType_Split_params holds the params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Split_params struct {
	S string
	N int
}

// MoqRegexp_starGenType_Split_paramsKey holds the map key params of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Split_paramsKey struct {
	Params struct {
		S string
		N int
	}
	Hashes struct {
		S hash.Hash
		N hash.Hash
	}
}

// MoqRegexp_starGenType_Split_resultsByParams contains the results for a given
// set of parameters for the Regexp_starGenType type
type MoqRegexp_starGenType_Split_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqRegexp_starGenType_Split_paramsKey]*MoqRegexp_starGenType_Split_results
}

// MoqRegexp_starGenType_Split_doFn defines the type of function needed when
// calling AndDo for the Regexp_starGenType type
type MoqRegexp_starGenType_Split_doFn func(s string, n int)

// MoqRegexp_starGenType_Split_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Regexp_starGenType type
type MoqRegexp_starGenType_Split_doReturnFn func(s string, n int) []string

// MoqRegexp_starGenType_Split_results holds the results of the
// Regexp_starGenType type
type MoqRegexp_starGenType_Split_results struct {
	Params  MoqRegexp_starGenType_Split_params
	Results []struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Split_doFn
		DoReturnFn MoqRegexp_starGenType_Split_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqRegexp_starGenType_Split_fnRecorder routes recorded function calls to the
// MoqRegexp_starGenType moq
type MoqRegexp_starGenType_Split_fnRecorder struct {
	Params    MoqRegexp_starGenType_Split_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqRegexp_starGenType_Split_results
	Moq       *MoqRegexp_starGenType
}

// MoqRegexp_starGenType_Split_anyParams isolates the any params functions of
// the Regexp_starGenType type
type MoqRegexp_starGenType_Split_anyParams struct {
	Recorder *MoqRegexp_starGenType_Split_fnRecorder
}

// NewMoqRegexp_starGenType creates a new moq of the Regexp_starGenType type
func NewMoqRegexp_starGenType(scene *moq.Scene, config *moq.Config) *MoqRegexp_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqRegexp_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqRegexp_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				String      struct{}
				Copy        struct{}
				Longest     struct{}
				NumSubexp   struct{}
				SubexpNames struct{}
				SubexpIndex struct {
					Name moq.ParamIndexing
				}
				LiteralPrefix struct{}
				MatchReader   struct {
					Param1 moq.ParamIndexing
				}
				MatchString struct {
					S moq.ParamIndexing
				}
				Match struct {
					B moq.ParamIndexing
				}
				ReplaceAllString struct {
					Src  moq.ParamIndexing
					Repl moq.ParamIndexing
				}
				ReplaceAllLiteralString struct {
					Src  moq.ParamIndexing
					Repl moq.ParamIndexing
				}
				ReplaceAllStringFunc struct {
					Src  moq.ParamIndexing
					Repl moq.ParamIndexing
				}
				ReplaceAll struct {
					Src  moq.ParamIndexing
					Repl moq.ParamIndexing
				}
				ReplaceAllLiteral struct {
					Src  moq.ParamIndexing
					Repl moq.ParamIndexing
				}
				ReplaceAllFunc struct {
					Src  moq.ParamIndexing
					Repl moq.ParamIndexing
				}
				Find struct {
					B moq.ParamIndexing
				}
				FindIndex struct {
					B moq.ParamIndexing
				}
				FindString struct {
					S moq.ParamIndexing
				}
				FindStringIndex struct {
					S moq.ParamIndexing
				}
				FindReaderIndex struct {
					Param1 moq.ParamIndexing
				}
				FindSubmatch struct {
					B moq.ParamIndexing
				}
				Expand struct {
					Dst      moq.ParamIndexing
					Template moq.ParamIndexing
					Src      moq.ParamIndexing
					Match    moq.ParamIndexing
				}
				ExpandString struct {
					Dst      moq.ParamIndexing
					Template moq.ParamIndexing
					Src      moq.ParamIndexing
					Match    moq.ParamIndexing
				}
				FindSubmatchIndex struct {
					B moq.ParamIndexing
				}
				FindStringSubmatch struct {
					S moq.ParamIndexing
				}
				FindStringSubmatchIndex struct {
					S moq.ParamIndexing
				}
				FindReaderSubmatchIndex struct {
					Param1 moq.ParamIndexing
				}
				FindAll struct {
					B moq.ParamIndexing
					N moq.ParamIndexing
				}
				FindAllIndex struct {
					B moq.ParamIndexing
					N moq.ParamIndexing
				}
				FindAllString struct {
					S moq.ParamIndexing
					N moq.ParamIndexing
				}
				FindAllStringIndex struct {
					S moq.ParamIndexing
					N moq.ParamIndexing
				}
				FindAllSubmatch struct {
					B moq.ParamIndexing
					N moq.ParamIndexing
				}
				FindAllSubmatchIndex struct {
					B moq.ParamIndexing
					N moq.ParamIndexing
				}
				FindAllStringSubmatch struct {
					S moq.ParamIndexing
					N moq.ParamIndexing
				}
				FindAllStringSubmatchIndex struct {
					S moq.ParamIndexing
					N moq.ParamIndexing
				}
				Split struct {
					S moq.ParamIndexing
					N moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			String      struct{}
			Copy        struct{}
			Longest     struct{}
			NumSubexp   struct{}
			SubexpNames struct{}
			SubexpIndex struct {
				Name moq.ParamIndexing
			}
			LiteralPrefix struct{}
			MatchReader   struct {
				Param1 moq.ParamIndexing
			}
			MatchString struct {
				S moq.ParamIndexing
			}
			Match struct {
				B moq.ParamIndexing
			}
			ReplaceAllString struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			ReplaceAllLiteralString struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			ReplaceAllStringFunc struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			ReplaceAll struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			ReplaceAllLiteral struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			ReplaceAllFunc struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}
			Find struct {
				B moq.ParamIndexing
			}
			FindIndex struct {
				B moq.ParamIndexing
			}
			FindString struct {
				S moq.ParamIndexing
			}
			FindStringIndex struct {
				S moq.ParamIndexing
			}
			FindReaderIndex struct {
				Param1 moq.ParamIndexing
			}
			FindSubmatch struct {
				B moq.ParamIndexing
			}
			Expand struct {
				Dst      moq.ParamIndexing
				Template moq.ParamIndexing
				Src      moq.ParamIndexing
				Match    moq.ParamIndexing
			}
			ExpandString struct {
				Dst      moq.ParamIndexing
				Template moq.ParamIndexing
				Src      moq.ParamIndexing
				Match    moq.ParamIndexing
			}
			FindSubmatchIndex struct {
				B moq.ParamIndexing
			}
			FindStringSubmatch struct {
				S moq.ParamIndexing
			}
			FindStringSubmatchIndex struct {
				S moq.ParamIndexing
			}
			FindReaderSubmatchIndex struct {
				Param1 moq.ParamIndexing
			}
			FindAll struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllIndex struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllString struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllStringIndex struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllSubmatch struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllSubmatchIndex struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllStringSubmatch struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}
			FindAllStringSubmatchIndex struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}
			Split struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}
		}{
			String:      struct{}{},
			Copy:        struct{}{},
			Longest:     struct{}{},
			NumSubexp:   struct{}{},
			SubexpNames: struct{}{},
			SubexpIndex: struct {
				Name moq.ParamIndexing
			}{
				Name: moq.ParamIndexByValue,
			},
			LiteralPrefix: struct{}{},
			MatchReader: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByHash,
			},
			MatchString: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			Match: struct {
				B moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
			},
			ReplaceAllString: struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}{
				Src:  moq.ParamIndexByValue,
				Repl: moq.ParamIndexByValue,
			},
			ReplaceAllLiteralString: struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}{
				Src:  moq.ParamIndexByValue,
				Repl: moq.ParamIndexByValue,
			},
			ReplaceAllStringFunc: struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}{
				Src:  moq.ParamIndexByValue,
				Repl: moq.ParamIndexByHash,
			},
			ReplaceAll: struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}{
				Src:  moq.ParamIndexByHash,
				Repl: moq.ParamIndexByHash,
			},
			ReplaceAllLiteral: struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}{
				Src:  moq.ParamIndexByHash,
				Repl: moq.ParamIndexByHash,
			},
			ReplaceAllFunc: struct {
				Src  moq.ParamIndexing
				Repl moq.ParamIndexing
			}{
				Src:  moq.ParamIndexByHash,
				Repl: moq.ParamIndexByHash,
			},
			Find: struct {
				B moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
			},
			FindIndex: struct {
				B moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
			},
			FindString: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			FindStringIndex: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			FindReaderIndex: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByHash,
			},
			FindSubmatch: struct {
				B moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
			},
			Expand: struct {
				Dst      moq.ParamIndexing
				Template moq.ParamIndexing
				Src      moq.ParamIndexing
				Match    moq.ParamIndexing
			}{
				Dst:      moq.ParamIndexByHash,
				Template: moq.ParamIndexByHash,
				Src:      moq.ParamIndexByHash,
				Match:    moq.ParamIndexByHash,
			},
			ExpandString: struct {
				Dst      moq.ParamIndexing
				Template moq.ParamIndexing
				Src      moq.ParamIndexing
				Match    moq.ParamIndexing
			}{
				Dst:      moq.ParamIndexByHash,
				Template: moq.ParamIndexByValue,
				Src:      moq.ParamIndexByValue,
				Match:    moq.ParamIndexByHash,
			},
			FindSubmatchIndex: struct {
				B moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
			},
			FindStringSubmatch: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			FindStringSubmatchIndex: struct {
				S moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
			},
			FindReaderSubmatchIndex: struct {
				Param1 moq.ParamIndexing
			}{
				Param1: moq.ParamIndexByHash,
			},
			FindAll: struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
				N: moq.ParamIndexByValue,
			},
			FindAllIndex: struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
				N: moq.ParamIndexByValue,
			},
			FindAllString: struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
				N: moq.ParamIndexByValue,
			},
			FindAllStringIndex: struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
				N: moq.ParamIndexByValue,
			},
			FindAllSubmatch: struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
				N: moq.ParamIndexByValue,
			},
			FindAllSubmatchIndex: struct {
				B moq.ParamIndexing
				N moq.ParamIndexing
			}{
				B: moq.ParamIndexByHash,
				N: moq.ParamIndexByValue,
			},
			FindAllStringSubmatch: struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
				N: moq.ParamIndexByValue,
			},
			FindAllStringSubmatchIndex: struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
				N: moq.ParamIndexByValue,
			},
			Split: struct {
				S moq.ParamIndexing
				N moq.ParamIndexing
			}{
				S: moq.ParamIndexByValue,
				N: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Regexp_starGenType type
func (m *MoqRegexp_starGenType) Mock() *MoqRegexp_starGenType_mock { return m.Moq }

func (m *MoqRegexp_starGenType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_String_params{}
	var results *MoqRegexp_starGenType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRegexp_starGenType_mock) Copy() (result1 *regexp.Regexp) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_Copy_params{}
	var results *MoqRegexp_starGenType_Copy_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Copy {
		paramsKey := m.Moq.ParamsKey_Copy(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Copy(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Copy(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Copy(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRegexp_starGenType_mock) Longest() {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_Longest_params{}
	var results *MoqRegexp_starGenType_Longest_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Longest {
		paramsKey := m.Moq.ParamsKey_Longest(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Longest(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Longest(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Longest(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqRegexp_starGenType_mock) NumSubexp() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_NumSubexp_params{}
	var results *MoqRegexp_starGenType_NumSubexp_results
	for _, resultsByParams := range m.Moq.ResultsByParams_NumSubexp {
		paramsKey := m.Moq.ParamsKey_NumSubexp(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_NumSubexp(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_NumSubexp(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_NumSubexp(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRegexp_starGenType_mock) SubexpNames() (result1 []string) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_SubexpNames_params{}
	var results *MoqRegexp_starGenType_SubexpNames_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SubexpNames {
		paramsKey := m.Moq.ParamsKey_SubexpNames(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SubexpNames(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SubexpNames(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SubexpNames(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqRegexp_starGenType_mock) SubexpIndex(name string) (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_SubexpIndex_params{
		Name: name,
	}
	var results *MoqRegexp_starGenType_SubexpIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_SubexpIndex {
		paramsKey := m.Moq.ParamsKey_SubexpIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_SubexpIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_SubexpIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_SubexpIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(name)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(name)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) LiteralPrefix() (prefix string, complete bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_LiteralPrefix_params{}
	var results *MoqRegexp_starGenType_LiteralPrefix_results
	for _, resultsByParams := range m.Moq.ResultsByParams_LiteralPrefix {
		paramsKey := m.Moq.ParamsKey_LiteralPrefix(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_LiteralPrefix(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_LiteralPrefix(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_LiteralPrefix(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		prefix = result.Values.Prefix
		complete = result.Values.Complete
	}
	if result.DoReturnFn != nil {
		prefix, complete = result.DoReturnFn()
	}
	return
}

func (m *MoqRegexp_starGenType_mock) MatchReader(param1 io.RuneReader) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_MatchReader_params{
		Param1: param1,
	}
	var results *MoqRegexp_starGenType_MatchReader_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MatchReader {
		paramsKey := m.Moq.ParamsKey_MatchReader(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MatchReader(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MatchReader(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MatchReader(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) MatchString(s string) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_MatchString_params{
		S: s,
	}
	var results *MoqRegexp_starGenType_MatchString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MatchString {
		paramsKey := m.Moq.ParamsKey_MatchString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MatchString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MatchString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MatchString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) Match(b []byte) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_Match_params{
		B: b,
	}
	var results *MoqRegexp_starGenType_Match_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Match {
		paramsKey := m.Moq.ParamsKey_Match(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Match(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Match(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Match(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(b)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) ReplaceAllString(src, repl string) (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_ReplaceAllString_params{
		Src:  src,
		Repl: repl,
	}
	var results *MoqRegexp_starGenType_ReplaceAllString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReplaceAllString {
		paramsKey := m.Moq.ParamsKey_ReplaceAllString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReplaceAllString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReplaceAllString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReplaceAllString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(src, repl)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(src, repl)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) ReplaceAllLiteralString(src, repl string) (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_ReplaceAllLiteralString_params{
		Src:  src,
		Repl: repl,
	}
	var results *MoqRegexp_starGenType_ReplaceAllLiteralString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReplaceAllLiteralString {
		paramsKey := m.Moq.ParamsKey_ReplaceAllLiteralString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReplaceAllLiteralString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReplaceAllLiteralString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReplaceAllLiteralString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(src, repl)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(src, repl)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) ReplaceAllStringFunc(src string, repl func(string) string) (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_ReplaceAllStringFunc_params{
		Src:  src,
		Repl: repl,
	}
	var results *MoqRegexp_starGenType_ReplaceAllStringFunc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReplaceAllStringFunc {
		paramsKey := m.Moq.ParamsKey_ReplaceAllStringFunc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReplaceAllStringFunc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReplaceAllStringFunc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReplaceAllStringFunc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(src, repl)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(src, repl)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) ReplaceAll(src, repl []byte) (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_ReplaceAll_params{
		Src:  src,
		Repl: repl,
	}
	var results *MoqRegexp_starGenType_ReplaceAll_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReplaceAll {
		paramsKey := m.Moq.ParamsKey_ReplaceAll(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReplaceAll(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReplaceAll(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReplaceAll(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(src, repl)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(src, repl)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) ReplaceAllLiteral(src, repl []byte) (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_ReplaceAllLiteral_params{
		Src:  src,
		Repl: repl,
	}
	var results *MoqRegexp_starGenType_ReplaceAllLiteral_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReplaceAllLiteral {
		paramsKey := m.Moq.ParamsKey_ReplaceAllLiteral(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReplaceAllLiteral(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReplaceAllLiteral(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReplaceAllLiteral(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(src, repl)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(src, repl)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) ReplaceAllFunc(src []byte, repl func([]byte) []byte) (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_ReplaceAllFunc_params{
		Src:  src,
		Repl: repl,
	}
	var results *MoqRegexp_starGenType_ReplaceAllFunc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ReplaceAllFunc {
		paramsKey := m.Moq.ParamsKey_ReplaceAllFunc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ReplaceAllFunc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ReplaceAllFunc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ReplaceAllFunc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(src, repl)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(src, repl)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) Find(b []byte) (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_Find_params{
		B: b,
	}
	var results *MoqRegexp_starGenType_Find_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Find {
		paramsKey := m.Moq.ParamsKey_Find(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Find(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Find(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Find(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(b)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindIndex(b []byte) (loc []int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindIndex_params{
		B: b,
	}
	var results *MoqRegexp_starGenType_FindIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindIndex {
		paramsKey := m.Moq.ParamsKey_FindIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b)
	}

	if result.Values != nil {
		loc = result.Values.Loc
	}
	if result.DoReturnFn != nil {
		loc = result.DoReturnFn(b)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindString(s string) (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindString_params{
		S: s,
	}
	var results *MoqRegexp_starGenType_FindString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindString {
		paramsKey := m.Moq.ParamsKey_FindString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindStringIndex(s string) (loc []int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindStringIndex_params{
		S: s,
	}
	var results *MoqRegexp_starGenType_FindStringIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindStringIndex {
		paramsKey := m.Moq.ParamsKey_FindStringIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindStringIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindStringIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindStringIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		loc = result.Values.Loc
	}
	if result.DoReturnFn != nil {
		loc = result.DoReturnFn(s)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindReaderIndex(param1 io.RuneReader) (loc []int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindReaderIndex_params{
		Param1: param1,
	}
	var results *MoqRegexp_starGenType_FindReaderIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindReaderIndex {
		paramsKey := m.Moq.ParamsKey_FindReaderIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindReaderIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindReaderIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindReaderIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		loc = result.Values.Loc
	}
	if result.DoReturnFn != nil {
		loc = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindSubmatch(b []byte) (result1 [][]byte) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindSubmatch_params{
		B: b,
	}
	var results *MoqRegexp_starGenType_FindSubmatch_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindSubmatch {
		paramsKey := m.Moq.ParamsKey_FindSubmatch(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindSubmatch(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindSubmatch(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindSubmatch(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(b)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) Expand(dst []byte, template []byte, src []byte, match []int) (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_Expand_params{
		Dst:      dst,
		Template: template,
		Src:      src,
		Match:    match,
	}
	var results *MoqRegexp_starGenType_Expand_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Expand {
		paramsKey := m.Moq.ParamsKey_Expand(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Expand(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Expand(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Expand(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(dst, template, src, match)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(dst, template, src, match)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) ExpandString(dst []byte, template string, src string, match []int) (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_ExpandString_params{
		Dst:      dst,
		Template: template,
		Src:      src,
		Match:    match,
	}
	var results *MoqRegexp_starGenType_ExpandString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ExpandString {
		paramsKey := m.Moq.ParamsKey_ExpandString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ExpandString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ExpandString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ExpandString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(dst, template, src, match)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(dst, template, src, match)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindSubmatchIndex(b []byte) (result1 []int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindSubmatchIndex_params{
		B: b,
	}
	var results *MoqRegexp_starGenType_FindSubmatchIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindSubmatchIndex {
		paramsKey := m.Moq.ParamsKey_FindSubmatchIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindSubmatchIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindSubmatchIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindSubmatchIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(b)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindStringSubmatch(s string) (result1 []string) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindStringSubmatch_params{
		S: s,
	}
	var results *MoqRegexp_starGenType_FindStringSubmatch_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindStringSubmatch {
		paramsKey := m.Moq.ParamsKey_FindStringSubmatch(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindStringSubmatch(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindStringSubmatch(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindStringSubmatch(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindStringSubmatchIndex(s string) (result1 []int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindStringSubmatchIndex_params{
		S: s,
	}
	var results *MoqRegexp_starGenType_FindStringSubmatchIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindStringSubmatchIndex {
		paramsKey := m.Moq.ParamsKey_FindStringSubmatchIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindStringSubmatchIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindStringSubmatchIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindStringSubmatchIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindReaderSubmatchIndex(param1 io.RuneReader) (result1 []int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindReaderSubmatchIndex_params{
		Param1: param1,
	}
	var results *MoqRegexp_starGenType_FindReaderSubmatchIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindReaderSubmatchIndex {
		paramsKey := m.Moq.ParamsKey_FindReaderSubmatchIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindReaderSubmatchIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindReaderSubmatchIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindReaderSubmatchIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(param1)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(param1)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindAll(b []byte, n int) (result1 [][]byte) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindAll_params{
		B: b,
		N: n,
	}
	var results *MoqRegexp_starGenType_FindAll_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindAll {
		paramsKey := m.Moq.ParamsKey_FindAll(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindAll(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindAll(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindAll(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(b, n)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindAllIndex(b []byte, n int) (result1 [][]int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindAllIndex_params{
		B: b,
		N: n,
	}
	var results *MoqRegexp_starGenType_FindAllIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindAllIndex {
		paramsKey := m.Moq.ParamsKey_FindAllIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindAllIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindAllIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindAllIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(b, n)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindAllString(s string, n int) (result1 []string) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindAllString_params{
		S: s,
		N: n,
	}
	var results *MoqRegexp_starGenType_FindAllString_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindAllString {
		paramsKey := m.Moq.ParamsKey_FindAllString(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindAllString(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindAllString(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindAllString(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s, n)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindAllStringIndex(s string, n int) (result1 [][]int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindAllStringIndex_params{
		S: s,
		N: n,
	}
	var results *MoqRegexp_starGenType_FindAllStringIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindAllStringIndex {
		paramsKey := m.Moq.ParamsKey_FindAllStringIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindAllStringIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindAllStringIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindAllStringIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s, n)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindAllSubmatch(b []byte, n int) (result1 [][][]byte) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindAllSubmatch_params{
		B: b,
		N: n,
	}
	var results *MoqRegexp_starGenType_FindAllSubmatch_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindAllSubmatch {
		paramsKey := m.Moq.ParamsKey_FindAllSubmatch(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindAllSubmatch(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindAllSubmatch(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindAllSubmatch(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(b, n)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindAllSubmatchIndex(b []byte, n int) (result1 [][]int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindAllSubmatchIndex_params{
		B: b,
		N: n,
	}
	var results *MoqRegexp_starGenType_FindAllSubmatchIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindAllSubmatchIndex {
		paramsKey := m.Moq.ParamsKey_FindAllSubmatchIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindAllSubmatchIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindAllSubmatchIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindAllSubmatchIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(b, n)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindAllStringSubmatch(s string, n int) (result1 [][]string) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindAllStringSubmatch_params{
		S: s,
		N: n,
	}
	var results *MoqRegexp_starGenType_FindAllStringSubmatch_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindAllStringSubmatch {
		paramsKey := m.Moq.ParamsKey_FindAllStringSubmatch(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindAllStringSubmatch(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindAllStringSubmatch(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindAllStringSubmatch(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s, n)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) FindAllStringSubmatchIndex(s string, n int) (result1 [][]int) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_FindAllStringSubmatchIndex_params{
		S: s,
		N: n,
	}
	var results *MoqRegexp_starGenType_FindAllStringSubmatchIndex_results
	for _, resultsByParams := range m.Moq.ResultsByParams_FindAllStringSubmatchIndex {
		paramsKey := m.Moq.ParamsKey_FindAllStringSubmatchIndex(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_FindAllStringSubmatchIndex(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_FindAllStringSubmatchIndex(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_FindAllStringSubmatchIndex(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s, n)
	}
	return
}

func (m *MoqRegexp_starGenType_mock) Split(s string, n int) (result1 []string) {
	m.Moq.Scene.T.Helper()
	params := MoqRegexp_starGenType_Split_params{
		S: s,
		N: n,
	}
	var results *MoqRegexp_starGenType_Split_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Split {
		paramsKey := m.Moq.ParamsKey_Split(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Split(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Split(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Split(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(s, n)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(s, n)
	}
	return
}

// OnCall returns the recorder implementation of the Regexp_starGenType type
func (m *MoqRegexp_starGenType) OnCall() *MoqRegexp_starGenType_recorder {
	return &MoqRegexp_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqRegexp_starGenType_recorder) String() *MoqRegexp_starGenType_String_fnRecorder {
	return &MoqRegexp_starGenType_String_fnRecorder{
		Params:   MoqRegexp_starGenType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_String_fnRecorder) Any() *MoqRegexp_starGenType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_String_anyParams{Recorder: r}
}

func (r *MoqRegexp_starGenType_String_fnRecorder) Seq() *MoqRegexp_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_String_fnRecorder) NoSeq() *MoqRegexp_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_String_fnRecorder) ReturnResults(result1 string) *MoqRegexp_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_String_doFn
		DoReturnFn MoqRegexp_starGenType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_String_fnRecorder) AndDo(fn MoqRegexp_starGenType_String_doFn) *MoqRegexp_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_String_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_String_doReturnFn) *MoqRegexp_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_String_doFn
		DoReturnFn MoqRegexp_starGenType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_String_paramsKey]*MoqRegexp_starGenType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_String_doFn
				DoReturnFn MoqRegexp_starGenType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_String(params MoqRegexp_starGenType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqRegexp_starGenType) ParamsKey_String(params MoqRegexp_starGenType_String_params, anyParams uint64) MoqRegexp_starGenType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqRegexp_starGenType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRegexp_starGenType_recorder) Copy() *MoqRegexp_starGenType_Copy_fnRecorder {
	return &MoqRegexp_starGenType_Copy_fnRecorder{
		Params:   MoqRegexp_starGenType_Copy_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_Copy_fnRecorder) Any() *MoqRegexp_starGenType_Copy_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Copy(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_Copy_anyParams{Recorder: r}
}

func (r *MoqRegexp_starGenType_Copy_fnRecorder) Seq() *MoqRegexp_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Copy(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_Copy_fnRecorder) NoSeq() *MoqRegexp_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Copy(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_Copy_fnRecorder) ReturnResults(result1 *regexp.Regexp) *MoqRegexp_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *regexp.Regexp
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Copy_doFn
		DoReturnFn MoqRegexp_starGenType_Copy_doReturnFn
	}{
		Values: &struct {
			Result1 *regexp.Regexp
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_Copy_fnRecorder) AndDo(fn MoqRegexp_starGenType_Copy_doFn) *MoqRegexp_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_Copy_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_Copy_doReturnFn) *MoqRegexp_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *regexp.Regexp
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Copy_doFn
		DoReturnFn MoqRegexp_starGenType_Copy_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_Copy_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_Copy_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Copy {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_Copy_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_Copy_paramsKey]*MoqRegexp_starGenType_Copy_results{},
		}
		r.Moq.ResultsByParams_Copy = append(r.Moq.ResultsByParams_Copy, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Copy) {
			copy(r.Moq.ResultsByParams_Copy[insertAt+1:], r.Moq.ResultsByParams_Copy[insertAt:0])
			r.Moq.ResultsByParams_Copy[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Copy(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_Copy_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_Copy_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_Copy_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *regexp.Regexp
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_Copy_doFn
				DoReturnFn MoqRegexp_starGenType_Copy_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_Copy(params MoqRegexp_starGenType_Copy_params) string {
	return fmt.Sprintf("Copy()")
}

func (m *MoqRegexp_starGenType) ParamsKey_Copy(params MoqRegexp_starGenType_Copy_params, anyParams uint64) MoqRegexp_starGenType_Copy_paramsKey {
	m.Scene.T.Helper()
	return MoqRegexp_starGenType_Copy_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRegexp_starGenType_recorder) Longest() *MoqRegexp_starGenType_Longest_fnRecorder {
	return &MoqRegexp_starGenType_Longest_fnRecorder{
		Params:   MoqRegexp_starGenType_Longest_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_Longest_fnRecorder) Any() *MoqRegexp_starGenType_Longest_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Longest(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_Longest_anyParams{Recorder: r}
}

func (r *MoqRegexp_starGenType_Longest_fnRecorder) Seq() *MoqRegexp_starGenType_Longest_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Longest(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_Longest_fnRecorder) NoSeq() *MoqRegexp_starGenType_Longest_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Longest(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_Longest_fnRecorder) ReturnResults() *MoqRegexp_starGenType_Longest_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Longest_doFn
		DoReturnFn MoqRegexp_starGenType_Longest_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_Longest_fnRecorder) AndDo(fn MoqRegexp_starGenType_Longest_doFn) *MoqRegexp_starGenType_Longest_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_Longest_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_Longest_doReturnFn) *MoqRegexp_starGenType_Longest_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Longest_doFn
		DoReturnFn MoqRegexp_starGenType_Longest_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_Longest_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_Longest_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Longest {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_Longest_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_Longest_paramsKey]*MoqRegexp_starGenType_Longest_results{},
		}
		r.Moq.ResultsByParams_Longest = append(r.Moq.ResultsByParams_Longest, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Longest) {
			copy(r.Moq.ResultsByParams_Longest[insertAt+1:], r.Moq.ResultsByParams_Longest[insertAt:0])
			r.Moq.ResultsByParams_Longest[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Longest(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_Longest_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_Longest_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_Longest_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_Longest_doFn
				DoReturnFn MoqRegexp_starGenType_Longest_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_Longest(params MoqRegexp_starGenType_Longest_params) string {
	return fmt.Sprintf("Longest()")
}

func (m *MoqRegexp_starGenType) ParamsKey_Longest(params MoqRegexp_starGenType_Longest_params, anyParams uint64) MoqRegexp_starGenType_Longest_paramsKey {
	m.Scene.T.Helper()
	return MoqRegexp_starGenType_Longest_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRegexp_starGenType_recorder) NumSubexp() *MoqRegexp_starGenType_NumSubexp_fnRecorder {
	return &MoqRegexp_starGenType_NumSubexp_fnRecorder{
		Params:   MoqRegexp_starGenType_NumSubexp_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_NumSubexp_fnRecorder) Any() *MoqRegexp_starGenType_NumSubexp_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumSubexp(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_NumSubexp_anyParams{Recorder: r}
}

func (r *MoqRegexp_starGenType_NumSubexp_fnRecorder) Seq() *MoqRegexp_starGenType_NumSubexp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumSubexp(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_NumSubexp_fnRecorder) NoSeq() *MoqRegexp_starGenType_NumSubexp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_NumSubexp(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_NumSubexp_fnRecorder) ReturnResults(result1 int) *MoqRegexp_starGenType_NumSubexp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_NumSubexp_doFn
		DoReturnFn MoqRegexp_starGenType_NumSubexp_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_NumSubexp_fnRecorder) AndDo(fn MoqRegexp_starGenType_NumSubexp_doFn) *MoqRegexp_starGenType_NumSubexp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_NumSubexp_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_NumSubexp_doReturnFn) *MoqRegexp_starGenType_NumSubexp_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_NumSubexp_doFn
		DoReturnFn MoqRegexp_starGenType_NumSubexp_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_NumSubexp_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_NumSubexp_resultsByParams
	for n, res := range r.Moq.ResultsByParams_NumSubexp {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_NumSubexp_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_NumSubexp_paramsKey]*MoqRegexp_starGenType_NumSubexp_results{},
		}
		r.Moq.ResultsByParams_NumSubexp = append(r.Moq.ResultsByParams_NumSubexp, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_NumSubexp) {
			copy(r.Moq.ResultsByParams_NumSubexp[insertAt+1:], r.Moq.ResultsByParams_NumSubexp[insertAt:0])
			r.Moq.ResultsByParams_NumSubexp[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_NumSubexp(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_NumSubexp_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_NumSubexp_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_NumSubexp_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_NumSubexp_doFn
				DoReturnFn MoqRegexp_starGenType_NumSubexp_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_NumSubexp(params MoqRegexp_starGenType_NumSubexp_params) string {
	return fmt.Sprintf("NumSubexp()")
}

func (m *MoqRegexp_starGenType) ParamsKey_NumSubexp(params MoqRegexp_starGenType_NumSubexp_params, anyParams uint64) MoqRegexp_starGenType_NumSubexp_paramsKey {
	m.Scene.T.Helper()
	return MoqRegexp_starGenType_NumSubexp_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRegexp_starGenType_recorder) SubexpNames() *MoqRegexp_starGenType_SubexpNames_fnRecorder {
	return &MoqRegexp_starGenType_SubexpNames_fnRecorder{
		Params:   MoqRegexp_starGenType_SubexpNames_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_SubexpNames_fnRecorder) Any() *MoqRegexp_starGenType_SubexpNames_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SubexpNames(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_SubexpNames_anyParams{Recorder: r}
}

func (r *MoqRegexp_starGenType_SubexpNames_fnRecorder) Seq() *MoqRegexp_starGenType_SubexpNames_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SubexpNames(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_SubexpNames_fnRecorder) NoSeq() *MoqRegexp_starGenType_SubexpNames_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SubexpNames(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_SubexpNames_fnRecorder) ReturnResults(result1 []string) *MoqRegexp_starGenType_SubexpNames_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_SubexpNames_doFn
		DoReturnFn MoqRegexp_starGenType_SubexpNames_doReturnFn
	}{
		Values: &struct {
			Result1 []string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_SubexpNames_fnRecorder) AndDo(fn MoqRegexp_starGenType_SubexpNames_doFn) *MoqRegexp_starGenType_SubexpNames_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_SubexpNames_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_SubexpNames_doReturnFn) *MoqRegexp_starGenType_SubexpNames_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_SubexpNames_doFn
		DoReturnFn MoqRegexp_starGenType_SubexpNames_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_SubexpNames_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_SubexpNames_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SubexpNames {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_SubexpNames_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_SubexpNames_paramsKey]*MoqRegexp_starGenType_SubexpNames_results{},
		}
		r.Moq.ResultsByParams_SubexpNames = append(r.Moq.ResultsByParams_SubexpNames, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SubexpNames) {
			copy(r.Moq.ResultsByParams_SubexpNames[insertAt+1:], r.Moq.ResultsByParams_SubexpNames[insertAt:0])
			r.Moq.ResultsByParams_SubexpNames[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SubexpNames(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_SubexpNames_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_SubexpNames_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_SubexpNames_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []string
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_SubexpNames_doFn
				DoReturnFn MoqRegexp_starGenType_SubexpNames_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_SubexpNames(params MoqRegexp_starGenType_SubexpNames_params) string {
	return fmt.Sprintf("SubexpNames()")
}

func (m *MoqRegexp_starGenType) ParamsKey_SubexpNames(params MoqRegexp_starGenType_SubexpNames_params, anyParams uint64) MoqRegexp_starGenType_SubexpNames_paramsKey {
	m.Scene.T.Helper()
	return MoqRegexp_starGenType_SubexpNames_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRegexp_starGenType_recorder) SubexpIndex(name string) *MoqRegexp_starGenType_SubexpIndex_fnRecorder {
	return &MoqRegexp_starGenType_SubexpIndex_fnRecorder{
		Params: MoqRegexp_starGenType_SubexpIndex_params{
			Name: name,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_SubexpIndex_fnRecorder) Any() *MoqRegexp_starGenType_SubexpIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SubexpIndex(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_SubexpIndex_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_SubexpIndex_anyParams) Name() *MoqRegexp_starGenType_SubexpIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_SubexpIndex_fnRecorder) Seq() *MoqRegexp_starGenType_SubexpIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SubexpIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_SubexpIndex_fnRecorder) NoSeq() *MoqRegexp_starGenType_SubexpIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_SubexpIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_SubexpIndex_fnRecorder) ReturnResults(result1 int) *MoqRegexp_starGenType_SubexpIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_SubexpIndex_doFn
		DoReturnFn MoqRegexp_starGenType_SubexpIndex_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_SubexpIndex_fnRecorder) AndDo(fn MoqRegexp_starGenType_SubexpIndex_doFn) *MoqRegexp_starGenType_SubexpIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_SubexpIndex_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_SubexpIndex_doReturnFn) *MoqRegexp_starGenType_SubexpIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_SubexpIndex_doFn
		DoReturnFn MoqRegexp_starGenType_SubexpIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_SubexpIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_SubexpIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_SubexpIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_SubexpIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_SubexpIndex_paramsKey]*MoqRegexp_starGenType_SubexpIndex_results{},
		}
		r.Moq.ResultsByParams_SubexpIndex = append(r.Moq.ResultsByParams_SubexpIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_SubexpIndex) {
			copy(r.Moq.ResultsByParams_SubexpIndex[insertAt+1:], r.Moq.ResultsByParams_SubexpIndex[insertAt:0])
			r.Moq.ResultsByParams_SubexpIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_SubexpIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_SubexpIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_SubexpIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_SubexpIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_SubexpIndex_doFn
				DoReturnFn MoqRegexp_starGenType_SubexpIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_SubexpIndex(params MoqRegexp_starGenType_SubexpIndex_params) string {
	return fmt.Sprintf("SubexpIndex(%#v)", params.Name)
}

func (m *MoqRegexp_starGenType) ParamsKey_SubexpIndex(params MoqRegexp_starGenType_SubexpIndex_params, anyParams uint64) MoqRegexp_starGenType_SubexpIndex_paramsKey {
	m.Scene.T.Helper()
	var nameUsed string
	var nameUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.SubexpIndex.Name == moq.ParamIndexByValue {
			nameUsed = params.Name
		} else {
			nameUsedHash = hash.DeepHash(params.Name)
		}
	}
	return MoqRegexp_starGenType_SubexpIndex_paramsKey{
		Params: struct{ Name string }{
			Name: nameUsed,
		},
		Hashes: struct{ Name hash.Hash }{
			Name: nameUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) LiteralPrefix() *MoqRegexp_starGenType_LiteralPrefix_fnRecorder {
	return &MoqRegexp_starGenType_LiteralPrefix_fnRecorder{
		Params:   MoqRegexp_starGenType_LiteralPrefix_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_LiteralPrefix_fnRecorder) Any() *MoqRegexp_starGenType_LiteralPrefix_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LiteralPrefix(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_LiteralPrefix_anyParams{Recorder: r}
}

func (r *MoqRegexp_starGenType_LiteralPrefix_fnRecorder) Seq() *MoqRegexp_starGenType_LiteralPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LiteralPrefix(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_LiteralPrefix_fnRecorder) NoSeq() *MoqRegexp_starGenType_LiteralPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_LiteralPrefix(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_LiteralPrefix_fnRecorder) ReturnResults(prefix string, complete bool) *MoqRegexp_starGenType_LiteralPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Prefix   string
			Complete bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_LiteralPrefix_doFn
		DoReturnFn MoqRegexp_starGenType_LiteralPrefix_doReturnFn
	}{
		Values: &struct {
			Prefix   string
			Complete bool
		}{
			Prefix:   prefix,
			Complete: complete,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_LiteralPrefix_fnRecorder) AndDo(fn MoqRegexp_starGenType_LiteralPrefix_doFn) *MoqRegexp_starGenType_LiteralPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_LiteralPrefix_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_LiteralPrefix_doReturnFn) *MoqRegexp_starGenType_LiteralPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Prefix   string
			Complete bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_LiteralPrefix_doFn
		DoReturnFn MoqRegexp_starGenType_LiteralPrefix_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_LiteralPrefix_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_LiteralPrefix_resultsByParams
	for n, res := range r.Moq.ResultsByParams_LiteralPrefix {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_LiteralPrefix_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_LiteralPrefix_paramsKey]*MoqRegexp_starGenType_LiteralPrefix_results{},
		}
		r.Moq.ResultsByParams_LiteralPrefix = append(r.Moq.ResultsByParams_LiteralPrefix, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_LiteralPrefix) {
			copy(r.Moq.ResultsByParams_LiteralPrefix[insertAt+1:], r.Moq.ResultsByParams_LiteralPrefix[insertAt:0])
			r.Moq.ResultsByParams_LiteralPrefix[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_LiteralPrefix(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_LiteralPrefix_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_LiteralPrefix_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_LiteralPrefix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Prefix   string
					Complete bool
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_LiteralPrefix_doFn
				DoReturnFn MoqRegexp_starGenType_LiteralPrefix_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_LiteralPrefix(params MoqRegexp_starGenType_LiteralPrefix_params) string {
	return fmt.Sprintf("LiteralPrefix()")
}

func (m *MoqRegexp_starGenType) ParamsKey_LiteralPrefix(params MoqRegexp_starGenType_LiteralPrefix_params, anyParams uint64) MoqRegexp_starGenType_LiteralPrefix_paramsKey {
	m.Scene.T.Helper()
	return MoqRegexp_starGenType_LiteralPrefix_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqRegexp_starGenType_recorder) MatchReader(param1 io.RuneReader) *MoqRegexp_starGenType_MatchReader_fnRecorder {
	return &MoqRegexp_starGenType_MatchReader_fnRecorder{
		Params: MoqRegexp_starGenType_MatchReader_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_MatchReader_fnRecorder) Any() *MoqRegexp_starGenType_MatchReader_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MatchReader(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_MatchReader_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_MatchReader_anyParams) Param1() *MoqRegexp_starGenType_MatchReader_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_MatchReader_fnRecorder) Seq() *MoqRegexp_starGenType_MatchReader_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MatchReader(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_MatchReader_fnRecorder) NoSeq() *MoqRegexp_starGenType_MatchReader_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MatchReader(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_MatchReader_fnRecorder) ReturnResults(result1 bool) *MoqRegexp_starGenType_MatchReader_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_MatchReader_doFn
		DoReturnFn MoqRegexp_starGenType_MatchReader_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_MatchReader_fnRecorder) AndDo(fn MoqRegexp_starGenType_MatchReader_doFn) *MoqRegexp_starGenType_MatchReader_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_MatchReader_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_MatchReader_doReturnFn) *MoqRegexp_starGenType_MatchReader_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_MatchReader_doFn
		DoReturnFn MoqRegexp_starGenType_MatchReader_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_MatchReader_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_MatchReader_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MatchReader {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_MatchReader_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_MatchReader_paramsKey]*MoqRegexp_starGenType_MatchReader_results{},
		}
		r.Moq.ResultsByParams_MatchReader = append(r.Moq.ResultsByParams_MatchReader, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MatchReader) {
			copy(r.Moq.ResultsByParams_MatchReader[insertAt+1:], r.Moq.ResultsByParams_MatchReader[insertAt:0])
			r.Moq.ResultsByParams_MatchReader[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MatchReader(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_MatchReader_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_MatchReader_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_MatchReader_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_MatchReader_doFn
				DoReturnFn MoqRegexp_starGenType_MatchReader_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_MatchReader(params MoqRegexp_starGenType_MatchReader_params) string {
	return fmt.Sprintf("MatchReader(%#v)", params.Param1)
}

func (m *MoqRegexp_starGenType) ParamsKey_MatchReader(params MoqRegexp_starGenType_MatchReader_params, anyParams uint64) MoqRegexp_starGenType_MatchReader_paramsKey {
	m.Scene.T.Helper()
	var param1Used io.RuneReader
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MatchReader.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqRegexp_starGenType_MatchReader_paramsKey{
		Params: struct{ Param1 io.RuneReader }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) MatchString(s string) *MoqRegexp_starGenType_MatchString_fnRecorder {
	return &MoqRegexp_starGenType_MatchString_fnRecorder{
		Params: MoqRegexp_starGenType_MatchString_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_MatchString_fnRecorder) Any() *MoqRegexp_starGenType_MatchString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MatchString(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_MatchString_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_MatchString_anyParams) S() *MoqRegexp_starGenType_MatchString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_MatchString_fnRecorder) Seq() *MoqRegexp_starGenType_MatchString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MatchString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_MatchString_fnRecorder) NoSeq() *MoqRegexp_starGenType_MatchString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MatchString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_MatchString_fnRecorder) ReturnResults(result1 bool) *MoqRegexp_starGenType_MatchString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_MatchString_doFn
		DoReturnFn MoqRegexp_starGenType_MatchString_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_MatchString_fnRecorder) AndDo(fn MoqRegexp_starGenType_MatchString_doFn) *MoqRegexp_starGenType_MatchString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_MatchString_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_MatchString_doReturnFn) *MoqRegexp_starGenType_MatchString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_MatchString_doFn
		DoReturnFn MoqRegexp_starGenType_MatchString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_MatchString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_MatchString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MatchString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_MatchString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_MatchString_paramsKey]*MoqRegexp_starGenType_MatchString_results{},
		}
		r.Moq.ResultsByParams_MatchString = append(r.Moq.ResultsByParams_MatchString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MatchString) {
			copy(r.Moq.ResultsByParams_MatchString[insertAt+1:], r.Moq.ResultsByParams_MatchString[insertAt:0])
			r.Moq.ResultsByParams_MatchString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MatchString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_MatchString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_MatchString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_MatchString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_MatchString_doFn
				DoReturnFn MoqRegexp_starGenType_MatchString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_MatchString(params MoqRegexp_starGenType_MatchString_params) string {
	return fmt.Sprintf("MatchString(%#v)", params.S)
}

func (m *MoqRegexp_starGenType) ParamsKey_MatchString(params MoqRegexp_starGenType_MatchString_params, anyParams uint64) MoqRegexp_starGenType_MatchString_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MatchString.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqRegexp_starGenType_MatchString_paramsKey{
		Params: struct{ S string }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) Match(b []byte) *MoqRegexp_starGenType_Match_fnRecorder {
	return &MoqRegexp_starGenType_Match_fnRecorder{
		Params: MoqRegexp_starGenType_Match_params{
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_Match_fnRecorder) Any() *MoqRegexp_starGenType_Match_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Match(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_Match_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_Match_anyParams) B() *MoqRegexp_starGenType_Match_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_Match_fnRecorder) Seq() *MoqRegexp_starGenType_Match_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Match(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_Match_fnRecorder) NoSeq() *MoqRegexp_starGenType_Match_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Match(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_Match_fnRecorder) ReturnResults(result1 bool) *MoqRegexp_starGenType_Match_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Match_doFn
		DoReturnFn MoqRegexp_starGenType_Match_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_Match_fnRecorder) AndDo(fn MoqRegexp_starGenType_Match_doFn) *MoqRegexp_starGenType_Match_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_Match_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_Match_doReturnFn) *MoqRegexp_starGenType_Match_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Match_doFn
		DoReturnFn MoqRegexp_starGenType_Match_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_Match_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_Match_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Match {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_Match_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_Match_paramsKey]*MoqRegexp_starGenType_Match_results{},
		}
		r.Moq.ResultsByParams_Match = append(r.Moq.ResultsByParams_Match, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Match) {
			copy(r.Moq.ResultsByParams_Match[insertAt+1:], r.Moq.ResultsByParams_Match[insertAt:0])
			r.Moq.ResultsByParams_Match[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Match(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_Match_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_Match_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_Match_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_Match_doFn
				DoReturnFn MoqRegexp_starGenType_Match_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_Match(params MoqRegexp_starGenType_Match_params) string {
	return fmt.Sprintf("Match(%#v)", params.B)
}

func (m *MoqRegexp_starGenType) ParamsKey_Match(params MoqRegexp_starGenType_Match_params, anyParams uint64) MoqRegexp_starGenType_Match_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Match.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the Match function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	return MoqRegexp_starGenType_Match_paramsKey{
		Params: struct{}{},
		Hashes: struct{ B hash.Hash }{
			B: bUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) ReplaceAllString(src, repl string) *MoqRegexp_starGenType_ReplaceAllString_fnRecorder {
	return &MoqRegexp_starGenType_ReplaceAllString_fnRecorder{
		Params: MoqRegexp_starGenType_ReplaceAllString_params{
			Src:  src,
			Repl: repl,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_ReplaceAllString_fnRecorder) Any() *MoqRegexp_starGenType_ReplaceAllString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllString(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_ReplaceAllString_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_ReplaceAllString_anyParams) Src() *MoqRegexp_starGenType_ReplaceAllString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_ReplaceAllString_anyParams) Repl() *MoqRegexp_starGenType_ReplaceAllString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_ReplaceAllString_fnRecorder) Seq() *MoqRegexp_starGenType_ReplaceAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllString_fnRecorder) NoSeq() *MoqRegexp_starGenType_ReplaceAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllString_fnRecorder) ReturnResults(result1 string) *MoqRegexp_starGenType_ReplaceAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllString_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllString_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllString_fnRecorder) AndDo(fn MoqRegexp_starGenType_ReplaceAllString_doFn) *MoqRegexp_starGenType_ReplaceAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllString_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_ReplaceAllString_doReturnFn) *MoqRegexp_starGenType_ReplaceAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllString_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_ReplaceAllString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReplaceAllString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_ReplaceAllString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_ReplaceAllString_paramsKey]*MoqRegexp_starGenType_ReplaceAllString_results{},
		}
		r.Moq.ResultsByParams_ReplaceAllString = append(r.Moq.ResultsByParams_ReplaceAllString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReplaceAllString) {
			copy(r.Moq.ResultsByParams_ReplaceAllString[insertAt+1:], r.Moq.ResultsByParams_ReplaceAllString[insertAt:0])
			r.Moq.ResultsByParams_ReplaceAllString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReplaceAllString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_ReplaceAllString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_ReplaceAllString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_ReplaceAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_ReplaceAllString_doFn
				DoReturnFn MoqRegexp_starGenType_ReplaceAllString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_ReplaceAllString(params MoqRegexp_starGenType_ReplaceAllString_params) string {
	return fmt.Sprintf("ReplaceAllString(%#v, %#v)", params.Src, params.Repl)
}

func (m *MoqRegexp_starGenType) ParamsKey_ReplaceAllString(params MoqRegexp_starGenType_ReplaceAllString_params, anyParams uint64) MoqRegexp_starGenType_ReplaceAllString_paramsKey {
	m.Scene.T.Helper()
	var srcUsed string
	var srcUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAllString.Src == moq.ParamIndexByValue {
			srcUsed = params.Src
		} else {
			srcUsedHash = hash.DeepHash(params.Src)
		}
	}
	var replUsed string
	var replUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAllString.Repl == moq.ParamIndexByValue {
			replUsed = params.Repl
		} else {
			replUsedHash = hash.DeepHash(params.Repl)
		}
	}
	return MoqRegexp_starGenType_ReplaceAllString_paramsKey{
		Params: struct{ Src, Repl string }{
			Src:  srcUsed,
			Repl: replUsed,
		},
		Hashes: struct{ Src, Repl hash.Hash }{
			Src:  srcUsedHash,
			Repl: replUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) ReplaceAllLiteralString(src, repl string) *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder {
	return &MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder{
		Params: MoqRegexp_starGenType_ReplaceAllLiteralString_params{
			Src:  src,
			Repl: repl,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder) Any() *MoqRegexp_starGenType_ReplaceAllLiteralString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllLiteralString(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_ReplaceAllLiteralString_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_ReplaceAllLiteralString_anyParams) Src() *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_ReplaceAllLiteralString_anyParams) Repl() *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder) Seq() *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllLiteralString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder) NoSeq() *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllLiteralString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder) ReturnResults(result1 string) *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllLiteralString_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllLiteralString_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder) AndDo(fn MoqRegexp_starGenType_ReplaceAllLiteralString_doFn) *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_ReplaceAllLiteralString_doReturnFn) *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllLiteralString_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllLiteralString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_ReplaceAllLiteralString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReplaceAllLiteralString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_ReplaceAllLiteralString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_ReplaceAllLiteralString_paramsKey]*MoqRegexp_starGenType_ReplaceAllLiteralString_results{},
		}
		r.Moq.ResultsByParams_ReplaceAllLiteralString = append(r.Moq.ResultsByParams_ReplaceAllLiteralString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReplaceAllLiteralString) {
			copy(r.Moq.ResultsByParams_ReplaceAllLiteralString[insertAt+1:], r.Moq.ResultsByParams_ReplaceAllLiteralString[insertAt:0])
			r.Moq.ResultsByParams_ReplaceAllLiteralString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReplaceAllLiteralString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_ReplaceAllLiteralString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_ReplaceAllLiteralString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_ReplaceAllLiteralString_doFn
				DoReturnFn MoqRegexp_starGenType_ReplaceAllLiteralString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_ReplaceAllLiteralString(params MoqRegexp_starGenType_ReplaceAllLiteralString_params) string {
	return fmt.Sprintf("ReplaceAllLiteralString(%#v, %#v)", params.Src, params.Repl)
}

func (m *MoqRegexp_starGenType) ParamsKey_ReplaceAllLiteralString(params MoqRegexp_starGenType_ReplaceAllLiteralString_params, anyParams uint64) MoqRegexp_starGenType_ReplaceAllLiteralString_paramsKey {
	m.Scene.T.Helper()
	var srcUsed string
	var srcUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAllLiteralString.Src == moq.ParamIndexByValue {
			srcUsed = params.Src
		} else {
			srcUsedHash = hash.DeepHash(params.Src)
		}
	}
	var replUsed string
	var replUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAllLiteralString.Repl == moq.ParamIndexByValue {
			replUsed = params.Repl
		} else {
			replUsedHash = hash.DeepHash(params.Repl)
		}
	}
	return MoqRegexp_starGenType_ReplaceAllLiteralString_paramsKey{
		Params: struct{ Src, Repl string }{
			Src:  srcUsed,
			Repl: replUsed,
		},
		Hashes: struct{ Src, Repl hash.Hash }{
			Src:  srcUsedHash,
			Repl: replUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) ReplaceAllStringFunc(src string, repl func(string) string) *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder {
	return &MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder{
		Params: MoqRegexp_starGenType_ReplaceAllStringFunc_params{
			Src:  src,
			Repl: repl,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder) Any() *MoqRegexp_starGenType_ReplaceAllStringFunc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllStringFunc(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_ReplaceAllStringFunc_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_ReplaceAllStringFunc_anyParams) Src() *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_ReplaceAllStringFunc_anyParams) Repl() *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder) Seq() *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllStringFunc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder) NoSeq() *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllStringFunc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder) ReturnResults(result1 string) *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllStringFunc_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllStringFunc_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder) AndDo(fn MoqRegexp_starGenType_ReplaceAllStringFunc_doFn) *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_ReplaceAllStringFunc_doReturnFn) *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllStringFunc_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllStringFunc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_ReplaceAllStringFunc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReplaceAllStringFunc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_ReplaceAllStringFunc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_ReplaceAllStringFunc_paramsKey]*MoqRegexp_starGenType_ReplaceAllStringFunc_results{},
		}
		r.Moq.ResultsByParams_ReplaceAllStringFunc = append(r.Moq.ResultsByParams_ReplaceAllStringFunc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReplaceAllStringFunc) {
			copy(r.Moq.ResultsByParams_ReplaceAllStringFunc[insertAt+1:], r.Moq.ResultsByParams_ReplaceAllStringFunc[insertAt:0])
			r.Moq.ResultsByParams_ReplaceAllStringFunc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReplaceAllStringFunc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_ReplaceAllStringFunc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_ReplaceAllStringFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_ReplaceAllStringFunc_doFn
				DoReturnFn MoqRegexp_starGenType_ReplaceAllStringFunc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_ReplaceAllStringFunc(params MoqRegexp_starGenType_ReplaceAllStringFunc_params) string {
	return fmt.Sprintf("ReplaceAllStringFunc(%#v, %#v)", params.Src, params.Repl)
}

func (m *MoqRegexp_starGenType) ParamsKey_ReplaceAllStringFunc(params MoqRegexp_starGenType_ReplaceAllStringFunc_params, anyParams uint64) MoqRegexp_starGenType_ReplaceAllStringFunc_paramsKey {
	m.Scene.T.Helper()
	var srcUsed string
	var srcUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAllStringFunc.Src == moq.ParamIndexByValue {
			srcUsed = params.Src
		} else {
			srcUsedHash = hash.DeepHash(params.Src)
		}
	}
	var replUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAllStringFunc.Repl == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The repl parameter of the ReplaceAllStringFunc function can't be indexed by value")
		}
		replUsedHash = hash.DeepHash(params.Repl)
	}
	return MoqRegexp_starGenType_ReplaceAllStringFunc_paramsKey{
		Params: struct{ Src string }{
			Src: srcUsed,
		},
		Hashes: struct {
			Src  hash.Hash
			Repl hash.Hash
		}{
			Src:  srcUsedHash,
			Repl: replUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) ReplaceAll(src, repl []byte) *MoqRegexp_starGenType_ReplaceAll_fnRecorder {
	return &MoqRegexp_starGenType_ReplaceAll_fnRecorder{
		Params: MoqRegexp_starGenType_ReplaceAll_params{
			Src:  src,
			Repl: repl,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_ReplaceAll_fnRecorder) Any() *MoqRegexp_starGenType_ReplaceAll_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAll(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_ReplaceAll_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_ReplaceAll_anyParams) Src() *MoqRegexp_starGenType_ReplaceAll_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_ReplaceAll_anyParams) Repl() *MoqRegexp_starGenType_ReplaceAll_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_ReplaceAll_fnRecorder) Seq() *MoqRegexp_starGenType_ReplaceAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAll(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAll_fnRecorder) NoSeq() *MoqRegexp_starGenType_ReplaceAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAll(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAll_fnRecorder) ReturnResults(result1 []byte) *MoqRegexp_starGenType_ReplaceAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAll_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAll_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAll_fnRecorder) AndDo(fn MoqRegexp_starGenType_ReplaceAll_doFn) *MoqRegexp_starGenType_ReplaceAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAll_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_ReplaceAll_doReturnFn) *MoqRegexp_starGenType_ReplaceAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAll_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAll_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAll_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_ReplaceAll_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReplaceAll {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_ReplaceAll_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_ReplaceAll_paramsKey]*MoqRegexp_starGenType_ReplaceAll_results{},
		}
		r.Moq.ResultsByParams_ReplaceAll = append(r.Moq.ResultsByParams_ReplaceAll, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReplaceAll) {
			copy(r.Moq.ResultsByParams_ReplaceAll[insertAt+1:], r.Moq.ResultsByParams_ReplaceAll[insertAt:0])
			r.Moq.ResultsByParams_ReplaceAll[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReplaceAll(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_ReplaceAll_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_ReplaceAll_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_ReplaceAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_ReplaceAll_doFn
				DoReturnFn MoqRegexp_starGenType_ReplaceAll_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_ReplaceAll(params MoqRegexp_starGenType_ReplaceAll_params) string {
	return fmt.Sprintf("ReplaceAll(%#v, %#v)", params.Src, params.Repl)
}

func (m *MoqRegexp_starGenType) ParamsKey_ReplaceAll(params MoqRegexp_starGenType_ReplaceAll_params, anyParams uint64) MoqRegexp_starGenType_ReplaceAll_paramsKey {
	m.Scene.T.Helper()
	var srcUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAll.Src == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The src parameter of the ReplaceAll function can't be indexed by value")
		}
		srcUsedHash = hash.DeepHash(params.Src)
	}
	var replUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAll.Repl == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The repl parameter of the ReplaceAll function can't be indexed by value")
		}
		replUsedHash = hash.DeepHash(params.Repl)
	}
	return MoqRegexp_starGenType_ReplaceAll_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Src, Repl hash.Hash }{
			Src:  srcUsedHash,
			Repl: replUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) ReplaceAllLiteral(src, repl []byte) *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder {
	return &MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder{
		Params: MoqRegexp_starGenType_ReplaceAllLiteral_params{
			Src:  src,
			Repl: repl,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder) Any() *MoqRegexp_starGenType_ReplaceAllLiteral_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllLiteral(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_ReplaceAllLiteral_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_ReplaceAllLiteral_anyParams) Src() *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_ReplaceAllLiteral_anyParams) Repl() *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder) Seq() *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllLiteral(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder) NoSeq() *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllLiteral(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder) ReturnResults(result1 []byte) *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllLiteral_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllLiteral_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder) AndDo(fn MoqRegexp_starGenType_ReplaceAllLiteral_doFn) *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_ReplaceAllLiteral_doReturnFn) *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllLiteral_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllLiteral_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_ReplaceAllLiteral_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReplaceAllLiteral {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_ReplaceAllLiteral_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_ReplaceAllLiteral_paramsKey]*MoqRegexp_starGenType_ReplaceAllLiteral_results{},
		}
		r.Moq.ResultsByParams_ReplaceAllLiteral = append(r.Moq.ResultsByParams_ReplaceAllLiteral, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReplaceAllLiteral) {
			copy(r.Moq.ResultsByParams_ReplaceAllLiteral[insertAt+1:], r.Moq.ResultsByParams_ReplaceAllLiteral[insertAt:0])
			r.Moq.ResultsByParams_ReplaceAllLiteral[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReplaceAllLiteral(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_ReplaceAllLiteral_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_ReplaceAllLiteral_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_ReplaceAllLiteral_doFn
				DoReturnFn MoqRegexp_starGenType_ReplaceAllLiteral_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_ReplaceAllLiteral(params MoqRegexp_starGenType_ReplaceAllLiteral_params) string {
	return fmt.Sprintf("ReplaceAllLiteral(%#v, %#v)", params.Src, params.Repl)
}

func (m *MoqRegexp_starGenType) ParamsKey_ReplaceAllLiteral(params MoqRegexp_starGenType_ReplaceAllLiteral_params, anyParams uint64) MoqRegexp_starGenType_ReplaceAllLiteral_paramsKey {
	m.Scene.T.Helper()
	var srcUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAllLiteral.Src == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The src parameter of the ReplaceAllLiteral function can't be indexed by value")
		}
		srcUsedHash = hash.DeepHash(params.Src)
	}
	var replUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAllLiteral.Repl == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The repl parameter of the ReplaceAllLiteral function can't be indexed by value")
		}
		replUsedHash = hash.DeepHash(params.Repl)
	}
	return MoqRegexp_starGenType_ReplaceAllLiteral_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Src, Repl hash.Hash }{
			Src:  srcUsedHash,
			Repl: replUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) ReplaceAllFunc(src []byte, repl func([]byte) []byte) *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder {
	return &MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder{
		Params: MoqRegexp_starGenType_ReplaceAllFunc_params{
			Src:  src,
			Repl: repl,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder) Any() *MoqRegexp_starGenType_ReplaceAllFunc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllFunc(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_ReplaceAllFunc_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_ReplaceAllFunc_anyParams) Src() *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_ReplaceAllFunc_anyParams) Repl() *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder) Seq() *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllFunc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder) NoSeq() *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ReplaceAllFunc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder) ReturnResults(result1 []byte) *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllFunc_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllFunc_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder) AndDo(fn MoqRegexp_starGenType_ReplaceAllFunc_doFn) *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_ReplaceAllFunc_doReturnFn) *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ReplaceAllFunc_doFn
		DoReturnFn MoqRegexp_starGenType_ReplaceAllFunc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_ReplaceAllFunc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ReplaceAllFunc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_ReplaceAllFunc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_ReplaceAllFunc_paramsKey]*MoqRegexp_starGenType_ReplaceAllFunc_results{},
		}
		r.Moq.ResultsByParams_ReplaceAllFunc = append(r.Moq.ResultsByParams_ReplaceAllFunc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ReplaceAllFunc) {
			copy(r.Moq.ResultsByParams_ReplaceAllFunc[insertAt+1:], r.Moq.ResultsByParams_ReplaceAllFunc[insertAt:0])
			r.Moq.ResultsByParams_ReplaceAllFunc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ReplaceAllFunc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_ReplaceAllFunc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_ReplaceAllFunc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_ReplaceAllFunc_doFn
				DoReturnFn MoqRegexp_starGenType_ReplaceAllFunc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_ReplaceAllFunc(params MoqRegexp_starGenType_ReplaceAllFunc_params) string {
	return fmt.Sprintf("ReplaceAllFunc(%#v, %#v)", params.Src, params.Repl)
}

func (m *MoqRegexp_starGenType) ParamsKey_ReplaceAllFunc(params MoqRegexp_starGenType_ReplaceAllFunc_params, anyParams uint64) MoqRegexp_starGenType_ReplaceAllFunc_paramsKey {
	m.Scene.T.Helper()
	var srcUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAllFunc.Src == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The src parameter of the ReplaceAllFunc function can't be indexed by value")
		}
		srcUsedHash = hash.DeepHash(params.Src)
	}
	var replUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ReplaceAllFunc.Repl == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The repl parameter of the ReplaceAllFunc function can't be indexed by value")
		}
		replUsedHash = hash.DeepHash(params.Repl)
	}
	return MoqRegexp_starGenType_ReplaceAllFunc_paramsKey{
		Params: struct{}{},
		Hashes: struct {
			Src  hash.Hash
			Repl hash.Hash
		}{
			Src:  srcUsedHash,
			Repl: replUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) Find(b []byte) *MoqRegexp_starGenType_Find_fnRecorder {
	return &MoqRegexp_starGenType_Find_fnRecorder{
		Params: MoqRegexp_starGenType_Find_params{
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_Find_fnRecorder) Any() *MoqRegexp_starGenType_Find_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Find(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_Find_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_Find_anyParams) B() *MoqRegexp_starGenType_Find_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_Find_fnRecorder) Seq() *MoqRegexp_starGenType_Find_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Find(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_Find_fnRecorder) NoSeq() *MoqRegexp_starGenType_Find_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Find(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_Find_fnRecorder) ReturnResults(result1 []byte) *MoqRegexp_starGenType_Find_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Find_doFn
		DoReturnFn MoqRegexp_starGenType_Find_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_Find_fnRecorder) AndDo(fn MoqRegexp_starGenType_Find_doFn) *MoqRegexp_starGenType_Find_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_Find_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_Find_doReturnFn) *MoqRegexp_starGenType_Find_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Find_doFn
		DoReturnFn MoqRegexp_starGenType_Find_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_Find_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_Find_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Find {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_Find_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_Find_paramsKey]*MoqRegexp_starGenType_Find_results{},
		}
		r.Moq.ResultsByParams_Find = append(r.Moq.ResultsByParams_Find, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Find) {
			copy(r.Moq.ResultsByParams_Find[insertAt+1:], r.Moq.ResultsByParams_Find[insertAt:0])
			r.Moq.ResultsByParams_Find[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Find(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_Find_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_Find_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_Find_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_Find_doFn
				DoReturnFn MoqRegexp_starGenType_Find_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_Find(params MoqRegexp_starGenType_Find_params) string {
	return fmt.Sprintf("Find(%#v)", params.B)
}

func (m *MoqRegexp_starGenType) ParamsKey_Find(params MoqRegexp_starGenType_Find_params, anyParams uint64) MoqRegexp_starGenType_Find_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Find.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the Find function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	return MoqRegexp_starGenType_Find_paramsKey{
		Params: struct{}{},
		Hashes: struct{ B hash.Hash }{
			B: bUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindIndex(b []byte) *MoqRegexp_starGenType_FindIndex_fnRecorder {
	return &MoqRegexp_starGenType_FindIndex_fnRecorder{
		Params: MoqRegexp_starGenType_FindIndex_params{
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindIndex_fnRecorder) Any() *MoqRegexp_starGenType_FindIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindIndex(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindIndex_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindIndex_anyParams) B() *MoqRegexp_starGenType_FindIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindIndex_fnRecorder) Seq() *MoqRegexp_starGenType_FindIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindIndex_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindIndex_fnRecorder) ReturnResults(loc []int) *MoqRegexp_starGenType_FindIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Loc []int }
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindIndex_doReturnFn
	}{
		Values: &struct{ Loc []int }{
			Loc: loc,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindIndex_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindIndex_doFn) *MoqRegexp_starGenType_FindIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindIndex_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindIndex_doReturnFn) *MoqRegexp_starGenType_FindIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Loc []int }
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindIndex_paramsKey]*MoqRegexp_starGenType_FindIndex_results{},
		}
		r.Moq.ResultsByParams_FindIndex = append(r.Moq.ResultsByParams_FindIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindIndex) {
			copy(r.Moq.ResultsByParams_FindIndex[insertAt+1:], r.Moq.ResultsByParams_FindIndex[insertAt:0])
			r.Moq.ResultsByParams_FindIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Loc []int }
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindIndex_doFn
				DoReturnFn MoqRegexp_starGenType_FindIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindIndex(params MoqRegexp_starGenType_FindIndex_params) string {
	return fmt.Sprintf("FindIndex(%#v)", params.B)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindIndex(params MoqRegexp_starGenType_FindIndex_params, anyParams uint64) MoqRegexp_starGenType_FindIndex_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindIndex.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the FindIndex function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	return MoqRegexp_starGenType_FindIndex_paramsKey{
		Params: struct{}{},
		Hashes: struct{ B hash.Hash }{
			B: bUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindString(s string) *MoqRegexp_starGenType_FindString_fnRecorder {
	return &MoqRegexp_starGenType_FindString_fnRecorder{
		Params: MoqRegexp_starGenType_FindString_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindString_fnRecorder) Any() *MoqRegexp_starGenType_FindString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindString(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindString_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindString_anyParams) S() *MoqRegexp_starGenType_FindString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindString_fnRecorder) Seq() *MoqRegexp_starGenType_FindString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindString_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindString_fnRecorder) ReturnResults(result1 string) *MoqRegexp_starGenType_FindString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindString_doFn
		DoReturnFn MoqRegexp_starGenType_FindString_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindString_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindString_doFn) *MoqRegexp_starGenType_FindString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindString_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindString_doReturnFn) *MoqRegexp_starGenType_FindString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindString_doFn
		DoReturnFn MoqRegexp_starGenType_FindString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindString_paramsKey]*MoqRegexp_starGenType_FindString_results{},
		}
		r.Moq.ResultsByParams_FindString = append(r.Moq.ResultsByParams_FindString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindString) {
			copy(r.Moq.ResultsByParams_FindString[insertAt+1:], r.Moq.ResultsByParams_FindString[insertAt:0])
			r.Moq.ResultsByParams_FindString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindString_doFn
				DoReturnFn MoqRegexp_starGenType_FindString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindString(params MoqRegexp_starGenType_FindString_params) string {
	return fmt.Sprintf("FindString(%#v)", params.S)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindString(params MoqRegexp_starGenType_FindString_params, anyParams uint64) MoqRegexp_starGenType_FindString_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindString.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqRegexp_starGenType_FindString_paramsKey{
		Params: struct{ S string }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindStringIndex(s string) *MoqRegexp_starGenType_FindStringIndex_fnRecorder {
	return &MoqRegexp_starGenType_FindStringIndex_fnRecorder{
		Params: MoqRegexp_starGenType_FindStringIndex_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindStringIndex_fnRecorder) Any() *MoqRegexp_starGenType_FindStringIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindStringIndex(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindStringIndex_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindStringIndex_anyParams) S() *MoqRegexp_starGenType_FindStringIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindStringIndex_fnRecorder) Seq() *MoqRegexp_starGenType_FindStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindStringIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindStringIndex_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindStringIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindStringIndex_fnRecorder) ReturnResults(loc []int) *MoqRegexp_starGenType_FindStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Loc []int }
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindStringIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindStringIndex_doReturnFn
	}{
		Values: &struct{ Loc []int }{
			Loc: loc,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindStringIndex_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindStringIndex_doFn) *MoqRegexp_starGenType_FindStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindStringIndex_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindStringIndex_doReturnFn) *MoqRegexp_starGenType_FindStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Loc []int }
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindStringIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindStringIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindStringIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindStringIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindStringIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindStringIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindStringIndex_paramsKey]*MoqRegexp_starGenType_FindStringIndex_results{},
		}
		r.Moq.ResultsByParams_FindStringIndex = append(r.Moq.ResultsByParams_FindStringIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindStringIndex) {
			copy(r.Moq.ResultsByParams_FindStringIndex[insertAt+1:], r.Moq.ResultsByParams_FindStringIndex[insertAt:0])
			r.Moq.ResultsByParams_FindStringIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindStringIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindStringIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindStringIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Loc []int }
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindStringIndex_doFn
				DoReturnFn MoqRegexp_starGenType_FindStringIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindStringIndex(params MoqRegexp_starGenType_FindStringIndex_params) string {
	return fmt.Sprintf("FindStringIndex(%#v)", params.S)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindStringIndex(params MoqRegexp_starGenType_FindStringIndex_params, anyParams uint64) MoqRegexp_starGenType_FindStringIndex_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindStringIndex.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqRegexp_starGenType_FindStringIndex_paramsKey{
		Params: struct{ S string }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindReaderIndex(param1 io.RuneReader) *MoqRegexp_starGenType_FindReaderIndex_fnRecorder {
	return &MoqRegexp_starGenType_FindReaderIndex_fnRecorder{
		Params: MoqRegexp_starGenType_FindReaderIndex_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindReaderIndex_fnRecorder) Any() *MoqRegexp_starGenType_FindReaderIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindReaderIndex(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindReaderIndex_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindReaderIndex_anyParams) Param1() *MoqRegexp_starGenType_FindReaderIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindReaderIndex_fnRecorder) Seq() *MoqRegexp_starGenType_FindReaderIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindReaderIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindReaderIndex_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindReaderIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindReaderIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindReaderIndex_fnRecorder) ReturnResults(loc []int) *MoqRegexp_starGenType_FindReaderIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Loc []int }
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindReaderIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindReaderIndex_doReturnFn
	}{
		Values: &struct{ Loc []int }{
			Loc: loc,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindReaderIndex_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindReaderIndex_doFn) *MoqRegexp_starGenType_FindReaderIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindReaderIndex_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindReaderIndex_doReturnFn) *MoqRegexp_starGenType_FindReaderIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Loc []int }
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindReaderIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindReaderIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindReaderIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindReaderIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindReaderIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindReaderIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindReaderIndex_paramsKey]*MoqRegexp_starGenType_FindReaderIndex_results{},
		}
		r.Moq.ResultsByParams_FindReaderIndex = append(r.Moq.ResultsByParams_FindReaderIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindReaderIndex) {
			copy(r.Moq.ResultsByParams_FindReaderIndex[insertAt+1:], r.Moq.ResultsByParams_FindReaderIndex[insertAt:0])
			r.Moq.ResultsByParams_FindReaderIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindReaderIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindReaderIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindReaderIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindReaderIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Loc []int }
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindReaderIndex_doFn
				DoReturnFn MoqRegexp_starGenType_FindReaderIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindReaderIndex(params MoqRegexp_starGenType_FindReaderIndex_params) string {
	return fmt.Sprintf("FindReaderIndex(%#v)", params.Param1)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindReaderIndex(params MoqRegexp_starGenType_FindReaderIndex_params, anyParams uint64) MoqRegexp_starGenType_FindReaderIndex_paramsKey {
	m.Scene.T.Helper()
	var param1Used io.RuneReader
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindReaderIndex.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqRegexp_starGenType_FindReaderIndex_paramsKey{
		Params: struct{ Param1 io.RuneReader }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindSubmatch(b []byte) *MoqRegexp_starGenType_FindSubmatch_fnRecorder {
	return &MoqRegexp_starGenType_FindSubmatch_fnRecorder{
		Params: MoqRegexp_starGenType_FindSubmatch_params{
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindSubmatch_fnRecorder) Any() *MoqRegexp_starGenType_FindSubmatch_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindSubmatch(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindSubmatch_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindSubmatch_anyParams) B() *MoqRegexp_starGenType_FindSubmatch_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindSubmatch_fnRecorder) Seq() *MoqRegexp_starGenType_FindSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindSubmatch(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindSubmatch_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindSubmatch(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindSubmatch_fnRecorder) ReturnResults(result1 [][]byte) *MoqRegexp_starGenType_FindSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindSubmatch_doReturnFn
	}{
		Values: &struct {
			Result1 [][]byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindSubmatch_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindSubmatch_doFn) *MoqRegexp_starGenType_FindSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindSubmatch_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindSubmatch_doReturnFn) *MoqRegexp_starGenType_FindSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindSubmatch_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindSubmatch_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindSubmatch_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindSubmatch {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindSubmatch_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindSubmatch_paramsKey]*MoqRegexp_starGenType_FindSubmatch_results{},
		}
		r.Moq.ResultsByParams_FindSubmatch = append(r.Moq.ResultsByParams_FindSubmatch, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindSubmatch) {
			copy(r.Moq.ResultsByParams_FindSubmatch[insertAt+1:], r.Moq.ResultsByParams_FindSubmatch[insertAt:0])
			r.Moq.ResultsByParams_FindSubmatch[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindSubmatch(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindSubmatch_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindSubmatch_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 [][]byte
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindSubmatch_doFn
				DoReturnFn MoqRegexp_starGenType_FindSubmatch_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindSubmatch(params MoqRegexp_starGenType_FindSubmatch_params) string {
	return fmt.Sprintf("FindSubmatch(%#v)", params.B)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindSubmatch(params MoqRegexp_starGenType_FindSubmatch_params, anyParams uint64) MoqRegexp_starGenType_FindSubmatch_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindSubmatch.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the FindSubmatch function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	return MoqRegexp_starGenType_FindSubmatch_paramsKey{
		Params: struct{}{},
		Hashes: struct{ B hash.Hash }{
			B: bUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) Expand(dst []byte, template []byte, src []byte, match []int) *MoqRegexp_starGenType_Expand_fnRecorder {
	return &MoqRegexp_starGenType_Expand_fnRecorder{
		Params: MoqRegexp_starGenType_Expand_params{
			Dst:      dst,
			Template: template,
			Src:      src,
			Match:    match,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_Expand_fnRecorder) Any() *MoqRegexp_starGenType_Expand_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Expand(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_Expand_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_Expand_anyParams) Dst() *MoqRegexp_starGenType_Expand_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_Expand_anyParams) Template() *MoqRegexp_starGenType_Expand_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqRegexp_starGenType_Expand_anyParams) Src() *MoqRegexp_starGenType_Expand_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (a *MoqRegexp_starGenType_Expand_anyParams) Match() *MoqRegexp_starGenType_Expand_fnRecorder {
	a.Recorder.AnyParams |= 1 << 3
	return a.Recorder
}

func (r *MoqRegexp_starGenType_Expand_fnRecorder) Seq() *MoqRegexp_starGenType_Expand_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Expand(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_Expand_fnRecorder) NoSeq() *MoqRegexp_starGenType_Expand_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Expand(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_Expand_fnRecorder) ReturnResults(result1 []byte) *MoqRegexp_starGenType_Expand_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Expand_doFn
		DoReturnFn MoqRegexp_starGenType_Expand_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_Expand_fnRecorder) AndDo(fn MoqRegexp_starGenType_Expand_doFn) *MoqRegexp_starGenType_Expand_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_Expand_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_Expand_doReturnFn) *MoqRegexp_starGenType_Expand_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Expand_doFn
		DoReturnFn MoqRegexp_starGenType_Expand_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_Expand_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_Expand_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Expand {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_Expand_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_Expand_paramsKey]*MoqRegexp_starGenType_Expand_results{},
		}
		r.Moq.ResultsByParams_Expand = append(r.Moq.ResultsByParams_Expand, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Expand) {
			copy(r.Moq.ResultsByParams_Expand[insertAt+1:], r.Moq.ResultsByParams_Expand[insertAt:0])
			r.Moq.ResultsByParams_Expand[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Expand(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_Expand_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_Expand_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_Expand_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_Expand_doFn
				DoReturnFn MoqRegexp_starGenType_Expand_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_Expand(params MoqRegexp_starGenType_Expand_params) string {
	return fmt.Sprintf("Expand(%#v, %#v, %#v, %#v)", params.Dst, params.Template, params.Src, params.Match)
}

func (m *MoqRegexp_starGenType) ParamsKey_Expand(params MoqRegexp_starGenType_Expand_params, anyParams uint64) MoqRegexp_starGenType_Expand_paramsKey {
	m.Scene.T.Helper()
	var dstUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Expand.Dst == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The dst parameter of the Expand function can't be indexed by value")
		}
		dstUsedHash = hash.DeepHash(params.Dst)
	}
	var templateUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Expand.Template == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The template parameter of the Expand function can't be indexed by value")
		}
		templateUsedHash = hash.DeepHash(params.Template)
	}
	var srcUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.Expand.Src == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The src parameter of the Expand function can't be indexed by value")
		}
		srcUsedHash = hash.DeepHash(params.Src)
	}
	var matchUsedHash hash.Hash
	if anyParams&(1<<3) == 0 {
		if m.Runtime.ParameterIndexing.Expand.Match == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The match parameter of the Expand function can't be indexed by value")
		}
		matchUsedHash = hash.DeepHash(params.Match)
	}
	return MoqRegexp_starGenType_Expand_paramsKey{
		Params: struct{}{},
		Hashes: struct {
			Dst      hash.Hash
			Template hash.Hash
			Src      hash.Hash
			Match    hash.Hash
		}{
			Dst:      dstUsedHash,
			Template: templateUsedHash,
			Src:      srcUsedHash,
			Match:    matchUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) ExpandString(dst []byte, template string, src string, match []int) *MoqRegexp_starGenType_ExpandString_fnRecorder {
	return &MoqRegexp_starGenType_ExpandString_fnRecorder{
		Params: MoqRegexp_starGenType_ExpandString_params{
			Dst:      dst,
			Template: template,
			Src:      src,
			Match:    match,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_ExpandString_fnRecorder) Any() *MoqRegexp_starGenType_ExpandString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ExpandString(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_ExpandString_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_ExpandString_anyParams) Dst() *MoqRegexp_starGenType_ExpandString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_ExpandString_anyParams) Template() *MoqRegexp_starGenType_ExpandString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqRegexp_starGenType_ExpandString_anyParams) Src() *MoqRegexp_starGenType_ExpandString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (a *MoqRegexp_starGenType_ExpandString_anyParams) Match() *MoqRegexp_starGenType_ExpandString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 3
	return a.Recorder
}

func (r *MoqRegexp_starGenType_ExpandString_fnRecorder) Seq() *MoqRegexp_starGenType_ExpandString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ExpandString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_ExpandString_fnRecorder) NoSeq() *MoqRegexp_starGenType_ExpandString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ExpandString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_ExpandString_fnRecorder) ReturnResults(result1 []byte) *MoqRegexp_starGenType_ExpandString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ExpandString_doFn
		DoReturnFn MoqRegexp_starGenType_ExpandString_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_ExpandString_fnRecorder) AndDo(fn MoqRegexp_starGenType_ExpandString_doFn) *MoqRegexp_starGenType_ExpandString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_ExpandString_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_ExpandString_doReturnFn) *MoqRegexp_starGenType_ExpandString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_ExpandString_doFn
		DoReturnFn MoqRegexp_starGenType_ExpandString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_ExpandString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_ExpandString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ExpandString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_ExpandString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_ExpandString_paramsKey]*MoqRegexp_starGenType_ExpandString_results{},
		}
		r.Moq.ResultsByParams_ExpandString = append(r.Moq.ResultsByParams_ExpandString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ExpandString) {
			copy(r.Moq.ResultsByParams_ExpandString[insertAt+1:], r.Moq.ResultsByParams_ExpandString[insertAt:0])
			r.Moq.ResultsByParams_ExpandString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ExpandString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_ExpandString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_ExpandString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_ExpandString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_ExpandString_doFn
				DoReturnFn MoqRegexp_starGenType_ExpandString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_ExpandString(params MoqRegexp_starGenType_ExpandString_params) string {
	return fmt.Sprintf("ExpandString(%#v, %#v, %#v, %#v)", params.Dst, params.Template, params.Src, params.Match)
}

func (m *MoqRegexp_starGenType) ParamsKey_ExpandString(params MoqRegexp_starGenType_ExpandString_params, anyParams uint64) MoqRegexp_starGenType_ExpandString_paramsKey {
	m.Scene.T.Helper()
	var dstUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ExpandString.Dst == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The dst parameter of the ExpandString function can't be indexed by value")
		}
		dstUsedHash = hash.DeepHash(params.Dst)
	}
	var templateUsed string
	var templateUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.ExpandString.Template == moq.ParamIndexByValue {
			templateUsed = params.Template
		} else {
			templateUsedHash = hash.DeepHash(params.Template)
		}
	}
	var srcUsed string
	var srcUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.ExpandString.Src == moq.ParamIndexByValue {
			srcUsed = params.Src
		} else {
			srcUsedHash = hash.DeepHash(params.Src)
		}
	}
	var matchUsedHash hash.Hash
	if anyParams&(1<<3) == 0 {
		if m.Runtime.ParameterIndexing.ExpandString.Match == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The match parameter of the ExpandString function can't be indexed by value")
		}
		matchUsedHash = hash.DeepHash(params.Match)
	}
	return MoqRegexp_starGenType_ExpandString_paramsKey{
		Params: struct {
			Template string
			Src      string
		}{
			Template: templateUsed,
			Src:      srcUsed,
		},
		Hashes: struct {
			Dst      hash.Hash
			Template hash.Hash
			Src      hash.Hash
			Match    hash.Hash
		}{
			Dst:      dstUsedHash,
			Template: templateUsedHash,
			Src:      srcUsedHash,
			Match:    matchUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindSubmatchIndex(b []byte) *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder {
	return &MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder{
		Params: MoqRegexp_starGenType_FindSubmatchIndex_params{
			B: b,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder) Any() *MoqRegexp_starGenType_FindSubmatchIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindSubmatchIndex(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindSubmatchIndex_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindSubmatchIndex_anyParams) B() *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder) Seq() *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindSubmatchIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindSubmatchIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder) ReturnResults(result1 []int) *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindSubmatchIndex_doReturnFn
	}{
		Values: &struct {
			Result1 []int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindSubmatchIndex_doFn) *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindSubmatchIndex_doReturnFn) *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindSubmatchIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindSubmatchIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindSubmatchIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindSubmatchIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindSubmatchIndex_paramsKey]*MoqRegexp_starGenType_FindSubmatchIndex_results{},
		}
		r.Moq.ResultsByParams_FindSubmatchIndex = append(r.Moq.ResultsByParams_FindSubmatchIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindSubmatchIndex) {
			copy(r.Moq.ResultsByParams_FindSubmatchIndex[insertAt+1:], r.Moq.ResultsByParams_FindSubmatchIndex[insertAt:0])
			r.Moq.ResultsByParams_FindSubmatchIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindSubmatchIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindSubmatchIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []int
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindSubmatchIndex_doFn
				DoReturnFn MoqRegexp_starGenType_FindSubmatchIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindSubmatchIndex(params MoqRegexp_starGenType_FindSubmatchIndex_params) string {
	return fmt.Sprintf("FindSubmatchIndex(%#v)", params.B)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindSubmatchIndex(params MoqRegexp_starGenType_FindSubmatchIndex_params, anyParams uint64) MoqRegexp_starGenType_FindSubmatchIndex_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindSubmatchIndex.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the FindSubmatchIndex function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	return MoqRegexp_starGenType_FindSubmatchIndex_paramsKey{
		Params: struct{}{},
		Hashes: struct{ B hash.Hash }{
			B: bUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindStringSubmatch(s string) *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder {
	return &MoqRegexp_starGenType_FindStringSubmatch_fnRecorder{
		Params: MoqRegexp_starGenType_FindStringSubmatch_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder) Any() *MoqRegexp_starGenType_FindStringSubmatch_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindStringSubmatch(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindStringSubmatch_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindStringSubmatch_anyParams) S() *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder) Seq() *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindStringSubmatch(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindStringSubmatch(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder) ReturnResults(result1 []string) *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindStringSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindStringSubmatch_doReturnFn
	}{
		Values: &struct {
			Result1 []string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindStringSubmatch_doFn) *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindStringSubmatch_doReturnFn) *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindStringSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindStringSubmatch_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindStringSubmatch_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindStringSubmatch {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindStringSubmatch_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindStringSubmatch_paramsKey]*MoqRegexp_starGenType_FindStringSubmatch_results{},
		}
		r.Moq.ResultsByParams_FindStringSubmatch = append(r.Moq.ResultsByParams_FindStringSubmatch, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindStringSubmatch) {
			copy(r.Moq.ResultsByParams_FindStringSubmatch[insertAt+1:], r.Moq.ResultsByParams_FindStringSubmatch[insertAt:0])
			r.Moq.ResultsByParams_FindStringSubmatch[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindStringSubmatch(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindStringSubmatch_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []string
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindStringSubmatch_doFn
				DoReturnFn MoqRegexp_starGenType_FindStringSubmatch_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindStringSubmatch(params MoqRegexp_starGenType_FindStringSubmatch_params) string {
	return fmt.Sprintf("FindStringSubmatch(%#v)", params.S)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindStringSubmatch(params MoqRegexp_starGenType_FindStringSubmatch_params, anyParams uint64) MoqRegexp_starGenType_FindStringSubmatch_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindStringSubmatch.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqRegexp_starGenType_FindStringSubmatch_paramsKey{
		Params: struct{ S string }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindStringSubmatchIndex(s string) *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder {
	return &MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder{
		Params: MoqRegexp_starGenType_FindStringSubmatchIndex_params{
			S: s,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder) Any() *MoqRegexp_starGenType_FindStringSubmatchIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindStringSubmatchIndex(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindStringSubmatchIndex_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindStringSubmatchIndex_anyParams) S() *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder) Seq() *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindStringSubmatchIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindStringSubmatchIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder) ReturnResults(result1 []int) *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindStringSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindStringSubmatchIndex_doReturnFn
	}{
		Values: &struct {
			Result1 []int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindStringSubmatchIndex_doFn) *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindStringSubmatchIndex_doReturnFn) *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindStringSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindStringSubmatchIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindStringSubmatchIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindStringSubmatchIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindStringSubmatchIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindStringSubmatchIndex_paramsKey]*MoqRegexp_starGenType_FindStringSubmatchIndex_results{},
		}
		r.Moq.ResultsByParams_FindStringSubmatchIndex = append(r.Moq.ResultsByParams_FindStringSubmatchIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindStringSubmatchIndex) {
			copy(r.Moq.ResultsByParams_FindStringSubmatchIndex[insertAt+1:], r.Moq.ResultsByParams_FindStringSubmatchIndex[insertAt:0])
			r.Moq.ResultsByParams_FindStringSubmatchIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindStringSubmatchIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindStringSubmatchIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []int
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindStringSubmatchIndex_doFn
				DoReturnFn MoqRegexp_starGenType_FindStringSubmatchIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindStringSubmatchIndex(params MoqRegexp_starGenType_FindStringSubmatchIndex_params) string {
	return fmt.Sprintf("FindStringSubmatchIndex(%#v)", params.S)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindStringSubmatchIndex(params MoqRegexp_starGenType_FindStringSubmatchIndex_params, anyParams uint64) MoqRegexp_starGenType_FindStringSubmatchIndex_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindStringSubmatchIndex.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	return MoqRegexp_starGenType_FindStringSubmatchIndex_paramsKey{
		Params: struct{ S string }{
			S: sUsed,
		},
		Hashes: struct{ S hash.Hash }{
			S: sUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindReaderSubmatchIndex(param1 io.RuneReader) *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder {
	return &MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder{
		Params: MoqRegexp_starGenType_FindReaderSubmatchIndex_params{
			Param1: param1,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder) Any() *MoqRegexp_starGenType_FindReaderSubmatchIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindReaderSubmatchIndex(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindReaderSubmatchIndex_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindReaderSubmatchIndex_anyParams) Param1() *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder) Seq() *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindReaderSubmatchIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindReaderSubmatchIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder) ReturnResults(result1 []int) *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindReaderSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindReaderSubmatchIndex_doReturnFn
	}{
		Values: &struct {
			Result1 []int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindReaderSubmatchIndex_doFn) *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindReaderSubmatchIndex_doReturnFn) *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindReaderSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindReaderSubmatchIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindReaderSubmatchIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindReaderSubmatchIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindReaderSubmatchIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindReaderSubmatchIndex_paramsKey]*MoqRegexp_starGenType_FindReaderSubmatchIndex_results{},
		}
		r.Moq.ResultsByParams_FindReaderSubmatchIndex = append(r.Moq.ResultsByParams_FindReaderSubmatchIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindReaderSubmatchIndex) {
			copy(r.Moq.ResultsByParams_FindReaderSubmatchIndex[insertAt+1:], r.Moq.ResultsByParams_FindReaderSubmatchIndex[insertAt:0])
			r.Moq.ResultsByParams_FindReaderSubmatchIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindReaderSubmatchIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindReaderSubmatchIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindReaderSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []int
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindReaderSubmatchIndex_doFn
				DoReturnFn MoqRegexp_starGenType_FindReaderSubmatchIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindReaderSubmatchIndex(params MoqRegexp_starGenType_FindReaderSubmatchIndex_params) string {
	return fmt.Sprintf("FindReaderSubmatchIndex(%#v)", params.Param1)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindReaderSubmatchIndex(params MoqRegexp_starGenType_FindReaderSubmatchIndex_params, anyParams uint64) MoqRegexp_starGenType_FindReaderSubmatchIndex_paramsKey {
	m.Scene.T.Helper()
	var param1Used io.RuneReader
	var param1UsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindReaderSubmatchIndex.Param1 == moq.ParamIndexByValue {
			param1Used = params.Param1
		} else {
			param1UsedHash = hash.DeepHash(params.Param1)
		}
	}
	return MoqRegexp_starGenType_FindReaderSubmatchIndex_paramsKey{
		Params: struct{ Param1 io.RuneReader }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindAll(b []byte, n int) *MoqRegexp_starGenType_FindAll_fnRecorder {
	return &MoqRegexp_starGenType_FindAll_fnRecorder{
		Params: MoqRegexp_starGenType_FindAll_params{
			B: b,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindAll_fnRecorder) Any() *MoqRegexp_starGenType_FindAll_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAll(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindAll_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindAll_anyParams) B() *MoqRegexp_starGenType_FindAll_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_FindAll_anyParams) N() *MoqRegexp_starGenType_FindAll_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindAll_fnRecorder) Seq() *MoqRegexp_starGenType_FindAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAll(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindAll_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAll(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindAll_fnRecorder) ReturnResults(result1 [][]byte) *MoqRegexp_starGenType_FindAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAll_doFn
		DoReturnFn MoqRegexp_starGenType_FindAll_doReturnFn
	}{
		Values: &struct {
			Result1 [][]byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindAll_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindAll_doFn) *MoqRegexp_starGenType_FindAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindAll_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindAll_doReturnFn) *MoqRegexp_starGenType_FindAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAll_doFn
		DoReturnFn MoqRegexp_starGenType_FindAll_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindAll_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindAll_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindAll {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindAll_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindAll_paramsKey]*MoqRegexp_starGenType_FindAll_results{},
		}
		r.Moq.ResultsByParams_FindAll = append(r.Moq.ResultsByParams_FindAll, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindAll) {
			copy(r.Moq.ResultsByParams_FindAll[insertAt+1:], r.Moq.ResultsByParams_FindAll[insertAt:0])
			r.Moq.ResultsByParams_FindAll[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindAll(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindAll_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindAll_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindAll_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 [][]byte
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindAll_doFn
				DoReturnFn MoqRegexp_starGenType_FindAll_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindAll(params MoqRegexp_starGenType_FindAll_params) string {
	return fmt.Sprintf("FindAll(%#v, %#v)", params.B, params.N)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindAll(params MoqRegexp_starGenType_FindAll_params, anyParams uint64) MoqRegexp_starGenType_FindAll_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindAll.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the FindAll function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.FindAll.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqRegexp_starGenType_FindAll_paramsKey{
		Params: struct{ N int }{
			N: nUsed,
		},
		Hashes: struct {
			B hash.Hash
			N hash.Hash
		}{
			B: bUsedHash,
			N: nUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindAllIndex(b []byte, n int) *MoqRegexp_starGenType_FindAllIndex_fnRecorder {
	return &MoqRegexp_starGenType_FindAllIndex_fnRecorder{
		Params: MoqRegexp_starGenType_FindAllIndex_params{
			B: b,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindAllIndex_fnRecorder) Any() *MoqRegexp_starGenType_FindAllIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllIndex(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindAllIndex_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindAllIndex_anyParams) B() *MoqRegexp_starGenType_FindAllIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_FindAllIndex_anyParams) N() *MoqRegexp_starGenType_FindAllIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindAllIndex_fnRecorder) Seq() *MoqRegexp_starGenType_FindAllIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindAllIndex_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindAllIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindAllIndex_fnRecorder) ReturnResults(result1 [][]int) *MoqRegexp_starGenType_FindAllIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllIndex_doReturnFn
	}{
		Values: &struct {
			Result1 [][]int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindAllIndex_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindAllIndex_doFn) *MoqRegexp_starGenType_FindAllIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindAllIndex_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindAllIndex_doReturnFn) *MoqRegexp_starGenType_FindAllIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindAllIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindAllIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindAllIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindAllIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindAllIndex_paramsKey]*MoqRegexp_starGenType_FindAllIndex_results{},
		}
		r.Moq.ResultsByParams_FindAllIndex = append(r.Moq.ResultsByParams_FindAllIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindAllIndex) {
			copy(r.Moq.ResultsByParams_FindAllIndex[insertAt+1:], r.Moq.ResultsByParams_FindAllIndex[insertAt:0])
			r.Moq.ResultsByParams_FindAllIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindAllIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindAllIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindAllIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindAllIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 [][]int
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindAllIndex_doFn
				DoReturnFn MoqRegexp_starGenType_FindAllIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindAllIndex(params MoqRegexp_starGenType_FindAllIndex_params) string {
	return fmt.Sprintf("FindAllIndex(%#v, %#v)", params.B, params.N)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindAllIndex(params MoqRegexp_starGenType_FindAllIndex_params, anyParams uint64) MoqRegexp_starGenType_FindAllIndex_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindAllIndex.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the FindAllIndex function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.FindAllIndex.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqRegexp_starGenType_FindAllIndex_paramsKey{
		Params: struct{ N int }{
			N: nUsed,
		},
		Hashes: struct {
			B hash.Hash
			N hash.Hash
		}{
			B: bUsedHash,
			N: nUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindAllString(s string, n int) *MoqRegexp_starGenType_FindAllString_fnRecorder {
	return &MoqRegexp_starGenType_FindAllString_fnRecorder{
		Params: MoqRegexp_starGenType_FindAllString_params{
			S: s,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindAllString_fnRecorder) Any() *MoqRegexp_starGenType_FindAllString_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllString(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindAllString_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindAllString_anyParams) S() *MoqRegexp_starGenType_FindAllString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_FindAllString_anyParams) N() *MoqRegexp_starGenType_FindAllString_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindAllString_fnRecorder) Seq() *MoqRegexp_starGenType_FindAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllString(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindAllString_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllString(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindAllString_fnRecorder) ReturnResults(result1 []string) *MoqRegexp_starGenType_FindAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllString_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllString_doReturnFn
	}{
		Values: &struct {
			Result1 []string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindAllString_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindAllString_doFn) *MoqRegexp_starGenType_FindAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindAllString_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindAllString_doReturnFn) *MoqRegexp_starGenType_FindAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllString_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllString_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindAllString_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindAllString_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindAllString {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindAllString_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindAllString_paramsKey]*MoqRegexp_starGenType_FindAllString_results{},
		}
		r.Moq.ResultsByParams_FindAllString = append(r.Moq.ResultsByParams_FindAllString, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindAllString) {
			copy(r.Moq.ResultsByParams_FindAllString[insertAt+1:], r.Moq.ResultsByParams_FindAllString[insertAt:0])
			r.Moq.ResultsByParams_FindAllString[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindAllString(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindAllString_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindAllString_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindAllString_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []string
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindAllString_doFn
				DoReturnFn MoqRegexp_starGenType_FindAllString_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindAllString(params MoqRegexp_starGenType_FindAllString_params) string {
	return fmt.Sprintf("FindAllString(%#v, %#v)", params.S, params.N)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindAllString(params MoqRegexp_starGenType_FindAllString_params, anyParams uint64) MoqRegexp_starGenType_FindAllString_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindAllString.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.FindAllString.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqRegexp_starGenType_FindAllString_paramsKey{
		Params: struct {
			S string
			N int
		}{
			S: sUsed,
			N: nUsed,
		},
		Hashes: struct {
			S hash.Hash
			N hash.Hash
		}{
			S: sUsedHash,
			N: nUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindAllStringIndex(s string, n int) *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder {
	return &MoqRegexp_starGenType_FindAllStringIndex_fnRecorder{
		Params: MoqRegexp_starGenType_FindAllStringIndex_params{
			S: s,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder) Any() *MoqRegexp_starGenType_FindAllStringIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllStringIndex(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindAllStringIndex_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindAllStringIndex_anyParams) S() *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_FindAllStringIndex_anyParams) N() *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder) Seq() *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllStringIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllStringIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder) ReturnResults(result1 [][]int) *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllStringIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllStringIndex_doReturnFn
	}{
		Values: &struct {
			Result1 [][]int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindAllStringIndex_doFn) *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindAllStringIndex_doReturnFn) *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllStringIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllStringIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindAllStringIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindAllStringIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindAllStringIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindAllStringIndex_paramsKey]*MoqRegexp_starGenType_FindAllStringIndex_results{},
		}
		r.Moq.ResultsByParams_FindAllStringIndex = append(r.Moq.ResultsByParams_FindAllStringIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindAllStringIndex) {
			copy(r.Moq.ResultsByParams_FindAllStringIndex[insertAt+1:], r.Moq.ResultsByParams_FindAllStringIndex[insertAt:0])
			r.Moq.ResultsByParams_FindAllStringIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindAllStringIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindAllStringIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindAllStringIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 [][]int
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindAllStringIndex_doFn
				DoReturnFn MoqRegexp_starGenType_FindAllStringIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindAllStringIndex(params MoqRegexp_starGenType_FindAllStringIndex_params) string {
	return fmt.Sprintf("FindAllStringIndex(%#v, %#v)", params.S, params.N)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindAllStringIndex(params MoqRegexp_starGenType_FindAllStringIndex_params, anyParams uint64) MoqRegexp_starGenType_FindAllStringIndex_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindAllStringIndex.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.FindAllStringIndex.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqRegexp_starGenType_FindAllStringIndex_paramsKey{
		Params: struct {
			S string
			N int
		}{
			S: sUsed,
			N: nUsed,
		},
		Hashes: struct {
			S hash.Hash
			N hash.Hash
		}{
			S: sUsedHash,
			N: nUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindAllSubmatch(b []byte, n int) *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder {
	return &MoqRegexp_starGenType_FindAllSubmatch_fnRecorder{
		Params: MoqRegexp_starGenType_FindAllSubmatch_params{
			B: b,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder) Any() *MoqRegexp_starGenType_FindAllSubmatch_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllSubmatch(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindAllSubmatch_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindAllSubmatch_anyParams) B() *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_FindAllSubmatch_anyParams) N() *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder) Seq() *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllSubmatch(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllSubmatch(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder) ReturnResults(result1 [][][]byte) *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][][]byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllSubmatch_doReturnFn
	}{
		Values: &struct {
			Result1 [][][]byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindAllSubmatch_doFn) *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindAllSubmatch_doReturnFn) *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][][]byte
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllSubmatch_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindAllSubmatch_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindAllSubmatch {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindAllSubmatch_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindAllSubmatch_paramsKey]*MoqRegexp_starGenType_FindAllSubmatch_results{},
		}
		r.Moq.ResultsByParams_FindAllSubmatch = append(r.Moq.ResultsByParams_FindAllSubmatch, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindAllSubmatch) {
			copy(r.Moq.ResultsByParams_FindAllSubmatch[insertAt+1:], r.Moq.ResultsByParams_FindAllSubmatch[insertAt:0])
			r.Moq.ResultsByParams_FindAllSubmatch[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindAllSubmatch(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindAllSubmatch_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindAllSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 [][][]byte
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindAllSubmatch_doFn
				DoReturnFn MoqRegexp_starGenType_FindAllSubmatch_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindAllSubmatch(params MoqRegexp_starGenType_FindAllSubmatch_params) string {
	return fmt.Sprintf("FindAllSubmatch(%#v, %#v)", params.B, params.N)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindAllSubmatch(params MoqRegexp_starGenType_FindAllSubmatch_params, anyParams uint64) MoqRegexp_starGenType_FindAllSubmatch_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindAllSubmatch.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the FindAllSubmatch function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.FindAllSubmatch.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqRegexp_starGenType_FindAllSubmatch_paramsKey{
		Params: struct{ N int }{
			N: nUsed,
		},
		Hashes: struct {
			B hash.Hash
			N hash.Hash
		}{
			B: bUsedHash,
			N: nUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindAllSubmatchIndex(b []byte, n int) *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder {
	return &MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder{
		Params: MoqRegexp_starGenType_FindAllSubmatchIndex_params{
			B: b,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder) Any() *MoqRegexp_starGenType_FindAllSubmatchIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllSubmatchIndex(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindAllSubmatchIndex_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindAllSubmatchIndex_anyParams) B() *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_FindAllSubmatchIndex_anyParams) N() *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder) Seq() *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllSubmatchIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllSubmatchIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder) ReturnResults(result1 [][]int) *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllSubmatchIndex_doReturnFn
	}{
		Values: &struct {
			Result1 [][]int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindAllSubmatchIndex_doFn) *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindAllSubmatchIndex_doReturnFn) *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllSubmatchIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindAllSubmatchIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindAllSubmatchIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindAllSubmatchIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindAllSubmatchIndex_paramsKey]*MoqRegexp_starGenType_FindAllSubmatchIndex_results{},
		}
		r.Moq.ResultsByParams_FindAllSubmatchIndex = append(r.Moq.ResultsByParams_FindAllSubmatchIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindAllSubmatchIndex) {
			copy(r.Moq.ResultsByParams_FindAllSubmatchIndex[insertAt+1:], r.Moq.ResultsByParams_FindAllSubmatchIndex[insertAt:0])
			r.Moq.ResultsByParams_FindAllSubmatchIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindAllSubmatchIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindAllSubmatchIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindAllSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 [][]int
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindAllSubmatchIndex_doFn
				DoReturnFn MoqRegexp_starGenType_FindAllSubmatchIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindAllSubmatchIndex(params MoqRegexp_starGenType_FindAllSubmatchIndex_params) string {
	return fmt.Sprintf("FindAllSubmatchIndex(%#v, %#v)", params.B, params.N)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindAllSubmatchIndex(params MoqRegexp_starGenType_FindAllSubmatchIndex_params, anyParams uint64) MoqRegexp_starGenType_FindAllSubmatchIndex_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindAllSubmatchIndex.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the FindAllSubmatchIndex function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.FindAllSubmatchIndex.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqRegexp_starGenType_FindAllSubmatchIndex_paramsKey{
		Params: struct{ N int }{
			N: nUsed,
		},
		Hashes: struct {
			B hash.Hash
			N hash.Hash
		}{
			B: bUsedHash,
			N: nUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindAllStringSubmatch(s string, n int) *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder {
	return &MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder{
		Params: MoqRegexp_starGenType_FindAllStringSubmatch_params{
			S: s,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder) Any() *MoqRegexp_starGenType_FindAllStringSubmatch_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllStringSubmatch(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindAllStringSubmatch_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindAllStringSubmatch_anyParams) S() *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_FindAllStringSubmatch_anyParams) N() *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder) Seq() *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllStringSubmatch(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllStringSubmatch(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder) ReturnResults(result1 [][]string) *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllStringSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllStringSubmatch_doReturnFn
	}{
		Values: &struct {
			Result1 [][]string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindAllStringSubmatch_doFn) *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindAllStringSubmatch_doReturnFn) *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllStringSubmatch_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllStringSubmatch_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindAllStringSubmatch_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindAllStringSubmatch {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindAllStringSubmatch_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindAllStringSubmatch_paramsKey]*MoqRegexp_starGenType_FindAllStringSubmatch_results{},
		}
		r.Moq.ResultsByParams_FindAllStringSubmatch = append(r.Moq.ResultsByParams_FindAllStringSubmatch, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindAllStringSubmatch) {
			copy(r.Moq.ResultsByParams_FindAllStringSubmatch[insertAt+1:], r.Moq.ResultsByParams_FindAllStringSubmatch[insertAt:0])
			r.Moq.ResultsByParams_FindAllStringSubmatch[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindAllStringSubmatch(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindAllStringSubmatch_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindAllStringSubmatch_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 [][]string
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindAllStringSubmatch_doFn
				DoReturnFn MoqRegexp_starGenType_FindAllStringSubmatch_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindAllStringSubmatch(params MoqRegexp_starGenType_FindAllStringSubmatch_params) string {
	return fmt.Sprintf("FindAllStringSubmatch(%#v, %#v)", params.S, params.N)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindAllStringSubmatch(params MoqRegexp_starGenType_FindAllStringSubmatch_params, anyParams uint64) MoqRegexp_starGenType_FindAllStringSubmatch_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindAllStringSubmatch.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.FindAllStringSubmatch.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqRegexp_starGenType_FindAllStringSubmatch_paramsKey{
		Params: struct {
			S string
			N int
		}{
			S: sUsed,
			N: nUsed,
		},
		Hashes: struct {
			S hash.Hash
			N hash.Hash
		}{
			S: sUsedHash,
			N: nUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) FindAllStringSubmatchIndex(s string, n int) *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder {
	return &MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder{
		Params: MoqRegexp_starGenType_FindAllStringSubmatchIndex_params{
			S: s,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder) Any() *MoqRegexp_starGenType_FindAllStringSubmatchIndex_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllStringSubmatchIndex(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_FindAllStringSubmatchIndex_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_FindAllStringSubmatchIndex_anyParams) S() *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_FindAllStringSubmatchIndex_anyParams) N() *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder) Seq() *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllStringSubmatchIndex(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder) NoSeq() *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_FindAllStringSubmatchIndex(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder) ReturnResults(result1 [][]int) *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllStringSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllStringSubmatchIndex_doReturnFn
	}{
		Values: &struct {
			Result1 [][]int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder) AndDo(fn MoqRegexp_starGenType_FindAllStringSubmatchIndex_doFn) *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_FindAllStringSubmatchIndex_doReturnFn) *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 [][]int
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_FindAllStringSubmatchIndex_doFn
		DoReturnFn MoqRegexp_starGenType_FindAllStringSubmatchIndex_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_FindAllStringSubmatchIndex_resultsByParams
	for n, res := range r.Moq.ResultsByParams_FindAllStringSubmatchIndex {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_FindAllStringSubmatchIndex_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_FindAllStringSubmatchIndex_paramsKey]*MoqRegexp_starGenType_FindAllStringSubmatchIndex_results{},
		}
		r.Moq.ResultsByParams_FindAllStringSubmatchIndex = append(r.Moq.ResultsByParams_FindAllStringSubmatchIndex, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_FindAllStringSubmatchIndex) {
			copy(r.Moq.ResultsByParams_FindAllStringSubmatchIndex[insertAt+1:], r.Moq.ResultsByParams_FindAllStringSubmatchIndex[insertAt:0])
			r.Moq.ResultsByParams_FindAllStringSubmatchIndex[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_FindAllStringSubmatchIndex(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_FindAllStringSubmatchIndex_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_FindAllStringSubmatchIndex_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 [][]int
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_FindAllStringSubmatchIndex_doFn
				DoReturnFn MoqRegexp_starGenType_FindAllStringSubmatchIndex_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_FindAllStringSubmatchIndex(params MoqRegexp_starGenType_FindAllStringSubmatchIndex_params) string {
	return fmt.Sprintf("FindAllStringSubmatchIndex(%#v, %#v)", params.S, params.N)
}

func (m *MoqRegexp_starGenType) ParamsKey_FindAllStringSubmatchIndex(params MoqRegexp_starGenType_FindAllStringSubmatchIndex_params, anyParams uint64) MoqRegexp_starGenType_FindAllStringSubmatchIndex_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.FindAllStringSubmatchIndex.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.FindAllStringSubmatchIndex.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqRegexp_starGenType_FindAllStringSubmatchIndex_paramsKey{
		Params: struct {
			S string
			N int
		}{
			S: sUsed,
			N: nUsed,
		},
		Hashes: struct {
			S hash.Hash
			N hash.Hash
		}{
			S: sUsedHash,
			N: nUsedHash,
		},
	}
}

func (m *MoqRegexp_starGenType_recorder) Split(s string, n int) *MoqRegexp_starGenType_Split_fnRecorder {
	return &MoqRegexp_starGenType_Split_fnRecorder{
		Params: MoqRegexp_starGenType_Split_params{
			S: s,
			N: n,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqRegexp_starGenType_Split_fnRecorder) Any() *MoqRegexp_starGenType_Split_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Split(r.Params))
		return nil
	}
	return &MoqRegexp_starGenType_Split_anyParams{Recorder: r}
}

func (a *MoqRegexp_starGenType_Split_anyParams) S() *MoqRegexp_starGenType_Split_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqRegexp_starGenType_Split_anyParams) N() *MoqRegexp_starGenType_Split_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqRegexp_starGenType_Split_fnRecorder) Seq() *MoqRegexp_starGenType_Split_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Split(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqRegexp_starGenType_Split_fnRecorder) NoSeq() *MoqRegexp_starGenType_Split_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Split(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqRegexp_starGenType_Split_fnRecorder) ReturnResults(result1 []string) *MoqRegexp_starGenType_Split_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Split_doFn
		DoReturnFn MoqRegexp_starGenType_Split_doReturnFn
	}{
		Values: &struct {
			Result1 []string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqRegexp_starGenType_Split_fnRecorder) AndDo(fn MoqRegexp_starGenType_Split_doFn) *MoqRegexp_starGenType_Split_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqRegexp_starGenType_Split_fnRecorder) DoReturnResults(fn MoqRegexp_starGenType_Split_doReturnFn) *MoqRegexp_starGenType_Split_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []string
		}
		Sequence   uint32
		DoFn       MoqRegexp_starGenType_Split_doFn
		DoReturnFn MoqRegexp_starGenType_Split_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqRegexp_starGenType_Split_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqRegexp_starGenType_Split_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Split {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqRegexp_starGenType_Split_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqRegexp_starGenType_Split_paramsKey]*MoqRegexp_starGenType_Split_results{},
		}
		r.Moq.ResultsByParams_Split = append(r.Moq.ResultsByParams_Split, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Split) {
			copy(r.Moq.ResultsByParams_Split[insertAt+1:], r.Moq.ResultsByParams_Split[insertAt:0])
			r.Moq.ResultsByParams_Split[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Split(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqRegexp_starGenType_Split_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqRegexp_starGenType_Split_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqRegexp_starGenType_Split_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []string
				}
				Sequence   uint32
				DoFn       MoqRegexp_starGenType_Split_doFn
				DoReturnFn MoqRegexp_starGenType_Split_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqRegexp_starGenType) PrettyParams_Split(params MoqRegexp_starGenType_Split_params) string {
	return fmt.Sprintf("Split(%#v, %#v)", params.S, params.N)
}

func (m *MoqRegexp_starGenType) ParamsKey_Split(params MoqRegexp_starGenType_Split_params, anyParams uint64) MoqRegexp_starGenType_Split_paramsKey {
	m.Scene.T.Helper()
	var sUsed string
	var sUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Split.S == moq.ParamIndexByValue {
			sUsed = params.S
		} else {
			sUsedHash = hash.DeepHash(params.S)
		}
	}
	var nUsed int
	var nUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.Split.N == moq.ParamIndexByValue {
			nUsed = params.N
		} else {
			nUsedHash = hash.DeepHash(params.N)
		}
	}
	return MoqRegexp_starGenType_Split_paramsKey{
		Params: struct {
			S string
			N int
		}{
			S: sUsed,
			N: nUsed,
		},
		Hashes: struct {
			S hash.Hash
			N hash.Hash
		}{
			S: sUsedHash,
			N: nUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqRegexp_starGenType) Reset() {
	m.ResultsByParams_String = nil
	m.ResultsByParams_Copy = nil
	m.ResultsByParams_Longest = nil
	m.ResultsByParams_NumSubexp = nil
	m.ResultsByParams_SubexpNames = nil
	m.ResultsByParams_SubexpIndex = nil
	m.ResultsByParams_LiteralPrefix = nil
	m.ResultsByParams_MatchReader = nil
	m.ResultsByParams_MatchString = nil
	m.ResultsByParams_Match = nil
	m.ResultsByParams_ReplaceAllString = nil
	m.ResultsByParams_ReplaceAllLiteralString = nil
	m.ResultsByParams_ReplaceAllStringFunc = nil
	m.ResultsByParams_ReplaceAll = nil
	m.ResultsByParams_ReplaceAllLiteral = nil
	m.ResultsByParams_ReplaceAllFunc = nil
	m.ResultsByParams_Find = nil
	m.ResultsByParams_FindIndex = nil
	m.ResultsByParams_FindString = nil
	m.ResultsByParams_FindStringIndex = nil
	m.ResultsByParams_FindReaderIndex = nil
	m.ResultsByParams_FindSubmatch = nil
	m.ResultsByParams_Expand = nil
	m.ResultsByParams_ExpandString = nil
	m.ResultsByParams_FindSubmatchIndex = nil
	m.ResultsByParams_FindStringSubmatch = nil
	m.ResultsByParams_FindStringSubmatchIndex = nil
	m.ResultsByParams_FindReaderSubmatchIndex = nil
	m.ResultsByParams_FindAll = nil
	m.ResultsByParams_FindAllIndex = nil
	m.ResultsByParams_FindAllString = nil
	m.ResultsByParams_FindAllStringIndex = nil
	m.ResultsByParams_FindAllSubmatch = nil
	m.ResultsByParams_FindAllSubmatchIndex = nil
	m.ResultsByParams_FindAllStringSubmatch = nil
	m.ResultsByParams_FindAllStringSubmatchIndex = nil
	m.ResultsByParams_Split = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqRegexp_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Copy {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Copy(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Longest {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Longest(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_NumSubexp {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_NumSubexp(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SubexpNames {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SubexpNames(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_SubexpIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_SubexpIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_LiteralPrefix {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_LiteralPrefix(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MatchReader {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MatchReader(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MatchString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MatchString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Match {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Match(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReplaceAllString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReplaceAllString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReplaceAllLiteralString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReplaceAllLiteralString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReplaceAllStringFunc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReplaceAllStringFunc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReplaceAll {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReplaceAll(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReplaceAllLiteral {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReplaceAllLiteral(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ReplaceAllFunc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ReplaceAllFunc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Find {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Find(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindStringIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindStringIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindReaderIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindReaderIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindSubmatch {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindSubmatch(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Expand {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Expand(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ExpandString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ExpandString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindSubmatchIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindSubmatchIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindStringSubmatch {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindStringSubmatch(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindStringSubmatchIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindStringSubmatchIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindReaderSubmatchIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindReaderSubmatchIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindAll {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindAll(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindAllIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindAllIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindAllString {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindAllString(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindAllStringIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindAllStringIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindAllSubmatch {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindAllSubmatch(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindAllSubmatchIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindAllSubmatchIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindAllStringSubmatch {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindAllStringSubmatch(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_FindAllStringSubmatchIndex {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_FindAllStringSubmatchIndex(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Split {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Split(results.Params))
			}
		}
	}
}
