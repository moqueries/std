// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package list

import (
	"container/list"
	"fmt"
	"math/bits"
	"sync/atomic"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that list.List_starGenType is mocked
// completely
var _ List_starGenType = (*MoqList_starGenType_mock)(nil)

// List_starGenType is the fabricated implementation type of this mock (emitted
// when mocking a collections of methods directly and not from an interface
// type)
type List_starGenType interface {
	Init() *list.List
	Len() int
	Front() *list.Element
	Back() *list.Element
	Remove(e *list.Element) interface{}
	PushFront(v interface{}) *list.Element
	PushBack(v interface{}) *list.Element
	InsertBefore(v interface{}, mark *list.Element) *list.Element
	InsertAfter(v interface{}, mark *list.Element) *list.Element
	MoveToFront(e *list.Element)
	MoveToBack(e *list.Element)
	MoveBefore(e, mark *list.Element)
	MoveAfter(e, mark *list.Element)
	PushBackList(other *list.List)
	PushFrontList(other *list.List)
}

// MoqList_starGenType holds the state of a moq of the List_starGenType type
type MoqList_starGenType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqList_starGenType_mock

	ResultsByParams_Init          []MoqList_starGenType_Init_resultsByParams
	ResultsByParams_Len           []MoqList_starGenType_Len_resultsByParams
	ResultsByParams_Front         []MoqList_starGenType_Front_resultsByParams
	ResultsByParams_Back          []MoqList_starGenType_Back_resultsByParams
	ResultsByParams_Remove        []MoqList_starGenType_Remove_resultsByParams
	ResultsByParams_PushFront     []MoqList_starGenType_PushFront_resultsByParams
	ResultsByParams_PushBack      []MoqList_starGenType_PushBack_resultsByParams
	ResultsByParams_InsertBefore  []MoqList_starGenType_InsertBefore_resultsByParams
	ResultsByParams_InsertAfter   []MoqList_starGenType_InsertAfter_resultsByParams
	ResultsByParams_MoveToFront   []MoqList_starGenType_MoveToFront_resultsByParams
	ResultsByParams_MoveToBack    []MoqList_starGenType_MoveToBack_resultsByParams
	ResultsByParams_MoveBefore    []MoqList_starGenType_MoveBefore_resultsByParams
	ResultsByParams_MoveAfter     []MoqList_starGenType_MoveAfter_resultsByParams
	ResultsByParams_PushBackList  []MoqList_starGenType_PushBackList_resultsByParams
	ResultsByParams_PushFrontList []MoqList_starGenType_PushFrontList_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			Init   struct{}
			Len    struct{}
			Front  struct{}
			Back   struct{}
			Remove struct {
				E moq.ParamIndexing
			}
			PushFront struct {
				V moq.ParamIndexing
			}
			PushBack struct {
				V moq.ParamIndexing
			}
			InsertBefore struct {
				V    moq.ParamIndexing
				Mark moq.ParamIndexing
			}
			InsertAfter struct {
				V    moq.ParamIndexing
				Mark moq.ParamIndexing
			}
			MoveToFront struct {
				E moq.ParamIndexing
			}
			MoveToBack struct {
				E moq.ParamIndexing
			}
			MoveBefore struct {
				E    moq.ParamIndexing
				Mark moq.ParamIndexing
			}
			MoveAfter struct {
				E    moq.ParamIndexing
				Mark moq.ParamIndexing
			}
			PushBackList struct {
				Other moq.ParamIndexing
			}
			PushFrontList struct {
				Other moq.ParamIndexing
			}
		}
	}
	// MoqList_starGenType_mock isolates the mock interface of the List_starGenType
}

// type
type MoqList_starGenType_mock struct {
	Moq *MoqList_starGenType
}

// MoqList_starGenType_recorder isolates the recorder interface of the
// List_starGenType type
type MoqList_starGenType_recorder struct {
	Moq *MoqList_starGenType
}

// MoqList_starGenType_Init_params holds the params of the List_starGenType
// type
type MoqList_starGenType_Init_params struct{}

// MoqList_starGenType_Init_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_Init_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqList_starGenType_Init_resultsByParams contains the results for a given
// set of parameters for the List_starGenType type
type MoqList_starGenType_Init_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_Init_paramsKey]*MoqList_starGenType_Init_results
}

// MoqList_starGenType_Init_doFn defines the type of function needed when
// calling AndDo for the List_starGenType type
type MoqList_starGenType_Init_doFn func()

// MoqList_starGenType_Init_doReturnFn defines the type of function needed when
// calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_Init_doReturnFn func() *list.List

// MoqList_starGenType_Init_results holds the results of the List_starGenType
// type
type MoqList_starGenType_Init_results struct {
	Params  MoqList_starGenType_Init_params
	Results []struct {
		Values *struct {
			Result1 *list.List
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Init_doFn
		DoReturnFn MoqList_starGenType_Init_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_Init_fnRecorder routes recorded function calls to the
// MoqList_starGenType moq
type MoqList_starGenType_Init_fnRecorder struct {
	Params    MoqList_starGenType_Init_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_Init_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_Init_anyParams isolates the any params functions of the
// List_starGenType type
type MoqList_starGenType_Init_anyParams struct {
	Recorder *MoqList_starGenType_Init_fnRecorder
}

// MoqList_starGenType_Len_params holds the params of the List_starGenType type
type MoqList_starGenType_Len_params struct{}

// MoqList_starGenType_Len_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_Len_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqList_starGenType_Len_resultsByParams contains the results for a given set
// of parameters for the List_starGenType type
type MoqList_starGenType_Len_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_Len_paramsKey]*MoqList_starGenType_Len_results
}

// MoqList_starGenType_Len_doFn defines the type of function needed when
// calling AndDo for the List_starGenType type
type MoqList_starGenType_Len_doFn func()

// MoqList_starGenType_Len_doReturnFn defines the type of function needed when
// calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_Len_doReturnFn func() int

// MoqList_starGenType_Len_results holds the results of the List_starGenType
// type
type MoqList_starGenType_Len_results struct {
	Params  MoqList_starGenType_Len_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Len_doFn
		DoReturnFn MoqList_starGenType_Len_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_Len_fnRecorder routes recorded function calls to the
// MoqList_starGenType moq
type MoqList_starGenType_Len_fnRecorder struct {
	Params    MoqList_starGenType_Len_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_Len_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_Len_anyParams isolates the any params functions of the
// List_starGenType type
type MoqList_starGenType_Len_anyParams struct {
	Recorder *MoqList_starGenType_Len_fnRecorder
}

// MoqList_starGenType_Front_params holds the params of the List_starGenType
// type
type MoqList_starGenType_Front_params struct{}

// MoqList_starGenType_Front_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_Front_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqList_starGenType_Front_resultsByParams contains the results for a given
// set of parameters for the List_starGenType type
type MoqList_starGenType_Front_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_Front_paramsKey]*MoqList_starGenType_Front_results
}

// MoqList_starGenType_Front_doFn defines the type of function needed when
// calling AndDo for the List_starGenType type
type MoqList_starGenType_Front_doFn func()

// MoqList_starGenType_Front_doReturnFn defines the type of function needed
// when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_Front_doReturnFn func() *list.Element

// MoqList_starGenType_Front_results holds the results of the List_starGenType
// type
type MoqList_starGenType_Front_results struct {
	Params  MoqList_starGenType_Front_params
	Results []struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Front_doFn
		DoReturnFn MoqList_starGenType_Front_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_Front_fnRecorder routes recorded function calls to the
// MoqList_starGenType moq
type MoqList_starGenType_Front_fnRecorder struct {
	Params    MoqList_starGenType_Front_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_Front_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_Front_anyParams isolates the any params functions of the
// List_starGenType type
type MoqList_starGenType_Front_anyParams struct {
	Recorder *MoqList_starGenType_Front_fnRecorder
}

// MoqList_starGenType_Back_params holds the params of the List_starGenType
// type
type MoqList_starGenType_Back_params struct{}

// MoqList_starGenType_Back_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_Back_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqList_starGenType_Back_resultsByParams contains the results for a given
// set of parameters for the List_starGenType type
type MoqList_starGenType_Back_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_Back_paramsKey]*MoqList_starGenType_Back_results
}

// MoqList_starGenType_Back_doFn defines the type of function needed when
// calling AndDo for the List_starGenType type
type MoqList_starGenType_Back_doFn func()

// MoqList_starGenType_Back_doReturnFn defines the type of function needed when
// calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_Back_doReturnFn func() *list.Element

// MoqList_starGenType_Back_results holds the results of the List_starGenType
// type
type MoqList_starGenType_Back_results struct {
	Params  MoqList_starGenType_Back_params
	Results []struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Back_doFn
		DoReturnFn MoqList_starGenType_Back_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_Back_fnRecorder routes recorded function calls to the
// MoqList_starGenType moq
type MoqList_starGenType_Back_fnRecorder struct {
	Params    MoqList_starGenType_Back_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_Back_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_Back_anyParams isolates the any params functions of the
// List_starGenType type
type MoqList_starGenType_Back_anyParams struct {
	Recorder *MoqList_starGenType_Back_fnRecorder
}

// MoqList_starGenType_Remove_params holds the params of the List_starGenType
// type
type MoqList_starGenType_Remove_params struct{ E *list.Element }

// MoqList_starGenType_Remove_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_Remove_paramsKey struct {
	Params struct{ E *list.Element }
	Hashes struct{ E hash.Hash }
}

// MoqList_starGenType_Remove_resultsByParams contains the results for a given
// set of parameters for the List_starGenType type
type MoqList_starGenType_Remove_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_Remove_paramsKey]*MoqList_starGenType_Remove_results
}

// MoqList_starGenType_Remove_doFn defines the type of function needed when
// calling AndDo for the List_starGenType type
type MoqList_starGenType_Remove_doFn func(e *list.Element)

// MoqList_starGenType_Remove_doReturnFn defines the type of function needed
// when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_Remove_doReturnFn func(e *list.Element) interface{}

// MoqList_starGenType_Remove_results holds the results of the List_starGenType
// type
type MoqList_starGenType_Remove_results struct {
	Params  MoqList_starGenType_Remove_params
	Results []struct {
		Values *struct {
			Result1 interface{}
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Remove_doFn
		DoReturnFn MoqList_starGenType_Remove_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_Remove_fnRecorder routes recorded function calls to the
// MoqList_starGenType moq
type MoqList_starGenType_Remove_fnRecorder struct {
	Params    MoqList_starGenType_Remove_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_Remove_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_Remove_anyParams isolates the any params functions of
// the List_starGenType type
type MoqList_starGenType_Remove_anyParams struct {
	Recorder *MoqList_starGenType_Remove_fnRecorder
}

// MoqList_starGenType_PushFront_params holds the params of the
// List_starGenType type
type MoqList_starGenType_PushFront_params struct{ V interface{} }

// MoqList_starGenType_PushFront_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_PushFront_paramsKey struct {
	Params struct{ V interface{} }
	Hashes struct{ V hash.Hash }
}

// MoqList_starGenType_PushFront_resultsByParams contains the results for a
// given set of parameters for the List_starGenType type
type MoqList_starGenType_PushFront_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_PushFront_paramsKey]*MoqList_starGenType_PushFront_results
}

// MoqList_starGenType_PushFront_doFn defines the type of function needed when
// calling AndDo for the List_starGenType type
type MoqList_starGenType_PushFront_doFn func(v interface{})

// MoqList_starGenType_PushFront_doReturnFn defines the type of function needed
// when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_PushFront_doReturnFn func(v interface{}) *list.Element

// MoqList_starGenType_PushFront_results holds the results of the
// List_starGenType type
type MoqList_starGenType_PushFront_results struct {
	Params  MoqList_starGenType_PushFront_params
	Results []struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushFront_doFn
		DoReturnFn MoqList_starGenType_PushFront_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_PushFront_fnRecorder routes recorded function calls to
// the MoqList_starGenType moq
type MoqList_starGenType_PushFront_fnRecorder struct {
	Params    MoqList_starGenType_PushFront_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_PushFront_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_PushFront_anyParams isolates the any params functions of
// the List_starGenType type
type MoqList_starGenType_PushFront_anyParams struct {
	Recorder *MoqList_starGenType_PushFront_fnRecorder
}

// MoqList_starGenType_PushBack_params holds the params of the List_starGenType
// type
type MoqList_starGenType_PushBack_params struct{ V interface{} }

// MoqList_starGenType_PushBack_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_PushBack_paramsKey struct {
	Params struct{ V interface{} }
	Hashes struct{ V hash.Hash }
}

// MoqList_starGenType_PushBack_resultsByParams contains the results for a
// given set of parameters for the List_starGenType type
type MoqList_starGenType_PushBack_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_PushBack_paramsKey]*MoqList_starGenType_PushBack_results
}

// MoqList_starGenType_PushBack_doFn defines the type of function needed when
// calling AndDo for the List_starGenType type
type MoqList_starGenType_PushBack_doFn func(v interface{})

// MoqList_starGenType_PushBack_doReturnFn defines the type of function needed
// when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_PushBack_doReturnFn func(v interface{}) *list.Element

// MoqList_starGenType_PushBack_results holds the results of the
// List_starGenType type
type MoqList_starGenType_PushBack_results struct {
	Params  MoqList_starGenType_PushBack_params
	Results []struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushBack_doFn
		DoReturnFn MoqList_starGenType_PushBack_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_PushBack_fnRecorder routes recorded function calls to
// the MoqList_starGenType moq
type MoqList_starGenType_PushBack_fnRecorder struct {
	Params    MoqList_starGenType_PushBack_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_PushBack_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_PushBack_anyParams isolates the any params functions of
// the List_starGenType type
type MoqList_starGenType_PushBack_anyParams struct {
	Recorder *MoqList_starGenType_PushBack_fnRecorder
}

// MoqList_starGenType_InsertBefore_params holds the params of the
// List_starGenType type
type MoqList_starGenType_InsertBefore_params struct {
	V    interface{}
	Mark *list.Element
}

// MoqList_starGenType_InsertBefore_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_InsertBefore_paramsKey struct {
	Params struct {
		V    interface{}
		Mark *list.Element
	}
	Hashes struct {
		V    hash.Hash
		Mark hash.Hash
	}
}

// MoqList_starGenType_InsertBefore_resultsByParams contains the results for a
// given set of parameters for the List_starGenType type
type MoqList_starGenType_InsertBefore_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_InsertBefore_paramsKey]*MoqList_starGenType_InsertBefore_results
}

// MoqList_starGenType_InsertBefore_doFn defines the type of function needed
// when calling AndDo for the List_starGenType type
type MoqList_starGenType_InsertBefore_doFn func(v interface{}, mark *list.Element)

// MoqList_starGenType_InsertBefore_doReturnFn defines the type of function
// needed when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_InsertBefore_doReturnFn func(v interface{}, mark *list.Element) *list.Element

// MoqList_starGenType_InsertBefore_results holds the results of the
// List_starGenType type
type MoqList_starGenType_InsertBefore_results struct {
	Params  MoqList_starGenType_InsertBefore_params
	Results []struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_InsertBefore_doFn
		DoReturnFn MoqList_starGenType_InsertBefore_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_InsertBefore_fnRecorder routes recorded function calls
// to the MoqList_starGenType moq
type MoqList_starGenType_InsertBefore_fnRecorder struct {
	Params    MoqList_starGenType_InsertBefore_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_InsertBefore_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_InsertBefore_anyParams isolates the any params functions
// of the List_starGenType type
type MoqList_starGenType_InsertBefore_anyParams struct {
	Recorder *MoqList_starGenType_InsertBefore_fnRecorder
}

// MoqList_starGenType_InsertAfter_params holds the params of the
// List_starGenType type
type MoqList_starGenType_InsertAfter_params struct {
	V    interface{}
	Mark *list.Element
}

// MoqList_starGenType_InsertAfter_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_InsertAfter_paramsKey struct {
	Params struct {
		V    interface{}
		Mark *list.Element
	}
	Hashes struct {
		V    hash.Hash
		Mark hash.Hash
	}
}

// MoqList_starGenType_InsertAfter_resultsByParams contains the results for a
// given set of parameters for the List_starGenType type
type MoqList_starGenType_InsertAfter_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_InsertAfter_paramsKey]*MoqList_starGenType_InsertAfter_results
}

// MoqList_starGenType_InsertAfter_doFn defines the type of function needed
// when calling AndDo for the List_starGenType type
type MoqList_starGenType_InsertAfter_doFn func(v interface{}, mark *list.Element)

// MoqList_starGenType_InsertAfter_doReturnFn defines the type of function
// needed when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_InsertAfter_doReturnFn func(v interface{}, mark *list.Element) *list.Element

// MoqList_starGenType_InsertAfter_results holds the results of the
// List_starGenType type
type MoqList_starGenType_InsertAfter_results struct {
	Params  MoqList_starGenType_InsertAfter_params
	Results []struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_InsertAfter_doFn
		DoReturnFn MoqList_starGenType_InsertAfter_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_InsertAfter_fnRecorder routes recorded function calls to
// the MoqList_starGenType moq
type MoqList_starGenType_InsertAfter_fnRecorder struct {
	Params    MoqList_starGenType_InsertAfter_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_InsertAfter_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_InsertAfter_anyParams isolates the any params functions
// of the List_starGenType type
type MoqList_starGenType_InsertAfter_anyParams struct {
	Recorder *MoqList_starGenType_InsertAfter_fnRecorder
}

// MoqList_starGenType_MoveToFront_params holds the params of the
// List_starGenType type
type MoqList_starGenType_MoveToFront_params struct{ E *list.Element }

// MoqList_starGenType_MoveToFront_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_MoveToFront_paramsKey struct {
	Params struct{ E *list.Element }
	Hashes struct{ E hash.Hash }
}

// MoqList_starGenType_MoveToFront_resultsByParams contains the results for a
// given set of parameters for the List_starGenType type
type MoqList_starGenType_MoveToFront_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_MoveToFront_paramsKey]*MoqList_starGenType_MoveToFront_results
}

// MoqList_starGenType_MoveToFront_doFn defines the type of function needed
// when calling AndDo for the List_starGenType type
type MoqList_starGenType_MoveToFront_doFn func(e *list.Element)

// MoqList_starGenType_MoveToFront_doReturnFn defines the type of function
// needed when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_MoveToFront_doReturnFn func(e *list.Element)

// MoqList_starGenType_MoveToFront_results holds the results of the
// List_starGenType type
type MoqList_starGenType_MoveToFront_results struct {
	Params  MoqList_starGenType_MoveToFront_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveToFront_doFn
		DoReturnFn MoqList_starGenType_MoveToFront_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_MoveToFront_fnRecorder routes recorded function calls to
// the MoqList_starGenType moq
type MoqList_starGenType_MoveToFront_fnRecorder struct {
	Params    MoqList_starGenType_MoveToFront_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_MoveToFront_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_MoveToFront_anyParams isolates the any params functions
// of the List_starGenType type
type MoqList_starGenType_MoveToFront_anyParams struct {
	Recorder *MoqList_starGenType_MoveToFront_fnRecorder
}

// MoqList_starGenType_MoveToBack_params holds the params of the
// List_starGenType type
type MoqList_starGenType_MoveToBack_params struct{ E *list.Element }

// MoqList_starGenType_MoveToBack_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_MoveToBack_paramsKey struct {
	Params struct{ E *list.Element }
	Hashes struct{ E hash.Hash }
}

// MoqList_starGenType_MoveToBack_resultsByParams contains the results for a
// given set of parameters for the List_starGenType type
type MoqList_starGenType_MoveToBack_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_MoveToBack_paramsKey]*MoqList_starGenType_MoveToBack_results
}

// MoqList_starGenType_MoveToBack_doFn defines the type of function needed when
// calling AndDo for the List_starGenType type
type MoqList_starGenType_MoveToBack_doFn func(e *list.Element)

// MoqList_starGenType_MoveToBack_doReturnFn defines the type of function
// needed when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_MoveToBack_doReturnFn func(e *list.Element)

// MoqList_starGenType_MoveToBack_results holds the results of the
// List_starGenType type
type MoqList_starGenType_MoveToBack_results struct {
	Params  MoqList_starGenType_MoveToBack_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveToBack_doFn
		DoReturnFn MoqList_starGenType_MoveToBack_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_MoveToBack_fnRecorder routes recorded function calls to
// the MoqList_starGenType moq
type MoqList_starGenType_MoveToBack_fnRecorder struct {
	Params    MoqList_starGenType_MoveToBack_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_MoveToBack_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_MoveToBack_anyParams isolates the any params functions
// of the List_starGenType type
type MoqList_starGenType_MoveToBack_anyParams struct {
	Recorder *MoqList_starGenType_MoveToBack_fnRecorder
}

// MoqList_starGenType_MoveBefore_params holds the params of the
// List_starGenType type
type MoqList_starGenType_MoveBefore_params struct{ E, Mark *list.Element }

// MoqList_starGenType_MoveBefore_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_MoveBefore_paramsKey struct {
	Params struct{ E, Mark *list.Element }
	Hashes struct{ E, Mark hash.Hash }
}

// MoqList_starGenType_MoveBefore_resultsByParams contains the results for a
// given set of parameters for the List_starGenType type
type MoqList_starGenType_MoveBefore_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_MoveBefore_paramsKey]*MoqList_starGenType_MoveBefore_results
}

// MoqList_starGenType_MoveBefore_doFn defines the type of function needed when
// calling AndDo for the List_starGenType type
type MoqList_starGenType_MoveBefore_doFn func(e, mark *list.Element)

// MoqList_starGenType_MoveBefore_doReturnFn defines the type of function
// needed when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_MoveBefore_doReturnFn func(e, mark *list.Element)

// MoqList_starGenType_MoveBefore_results holds the results of the
// List_starGenType type
type MoqList_starGenType_MoveBefore_results struct {
	Params  MoqList_starGenType_MoveBefore_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveBefore_doFn
		DoReturnFn MoqList_starGenType_MoveBefore_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_MoveBefore_fnRecorder routes recorded function calls to
// the MoqList_starGenType moq
type MoqList_starGenType_MoveBefore_fnRecorder struct {
	Params    MoqList_starGenType_MoveBefore_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_MoveBefore_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_MoveBefore_anyParams isolates the any params functions
// of the List_starGenType type
type MoqList_starGenType_MoveBefore_anyParams struct {
	Recorder *MoqList_starGenType_MoveBefore_fnRecorder
}

// MoqList_starGenType_MoveAfter_params holds the params of the
// List_starGenType type
type MoqList_starGenType_MoveAfter_params struct{ E, Mark *list.Element }

// MoqList_starGenType_MoveAfter_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_MoveAfter_paramsKey struct {
	Params struct{ E, Mark *list.Element }
	Hashes struct{ E, Mark hash.Hash }
}

// MoqList_starGenType_MoveAfter_resultsByParams contains the results for a
// given set of parameters for the List_starGenType type
type MoqList_starGenType_MoveAfter_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_MoveAfter_paramsKey]*MoqList_starGenType_MoveAfter_results
}

// MoqList_starGenType_MoveAfter_doFn defines the type of function needed when
// calling AndDo for the List_starGenType type
type MoqList_starGenType_MoveAfter_doFn func(e, mark *list.Element)

// MoqList_starGenType_MoveAfter_doReturnFn defines the type of function needed
// when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_MoveAfter_doReturnFn func(e, mark *list.Element)

// MoqList_starGenType_MoveAfter_results holds the results of the
// List_starGenType type
type MoqList_starGenType_MoveAfter_results struct {
	Params  MoqList_starGenType_MoveAfter_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveAfter_doFn
		DoReturnFn MoqList_starGenType_MoveAfter_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_MoveAfter_fnRecorder routes recorded function calls to
// the MoqList_starGenType moq
type MoqList_starGenType_MoveAfter_fnRecorder struct {
	Params    MoqList_starGenType_MoveAfter_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_MoveAfter_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_MoveAfter_anyParams isolates the any params functions of
// the List_starGenType type
type MoqList_starGenType_MoveAfter_anyParams struct {
	Recorder *MoqList_starGenType_MoveAfter_fnRecorder
}

// MoqList_starGenType_PushBackList_params holds the params of the
// List_starGenType type
type MoqList_starGenType_PushBackList_params struct{ Other *list.List }

// MoqList_starGenType_PushBackList_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_PushBackList_paramsKey struct {
	Params struct{ Other *list.List }
	Hashes struct{ Other hash.Hash }
}

// MoqList_starGenType_PushBackList_resultsByParams contains the results for a
// given set of parameters for the List_starGenType type
type MoqList_starGenType_PushBackList_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_PushBackList_paramsKey]*MoqList_starGenType_PushBackList_results
}

// MoqList_starGenType_PushBackList_doFn defines the type of function needed
// when calling AndDo for the List_starGenType type
type MoqList_starGenType_PushBackList_doFn func(other *list.List)

// MoqList_starGenType_PushBackList_doReturnFn defines the type of function
// needed when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_PushBackList_doReturnFn func(other *list.List)

// MoqList_starGenType_PushBackList_results holds the results of the
// List_starGenType type
type MoqList_starGenType_PushBackList_results struct {
	Params  MoqList_starGenType_PushBackList_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushBackList_doFn
		DoReturnFn MoqList_starGenType_PushBackList_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_PushBackList_fnRecorder routes recorded function calls
// to the MoqList_starGenType moq
type MoqList_starGenType_PushBackList_fnRecorder struct {
	Params    MoqList_starGenType_PushBackList_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_PushBackList_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_PushBackList_anyParams isolates the any params functions
// of the List_starGenType type
type MoqList_starGenType_PushBackList_anyParams struct {
	Recorder *MoqList_starGenType_PushBackList_fnRecorder
}

// MoqList_starGenType_PushFrontList_params holds the params of the
// List_starGenType type
type MoqList_starGenType_PushFrontList_params struct{ Other *list.List }

// MoqList_starGenType_PushFrontList_paramsKey holds the map key params of the
// List_starGenType type
type MoqList_starGenType_PushFrontList_paramsKey struct {
	Params struct{ Other *list.List }
	Hashes struct{ Other hash.Hash }
}

// MoqList_starGenType_PushFrontList_resultsByParams contains the results for a
// given set of parameters for the List_starGenType type
type MoqList_starGenType_PushFrontList_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqList_starGenType_PushFrontList_paramsKey]*MoqList_starGenType_PushFrontList_results
}

// MoqList_starGenType_PushFrontList_doFn defines the type of function needed
// when calling AndDo for the List_starGenType type
type MoqList_starGenType_PushFrontList_doFn func(other *list.List)

// MoqList_starGenType_PushFrontList_doReturnFn defines the type of function
// needed when calling DoReturnResults for the List_starGenType type
type MoqList_starGenType_PushFrontList_doReturnFn func(other *list.List)

// MoqList_starGenType_PushFrontList_results holds the results of the
// List_starGenType type
type MoqList_starGenType_PushFrontList_results struct {
	Params  MoqList_starGenType_PushFrontList_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushFrontList_doFn
		DoReturnFn MoqList_starGenType_PushFrontList_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqList_starGenType_PushFrontList_fnRecorder routes recorded function calls
// to the MoqList_starGenType moq
type MoqList_starGenType_PushFrontList_fnRecorder struct {
	Params    MoqList_starGenType_PushFrontList_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqList_starGenType_PushFrontList_results
	Moq       *MoqList_starGenType
}

// MoqList_starGenType_PushFrontList_anyParams isolates the any params
// functions of the List_starGenType type
type MoqList_starGenType_PushFrontList_anyParams struct {
	Recorder *MoqList_starGenType_PushFrontList_fnRecorder
}

// NewMoqList_starGenType creates a new moq of the List_starGenType type
func NewMoqList_starGenType(scene *moq.Scene, config *moq.Config) *MoqList_starGenType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqList_starGenType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqList_starGenType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				Init   struct{}
				Len    struct{}
				Front  struct{}
				Back   struct{}
				Remove struct {
					E moq.ParamIndexing
				}
				PushFront struct {
					V moq.ParamIndexing
				}
				PushBack struct {
					V moq.ParamIndexing
				}
				InsertBefore struct {
					V    moq.ParamIndexing
					Mark moq.ParamIndexing
				}
				InsertAfter struct {
					V    moq.ParamIndexing
					Mark moq.ParamIndexing
				}
				MoveToFront struct {
					E moq.ParamIndexing
				}
				MoveToBack struct {
					E moq.ParamIndexing
				}
				MoveBefore struct {
					E    moq.ParamIndexing
					Mark moq.ParamIndexing
				}
				MoveAfter struct {
					E    moq.ParamIndexing
					Mark moq.ParamIndexing
				}
				PushBackList struct {
					Other moq.ParamIndexing
				}
				PushFrontList struct {
					Other moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			Init   struct{}
			Len    struct{}
			Front  struct{}
			Back   struct{}
			Remove struct {
				E moq.ParamIndexing
			}
			PushFront struct {
				V moq.ParamIndexing
			}
			PushBack struct {
				V moq.ParamIndexing
			}
			InsertBefore struct {
				V    moq.ParamIndexing
				Mark moq.ParamIndexing
			}
			InsertAfter struct {
				V    moq.ParamIndexing
				Mark moq.ParamIndexing
			}
			MoveToFront struct {
				E moq.ParamIndexing
			}
			MoveToBack struct {
				E moq.ParamIndexing
			}
			MoveBefore struct {
				E    moq.ParamIndexing
				Mark moq.ParamIndexing
			}
			MoveAfter struct {
				E    moq.ParamIndexing
				Mark moq.ParamIndexing
			}
			PushBackList struct {
				Other moq.ParamIndexing
			}
			PushFrontList struct {
				Other moq.ParamIndexing
			}
		}{
			Init:  struct{}{},
			Len:   struct{}{},
			Front: struct{}{},
			Back:  struct{}{},
			Remove: struct {
				E moq.ParamIndexing
			}{
				E: moq.ParamIndexByHash,
			},
			PushFront: struct {
				V moq.ParamIndexing
			}{
				V: moq.ParamIndexByHash,
			},
			PushBack: struct {
				V moq.ParamIndexing
			}{
				V: moq.ParamIndexByHash,
			},
			InsertBefore: struct {
				V    moq.ParamIndexing
				Mark moq.ParamIndexing
			}{
				V:    moq.ParamIndexByHash,
				Mark: moq.ParamIndexByHash,
			},
			InsertAfter: struct {
				V    moq.ParamIndexing
				Mark moq.ParamIndexing
			}{
				V:    moq.ParamIndexByHash,
				Mark: moq.ParamIndexByHash,
			},
			MoveToFront: struct {
				E moq.ParamIndexing
			}{
				E: moq.ParamIndexByHash,
			},
			MoveToBack: struct {
				E moq.ParamIndexing
			}{
				E: moq.ParamIndexByHash,
			},
			MoveBefore: struct {
				E    moq.ParamIndexing
				Mark moq.ParamIndexing
			}{
				E:    moq.ParamIndexByHash,
				Mark: moq.ParamIndexByHash,
			},
			MoveAfter: struct {
				E    moq.ParamIndexing
				Mark moq.ParamIndexing
			}{
				E:    moq.ParamIndexByHash,
				Mark: moq.ParamIndexByHash,
			},
			PushBackList: struct {
				Other moq.ParamIndexing
			}{
				Other: moq.ParamIndexByHash,
			},
			PushFrontList: struct {
				Other moq.ParamIndexing
			}{
				Other: moq.ParamIndexByHash,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the List_starGenType type
func (m *MoqList_starGenType) Mock() *MoqList_starGenType_mock { return m.Moq }

func (m *MoqList_starGenType_mock) Init() (result1 *list.List) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_Init_params{}
	var results *MoqList_starGenType_Init_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Init {
		paramsKey := m.Moq.ParamsKey_Init(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Init(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Init(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Init(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqList_starGenType_mock) Len() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_Len_params{}
	var results *MoqList_starGenType_Len_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Len {
		paramsKey := m.Moq.ParamsKey_Len(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Len(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Len(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Len(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqList_starGenType_mock) Front() (result1 *list.Element) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_Front_params{}
	var results *MoqList_starGenType_Front_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Front {
		paramsKey := m.Moq.ParamsKey_Front(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Front(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Front(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Front(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqList_starGenType_mock) Back() (result1 *list.Element) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_Back_params{}
	var results *MoqList_starGenType_Back_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Back {
		paramsKey := m.Moq.ParamsKey_Back(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Back(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Back(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Back(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqList_starGenType_mock) Remove(e *list.Element) (result1 interface{}) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_Remove_params{
		E: e,
	}
	var results *MoqList_starGenType_Remove_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Remove {
		paramsKey := m.Moq.ParamsKey_Remove(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Remove(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Remove(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Remove(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(e)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(e)
	}
	return
}

func (m *MoqList_starGenType_mock) PushFront(v interface{}) (result1 *list.Element) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_PushFront_params{
		V: v,
	}
	var results *MoqList_starGenType_PushFront_results
	for _, resultsByParams := range m.Moq.ResultsByParams_PushFront {
		paramsKey := m.Moq.ParamsKey_PushFront(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_PushFront(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_PushFront(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_PushFront(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(v)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(v)
	}
	return
}

func (m *MoqList_starGenType_mock) PushBack(v interface{}) (result1 *list.Element) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_PushBack_params{
		V: v,
	}
	var results *MoqList_starGenType_PushBack_results
	for _, resultsByParams := range m.Moq.ResultsByParams_PushBack {
		paramsKey := m.Moq.ParamsKey_PushBack(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_PushBack(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_PushBack(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_PushBack(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(v)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(v)
	}
	return
}

func (m *MoqList_starGenType_mock) InsertBefore(v interface{}, mark *list.Element) (result1 *list.Element) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_InsertBefore_params{
		V:    v,
		Mark: mark,
	}
	var results *MoqList_starGenType_InsertBefore_results
	for _, resultsByParams := range m.Moq.ResultsByParams_InsertBefore {
		paramsKey := m.Moq.ParamsKey_InsertBefore(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_InsertBefore(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_InsertBefore(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_InsertBefore(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(v, mark)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(v, mark)
	}
	return
}

func (m *MoqList_starGenType_mock) InsertAfter(v interface{}, mark *list.Element) (result1 *list.Element) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_InsertAfter_params{
		V:    v,
		Mark: mark,
	}
	var results *MoqList_starGenType_InsertAfter_results
	for _, resultsByParams := range m.Moq.ResultsByParams_InsertAfter {
		paramsKey := m.Moq.ParamsKey_InsertAfter(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_InsertAfter(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_InsertAfter(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_InsertAfter(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(v, mark)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(v, mark)
	}
	return
}

func (m *MoqList_starGenType_mock) MoveToFront(e *list.Element) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_MoveToFront_params{
		E: e,
	}
	var results *MoqList_starGenType_MoveToFront_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MoveToFront {
		paramsKey := m.Moq.ParamsKey_MoveToFront(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MoveToFront(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MoveToFront(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MoveToFront(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(e)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(e)
	}
	return
}

func (m *MoqList_starGenType_mock) MoveToBack(e *list.Element) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_MoveToBack_params{
		E: e,
	}
	var results *MoqList_starGenType_MoveToBack_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MoveToBack {
		paramsKey := m.Moq.ParamsKey_MoveToBack(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MoveToBack(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MoveToBack(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MoveToBack(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(e)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(e)
	}
	return
}

func (m *MoqList_starGenType_mock) MoveBefore(e, mark *list.Element) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_MoveBefore_params{
		E:    e,
		Mark: mark,
	}
	var results *MoqList_starGenType_MoveBefore_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MoveBefore {
		paramsKey := m.Moq.ParamsKey_MoveBefore(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MoveBefore(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MoveBefore(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MoveBefore(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(e, mark)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(e, mark)
	}
	return
}

func (m *MoqList_starGenType_mock) MoveAfter(e, mark *list.Element) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_MoveAfter_params{
		E:    e,
		Mark: mark,
	}
	var results *MoqList_starGenType_MoveAfter_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MoveAfter {
		paramsKey := m.Moq.ParamsKey_MoveAfter(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MoveAfter(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MoveAfter(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MoveAfter(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(e, mark)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(e, mark)
	}
	return
}

func (m *MoqList_starGenType_mock) PushBackList(other *list.List) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_PushBackList_params{
		Other: other,
	}
	var results *MoqList_starGenType_PushBackList_results
	for _, resultsByParams := range m.Moq.ResultsByParams_PushBackList {
		paramsKey := m.Moq.ParamsKey_PushBackList(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_PushBackList(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_PushBackList(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_PushBackList(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(other)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(other)
	}
	return
}

func (m *MoqList_starGenType_mock) PushFrontList(other *list.List) {
	m.Moq.Scene.T.Helper()
	params := MoqList_starGenType_PushFrontList_params{
		Other: other,
	}
	var results *MoqList_starGenType_PushFrontList_results
	for _, resultsByParams := range m.Moq.ResultsByParams_PushFrontList {
		paramsKey := m.Moq.ParamsKey_PushFrontList(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_PushFrontList(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_PushFrontList(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_PushFrontList(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(other)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(other)
	}
	return
}

// OnCall returns the recorder implementation of the List_starGenType type
func (m *MoqList_starGenType) OnCall() *MoqList_starGenType_recorder {
	return &MoqList_starGenType_recorder{
		Moq: m,
	}
}

func (m *MoqList_starGenType_recorder) Init() *MoqList_starGenType_Init_fnRecorder {
	return &MoqList_starGenType_Init_fnRecorder{
		Params:   MoqList_starGenType_Init_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_Init_fnRecorder) Any() *MoqList_starGenType_Init_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Init(r.Params))
		return nil
	}
	return &MoqList_starGenType_Init_anyParams{Recorder: r}
}

func (r *MoqList_starGenType_Init_fnRecorder) Seq() *MoqList_starGenType_Init_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Init(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_Init_fnRecorder) NoSeq() *MoqList_starGenType_Init_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Init(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_Init_fnRecorder) ReturnResults(result1 *list.List) *MoqList_starGenType_Init_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.List
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Init_doFn
		DoReturnFn MoqList_starGenType_Init_doReturnFn
	}{
		Values: &struct {
			Result1 *list.List
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_Init_fnRecorder) AndDo(fn MoqList_starGenType_Init_doFn) *MoqList_starGenType_Init_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_Init_fnRecorder) DoReturnResults(fn MoqList_starGenType_Init_doReturnFn) *MoqList_starGenType_Init_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.List
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Init_doFn
		DoReturnFn MoqList_starGenType_Init_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_Init_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_Init_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Init {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_Init_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_Init_paramsKey]*MoqList_starGenType_Init_results{},
		}
		r.Moq.ResultsByParams_Init = append(r.Moq.ResultsByParams_Init, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Init) {
			copy(r.Moq.ResultsByParams_Init[insertAt+1:], r.Moq.ResultsByParams_Init[insertAt:0])
			r.Moq.ResultsByParams_Init[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Init(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_Init_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_Init_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_Init_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *list.List
				}
				Sequence   uint32
				DoFn       MoqList_starGenType_Init_doFn
				DoReturnFn MoqList_starGenType_Init_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_Init(params MoqList_starGenType_Init_params) string {
	return fmt.Sprintf("Init()")
}

func (m *MoqList_starGenType) ParamsKey_Init(params MoqList_starGenType_Init_params, anyParams uint64) MoqList_starGenType_Init_paramsKey {
	m.Scene.T.Helper()
	return MoqList_starGenType_Init_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqList_starGenType_recorder) Len() *MoqList_starGenType_Len_fnRecorder {
	return &MoqList_starGenType_Len_fnRecorder{
		Params:   MoqList_starGenType_Len_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_Len_fnRecorder) Any() *MoqList_starGenType_Len_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	return &MoqList_starGenType_Len_anyParams{Recorder: r}
}

func (r *MoqList_starGenType_Len_fnRecorder) Seq() *MoqList_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_Len_fnRecorder) NoSeq() *MoqList_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Len(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_Len_fnRecorder) ReturnResults(result1 int) *MoqList_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Len_doFn
		DoReturnFn MoqList_starGenType_Len_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_Len_fnRecorder) AndDo(fn MoqList_starGenType_Len_doFn) *MoqList_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_Len_fnRecorder) DoReturnResults(fn MoqList_starGenType_Len_doReturnFn) *MoqList_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Len_doFn
		DoReturnFn MoqList_starGenType_Len_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_Len_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_Len_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Len {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_Len_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_Len_paramsKey]*MoqList_starGenType_Len_results{},
		}
		r.Moq.ResultsByParams_Len = append(r.Moq.ResultsByParams_Len, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Len) {
			copy(r.Moq.ResultsByParams_Len[insertAt+1:], r.Moq.ResultsByParams_Len[insertAt:0])
			r.Moq.ResultsByParams_Len[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Len(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_Len_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_Len_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_Len_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqList_starGenType_Len_doFn
				DoReturnFn MoqList_starGenType_Len_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_Len(params MoqList_starGenType_Len_params) string {
	return fmt.Sprintf("Len()")
}

func (m *MoqList_starGenType) ParamsKey_Len(params MoqList_starGenType_Len_params, anyParams uint64) MoqList_starGenType_Len_paramsKey {
	m.Scene.T.Helper()
	return MoqList_starGenType_Len_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqList_starGenType_recorder) Front() *MoqList_starGenType_Front_fnRecorder {
	return &MoqList_starGenType_Front_fnRecorder{
		Params:   MoqList_starGenType_Front_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_Front_fnRecorder) Any() *MoqList_starGenType_Front_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Front(r.Params))
		return nil
	}
	return &MoqList_starGenType_Front_anyParams{Recorder: r}
}

func (r *MoqList_starGenType_Front_fnRecorder) Seq() *MoqList_starGenType_Front_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Front(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_Front_fnRecorder) NoSeq() *MoqList_starGenType_Front_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Front(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_Front_fnRecorder) ReturnResults(result1 *list.Element) *MoqList_starGenType_Front_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Front_doFn
		DoReturnFn MoqList_starGenType_Front_doReturnFn
	}{
		Values: &struct {
			Result1 *list.Element
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_Front_fnRecorder) AndDo(fn MoqList_starGenType_Front_doFn) *MoqList_starGenType_Front_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_Front_fnRecorder) DoReturnResults(fn MoqList_starGenType_Front_doReturnFn) *MoqList_starGenType_Front_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Front_doFn
		DoReturnFn MoqList_starGenType_Front_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_Front_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_Front_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Front {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_Front_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_Front_paramsKey]*MoqList_starGenType_Front_results{},
		}
		r.Moq.ResultsByParams_Front = append(r.Moq.ResultsByParams_Front, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Front) {
			copy(r.Moq.ResultsByParams_Front[insertAt+1:], r.Moq.ResultsByParams_Front[insertAt:0])
			r.Moq.ResultsByParams_Front[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Front(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_Front_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_Front_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_Front_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *list.Element
				}
				Sequence   uint32
				DoFn       MoqList_starGenType_Front_doFn
				DoReturnFn MoqList_starGenType_Front_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_Front(params MoqList_starGenType_Front_params) string {
	return fmt.Sprintf("Front()")
}

func (m *MoqList_starGenType) ParamsKey_Front(params MoqList_starGenType_Front_params, anyParams uint64) MoqList_starGenType_Front_paramsKey {
	m.Scene.T.Helper()
	return MoqList_starGenType_Front_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqList_starGenType_recorder) Back() *MoqList_starGenType_Back_fnRecorder {
	return &MoqList_starGenType_Back_fnRecorder{
		Params:   MoqList_starGenType_Back_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_Back_fnRecorder) Any() *MoqList_starGenType_Back_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Back(r.Params))
		return nil
	}
	return &MoqList_starGenType_Back_anyParams{Recorder: r}
}

func (r *MoqList_starGenType_Back_fnRecorder) Seq() *MoqList_starGenType_Back_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Back(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_Back_fnRecorder) NoSeq() *MoqList_starGenType_Back_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Back(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_Back_fnRecorder) ReturnResults(result1 *list.Element) *MoqList_starGenType_Back_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Back_doFn
		DoReturnFn MoqList_starGenType_Back_doReturnFn
	}{
		Values: &struct {
			Result1 *list.Element
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_Back_fnRecorder) AndDo(fn MoqList_starGenType_Back_doFn) *MoqList_starGenType_Back_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_Back_fnRecorder) DoReturnResults(fn MoqList_starGenType_Back_doReturnFn) *MoqList_starGenType_Back_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Back_doFn
		DoReturnFn MoqList_starGenType_Back_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_Back_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_Back_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Back {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_Back_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_Back_paramsKey]*MoqList_starGenType_Back_results{},
		}
		r.Moq.ResultsByParams_Back = append(r.Moq.ResultsByParams_Back, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Back) {
			copy(r.Moq.ResultsByParams_Back[insertAt+1:], r.Moq.ResultsByParams_Back[insertAt:0])
			r.Moq.ResultsByParams_Back[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Back(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_Back_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_Back_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_Back_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *list.Element
				}
				Sequence   uint32
				DoFn       MoqList_starGenType_Back_doFn
				DoReturnFn MoqList_starGenType_Back_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_Back(params MoqList_starGenType_Back_params) string {
	return fmt.Sprintf("Back()")
}

func (m *MoqList_starGenType) ParamsKey_Back(params MoqList_starGenType_Back_params, anyParams uint64) MoqList_starGenType_Back_paramsKey {
	m.Scene.T.Helper()
	return MoqList_starGenType_Back_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqList_starGenType_recorder) Remove(e *list.Element) *MoqList_starGenType_Remove_fnRecorder {
	return &MoqList_starGenType_Remove_fnRecorder{
		Params: MoqList_starGenType_Remove_params{
			E: e,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_Remove_fnRecorder) Any() *MoqList_starGenType_Remove_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Remove(r.Params))
		return nil
	}
	return &MoqList_starGenType_Remove_anyParams{Recorder: r}
}

func (a *MoqList_starGenType_Remove_anyParams) E() *MoqList_starGenType_Remove_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqList_starGenType_Remove_fnRecorder) Seq() *MoqList_starGenType_Remove_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Remove(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_Remove_fnRecorder) NoSeq() *MoqList_starGenType_Remove_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Remove(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_Remove_fnRecorder) ReturnResults(result1 interface{}) *MoqList_starGenType_Remove_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 interface{}
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Remove_doFn
		DoReturnFn MoqList_starGenType_Remove_doReturnFn
	}{
		Values: &struct {
			Result1 interface{}
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_Remove_fnRecorder) AndDo(fn MoqList_starGenType_Remove_doFn) *MoqList_starGenType_Remove_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_Remove_fnRecorder) DoReturnResults(fn MoqList_starGenType_Remove_doReturnFn) *MoqList_starGenType_Remove_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 interface{}
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_Remove_doFn
		DoReturnFn MoqList_starGenType_Remove_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_Remove_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_Remove_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Remove {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_Remove_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_Remove_paramsKey]*MoqList_starGenType_Remove_results{},
		}
		r.Moq.ResultsByParams_Remove = append(r.Moq.ResultsByParams_Remove, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Remove) {
			copy(r.Moq.ResultsByParams_Remove[insertAt+1:], r.Moq.ResultsByParams_Remove[insertAt:0])
			r.Moq.ResultsByParams_Remove[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Remove(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_Remove_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_Remove_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_Remove_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 interface{}
				}
				Sequence   uint32
				DoFn       MoqList_starGenType_Remove_doFn
				DoReturnFn MoqList_starGenType_Remove_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_Remove(params MoqList_starGenType_Remove_params) string {
	return fmt.Sprintf("Remove(%#v)", params.E)
}

func (m *MoqList_starGenType) ParamsKey_Remove(params MoqList_starGenType_Remove_params, anyParams uint64) MoqList_starGenType_Remove_paramsKey {
	m.Scene.T.Helper()
	var eUsed *list.Element
	var eUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Remove.E == moq.ParamIndexByValue {
			eUsed = params.E
		} else {
			eUsedHash = hash.DeepHash(params.E)
		}
	}
	return MoqList_starGenType_Remove_paramsKey{
		Params: struct{ E *list.Element }{
			E: eUsed,
		},
		Hashes: struct{ E hash.Hash }{
			E: eUsedHash,
		},
	}
}

func (m *MoqList_starGenType_recorder) PushFront(v interface{}) *MoqList_starGenType_PushFront_fnRecorder {
	return &MoqList_starGenType_PushFront_fnRecorder{
		Params: MoqList_starGenType_PushFront_params{
			V: v,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_PushFront_fnRecorder) Any() *MoqList_starGenType_PushFront_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushFront(r.Params))
		return nil
	}
	return &MoqList_starGenType_PushFront_anyParams{Recorder: r}
}

func (a *MoqList_starGenType_PushFront_anyParams) V() *MoqList_starGenType_PushFront_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqList_starGenType_PushFront_fnRecorder) Seq() *MoqList_starGenType_PushFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushFront(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_PushFront_fnRecorder) NoSeq() *MoqList_starGenType_PushFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushFront(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_PushFront_fnRecorder) ReturnResults(result1 *list.Element) *MoqList_starGenType_PushFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushFront_doFn
		DoReturnFn MoqList_starGenType_PushFront_doReturnFn
	}{
		Values: &struct {
			Result1 *list.Element
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_PushFront_fnRecorder) AndDo(fn MoqList_starGenType_PushFront_doFn) *MoqList_starGenType_PushFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_PushFront_fnRecorder) DoReturnResults(fn MoqList_starGenType_PushFront_doReturnFn) *MoqList_starGenType_PushFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushFront_doFn
		DoReturnFn MoqList_starGenType_PushFront_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_PushFront_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_PushFront_resultsByParams
	for n, res := range r.Moq.ResultsByParams_PushFront {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_PushFront_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_PushFront_paramsKey]*MoqList_starGenType_PushFront_results{},
		}
		r.Moq.ResultsByParams_PushFront = append(r.Moq.ResultsByParams_PushFront, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_PushFront) {
			copy(r.Moq.ResultsByParams_PushFront[insertAt+1:], r.Moq.ResultsByParams_PushFront[insertAt:0])
			r.Moq.ResultsByParams_PushFront[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_PushFront(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_PushFront_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_PushFront_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_PushFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *list.Element
				}
				Sequence   uint32
				DoFn       MoqList_starGenType_PushFront_doFn
				DoReturnFn MoqList_starGenType_PushFront_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_PushFront(params MoqList_starGenType_PushFront_params) string {
	return fmt.Sprintf("PushFront(%#v)", params.V)
}

func (m *MoqList_starGenType) ParamsKey_PushFront(params MoqList_starGenType_PushFront_params, anyParams uint64) MoqList_starGenType_PushFront_paramsKey {
	m.Scene.T.Helper()
	var vUsed interface{}
	var vUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.PushFront.V == moq.ParamIndexByValue {
			vUsed = params.V
		} else {
			vUsedHash = hash.DeepHash(params.V)
		}
	}
	return MoqList_starGenType_PushFront_paramsKey{
		Params: struct{ V interface{} }{
			V: vUsed,
		},
		Hashes: struct{ V hash.Hash }{
			V: vUsedHash,
		},
	}
}

func (m *MoqList_starGenType_recorder) PushBack(v interface{}) *MoqList_starGenType_PushBack_fnRecorder {
	return &MoqList_starGenType_PushBack_fnRecorder{
		Params: MoqList_starGenType_PushBack_params{
			V: v,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_PushBack_fnRecorder) Any() *MoqList_starGenType_PushBack_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushBack(r.Params))
		return nil
	}
	return &MoqList_starGenType_PushBack_anyParams{Recorder: r}
}

func (a *MoqList_starGenType_PushBack_anyParams) V() *MoqList_starGenType_PushBack_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqList_starGenType_PushBack_fnRecorder) Seq() *MoqList_starGenType_PushBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushBack(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_PushBack_fnRecorder) NoSeq() *MoqList_starGenType_PushBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushBack(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_PushBack_fnRecorder) ReturnResults(result1 *list.Element) *MoqList_starGenType_PushBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushBack_doFn
		DoReturnFn MoqList_starGenType_PushBack_doReturnFn
	}{
		Values: &struct {
			Result1 *list.Element
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_PushBack_fnRecorder) AndDo(fn MoqList_starGenType_PushBack_doFn) *MoqList_starGenType_PushBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_PushBack_fnRecorder) DoReturnResults(fn MoqList_starGenType_PushBack_doReturnFn) *MoqList_starGenType_PushBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushBack_doFn
		DoReturnFn MoqList_starGenType_PushBack_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_PushBack_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_PushBack_resultsByParams
	for n, res := range r.Moq.ResultsByParams_PushBack {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_PushBack_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_PushBack_paramsKey]*MoqList_starGenType_PushBack_results{},
		}
		r.Moq.ResultsByParams_PushBack = append(r.Moq.ResultsByParams_PushBack, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_PushBack) {
			copy(r.Moq.ResultsByParams_PushBack[insertAt+1:], r.Moq.ResultsByParams_PushBack[insertAt:0])
			r.Moq.ResultsByParams_PushBack[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_PushBack(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_PushBack_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_PushBack_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_PushBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *list.Element
				}
				Sequence   uint32
				DoFn       MoqList_starGenType_PushBack_doFn
				DoReturnFn MoqList_starGenType_PushBack_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_PushBack(params MoqList_starGenType_PushBack_params) string {
	return fmt.Sprintf("PushBack(%#v)", params.V)
}

func (m *MoqList_starGenType) ParamsKey_PushBack(params MoqList_starGenType_PushBack_params, anyParams uint64) MoqList_starGenType_PushBack_paramsKey {
	m.Scene.T.Helper()
	var vUsed interface{}
	var vUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.PushBack.V == moq.ParamIndexByValue {
			vUsed = params.V
		} else {
			vUsedHash = hash.DeepHash(params.V)
		}
	}
	return MoqList_starGenType_PushBack_paramsKey{
		Params: struct{ V interface{} }{
			V: vUsed,
		},
		Hashes: struct{ V hash.Hash }{
			V: vUsedHash,
		},
	}
}

func (m *MoqList_starGenType_recorder) InsertBefore(v interface{}, mark *list.Element) *MoqList_starGenType_InsertBefore_fnRecorder {
	return &MoqList_starGenType_InsertBefore_fnRecorder{
		Params: MoqList_starGenType_InsertBefore_params{
			V:    v,
			Mark: mark,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_InsertBefore_fnRecorder) Any() *MoqList_starGenType_InsertBefore_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_InsertBefore(r.Params))
		return nil
	}
	return &MoqList_starGenType_InsertBefore_anyParams{Recorder: r}
}

func (a *MoqList_starGenType_InsertBefore_anyParams) V() *MoqList_starGenType_InsertBefore_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqList_starGenType_InsertBefore_anyParams) Mark() *MoqList_starGenType_InsertBefore_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqList_starGenType_InsertBefore_fnRecorder) Seq() *MoqList_starGenType_InsertBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_InsertBefore(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_InsertBefore_fnRecorder) NoSeq() *MoqList_starGenType_InsertBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_InsertBefore(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_InsertBefore_fnRecorder) ReturnResults(result1 *list.Element) *MoqList_starGenType_InsertBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_InsertBefore_doFn
		DoReturnFn MoqList_starGenType_InsertBefore_doReturnFn
	}{
		Values: &struct {
			Result1 *list.Element
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_InsertBefore_fnRecorder) AndDo(fn MoqList_starGenType_InsertBefore_doFn) *MoqList_starGenType_InsertBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_InsertBefore_fnRecorder) DoReturnResults(fn MoqList_starGenType_InsertBefore_doReturnFn) *MoqList_starGenType_InsertBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_InsertBefore_doFn
		DoReturnFn MoqList_starGenType_InsertBefore_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_InsertBefore_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_InsertBefore_resultsByParams
	for n, res := range r.Moq.ResultsByParams_InsertBefore {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_InsertBefore_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_InsertBefore_paramsKey]*MoqList_starGenType_InsertBefore_results{},
		}
		r.Moq.ResultsByParams_InsertBefore = append(r.Moq.ResultsByParams_InsertBefore, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_InsertBefore) {
			copy(r.Moq.ResultsByParams_InsertBefore[insertAt+1:], r.Moq.ResultsByParams_InsertBefore[insertAt:0])
			r.Moq.ResultsByParams_InsertBefore[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_InsertBefore(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_InsertBefore_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_InsertBefore_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_InsertBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *list.Element
				}
				Sequence   uint32
				DoFn       MoqList_starGenType_InsertBefore_doFn
				DoReturnFn MoqList_starGenType_InsertBefore_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_InsertBefore(params MoqList_starGenType_InsertBefore_params) string {
	return fmt.Sprintf("InsertBefore(%#v, %#v)", params.V, params.Mark)
}

func (m *MoqList_starGenType) ParamsKey_InsertBefore(params MoqList_starGenType_InsertBefore_params, anyParams uint64) MoqList_starGenType_InsertBefore_paramsKey {
	m.Scene.T.Helper()
	var vUsed interface{}
	var vUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.InsertBefore.V == moq.ParamIndexByValue {
			vUsed = params.V
		} else {
			vUsedHash = hash.DeepHash(params.V)
		}
	}
	var markUsed *list.Element
	var markUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.InsertBefore.Mark == moq.ParamIndexByValue {
			markUsed = params.Mark
		} else {
			markUsedHash = hash.DeepHash(params.Mark)
		}
	}
	return MoqList_starGenType_InsertBefore_paramsKey{
		Params: struct {
			V    interface{}
			Mark *list.Element
		}{
			V:    vUsed,
			Mark: markUsed,
		},
		Hashes: struct {
			V    hash.Hash
			Mark hash.Hash
		}{
			V:    vUsedHash,
			Mark: markUsedHash,
		},
	}
}

func (m *MoqList_starGenType_recorder) InsertAfter(v interface{}, mark *list.Element) *MoqList_starGenType_InsertAfter_fnRecorder {
	return &MoqList_starGenType_InsertAfter_fnRecorder{
		Params: MoqList_starGenType_InsertAfter_params{
			V:    v,
			Mark: mark,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_InsertAfter_fnRecorder) Any() *MoqList_starGenType_InsertAfter_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_InsertAfter(r.Params))
		return nil
	}
	return &MoqList_starGenType_InsertAfter_anyParams{Recorder: r}
}

func (a *MoqList_starGenType_InsertAfter_anyParams) V() *MoqList_starGenType_InsertAfter_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqList_starGenType_InsertAfter_anyParams) Mark() *MoqList_starGenType_InsertAfter_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqList_starGenType_InsertAfter_fnRecorder) Seq() *MoqList_starGenType_InsertAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_InsertAfter(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_InsertAfter_fnRecorder) NoSeq() *MoqList_starGenType_InsertAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_InsertAfter(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_InsertAfter_fnRecorder) ReturnResults(result1 *list.Element) *MoqList_starGenType_InsertAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_InsertAfter_doFn
		DoReturnFn MoqList_starGenType_InsertAfter_doReturnFn
	}{
		Values: &struct {
			Result1 *list.Element
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_InsertAfter_fnRecorder) AndDo(fn MoqList_starGenType_InsertAfter_doFn) *MoqList_starGenType_InsertAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_InsertAfter_fnRecorder) DoReturnResults(fn MoqList_starGenType_InsertAfter_doReturnFn) *MoqList_starGenType_InsertAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *list.Element
		}
		Sequence   uint32
		DoFn       MoqList_starGenType_InsertAfter_doFn
		DoReturnFn MoqList_starGenType_InsertAfter_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_InsertAfter_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_InsertAfter_resultsByParams
	for n, res := range r.Moq.ResultsByParams_InsertAfter {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_InsertAfter_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_InsertAfter_paramsKey]*MoqList_starGenType_InsertAfter_results{},
		}
		r.Moq.ResultsByParams_InsertAfter = append(r.Moq.ResultsByParams_InsertAfter, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_InsertAfter) {
			copy(r.Moq.ResultsByParams_InsertAfter[insertAt+1:], r.Moq.ResultsByParams_InsertAfter[insertAt:0])
			r.Moq.ResultsByParams_InsertAfter[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_InsertAfter(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_InsertAfter_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_InsertAfter_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_InsertAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *list.Element
				}
				Sequence   uint32
				DoFn       MoqList_starGenType_InsertAfter_doFn
				DoReturnFn MoqList_starGenType_InsertAfter_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_InsertAfter(params MoqList_starGenType_InsertAfter_params) string {
	return fmt.Sprintf("InsertAfter(%#v, %#v)", params.V, params.Mark)
}

func (m *MoqList_starGenType) ParamsKey_InsertAfter(params MoqList_starGenType_InsertAfter_params, anyParams uint64) MoqList_starGenType_InsertAfter_paramsKey {
	m.Scene.T.Helper()
	var vUsed interface{}
	var vUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.InsertAfter.V == moq.ParamIndexByValue {
			vUsed = params.V
		} else {
			vUsedHash = hash.DeepHash(params.V)
		}
	}
	var markUsed *list.Element
	var markUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.InsertAfter.Mark == moq.ParamIndexByValue {
			markUsed = params.Mark
		} else {
			markUsedHash = hash.DeepHash(params.Mark)
		}
	}
	return MoqList_starGenType_InsertAfter_paramsKey{
		Params: struct {
			V    interface{}
			Mark *list.Element
		}{
			V:    vUsed,
			Mark: markUsed,
		},
		Hashes: struct {
			V    hash.Hash
			Mark hash.Hash
		}{
			V:    vUsedHash,
			Mark: markUsedHash,
		},
	}
}

func (m *MoqList_starGenType_recorder) MoveToFront(e *list.Element) *MoqList_starGenType_MoveToFront_fnRecorder {
	return &MoqList_starGenType_MoveToFront_fnRecorder{
		Params: MoqList_starGenType_MoveToFront_params{
			E: e,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_MoveToFront_fnRecorder) Any() *MoqList_starGenType_MoveToFront_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveToFront(r.Params))
		return nil
	}
	return &MoqList_starGenType_MoveToFront_anyParams{Recorder: r}
}

func (a *MoqList_starGenType_MoveToFront_anyParams) E() *MoqList_starGenType_MoveToFront_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqList_starGenType_MoveToFront_fnRecorder) Seq() *MoqList_starGenType_MoveToFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveToFront(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_MoveToFront_fnRecorder) NoSeq() *MoqList_starGenType_MoveToFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveToFront(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_MoveToFront_fnRecorder) ReturnResults() *MoqList_starGenType_MoveToFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveToFront_doFn
		DoReturnFn MoqList_starGenType_MoveToFront_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_MoveToFront_fnRecorder) AndDo(fn MoqList_starGenType_MoveToFront_doFn) *MoqList_starGenType_MoveToFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_MoveToFront_fnRecorder) DoReturnResults(fn MoqList_starGenType_MoveToFront_doReturnFn) *MoqList_starGenType_MoveToFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveToFront_doFn
		DoReturnFn MoqList_starGenType_MoveToFront_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_MoveToFront_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_MoveToFront_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MoveToFront {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_MoveToFront_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_MoveToFront_paramsKey]*MoqList_starGenType_MoveToFront_results{},
		}
		r.Moq.ResultsByParams_MoveToFront = append(r.Moq.ResultsByParams_MoveToFront, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MoveToFront) {
			copy(r.Moq.ResultsByParams_MoveToFront[insertAt+1:], r.Moq.ResultsByParams_MoveToFront[insertAt:0])
			r.Moq.ResultsByParams_MoveToFront[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MoveToFront(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_MoveToFront_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_MoveToFront_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_MoveToFront_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqList_starGenType_MoveToFront_doFn
				DoReturnFn MoqList_starGenType_MoveToFront_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_MoveToFront(params MoqList_starGenType_MoveToFront_params) string {
	return fmt.Sprintf("MoveToFront(%#v)", params.E)
}

func (m *MoqList_starGenType) ParamsKey_MoveToFront(params MoqList_starGenType_MoveToFront_params, anyParams uint64) MoqList_starGenType_MoveToFront_paramsKey {
	m.Scene.T.Helper()
	var eUsed *list.Element
	var eUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MoveToFront.E == moq.ParamIndexByValue {
			eUsed = params.E
		} else {
			eUsedHash = hash.DeepHash(params.E)
		}
	}
	return MoqList_starGenType_MoveToFront_paramsKey{
		Params: struct{ E *list.Element }{
			E: eUsed,
		},
		Hashes: struct{ E hash.Hash }{
			E: eUsedHash,
		},
	}
}

func (m *MoqList_starGenType_recorder) MoveToBack(e *list.Element) *MoqList_starGenType_MoveToBack_fnRecorder {
	return &MoqList_starGenType_MoveToBack_fnRecorder{
		Params: MoqList_starGenType_MoveToBack_params{
			E: e,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_MoveToBack_fnRecorder) Any() *MoqList_starGenType_MoveToBack_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveToBack(r.Params))
		return nil
	}
	return &MoqList_starGenType_MoveToBack_anyParams{Recorder: r}
}

func (a *MoqList_starGenType_MoveToBack_anyParams) E() *MoqList_starGenType_MoveToBack_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqList_starGenType_MoveToBack_fnRecorder) Seq() *MoqList_starGenType_MoveToBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveToBack(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_MoveToBack_fnRecorder) NoSeq() *MoqList_starGenType_MoveToBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveToBack(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_MoveToBack_fnRecorder) ReturnResults() *MoqList_starGenType_MoveToBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveToBack_doFn
		DoReturnFn MoqList_starGenType_MoveToBack_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_MoveToBack_fnRecorder) AndDo(fn MoqList_starGenType_MoveToBack_doFn) *MoqList_starGenType_MoveToBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_MoveToBack_fnRecorder) DoReturnResults(fn MoqList_starGenType_MoveToBack_doReturnFn) *MoqList_starGenType_MoveToBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveToBack_doFn
		DoReturnFn MoqList_starGenType_MoveToBack_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_MoveToBack_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_MoveToBack_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MoveToBack {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_MoveToBack_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_MoveToBack_paramsKey]*MoqList_starGenType_MoveToBack_results{},
		}
		r.Moq.ResultsByParams_MoveToBack = append(r.Moq.ResultsByParams_MoveToBack, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MoveToBack) {
			copy(r.Moq.ResultsByParams_MoveToBack[insertAt+1:], r.Moq.ResultsByParams_MoveToBack[insertAt:0])
			r.Moq.ResultsByParams_MoveToBack[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MoveToBack(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_MoveToBack_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_MoveToBack_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_MoveToBack_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqList_starGenType_MoveToBack_doFn
				DoReturnFn MoqList_starGenType_MoveToBack_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_MoveToBack(params MoqList_starGenType_MoveToBack_params) string {
	return fmt.Sprintf("MoveToBack(%#v)", params.E)
}

func (m *MoqList_starGenType) ParamsKey_MoveToBack(params MoqList_starGenType_MoveToBack_params, anyParams uint64) MoqList_starGenType_MoveToBack_paramsKey {
	m.Scene.T.Helper()
	var eUsed *list.Element
	var eUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MoveToBack.E == moq.ParamIndexByValue {
			eUsed = params.E
		} else {
			eUsedHash = hash.DeepHash(params.E)
		}
	}
	return MoqList_starGenType_MoveToBack_paramsKey{
		Params: struct{ E *list.Element }{
			E: eUsed,
		},
		Hashes: struct{ E hash.Hash }{
			E: eUsedHash,
		},
	}
}

func (m *MoqList_starGenType_recorder) MoveBefore(e, mark *list.Element) *MoqList_starGenType_MoveBefore_fnRecorder {
	return &MoqList_starGenType_MoveBefore_fnRecorder{
		Params: MoqList_starGenType_MoveBefore_params{
			E:    e,
			Mark: mark,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_MoveBefore_fnRecorder) Any() *MoqList_starGenType_MoveBefore_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveBefore(r.Params))
		return nil
	}
	return &MoqList_starGenType_MoveBefore_anyParams{Recorder: r}
}

func (a *MoqList_starGenType_MoveBefore_anyParams) E() *MoqList_starGenType_MoveBefore_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqList_starGenType_MoveBefore_anyParams) Mark() *MoqList_starGenType_MoveBefore_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqList_starGenType_MoveBefore_fnRecorder) Seq() *MoqList_starGenType_MoveBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveBefore(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_MoveBefore_fnRecorder) NoSeq() *MoqList_starGenType_MoveBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveBefore(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_MoveBefore_fnRecorder) ReturnResults() *MoqList_starGenType_MoveBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveBefore_doFn
		DoReturnFn MoqList_starGenType_MoveBefore_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_MoveBefore_fnRecorder) AndDo(fn MoqList_starGenType_MoveBefore_doFn) *MoqList_starGenType_MoveBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_MoveBefore_fnRecorder) DoReturnResults(fn MoqList_starGenType_MoveBefore_doReturnFn) *MoqList_starGenType_MoveBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveBefore_doFn
		DoReturnFn MoqList_starGenType_MoveBefore_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_MoveBefore_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_MoveBefore_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MoveBefore {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_MoveBefore_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_MoveBefore_paramsKey]*MoqList_starGenType_MoveBefore_results{},
		}
		r.Moq.ResultsByParams_MoveBefore = append(r.Moq.ResultsByParams_MoveBefore, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MoveBefore) {
			copy(r.Moq.ResultsByParams_MoveBefore[insertAt+1:], r.Moq.ResultsByParams_MoveBefore[insertAt:0])
			r.Moq.ResultsByParams_MoveBefore[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MoveBefore(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_MoveBefore_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_MoveBefore_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_MoveBefore_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqList_starGenType_MoveBefore_doFn
				DoReturnFn MoqList_starGenType_MoveBefore_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_MoveBefore(params MoqList_starGenType_MoveBefore_params) string {
	return fmt.Sprintf("MoveBefore(%#v, %#v)", params.E, params.Mark)
}

func (m *MoqList_starGenType) ParamsKey_MoveBefore(params MoqList_starGenType_MoveBefore_params, anyParams uint64) MoqList_starGenType_MoveBefore_paramsKey {
	m.Scene.T.Helper()
	var eUsed *list.Element
	var eUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MoveBefore.E == moq.ParamIndexByValue {
			eUsed = params.E
		} else {
			eUsedHash = hash.DeepHash(params.E)
		}
	}
	var markUsed *list.Element
	var markUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.MoveBefore.Mark == moq.ParamIndexByValue {
			markUsed = params.Mark
		} else {
			markUsedHash = hash.DeepHash(params.Mark)
		}
	}
	return MoqList_starGenType_MoveBefore_paramsKey{
		Params: struct{ E, Mark *list.Element }{
			E:    eUsed,
			Mark: markUsed,
		},
		Hashes: struct{ E, Mark hash.Hash }{
			E:    eUsedHash,
			Mark: markUsedHash,
		},
	}
}

func (m *MoqList_starGenType_recorder) MoveAfter(e, mark *list.Element) *MoqList_starGenType_MoveAfter_fnRecorder {
	return &MoqList_starGenType_MoveAfter_fnRecorder{
		Params: MoqList_starGenType_MoveAfter_params{
			E:    e,
			Mark: mark,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_MoveAfter_fnRecorder) Any() *MoqList_starGenType_MoveAfter_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveAfter(r.Params))
		return nil
	}
	return &MoqList_starGenType_MoveAfter_anyParams{Recorder: r}
}

func (a *MoqList_starGenType_MoveAfter_anyParams) E() *MoqList_starGenType_MoveAfter_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqList_starGenType_MoveAfter_anyParams) Mark() *MoqList_starGenType_MoveAfter_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqList_starGenType_MoveAfter_fnRecorder) Seq() *MoqList_starGenType_MoveAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveAfter(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_MoveAfter_fnRecorder) NoSeq() *MoqList_starGenType_MoveAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MoveAfter(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_MoveAfter_fnRecorder) ReturnResults() *MoqList_starGenType_MoveAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveAfter_doFn
		DoReturnFn MoqList_starGenType_MoveAfter_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_MoveAfter_fnRecorder) AndDo(fn MoqList_starGenType_MoveAfter_doFn) *MoqList_starGenType_MoveAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_MoveAfter_fnRecorder) DoReturnResults(fn MoqList_starGenType_MoveAfter_doReturnFn) *MoqList_starGenType_MoveAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_MoveAfter_doFn
		DoReturnFn MoqList_starGenType_MoveAfter_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_MoveAfter_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_MoveAfter_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MoveAfter {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_MoveAfter_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_MoveAfter_paramsKey]*MoqList_starGenType_MoveAfter_results{},
		}
		r.Moq.ResultsByParams_MoveAfter = append(r.Moq.ResultsByParams_MoveAfter, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MoveAfter) {
			copy(r.Moq.ResultsByParams_MoveAfter[insertAt+1:], r.Moq.ResultsByParams_MoveAfter[insertAt:0])
			r.Moq.ResultsByParams_MoveAfter[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MoveAfter(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_MoveAfter_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_MoveAfter_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_MoveAfter_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqList_starGenType_MoveAfter_doFn
				DoReturnFn MoqList_starGenType_MoveAfter_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_MoveAfter(params MoqList_starGenType_MoveAfter_params) string {
	return fmt.Sprintf("MoveAfter(%#v, %#v)", params.E, params.Mark)
}

func (m *MoqList_starGenType) ParamsKey_MoveAfter(params MoqList_starGenType_MoveAfter_params, anyParams uint64) MoqList_starGenType_MoveAfter_paramsKey {
	m.Scene.T.Helper()
	var eUsed *list.Element
	var eUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.MoveAfter.E == moq.ParamIndexByValue {
			eUsed = params.E
		} else {
			eUsedHash = hash.DeepHash(params.E)
		}
	}
	var markUsed *list.Element
	var markUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.MoveAfter.Mark == moq.ParamIndexByValue {
			markUsed = params.Mark
		} else {
			markUsedHash = hash.DeepHash(params.Mark)
		}
	}
	return MoqList_starGenType_MoveAfter_paramsKey{
		Params: struct{ E, Mark *list.Element }{
			E:    eUsed,
			Mark: markUsed,
		},
		Hashes: struct{ E, Mark hash.Hash }{
			E:    eUsedHash,
			Mark: markUsedHash,
		},
	}
}

func (m *MoqList_starGenType_recorder) PushBackList(other *list.List) *MoqList_starGenType_PushBackList_fnRecorder {
	return &MoqList_starGenType_PushBackList_fnRecorder{
		Params: MoqList_starGenType_PushBackList_params{
			Other: other,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_PushBackList_fnRecorder) Any() *MoqList_starGenType_PushBackList_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushBackList(r.Params))
		return nil
	}
	return &MoqList_starGenType_PushBackList_anyParams{Recorder: r}
}

func (a *MoqList_starGenType_PushBackList_anyParams) Other() *MoqList_starGenType_PushBackList_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqList_starGenType_PushBackList_fnRecorder) Seq() *MoqList_starGenType_PushBackList_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushBackList(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_PushBackList_fnRecorder) NoSeq() *MoqList_starGenType_PushBackList_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushBackList(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_PushBackList_fnRecorder) ReturnResults() *MoqList_starGenType_PushBackList_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushBackList_doFn
		DoReturnFn MoqList_starGenType_PushBackList_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_PushBackList_fnRecorder) AndDo(fn MoqList_starGenType_PushBackList_doFn) *MoqList_starGenType_PushBackList_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_PushBackList_fnRecorder) DoReturnResults(fn MoqList_starGenType_PushBackList_doReturnFn) *MoqList_starGenType_PushBackList_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushBackList_doFn
		DoReturnFn MoqList_starGenType_PushBackList_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_PushBackList_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_PushBackList_resultsByParams
	for n, res := range r.Moq.ResultsByParams_PushBackList {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_PushBackList_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_PushBackList_paramsKey]*MoqList_starGenType_PushBackList_results{},
		}
		r.Moq.ResultsByParams_PushBackList = append(r.Moq.ResultsByParams_PushBackList, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_PushBackList) {
			copy(r.Moq.ResultsByParams_PushBackList[insertAt+1:], r.Moq.ResultsByParams_PushBackList[insertAt:0])
			r.Moq.ResultsByParams_PushBackList[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_PushBackList(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_PushBackList_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_PushBackList_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_PushBackList_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqList_starGenType_PushBackList_doFn
				DoReturnFn MoqList_starGenType_PushBackList_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_PushBackList(params MoqList_starGenType_PushBackList_params) string {
	return fmt.Sprintf("PushBackList(%#v)", params.Other)
}

func (m *MoqList_starGenType) ParamsKey_PushBackList(params MoqList_starGenType_PushBackList_params, anyParams uint64) MoqList_starGenType_PushBackList_paramsKey {
	m.Scene.T.Helper()
	var otherUsed *list.List
	var otherUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.PushBackList.Other == moq.ParamIndexByValue {
			otherUsed = params.Other
		} else {
			otherUsedHash = hash.DeepHash(params.Other)
		}
	}
	return MoqList_starGenType_PushBackList_paramsKey{
		Params: struct{ Other *list.List }{
			Other: otherUsed,
		},
		Hashes: struct{ Other hash.Hash }{
			Other: otherUsedHash,
		},
	}
}

func (m *MoqList_starGenType_recorder) PushFrontList(other *list.List) *MoqList_starGenType_PushFrontList_fnRecorder {
	return &MoqList_starGenType_PushFrontList_fnRecorder{
		Params: MoqList_starGenType_PushFrontList_params{
			Other: other,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqList_starGenType_PushFrontList_fnRecorder) Any() *MoqList_starGenType_PushFrontList_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushFrontList(r.Params))
		return nil
	}
	return &MoqList_starGenType_PushFrontList_anyParams{Recorder: r}
}

func (a *MoqList_starGenType_PushFrontList_anyParams) Other() *MoqList_starGenType_PushFrontList_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqList_starGenType_PushFrontList_fnRecorder) Seq() *MoqList_starGenType_PushFrontList_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushFrontList(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqList_starGenType_PushFrontList_fnRecorder) NoSeq() *MoqList_starGenType_PushFrontList_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_PushFrontList(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqList_starGenType_PushFrontList_fnRecorder) ReturnResults() *MoqList_starGenType_PushFrontList_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushFrontList_doFn
		DoReturnFn MoqList_starGenType_PushFrontList_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqList_starGenType_PushFrontList_fnRecorder) AndDo(fn MoqList_starGenType_PushFrontList_doFn) *MoqList_starGenType_PushFrontList_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqList_starGenType_PushFrontList_fnRecorder) DoReturnResults(fn MoqList_starGenType_PushFrontList_doReturnFn) *MoqList_starGenType_PushFrontList_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqList_starGenType_PushFrontList_doFn
		DoReturnFn MoqList_starGenType_PushFrontList_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqList_starGenType_PushFrontList_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqList_starGenType_PushFrontList_resultsByParams
	for n, res := range r.Moq.ResultsByParams_PushFrontList {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqList_starGenType_PushFrontList_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqList_starGenType_PushFrontList_paramsKey]*MoqList_starGenType_PushFrontList_results{},
		}
		r.Moq.ResultsByParams_PushFrontList = append(r.Moq.ResultsByParams_PushFrontList, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_PushFrontList) {
			copy(r.Moq.ResultsByParams_PushFrontList[insertAt+1:], r.Moq.ResultsByParams_PushFrontList[insertAt:0])
			r.Moq.ResultsByParams_PushFrontList[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_PushFrontList(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqList_starGenType_PushFrontList_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqList_starGenType_PushFrontList_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqList_starGenType_PushFrontList_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqList_starGenType_PushFrontList_doFn
				DoReturnFn MoqList_starGenType_PushFrontList_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqList_starGenType) PrettyParams_PushFrontList(params MoqList_starGenType_PushFrontList_params) string {
	return fmt.Sprintf("PushFrontList(%#v)", params.Other)
}

func (m *MoqList_starGenType) ParamsKey_PushFrontList(params MoqList_starGenType_PushFrontList_params, anyParams uint64) MoqList_starGenType_PushFrontList_paramsKey {
	m.Scene.T.Helper()
	var otherUsed *list.List
	var otherUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.PushFrontList.Other == moq.ParamIndexByValue {
			otherUsed = params.Other
		} else {
			otherUsedHash = hash.DeepHash(params.Other)
		}
	}
	return MoqList_starGenType_PushFrontList_paramsKey{
		Params: struct{ Other *list.List }{
			Other: otherUsed,
		},
		Hashes: struct{ Other hash.Hash }{
			Other: otherUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqList_starGenType) Reset() {
	m.ResultsByParams_Init = nil
	m.ResultsByParams_Len = nil
	m.ResultsByParams_Front = nil
	m.ResultsByParams_Back = nil
	m.ResultsByParams_Remove = nil
	m.ResultsByParams_PushFront = nil
	m.ResultsByParams_PushBack = nil
	m.ResultsByParams_InsertBefore = nil
	m.ResultsByParams_InsertAfter = nil
	m.ResultsByParams_MoveToFront = nil
	m.ResultsByParams_MoveToBack = nil
	m.ResultsByParams_MoveBefore = nil
	m.ResultsByParams_MoveAfter = nil
	m.ResultsByParams_PushBackList = nil
	m.ResultsByParams_PushFrontList = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqList_starGenType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_Init {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Init(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Len {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Len(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Front {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Front(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Back {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Back(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Remove {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Remove(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_PushFront {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_PushFront(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_PushBack {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_PushBack(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_InsertBefore {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_InsertBefore(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_InsertAfter {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_InsertAfter(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MoveToFront {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MoveToFront(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MoveToBack {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MoveToBack(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MoveBefore {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MoveBefore(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MoveAfter {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MoveAfter(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_PushBackList {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_PushBackList(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_PushFrontList {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_PushFrontList(results.Params))
			}
		}
	}
}
