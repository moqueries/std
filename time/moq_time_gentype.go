// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package time

import (
	"fmt"
	"math/bits"
	"sync/atomic"
	"time"

	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that time.Time_genType is mocked
// completely
var _ Time_genType = (*MoqTime_genType_mock)(nil)

// Time_genType is the fabricated implementation type of this mock (emitted
// when mocking a collections of methods directly and not from an interface
// type)
type Time_genType interface {
	String() string
	Format(layout string) string
	AppendFormat(b []byte, layout string) []byte
	After(u time.Time) bool
	Before(u time.Time) bool
	Equal(u time.Time) bool
	IsZero() bool
	Date() (year int, month time.Month, day int)
	Year() int
	Month() time.Month
	Day() int
	Weekday() time.Weekday
	ISOWeek() (year, week int)
	Clock() (hour, min, sec int)
	Hour() int
	Minute() int
	Second() int
	Nanosecond() int
	YearDay() int
	Add(d time.Duration) time.Time
	Sub(u time.Time) time.Duration
	AddDate(years int, months int, days int) time.Time
	UTC() time.Time
	Local() time.Time
	In(loc *time.Location) time.Time
	Location() *time.Location
	Zone() (name string, offset int)
	Unix() int64
	UnixNano() int64
	MarshalBinary() ([]byte, error)
	GobEncode() ([]byte, error)
	MarshalJSON() ([]byte, error)
	MarshalText() ([]byte, error)
	Truncate(d time.Duration) time.Time
	Round(d time.Duration) time.Time
}

// MoqTime_genType holds the state of a moq of the Time_genType type
type MoqTime_genType struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqTime_genType_mock

	ResultsByParams_String        []MoqTime_genType_String_resultsByParams
	ResultsByParams_Format        []MoqTime_genType_Format_resultsByParams
	ResultsByParams_AppendFormat  []MoqTime_genType_AppendFormat_resultsByParams
	ResultsByParams_After         []MoqTime_genType_After_resultsByParams
	ResultsByParams_Before        []MoqTime_genType_Before_resultsByParams
	ResultsByParams_Equal         []MoqTime_genType_Equal_resultsByParams
	ResultsByParams_IsZero        []MoqTime_genType_IsZero_resultsByParams
	ResultsByParams_Date          []MoqTime_genType_Date_resultsByParams
	ResultsByParams_Year          []MoqTime_genType_Year_resultsByParams
	ResultsByParams_Month         []MoqTime_genType_Month_resultsByParams
	ResultsByParams_Day           []MoqTime_genType_Day_resultsByParams
	ResultsByParams_Weekday       []MoqTime_genType_Weekday_resultsByParams
	ResultsByParams_ISOWeek       []MoqTime_genType_ISOWeek_resultsByParams
	ResultsByParams_Clock         []MoqTime_genType_Clock_resultsByParams
	ResultsByParams_Hour          []MoqTime_genType_Hour_resultsByParams
	ResultsByParams_Minute        []MoqTime_genType_Minute_resultsByParams
	ResultsByParams_Second        []MoqTime_genType_Second_resultsByParams
	ResultsByParams_Nanosecond    []MoqTime_genType_Nanosecond_resultsByParams
	ResultsByParams_YearDay       []MoqTime_genType_YearDay_resultsByParams
	ResultsByParams_Add           []MoqTime_genType_Add_resultsByParams
	ResultsByParams_Sub           []MoqTime_genType_Sub_resultsByParams
	ResultsByParams_AddDate       []MoqTime_genType_AddDate_resultsByParams
	ResultsByParams_UTC           []MoqTime_genType_UTC_resultsByParams
	ResultsByParams_Local         []MoqTime_genType_Local_resultsByParams
	ResultsByParams_In            []MoqTime_genType_In_resultsByParams
	ResultsByParams_Location      []MoqTime_genType_Location_resultsByParams
	ResultsByParams_Zone          []MoqTime_genType_Zone_resultsByParams
	ResultsByParams_Unix          []MoqTime_genType_Unix_resultsByParams
	ResultsByParams_UnixNano      []MoqTime_genType_UnixNano_resultsByParams
	ResultsByParams_MarshalBinary []MoqTime_genType_MarshalBinary_resultsByParams
	ResultsByParams_GobEncode     []MoqTime_genType_GobEncode_resultsByParams
	ResultsByParams_MarshalJSON   []MoqTime_genType_MarshalJSON_resultsByParams
	ResultsByParams_MarshalText   []MoqTime_genType_MarshalText_resultsByParams
	ResultsByParams_Truncate      []MoqTime_genType_Truncate_resultsByParams
	ResultsByParams_Round         []MoqTime_genType_Round_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			String struct{}
			Format struct {
				Layout moq.ParamIndexing
			}
			AppendFormat struct {
				B      moq.ParamIndexing
				Layout moq.ParamIndexing
			}
			After struct {
				U moq.ParamIndexing
			}
			Before struct {
				U moq.ParamIndexing
			}
			Equal struct {
				U moq.ParamIndexing
			}
			IsZero     struct{}
			Date       struct{}
			Year       struct{}
			Month      struct{}
			Day        struct{}
			Weekday    struct{}
			ISOWeek    struct{}
			Clock      struct{}
			Hour       struct{}
			Minute     struct{}
			Second     struct{}
			Nanosecond struct{}
			YearDay    struct{}
			Add        struct {
				D moq.ParamIndexing
			}
			Sub struct {
				U moq.ParamIndexing
			}
			AddDate struct {
				Years  moq.ParamIndexing
				Months moq.ParamIndexing
				Days   moq.ParamIndexing
			}
			UTC   struct{}
			Local struct{}
			In    struct {
				Loc moq.ParamIndexing
			}
			Location      struct{}
			Zone          struct{}
			Unix          struct{}
			UnixNano      struct{}
			MarshalBinary struct{}
			GobEncode     struct{}
			MarshalJSON   struct{}
			MarshalText   struct{}
			Truncate      struct {
				D moq.ParamIndexing
			}
			Round struct {
				D moq.ParamIndexing
			}
		}
	}
	// MoqTime_genType_mock isolates the mock interface of the Time_genType type
}

type MoqTime_genType_mock struct {
	Moq *MoqTime_genType
}

// MoqTime_genType_recorder isolates the recorder interface of the Time_genType
// type
type MoqTime_genType_recorder struct {
	Moq *MoqTime_genType
}

// MoqTime_genType_String_params holds the params of the Time_genType type
type MoqTime_genType_String_params struct{}

// MoqTime_genType_String_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_String_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_String_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_String_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_String_paramsKey]*MoqTime_genType_String_results
}

// MoqTime_genType_String_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_String_doFn func()

// MoqTime_genType_String_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_String_doReturnFn func() string

// MoqTime_genType_String_results holds the results of the Time_genType type
type MoqTime_genType_String_results struct {
	Params  MoqTime_genType_String_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTime_genType_String_doFn
		DoReturnFn MoqTime_genType_String_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_String_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_String_fnRecorder struct {
	Params    MoqTime_genType_String_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_String_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_String_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_String_anyParams struct {
	Recorder *MoqTime_genType_String_fnRecorder
}

// MoqTime_genType_Format_params holds the params of the Time_genType type
type MoqTime_genType_Format_params struct{ Layout string }

// MoqTime_genType_Format_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_Format_paramsKey struct {
	Params struct{ Layout string }
	Hashes struct{ Layout hash.Hash }
}

// MoqTime_genType_Format_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_Format_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Format_paramsKey]*MoqTime_genType_Format_results
}

// MoqTime_genType_Format_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Format_doFn func(layout string)

// MoqTime_genType_Format_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Format_doReturnFn func(layout string) string

// MoqTime_genType_Format_results holds the results of the Time_genType type
type MoqTime_genType_Format_results struct {
	Params  MoqTime_genType_Format_params
	Results []struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Format_doFn
		DoReturnFn MoqTime_genType_Format_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Format_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Format_fnRecorder struct {
	Params    MoqTime_genType_Format_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Format_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Format_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Format_anyParams struct {
	Recorder *MoqTime_genType_Format_fnRecorder
}

// MoqTime_genType_AppendFormat_params holds the params of the Time_genType
// type
type MoqTime_genType_AppendFormat_params struct {
	B      []byte
	Layout string
}

// MoqTime_genType_AppendFormat_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_AppendFormat_paramsKey struct {
	Params struct{ Layout string }
	Hashes struct {
		B      hash.Hash
		Layout hash.Hash
	}
}

// MoqTime_genType_AppendFormat_resultsByParams contains the results for a
// given set of parameters for the Time_genType type
type MoqTime_genType_AppendFormat_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_AppendFormat_paramsKey]*MoqTime_genType_AppendFormat_results
}

// MoqTime_genType_AppendFormat_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_AppendFormat_doFn func(b []byte, layout string)

// MoqTime_genType_AppendFormat_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Time_genType type
type MoqTime_genType_AppendFormat_doReturnFn func(b []byte, layout string) []byte

// MoqTime_genType_AppendFormat_results holds the results of the Time_genType
// type
type MoqTime_genType_AppendFormat_results struct {
	Params  MoqTime_genType_AppendFormat_params
	Results []struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqTime_genType_AppendFormat_doFn
		DoReturnFn MoqTime_genType_AppendFormat_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_AppendFormat_fnRecorder routes recorded function calls to
// the MoqTime_genType moq
type MoqTime_genType_AppendFormat_fnRecorder struct {
	Params    MoqTime_genType_AppendFormat_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_AppendFormat_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_AppendFormat_anyParams isolates the any params functions of
// the Time_genType type
type MoqTime_genType_AppendFormat_anyParams struct {
	Recorder *MoqTime_genType_AppendFormat_fnRecorder
}

// MoqTime_genType_After_params holds the params of the Time_genType type
type MoqTime_genType_After_params struct{ U time.Time }

// MoqTime_genType_After_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_After_paramsKey struct {
	Params struct{ U time.Time }
	Hashes struct{ U hash.Hash }
}

// MoqTime_genType_After_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_After_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_After_paramsKey]*MoqTime_genType_After_results
}

// MoqTime_genType_After_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_After_doFn func(u time.Time)

// MoqTime_genType_After_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_After_doReturnFn func(u time.Time) bool

// MoqTime_genType_After_results holds the results of the Time_genType type
type MoqTime_genType_After_results struct {
	Params  MoqTime_genType_After_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_After_doFn
		DoReturnFn MoqTime_genType_After_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_After_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_After_fnRecorder struct {
	Params    MoqTime_genType_After_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_After_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_After_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_After_anyParams struct {
	Recorder *MoqTime_genType_After_fnRecorder
}

// MoqTime_genType_Before_params holds the params of the Time_genType type
type MoqTime_genType_Before_params struct{ U time.Time }

// MoqTime_genType_Before_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_Before_paramsKey struct {
	Params struct{ U time.Time }
	Hashes struct{ U hash.Hash }
}

// MoqTime_genType_Before_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_Before_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Before_paramsKey]*MoqTime_genType_Before_results
}

// MoqTime_genType_Before_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Before_doFn func(u time.Time)

// MoqTime_genType_Before_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Before_doReturnFn func(u time.Time) bool

// MoqTime_genType_Before_results holds the results of the Time_genType type
type MoqTime_genType_Before_results struct {
	Params  MoqTime_genType_Before_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Before_doFn
		DoReturnFn MoqTime_genType_Before_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Before_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Before_fnRecorder struct {
	Params    MoqTime_genType_Before_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Before_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Before_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Before_anyParams struct {
	Recorder *MoqTime_genType_Before_fnRecorder
}

// MoqTime_genType_Equal_params holds the params of the Time_genType type
type MoqTime_genType_Equal_params struct{ U time.Time }

// MoqTime_genType_Equal_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Equal_paramsKey struct {
	Params struct{ U time.Time }
	Hashes struct{ U hash.Hash }
}

// MoqTime_genType_Equal_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_Equal_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Equal_paramsKey]*MoqTime_genType_Equal_results
}

// MoqTime_genType_Equal_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Equal_doFn func(u time.Time)

// MoqTime_genType_Equal_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Equal_doReturnFn func(u time.Time) bool

// MoqTime_genType_Equal_results holds the results of the Time_genType type
type MoqTime_genType_Equal_results struct {
	Params  MoqTime_genType_Equal_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Equal_doFn
		DoReturnFn MoqTime_genType_Equal_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Equal_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Equal_fnRecorder struct {
	Params    MoqTime_genType_Equal_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Equal_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Equal_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Equal_anyParams struct {
	Recorder *MoqTime_genType_Equal_fnRecorder
}

// MoqTime_genType_IsZero_params holds the params of the Time_genType type
type MoqTime_genType_IsZero_params struct{}

// MoqTime_genType_IsZero_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_IsZero_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_IsZero_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_IsZero_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_IsZero_paramsKey]*MoqTime_genType_IsZero_results
}

// MoqTime_genType_IsZero_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_IsZero_doFn func()

// MoqTime_genType_IsZero_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_IsZero_doReturnFn func() bool

// MoqTime_genType_IsZero_results holds the results of the Time_genType type
type MoqTime_genType_IsZero_results struct {
	Params  MoqTime_genType_IsZero_params
	Results []struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_IsZero_doFn
		DoReturnFn MoqTime_genType_IsZero_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_IsZero_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_IsZero_fnRecorder struct {
	Params    MoqTime_genType_IsZero_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_IsZero_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_IsZero_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_IsZero_anyParams struct {
	Recorder *MoqTime_genType_IsZero_fnRecorder
}

// MoqTime_genType_Date_params holds the params of the Time_genType type
type MoqTime_genType_Date_params struct{}

// MoqTime_genType_Date_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Date_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Date_resultsByParams contains the results for a given set of
// parameters for the Time_genType type
type MoqTime_genType_Date_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Date_paramsKey]*MoqTime_genType_Date_results
}

// MoqTime_genType_Date_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Date_doFn func()

// MoqTime_genType_Date_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Date_doReturnFn func() (year int, month time.Month, day int)

// MoqTime_genType_Date_results holds the results of the Time_genType type
type MoqTime_genType_Date_results struct {
	Params  MoqTime_genType_Date_params
	Results []struct {
		Values *struct {
			Year  int
			Month time.Month
			Day   int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Date_doFn
		DoReturnFn MoqTime_genType_Date_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Date_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Date_fnRecorder struct {
	Params    MoqTime_genType_Date_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Date_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Date_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Date_anyParams struct {
	Recorder *MoqTime_genType_Date_fnRecorder
}

// MoqTime_genType_Year_params holds the params of the Time_genType type
type MoqTime_genType_Year_params struct{}

// MoqTime_genType_Year_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Year_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Year_resultsByParams contains the results for a given set of
// parameters for the Time_genType type
type MoqTime_genType_Year_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Year_paramsKey]*MoqTime_genType_Year_results
}

// MoqTime_genType_Year_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Year_doFn func()

// MoqTime_genType_Year_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Year_doReturnFn func() int

// MoqTime_genType_Year_results holds the results of the Time_genType type
type MoqTime_genType_Year_results struct {
	Params  MoqTime_genType_Year_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Year_doFn
		DoReturnFn MoqTime_genType_Year_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Year_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Year_fnRecorder struct {
	Params    MoqTime_genType_Year_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Year_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Year_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Year_anyParams struct {
	Recorder *MoqTime_genType_Year_fnRecorder
}

// MoqTime_genType_Month_params holds the params of the Time_genType type
type MoqTime_genType_Month_params struct{}

// MoqTime_genType_Month_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Month_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Month_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_Month_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Month_paramsKey]*MoqTime_genType_Month_results
}

// MoqTime_genType_Month_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Month_doFn func()

// MoqTime_genType_Month_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Month_doReturnFn func() time.Month

// MoqTime_genType_Month_results holds the results of the Time_genType type
type MoqTime_genType_Month_results struct {
	Params  MoqTime_genType_Month_params
	Results []struct {
		Values *struct {
			Result1 time.Month
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Month_doFn
		DoReturnFn MoqTime_genType_Month_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Month_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Month_fnRecorder struct {
	Params    MoqTime_genType_Month_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Month_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Month_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Month_anyParams struct {
	Recorder *MoqTime_genType_Month_fnRecorder
}

// MoqTime_genType_Day_params holds the params of the Time_genType type
type MoqTime_genType_Day_params struct{}

// MoqTime_genType_Day_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Day_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Day_resultsByParams contains the results for a given set of
// parameters for the Time_genType type
type MoqTime_genType_Day_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Day_paramsKey]*MoqTime_genType_Day_results
}

// MoqTime_genType_Day_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Day_doFn func()

// MoqTime_genType_Day_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Day_doReturnFn func() int

// MoqTime_genType_Day_results holds the results of the Time_genType type
type MoqTime_genType_Day_results struct {
	Params  MoqTime_genType_Day_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Day_doFn
		DoReturnFn MoqTime_genType_Day_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Day_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Day_fnRecorder struct {
	Params    MoqTime_genType_Day_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Day_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Day_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Day_anyParams struct {
	Recorder *MoqTime_genType_Day_fnRecorder
}

// MoqTime_genType_Weekday_params holds the params of the Time_genType type
type MoqTime_genType_Weekday_params struct{}

// MoqTime_genType_Weekday_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_Weekday_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Weekday_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_Weekday_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Weekday_paramsKey]*MoqTime_genType_Weekday_results
}

// MoqTime_genType_Weekday_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_Weekday_doFn func()

// MoqTime_genType_Weekday_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Weekday_doReturnFn func() time.Weekday

// MoqTime_genType_Weekday_results holds the results of the Time_genType type
type MoqTime_genType_Weekday_results struct {
	Params  MoqTime_genType_Weekday_params
	Results []struct {
		Values *struct {
			Result1 time.Weekday
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Weekday_doFn
		DoReturnFn MoqTime_genType_Weekday_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Weekday_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Weekday_fnRecorder struct {
	Params    MoqTime_genType_Weekday_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Weekday_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Weekday_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Weekday_anyParams struct {
	Recorder *MoqTime_genType_Weekday_fnRecorder
}

// MoqTime_genType_ISOWeek_params holds the params of the Time_genType type
type MoqTime_genType_ISOWeek_params struct{}

// MoqTime_genType_ISOWeek_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_ISOWeek_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_ISOWeek_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_ISOWeek_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_ISOWeek_paramsKey]*MoqTime_genType_ISOWeek_results
}

// MoqTime_genType_ISOWeek_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_ISOWeek_doFn func()

// MoqTime_genType_ISOWeek_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_ISOWeek_doReturnFn func() (year, week int)

// MoqTime_genType_ISOWeek_results holds the results of the Time_genType type
type MoqTime_genType_ISOWeek_results struct {
	Params  MoqTime_genType_ISOWeek_params
	Results []struct {
		Values     *struct{ Year, Week int }
		Sequence   uint32
		DoFn       MoqTime_genType_ISOWeek_doFn
		DoReturnFn MoqTime_genType_ISOWeek_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_ISOWeek_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_ISOWeek_fnRecorder struct {
	Params    MoqTime_genType_ISOWeek_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_ISOWeek_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_ISOWeek_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_ISOWeek_anyParams struct {
	Recorder *MoqTime_genType_ISOWeek_fnRecorder
}

// MoqTime_genType_Clock_params holds the params of the Time_genType type
type MoqTime_genType_Clock_params struct{}

// MoqTime_genType_Clock_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Clock_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Clock_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_Clock_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Clock_paramsKey]*MoqTime_genType_Clock_results
}

// MoqTime_genType_Clock_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Clock_doFn func()

// MoqTime_genType_Clock_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Clock_doReturnFn func() (hour, min, sec int)

// MoqTime_genType_Clock_results holds the results of the Time_genType type
type MoqTime_genType_Clock_results struct {
	Params  MoqTime_genType_Clock_params
	Results []struct {
		Values     *struct{ Hour, Min, Sec int }
		Sequence   uint32
		DoFn       MoqTime_genType_Clock_doFn
		DoReturnFn MoqTime_genType_Clock_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Clock_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Clock_fnRecorder struct {
	Params    MoqTime_genType_Clock_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Clock_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Clock_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Clock_anyParams struct {
	Recorder *MoqTime_genType_Clock_fnRecorder
}

// MoqTime_genType_Hour_params holds the params of the Time_genType type
type MoqTime_genType_Hour_params struct{}

// MoqTime_genType_Hour_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Hour_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Hour_resultsByParams contains the results for a given set of
// parameters for the Time_genType type
type MoqTime_genType_Hour_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Hour_paramsKey]*MoqTime_genType_Hour_results
}

// MoqTime_genType_Hour_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Hour_doFn func()

// MoqTime_genType_Hour_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Hour_doReturnFn func() int

// MoqTime_genType_Hour_results holds the results of the Time_genType type
type MoqTime_genType_Hour_results struct {
	Params  MoqTime_genType_Hour_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Hour_doFn
		DoReturnFn MoqTime_genType_Hour_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Hour_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Hour_fnRecorder struct {
	Params    MoqTime_genType_Hour_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Hour_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Hour_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Hour_anyParams struct {
	Recorder *MoqTime_genType_Hour_fnRecorder
}

// MoqTime_genType_Minute_params holds the params of the Time_genType type
type MoqTime_genType_Minute_params struct{}

// MoqTime_genType_Minute_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_Minute_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Minute_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_Minute_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Minute_paramsKey]*MoqTime_genType_Minute_results
}

// MoqTime_genType_Minute_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Minute_doFn func()

// MoqTime_genType_Minute_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Minute_doReturnFn func() int

// MoqTime_genType_Minute_results holds the results of the Time_genType type
type MoqTime_genType_Minute_results struct {
	Params  MoqTime_genType_Minute_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Minute_doFn
		DoReturnFn MoqTime_genType_Minute_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Minute_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Minute_fnRecorder struct {
	Params    MoqTime_genType_Minute_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Minute_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Minute_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Minute_anyParams struct {
	Recorder *MoqTime_genType_Minute_fnRecorder
}

// MoqTime_genType_Second_params holds the params of the Time_genType type
type MoqTime_genType_Second_params struct{}

// MoqTime_genType_Second_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_Second_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Second_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_Second_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Second_paramsKey]*MoqTime_genType_Second_results
}

// MoqTime_genType_Second_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Second_doFn func()

// MoqTime_genType_Second_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Second_doReturnFn func() int

// MoqTime_genType_Second_results holds the results of the Time_genType type
type MoqTime_genType_Second_results struct {
	Params  MoqTime_genType_Second_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Second_doFn
		DoReturnFn MoqTime_genType_Second_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Second_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Second_fnRecorder struct {
	Params    MoqTime_genType_Second_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Second_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Second_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Second_anyParams struct {
	Recorder *MoqTime_genType_Second_fnRecorder
}

// MoqTime_genType_Nanosecond_params holds the params of the Time_genType type
type MoqTime_genType_Nanosecond_params struct{}

// MoqTime_genType_Nanosecond_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_Nanosecond_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Nanosecond_resultsByParams contains the results for a given
// set of parameters for the Time_genType type
type MoqTime_genType_Nanosecond_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Nanosecond_paramsKey]*MoqTime_genType_Nanosecond_results
}

// MoqTime_genType_Nanosecond_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_Nanosecond_doFn func()

// MoqTime_genType_Nanosecond_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Time_genType type
type MoqTime_genType_Nanosecond_doReturnFn func() int

// MoqTime_genType_Nanosecond_results holds the results of the Time_genType
// type
type MoqTime_genType_Nanosecond_results struct {
	Params  MoqTime_genType_Nanosecond_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Nanosecond_doFn
		DoReturnFn MoqTime_genType_Nanosecond_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Nanosecond_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Nanosecond_fnRecorder struct {
	Params    MoqTime_genType_Nanosecond_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Nanosecond_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Nanosecond_anyParams isolates the any params functions of
// the Time_genType type
type MoqTime_genType_Nanosecond_anyParams struct {
	Recorder *MoqTime_genType_Nanosecond_fnRecorder
}

// MoqTime_genType_YearDay_params holds the params of the Time_genType type
type MoqTime_genType_YearDay_params struct{}

// MoqTime_genType_YearDay_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_YearDay_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_YearDay_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_YearDay_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_YearDay_paramsKey]*MoqTime_genType_YearDay_results
}

// MoqTime_genType_YearDay_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_YearDay_doFn func()

// MoqTime_genType_YearDay_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_YearDay_doReturnFn func() int

// MoqTime_genType_YearDay_results holds the results of the Time_genType type
type MoqTime_genType_YearDay_results struct {
	Params  MoqTime_genType_YearDay_params
	Results []struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_YearDay_doFn
		DoReturnFn MoqTime_genType_YearDay_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_YearDay_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_YearDay_fnRecorder struct {
	Params    MoqTime_genType_YearDay_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_YearDay_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_YearDay_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_YearDay_anyParams struct {
	Recorder *MoqTime_genType_YearDay_fnRecorder
}

// MoqTime_genType_Add_params holds the params of the Time_genType type
type MoqTime_genType_Add_params struct{ D time.Duration }

// MoqTime_genType_Add_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Add_paramsKey struct {
	Params struct{ D time.Duration }
	Hashes struct{ D hash.Hash }
}

// MoqTime_genType_Add_resultsByParams contains the results for a given set of
// parameters for the Time_genType type
type MoqTime_genType_Add_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Add_paramsKey]*MoqTime_genType_Add_results
}

// MoqTime_genType_Add_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Add_doFn func(d time.Duration)

// MoqTime_genType_Add_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Add_doReturnFn func(d time.Duration) time.Time

// MoqTime_genType_Add_results holds the results of the Time_genType type
type MoqTime_genType_Add_results struct {
	Params  MoqTime_genType_Add_params
	Results []struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Add_doFn
		DoReturnFn MoqTime_genType_Add_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Add_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Add_fnRecorder struct {
	Params    MoqTime_genType_Add_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Add_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Add_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Add_anyParams struct {
	Recorder *MoqTime_genType_Add_fnRecorder
}

// MoqTime_genType_Sub_params holds the params of the Time_genType type
type MoqTime_genType_Sub_params struct{ U time.Time }

// MoqTime_genType_Sub_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Sub_paramsKey struct {
	Params struct{ U time.Time }
	Hashes struct{ U hash.Hash }
}

// MoqTime_genType_Sub_resultsByParams contains the results for a given set of
// parameters for the Time_genType type
type MoqTime_genType_Sub_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Sub_paramsKey]*MoqTime_genType_Sub_results
}

// MoqTime_genType_Sub_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Sub_doFn func(u time.Time)

// MoqTime_genType_Sub_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Sub_doReturnFn func(u time.Time) time.Duration

// MoqTime_genType_Sub_results holds the results of the Time_genType type
type MoqTime_genType_Sub_results struct {
	Params  MoqTime_genType_Sub_params
	Results []struct {
		Values *struct {
			Result1 time.Duration
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Sub_doFn
		DoReturnFn MoqTime_genType_Sub_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Sub_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Sub_fnRecorder struct {
	Params    MoqTime_genType_Sub_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Sub_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Sub_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Sub_anyParams struct {
	Recorder *MoqTime_genType_Sub_fnRecorder
}

// MoqTime_genType_AddDate_params holds the params of the Time_genType type
type MoqTime_genType_AddDate_params struct {
	Years  int
	Months int
	Days   int
}

// MoqTime_genType_AddDate_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_AddDate_paramsKey struct {
	Params struct {
		Years  int
		Months int
		Days   int
	}
	Hashes struct {
		Years  hash.Hash
		Months hash.Hash
		Days   hash.Hash
	}
}

// MoqTime_genType_AddDate_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_AddDate_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_AddDate_paramsKey]*MoqTime_genType_AddDate_results
}

// MoqTime_genType_AddDate_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_AddDate_doFn func(years int, months int, days int)

// MoqTime_genType_AddDate_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_AddDate_doReturnFn func(years int, months int, days int) time.Time

// MoqTime_genType_AddDate_results holds the results of the Time_genType type
type MoqTime_genType_AddDate_results struct {
	Params  MoqTime_genType_AddDate_params
	Results []struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_AddDate_doFn
		DoReturnFn MoqTime_genType_AddDate_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_AddDate_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_AddDate_fnRecorder struct {
	Params    MoqTime_genType_AddDate_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_AddDate_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_AddDate_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_AddDate_anyParams struct {
	Recorder *MoqTime_genType_AddDate_fnRecorder
}

// MoqTime_genType_UTC_params holds the params of the Time_genType type
type MoqTime_genType_UTC_params struct{}

// MoqTime_genType_UTC_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_UTC_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_UTC_resultsByParams contains the results for a given set of
// parameters for the Time_genType type
type MoqTime_genType_UTC_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_UTC_paramsKey]*MoqTime_genType_UTC_results
}

// MoqTime_genType_UTC_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_UTC_doFn func()

// MoqTime_genType_UTC_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_UTC_doReturnFn func() time.Time

// MoqTime_genType_UTC_results holds the results of the Time_genType type
type MoqTime_genType_UTC_results struct {
	Params  MoqTime_genType_UTC_params
	Results []struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_UTC_doFn
		DoReturnFn MoqTime_genType_UTC_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_UTC_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_UTC_fnRecorder struct {
	Params    MoqTime_genType_UTC_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_UTC_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_UTC_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_UTC_anyParams struct {
	Recorder *MoqTime_genType_UTC_fnRecorder
}

// MoqTime_genType_Local_params holds the params of the Time_genType type
type MoqTime_genType_Local_params struct{}

// MoqTime_genType_Local_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Local_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Local_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_Local_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Local_paramsKey]*MoqTime_genType_Local_results
}

// MoqTime_genType_Local_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Local_doFn func()

// MoqTime_genType_Local_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Local_doReturnFn func() time.Time

// MoqTime_genType_Local_results holds the results of the Time_genType type
type MoqTime_genType_Local_results struct {
	Params  MoqTime_genType_Local_params
	Results []struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Local_doFn
		DoReturnFn MoqTime_genType_Local_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Local_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Local_fnRecorder struct {
	Params    MoqTime_genType_Local_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Local_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Local_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Local_anyParams struct {
	Recorder *MoqTime_genType_Local_fnRecorder
}

// MoqTime_genType_In_params holds the params of the Time_genType type
type MoqTime_genType_In_params struct{ Loc *time.Location }

// MoqTime_genType_In_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_In_paramsKey struct {
	Params struct{ Loc *time.Location }
	Hashes struct{ Loc hash.Hash }
}

// MoqTime_genType_In_resultsByParams contains the results for a given set of
// parameters for the Time_genType type
type MoqTime_genType_In_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_In_paramsKey]*MoqTime_genType_In_results
}

// MoqTime_genType_In_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_In_doFn func(loc *time.Location)

// MoqTime_genType_In_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_In_doReturnFn func(loc *time.Location) time.Time

// MoqTime_genType_In_results holds the results of the Time_genType type
type MoqTime_genType_In_results struct {
	Params  MoqTime_genType_In_params
	Results []struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_In_doFn
		DoReturnFn MoqTime_genType_In_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_In_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_In_fnRecorder struct {
	Params    MoqTime_genType_In_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_In_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_In_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_In_anyParams struct {
	Recorder *MoqTime_genType_In_fnRecorder
}

// MoqTime_genType_Location_params holds the params of the Time_genType type
type MoqTime_genType_Location_params struct{}

// MoqTime_genType_Location_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_Location_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Location_resultsByParams contains the results for a given
// set of parameters for the Time_genType type
type MoqTime_genType_Location_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Location_paramsKey]*MoqTime_genType_Location_results
}

// MoqTime_genType_Location_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_Location_doFn func()

// MoqTime_genType_Location_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Location_doReturnFn func() *time.Location

// MoqTime_genType_Location_results holds the results of the Time_genType type
type MoqTime_genType_Location_results struct {
	Params  MoqTime_genType_Location_params
	Results []struct {
		Values *struct {
			Result1 *time.Location
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Location_doFn
		DoReturnFn MoqTime_genType_Location_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Location_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Location_fnRecorder struct {
	Params    MoqTime_genType_Location_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Location_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Location_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Location_anyParams struct {
	Recorder *MoqTime_genType_Location_fnRecorder
}

// MoqTime_genType_Zone_params holds the params of the Time_genType type
type MoqTime_genType_Zone_params struct{}

// MoqTime_genType_Zone_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Zone_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Zone_resultsByParams contains the results for a given set of
// parameters for the Time_genType type
type MoqTime_genType_Zone_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Zone_paramsKey]*MoqTime_genType_Zone_results
}

// MoqTime_genType_Zone_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Zone_doFn func()

// MoqTime_genType_Zone_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Zone_doReturnFn func() (name string, offset int)

// MoqTime_genType_Zone_results holds the results of the Time_genType type
type MoqTime_genType_Zone_results struct {
	Params  MoqTime_genType_Zone_params
	Results []struct {
		Values *struct {
			Name   string
			Offset int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Zone_doFn
		DoReturnFn MoqTime_genType_Zone_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Zone_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Zone_fnRecorder struct {
	Params    MoqTime_genType_Zone_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Zone_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Zone_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Zone_anyParams struct {
	Recorder *MoqTime_genType_Zone_fnRecorder
}

// MoqTime_genType_Unix_params holds the params of the Time_genType type
type MoqTime_genType_Unix_params struct{}

// MoqTime_genType_Unix_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Unix_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_Unix_resultsByParams contains the results for a given set of
// parameters for the Time_genType type
type MoqTime_genType_Unix_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Unix_paramsKey]*MoqTime_genType_Unix_results
}

// MoqTime_genType_Unix_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Unix_doFn func()

// MoqTime_genType_Unix_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Unix_doReturnFn func() int64

// MoqTime_genType_Unix_results holds the results of the Time_genType type
type MoqTime_genType_Unix_results struct {
	Params  MoqTime_genType_Unix_params
	Results []struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Unix_doFn
		DoReturnFn MoqTime_genType_Unix_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Unix_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Unix_fnRecorder struct {
	Params    MoqTime_genType_Unix_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Unix_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Unix_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Unix_anyParams struct {
	Recorder *MoqTime_genType_Unix_fnRecorder
}

// MoqTime_genType_UnixNano_params holds the params of the Time_genType type
type MoqTime_genType_UnixNano_params struct{}

// MoqTime_genType_UnixNano_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_UnixNano_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_UnixNano_resultsByParams contains the results for a given
// set of parameters for the Time_genType type
type MoqTime_genType_UnixNano_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_UnixNano_paramsKey]*MoqTime_genType_UnixNano_results
}

// MoqTime_genType_UnixNano_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_UnixNano_doFn func()

// MoqTime_genType_UnixNano_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_UnixNano_doReturnFn func() int64

// MoqTime_genType_UnixNano_results holds the results of the Time_genType type
type MoqTime_genType_UnixNano_results struct {
	Params  MoqTime_genType_UnixNano_params
	Results []struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqTime_genType_UnixNano_doFn
		DoReturnFn MoqTime_genType_UnixNano_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_UnixNano_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_UnixNano_fnRecorder struct {
	Params    MoqTime_genType_UnixNano_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_UnixNano_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_UnixNano_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_UnixNano_anyParams struct {
	Recorder *MoqTime_genType_UnixNano_fnRecorder
}

// MoqTime_genType_MarshalBinary_params holds the params of the Time_genType
// type
type MoqTime_genType_MarshalBinary_params struct{}

// MoqTime_genType_MarshalBinary_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_MarshalBinary_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_MarshalBinary_resultsByParams contains the results for a
// given set of parameters for the Time_genType type
type MoqTime_genType_MarshalBinary_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_MarshalBinary_paramsKey]*MoqTime_genType_MarshalBinary_results
}

// MoqTime_genType_MarshalBinary_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_MarshalBinary_doFn func()

// MoqTime_genType_MarshalBinary_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Time_genType type
type MoqTime_genType_MarshalBinary_doReturnFn func() ([]byte, error)

// MoqTime_genType_MarshalBinary_results holds the results of the Time_genType
// type
type MoqTime_genType_MarshalBinary_results struct {
	Params  MoqTime_genType_MarshalBinary_params
	Results []struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_MarshalBinary_doFn
		DoReturnFn MoqTime_genType_MarshalBinary_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_MarshalBinary_fnRecorder routes recorded function calls to
// the MoqTime_genType moq
type MoqTime_genType_MarshalBinary_fnRecorder struct {
	Params    MoqTime_genType_MarshalBinary_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_MarshalBinary_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_MarshalBinary_anyParams isolates the any params functions of
// the Time_genType type
type MoqTime_genType_MarshalBinary_anyParams struct {
	Recorder *MoqTime_genType_MarshalBinary_fnRecorder
}

// MoqTime_genType_GobEncode_params holds the params of the Time_genType type
type MoqTime_genType_GobEncode_params struct{}

// MoqTime_genType_GobEncode_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_GobEncode_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_GobEncode_resultsByParams contains the results for a given
// set of parameters for the Time_genType type
type MoqTime_genType_GobEncode_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_GobEncode_paramsKey]*MoqTime_genType_GobEncode_results
}

// MoqTime_genType_GobEncode_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_GobEncode_doFn func()

// MoqTime_genType_GobEncode_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Time_genType type
type MoqTime_genType_GobEncode_doReturnFn func() ([]byte, error)

// MoqTime_genType_GobEncode_results holds the results of the Time_genType type
type MoqTime_genType_GobEncode_results struct {
	Params  MoqTime_genType_GobEncode_params
	Results []struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_GobEncode_doFn
		DoReturnFn MoqTime_genType_GobEncode_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_GobEncode_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_GobEncode_fnRecorder struct {
	Params    MoqTime_genType_GobEncode_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_GobEncode_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_GobEncode_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_GobEncode_anyParams struct {
	Recorder *MoqTime_genType_GobEncode_fnRecorder
}

// MoqTime_genType_MarshalJSON_params holds the params of the Time_genType type
type MoqTime_genType_MarshalJSON_params struct{}

// MoqTime_genType_MarshalJSON_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_MarshalJSON_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_MarshalJSON_resultsByParams contains the results for a given
// set of parameters for the Time_genType type
type MoqTime_genType_MarshalJSON_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_MarshalJSON_paramsKey]*MoqTime_genType_MarshalJSON_results
}

// MoqTime_genType_MarshalJSON_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_MarshalJSON_doFn func()

// MoqTime_genType_MarshalJSON_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Time_genType type
type MoqTime_genType_MarshalJSON_doReturnFn func() ([]byte, error)

// MoqTime_genType_MarshalJSON_results holds the results of the Time_genType
// type
type MoqTime_genType_MarshalJSON_results struct {
	Params  MoqTime_genType_MarshalJSON_params
	Results []struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_MarshalJSON_doFn
		DoReturnFn MoqTime_genType_MarshalJSON_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_MarshalJSON_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_MarshalJSON_fnRecorder struct {
	Params    MoqTime_genType_MarshalJSON_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_MarshalJSON_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_MarshalJSON_anyParams isolates the any params functions of
// the Time_genType type
type MoqTime_genType_MarshalJSON_anyParams struct {
	Recorder *MoqTime_genType_MarshalJSON_fnRecorder
}

// MoqTime_genType_MarshalText_params holds the params of the Time_genType type
type MoqTime_genType_MarshalText_params struct{}

// MoqTime_genType_MarshalText_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_MarshalText_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqTime_genType_MarshalText_resultsByParams contains the results for a given
// set of parameters for the Time_genType type
type MoqTime_genType_MarshalText_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_MarshalText_paramsKey]*MoqTime_genType_MarshalText_results
}

// MoqTime_genType_MarshalText_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_MarshalText_doFn func()

// MoqTime_genType_MarshalText_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Time_genType type
type MoqTime_genType_MarshalText_doReturnFn func() ([]byte, error)

// MoqTime_genType_MarshalText_results holds the results of the Time_genType
// type
type MoqTime_genType_MarshalText_results struct {
	Params  MoqTime_genType_MarshalText_params
	Results []struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_MarshalText_doFn
		DoReturnFn MoqTime_genType_MarshalText_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_MarshalText_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_MarshalText_fnRecorder struct {
	Params    MoqTime_genType_MarshalText_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_MarshalText_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_MarshalText_anyParams isolates the any params functions of
// the Time_genType type
type MoqTime_genType_MarshalText_anyParams struct {
	Recorder *MoqTime_genType_MarshalText_fnRecorder
}

// MoqTime_genType_Truncate_params holds the params of the Time_genType type
type MoqTime_genType_Truncate_params struct{ D time.Duration }

// MoqTime_genType_Truncate_paramsKey holds the map key params of the
// Time_genType type
type MoqTime_genType_Truncate_paramsKey struct {
	Params struct{ D time.Duration }
	Hashes struct{ D hash.Hash }
}

// MoqTime_genType_Truncate_resultsByParams contains the results for a given
// set of parameters for the Time_genType type
type MoqTime_genType_Truncate_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Truncate_paramsKey]*MoqTime_genType_Truncate_results
}

// MoqTime_genType_Truncate_doFn defines the type of function needed when
// calling AndDo for the Time_genType type
type MoqTime_genType_Truncate_doFn func(d time.Duration)

// MoqTime_genType_Truncate_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Truncate_doReturnFn func(d time.Duration) time.Time

// MoqTime_genType_Truncate_results holds the results of the Time_genType type
type MoqTime_genType_Truncate_results struct {
	Params  MoqTime_genType_Truncate_params
	Results []struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Truncate_doFn
		DoReturnFn MoqTime_genType_Truncate_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Truncate_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Truncate_fnRecorder struct {
	Params    MoqTime_genType_Truncate_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Truncate_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Truncate_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Truncate_anyParams struct {
	Recorder *MoqTime_genType_Truncate_fnRecorder
}

// MoqTime_genType_Round_params holds the params of the Time_genType type
type MoqTime_genType_Round_params struct{ D time.Duration }

// MoqTime_genType_Round_paramsKey holds the map key params of the Time_genType
// type
type MoqTime_genType_Round_paramsKey struct {
	Params struct{ D time.Duration }
	Hashes struct{ D hash.Hash }
}

// MoqTime_genType_Round_resultsByParams contains the results for a given set
// of parameters for the Time_genType type
type MoqTime_genType_Round_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqTime_genType_Round_paramsKey]*MoqTime_genType_Round_results
}

// MoqTime_genType_Round_doFn defines the type of function needed when calling
// AndDo for the Time_genType type
type MoqTime_genType_Round_doFn func(d time.Duration)

// MoqTime_genType_Round_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Time_genType type
type MoqTime_genType_Round_doReturnFn func(d time.Duration) time.Time

// MoqTime_genType_Round_results holds the results of the Time_genType type
type MoqTime_genType_Round_results struct {
	Params  MoqTime_genType_Round_params
	Results []struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Round_doFn
		DoReturnFn MoqTime_genType_Round_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqTime_genType_Round_fnRecorder routes recorded function calls to the
// MoqTime_genType moq
type MoqTime_genType_Round_fnRecorder struct {
	Params    MoqTime_genType_Round_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqTime_genType_Round_results
	Moq       *MoqTime_genType
}

// MoqTime_genType_Round_anyParams isolates the any params functions of the
// Time_genType type
type MoqTime_genType_Round_anyParams struct {
	Recorder *MoqTime_genType_Round_fnRecorder
}

// NewMoqTime_genType creates a new moq of the Time_genType type
func NewMoqTime_genType(scene *moq.Scene, config *moq.Config) *MoqTime_genType {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqTime_genType{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqTime_genType_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				String struct{}
				Format struct {
					Layout moq.ParamIndexing
				}
				AppendFormat struct {
					B      moq.ParamIndexing
					Layout moq.ParamIndexing
				}
				After struct {
					U moq.ParamIndexing
				}
				Before struct {
					U moq.ParamIndexing
				}
				Equal struct {
					U moq.ParamIndexing
				}
				IsZero     struct{}
				Date       struct{}
				Year       struct{}
				Month      struct{}
				Day        struct{}
				Weekday    struct{}
				ISOWeek    struct{}
				Clock      struct{}
				Hour       struct{}
				Minute     struct{}
				Second     struct{}
				Nanosecond struct{}
				YearDay    struct{}
				Add        struct {
					D moq.ParamIndexing
				}
				Sub struct {
					U moq.ParamIndexing
				}
				AddDate struct {
					Years  moq.ParamIndexing
					Months moq.ParamIndexing
					Days   moq.ParamIndexing
				}
				UTC   struct{}
				Local struct{}
				In    struct {
					Loc moq.ParamIndexing
				}
				Location      struct{}
				Zone          struct{}
				Unix          struct{}
				UnixNano      struct{}
				MarshalBinary struct{}
				GobEncode     struct{}
				MarshalJSON   struct{}
				MarshalText   struct{}
				Truncate      struct {
					D moq.ParamIndexing
				}
				Round struct {
					D moq.ParamIndexing
				}
			}
		}{ParameterIndexing: struct {
			String struct{}
			Format struct {
				Layout moq.ParamIndexing
			}
			AppendFormat struct {
				B      moq.ParamIndexing
				Layout moq.ParamIndexing
			}
			After struct {
				U moq.ParamIndexing
			}
			Before struct {
				U moq.ParamIndexing
			}
			Equal struct {
				U moq.ParamIndexing
			}
			IsZero     struct{}
			Date       struct{}
			Year       struct{}
			Month      struct{}
			Day        struct{}
			Weekday    struct{}
			ISOWeek    struct{}
			Clock      struct{}
			Hour       struct{}
			Minute     struct{}
			Second     struct{}
			Nanosecond struct{}
			YearDay    struct{}
			Add        struct {
				D moq.ParamIndexing
			}
			Sub struct {
				U moq.ParamIndexing
			}
			AddDate struct {
				Years  moq.ParamIndexing
				Months moq.ParamIndexing
				Days   moq.ParamIndexing
			}
			UTC   struct{}
			Local struct{}
			In    struct {
				Loc moq.ParamIndexing
			}
			Location      struct{}
			Zone          struct{}
			Unix          struct{}
			UnixNano      struct{}
			MarshalBinary struct{}
			GobEncode     struct{}
			MarshalJSON   struct{}
			MarshalText   struct{}
			Truncate      struct {
				D moq.ParamIndexing
			}
			Round struct {
				D moq.ParamIndexing
			}
		}{
			String: struct{}{},
			Format: struct {
				Layout moq.ParamIndexing
			}{
				Layout: moq.ParamIndexByValue,
			},
			AppendFormat: struct {
				B      moq.ParamIndexing
				Layout moq.ParamIndexing
			}{
				B:      moq.ParamIndexByHash,
				Layout: moq.ParamIndexByValue,
			},
			After: struct {
				U moq.ParamIndexing
			}{
				U: moq.ParamIndexByHash,
			},
			Before: struct {
				U moq.ParamIndexing
			}{
				U: moq.ParamIndexByHash,
			},
			Equal: struct {
				U moq.ParamIndexing
			}{
				U: moq.ParamIndexByHash,
			},
			IsZero:     struct{}{},
			Date:       struct{}{},
			Year:       struct{}{},
			Month:      struct{}{},
			Day:        struct{}{},
			Weekday:    struct{}{},
			ISOWeek:    struct{}{},
			Clock:      struct{}{},
			Hour:       struct{}{},
			Minute:     struct{}{},
			Second:     struct{}{},
			Nanosecond: struct{}{},
			YearDay:    struct{}{},
			Add: struct {
				D moq.ParamIndexing
			}{
				D: moq.ParamIndexByValue,
			},
			Sub: struct {
				U moq.ParamIndexing
			}{
				U: moq.ParamIndexByHash,
			},
			AddDate: struct {
				Years  moq.ParamIndexing
				Months moq.ParamIndexing
				Days   moq.ParamIndexing
			}{
				Years:  moq.ParamIndexByValue,
				Months: moq.ParamIndexByValue,
				Days:   moq.ParamIndexByValue,
			},
			UTC:   struct{}{},
			Local: struct{}{},
			In: struct {
				Loc moq.ParamIndexing
			}{
				Loc: moq.ParamIndexByHash,
			},
			Location:      struct{}{},
			Zone:          struct{}{},
			Unix:          struct{}{},
			UnixNano:      struct{}{},
			MarshalBinary: struct{}{},
			GobEncode:     struct{}{},
			MarshalJSON:   struct{}{},
			MarshalText:   struct{}{},
			Truncate: struct {
				D moq.ParamIndexing
			}{
				D: moq.ParamIndexByValue,
			},
			Round: struct {
				D moq.ParamIndexing
			}{
				D: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Time_genType type
func (m *MoqTime_genType) Mock() *MoqTime_genType_mock { return m.Moq }

func (m *MoqTime_genType_mock) String() (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_String_params{}
	var results *MoqTime_genType_String_results
	for _, resultsByParams := range m.Moq.ResultsByParams_String {
		paramsKey := m.Moq.ParamsKey_String(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_String(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_String(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_String(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Format(layout string) (result1 string) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Format_params{
		Layout: layout,
	}
	var results *MoqTime_genType_Format_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Format {
		paramsKey := m.Moq.ParamsKey_Format(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Format(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Format(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Format(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(layout)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(layout)
	}
	return
}

func (m *MoqTime_genType_mock) AppendFormat(b []byte, layout string) (result1 []byte) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_AppendFormat_params{
		B:      b,
		Layout: layout,
	}
	var results *MoqTime_genType_AppendFormat_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AppendFormat {
		paramsKey := m.Moq.ParamsKey_AppendFormat(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AppendFormat(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AppendFormat(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AppendFormat(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(b, layout)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(b, layout)
	}
	return
}

func (m *MoqTime_genType_mock) After(u time.Time) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_After_params{
		U: u,
	}
	var results *MoqTime_genType_After_results
	for _, resultsByParams := range m.Moq.ResultsByParams_After {
		paramsKey := m.Moq.ParamsKey_After(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_After(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_After(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_After(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(u)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(u)
	}
	return
}

func (m *MoqTime_genType_mock) Before(u time.Time) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Before_params{
		U: u,
	}
	var results *MoqTime_genType_Before_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Before {
		paramsKey := m.Moq.ParamsKey_Before(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Before(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Before(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Before(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(u)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(u)
	}
	return
}

func (m *MoqTime_genType_mock) Equal(u time.Time) (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Equal_params{
		U: u,
	}
	var results *MoqTime_genType_Equal_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Equal {
		paramsKey := m.Moq.ParamsKey_Equal(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Equal(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Equal(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Equal(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(u)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(u)
	}
	return
}

func (m *MoqTime_genType_mock) IsZero() (result1 bool) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_IsZero_params{}
	var results *MoqTime_genType_IsZero_results
	for _, resultsByParams := range m.Moq.ResultsByParams_IsZero {
		paramsKey := m.Moq.ParamsKey_IsZero(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_IsZero(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_IsZero(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_IsZero(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Date() (year int, month time.Month, day int) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Date_params{}
	var results *MoqTime_genType_Date_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Date {
		paramsKey := m.Moq.ParamsKey_Date(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Date(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Date(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Date(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		year = result.Values.Year
		month = result.Values.Month
		day = result.Values.Day
	}
	if result.DoReturnFn != nil {
		year, month, day = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Year() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Year_params{}
	var results *MoqTime_genType_Year_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Year {
		paramsKey := m.Moq.ParamsKey_Year(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Year(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Year(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Year(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Month() (result1 time.Month) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Month_params{}
	var results *MoqTime_genType_Month_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Month {
		paramsKey := m.Moq.ParamsKey_Month(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Month(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Month(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Month(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Day() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Day_params{}
	var results *MoqTime_genType_Day_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Day {
		paramsKey := m.Moq.ParamsKey_Day(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Day(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Day(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Day(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Weekday() (result1 time.Weekday) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Weekday_params{}
	var results *MoqTime_genType_Weekday_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Weekday {
		paramsKey := m.Moq.ParamsKey_Weekday(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Weekday(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Weekday(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Weekday(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) ISOWeek() (year, week int) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_ISOWeek_params{}
	var results *MoqTime_genType_ISOWeek_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ISOWeek {
		paramsKey := m.Moq.ParamsKey_ISOWeek(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ISOWeek(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ISOWeek(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ISOWeek(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		year = result.Values.Year
		week = result.Values.Week
	}
	if result.DoReturnFn != nil {
		year, week = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Clock() (hour, min, sec int) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Clock_params{}
	var results *MoqTime_genType_Clock_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Clock {
		paramsKey := m.Moq.ParamsKey_Clock(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Clock(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Clock(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Clock(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		hour = result.Values.Hour
		min = result.Values.Min
		sec = result.Values.Sec
	}
	if result.DoReturnFn != nil {
		hour, min, sec = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Hour() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Hour_params{}
	var results *MoqTime_genType_Hour_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Hour {
		paramsKey := m.Moq.ParamsKey_Hour(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Hour(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Hour(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Hour(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Minute() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Minute_params{}
	var results *MoqTime_genType_Minute_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Minute {
		paramsKey := m.Moq.ParamsKey_Minute(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Minute(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Minute(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Minute(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Second() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Second_params{}
	var results *MoqTime_genType_Second_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Second {
		paramsKey := m.Moq.ParamsKey_Second(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Second(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Second(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Second(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Nanosecond() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Nanosecond_params{}
	var results *MoqTime_genType_Nanosecond_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Nanosecond {
		paramsKey := m.Moq.ParamsKey_Nanosecond(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Nanosecond(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Nanosecond(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Nanosecond(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) YearDay() (result1 int) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_YearDay_params{}
	var results *MoqTime_genType_YearDay_results
	for _, resultsByParams := range m.Moq.ResultsByParams_YearDay {
		paramsKey := m.Moq.ParamsKey_YearDay(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_YearDay(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_YearDay(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_YearDay(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Add(d time.Duration) (result1 time.Time) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Add_params{
		D: d,
	}
	var results *MoqTime_genType_Add_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Add {
		paramsKey := m.Moq.ParamsKey_Add(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Add(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Add(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Add(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(d)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(d)
	}
	return
}

func (m *MoqTime_genType_mock) Sub(u time.Time) (result1 time.Duration) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Sub_params{
		U: u,
	}
	var results *MoqTime_genType_Sub_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Sub {
		paramsKey := m.Moq.ParamsKey_Sub(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Sub(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Sub(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Sub(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(u)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(u)
	}
	return
}

func (m *MoqTime_genType_mock) AddDate(years int, months int, days int) (result1 time.Time) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_AddDate_params{
		Years:  years,
		Months: months,
		Days:   days,
	}
	var results *MoqTime_genType_AddDate_results
	for _, resultsByParams := range m.Moq.ResultsByParams_AddDate {
		paramsKey := m.Moq.ParamsKey_AddDate(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_AddDate(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_AddDate(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_AddDate(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(years, months, days)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(years, months, days)
	}
	return
}

func (m *MoqTime_genType_mock) UTC() (result1 time.Time) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_UTC_params{}
	var results *MoqTime_genType_UTC_results
	for _, resultsByParams := range m.Moq.ResultsByParams_UTC {
		paramsKey := m.Moq.ParamsKey_UTC(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_UTC(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_UTC(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_UTC(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Local() (result1 time.Time) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Local_params{}
	var results *MoqTime_genType_Local_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Local {
		paramsKey := m.Moq.ParamsKey_Local(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Local(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Local(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Local(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) In(loc *time.Location) (result1 time.Time) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_In_params{
		Loc: loc,
	}
	var results *MoqTime_genType_In_results
	for _, resultsByParams := range m.Moq.ResultsByParams_In {
		paramsKey := m.Moq.ParamsKey_In(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_In(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_In(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_In(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(loc)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(loc)
	}
	return
}

func (m *MoqTime_genType_mock) Location() (result1 *time.Location) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Location_params{}
	var results *MoqTime_genType_Location_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Location {
		paramsKey := m.Moq.ParamsKey_Location(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Location(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Location(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Location(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Zone() (name string, offset int) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Zone_params{}
	var results *MoqTime_genType_Zone_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Zone {
		paramsKey := m.Moq.ParamsKey_Zone(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Zone(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Zone(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Zone(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		name = result.Values.Name
		offset = result.Values.Offset
	}
	if result.DoReturnFn != nil {
		name, offset = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Unix() (result1 int64) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Unix_params{}
	var results *MoqTime_genType_Unix_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Unix {
		paramsKey := m.Moq.ParamsKey_Unix(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Unix(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Unix(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Unix(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) UnixNano() (result1 int64) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_UnixNano_params{}
	var results *MoqTime_genType_UnixNano_results
	for _, resultsByParams := range m.Moq.ResultsByParams_UnixNano {
		paramsKey := m.Moq.ParamsKey_UnixNano(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_UnixNano(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_UnixNano(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_UnixNano(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) MarshalBinary() (result1 []byte, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_MarshalBinary_params{}
	var results *MoqTime_genType_MarshalBinary_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MarshalBinary {
		paramsKey := m.Moq.ParamsKey_MarshalBinary(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MarshalBinary(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MarshalBinary(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MarshalBinary(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) GobEncode() (result1 []byte, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_GobEncode_params{}
	var results *MoqTime_genType_GobEncode_results
	for _, resultsByParams := range m.Moq.ResultsByParams_GobEncode {
		paramsKey := m.Moq.ParamsKey_GobEncode(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_GobEncode(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_GobEncode(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_GobEncode(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) MarshalJSON() (result1 []byte, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_MarshalJSON_params{}
	var results *MoqTime_genType_MarshalJSON_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MarshalJSON {
		paramsKey := m.Moq.ParamsKey_MarshalJSON(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MarshalJSON(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MarshalJSON(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MarshalJSON(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) MarshalText() (result1 []byte, result2 error) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_MarshalText_params{}
	var results *MoqTime_genType_MarshalText_results
	for _, resultsByParams := range m.Moq.ResultsByParams_MarshalText {
		paramsKey := m.Moq.ParamsKey_MarshalText(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_MarshalText(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_MarshalText(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_MarshalText(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.Values != nil {
		result1 = result.Values.Result1
		result2 = result.Values.Result2
	}
	if result.DoReturnFn != nil {
		result1, result2 = result.DoReturnFn()
	}
	return
}

func (m *MoqTime_genType_mock) Truncate(d time.Duration) (result1 time.Time) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Truncate_params{
		D: d,
	}
	var results *MoqTime_genType_Truncate_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Truncate {
		paramsKey := m.Moq.ParamsKey_Truncate(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Truncate(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Truncate(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Truncate(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(d)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(d)
	}
	return
}

func (m *MoqTime_genType_mock) Round(d time.Duration) (result1 time.Time) {
	m.Moq.Scene.T.Helper()
	params := MoqTime_genType_Round_params{
		D: d,
	}
	var results *MoqTime_genType_Round_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Round {
		paramsKey := m.Moq.ParamsKey_Round(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Round(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Round(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Round(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(d)
	}

	if result.Values != nil {
		result1 = result.Values.Result1
	}
	if result.DoReturnFn != nil {
		result1 = result.DoReturnFn(d)
	}
	return
}

// OnCall returns the recorder implementation of the Time_genType type
func (m *MoqTime_genType) OnCall() *MoqTime_genType_recorder {
	return &MoqTime_genType_recorder{
		Moq: m,
	}
}

func (m *MoqTime_genType_recorder) String() *MoqTime_genType_String_fnRecorder {
	return &MoqTime_genType_String_fnRecorder{
		Params:   MoqTime_genType_String_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_String_fnRecorder) Any() *MoqTime_genType_String_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	return &MoqTime_genType_String_anyParams{Recorder: r}
}

func (r *MoqTime_genType_String_fnRecorder) Seq() *MoqTime_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_String_fnRecorder) NoSeq() *MoqTime_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_String(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_String_fnRecorder) ReturnResults(result1 string) *MoqTime_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTime_genType_String_doFn
		DoReturnFn MoqTime_genType_String_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_String_fnRecorder) AndDo(fn MoqTime_genType_String_doFn) *MoqTime_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_String_fnRecorder) DoReturnResults(fn MoqTime_genType_String_doReturnFn) *MoqTime_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTime_genType_String_doFn
		DoReturnFn MoqTime_genType_String_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_String_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_String_resultsByParams
	for n, res := range r.Moq.ResultsByParams_String {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_String_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_String_paramsKey]*MoqTime_genType_String_results{},
		}
		r.Moq.ResultsByParams_String = append(r.Moq.ResultsByParams_String, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_String) {
			copy(r.Moq.ResultsByParams_String[insertAt+1:], r.Moq.ResultsByParams_String[insertAt:0])
			r.Moq.ResultsByParams_String[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_String(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_String_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_String_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_String_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqTime_genType_String_doFn
				DoReturnFn MoqTime_genType_String_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_String(params MoqTime_genType_String_params) string {
	return fmt.Sprintf("String()")
}

func (m *MoqTime_genType) ParamsKey_String(params MoqTime_genType_String_params, anyParams uint64) MoqTime_genType_String_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_String_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Format(layout string) *MoqTime_genType_Format_fnRecorder {
	return &MoqTime_genType_Format_fnRecorder{
		Params: MoqTime_genType_Format_params{
			Layout: layout,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Format_fnRecorder) Any() *MoqTime_genType_Format_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Format(r.Params))
		return nil
	}
	return &MoqTime_genType_Format_anyParams{Recorder: r}
}

func (a *MoqTime_genType_Format_anyParams) Layout() *MoqTime_genType_Format_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTime_genType_Format_fnRecorder) Seq() *MoqTime_genType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Format(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Format_fnRecorder) NoSeq() *MoqTime_genType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Format(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Format_fnRecorder) ReturnResults(result1 string) *MoqTime_genType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Format_doFn
		DoReturnFn MoqTime_genType_Format_doReturnFn
	}{
		Values: &struct {
			Result1 string
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Format_fnRecorder) AndDo(fn MoqTime_genType_Format_doFn) *MoqTime_genType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Format_fnRecorder) DoReturnResults(fn MoqTime_genType_Format_doReturnFn) *MoqTime_genType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 string
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Format_doFn
		DoReturnFn MoqTime_genType_Format_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Format_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Format_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Format {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Format_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Format_paramsKey]*MoqTime_genType_Format_results{},
		}
		r.Moq.ResultsByParams_Format = append(r.Moq.ResultsByParams_Format, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Format) {
			copy(r.Moq.ResultsByParams_Format[insertAt+1:], r.Moq.ResultsByParams_Format[insertAt:0])
			r.Moq.ResultsByParams_Format[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Format(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Format_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Format_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Format_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 string
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Format_doFn
				DoReturnFn MoqTime_genType_Format_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Format(params MoqTime_genType_Format_params) string {
	return fmt.Sprintf("Format(%#v)", params.Layout)
}

func (m *MoqTime_genType) ParamsKey_Format(params MoqTime_genType_Format_params, anyParams uint64) MoqTime_genType_Format_paramsKey {
	m.Scene.T.Helper()
	var layoutUsed string
	var layoutUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Format.Layout == moq.ParamIndexByValue {
			layoutUsed = params.Layout
		} else {
			layoutUsedHash = hash.DeepHash(params.Layout)
		}
	}
	return MoqTime_genType_Format_paramsKey{
		Params: struct{ Layout string }{
			Layout: layoutUsed,
		},
		Hashes: struct{ Layout hash.Hash }{
			Layout: layoutUsedHash,
		},
	}
}

func (m *MoqTime_genType_recorder) AppendFormat(b []byte, layout string) *MoqTime_genType_AppendFormat_fnRecorder {
	return &MoqTime_genType_AppendFormat_fnRecorder{
		Params: MoqTime_genType_AppendFormat_params{
			B:      b,
			Layout: layout,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_AppendFormat_fnRecorder) Any() *MoqTime_genType_AppendFormat_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AppendFormat(r.Params))
		return nil
	}
	return &MoqTime_genType_AppendFormat_anyParams{Recorder: r}
}

func (a *MoqTime_genType_AppendFormat_anyParams) B() *MoqTime_genType_AppendFormat_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqTime_genType_AppendFormat_anyParams) Layout() *MoqTime_genType_AppendFormat_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (r *MoqTime_genType_AppendFormat_fnRecorder) Seq() *MoqTime_genType_AppendFormat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AppendFormat(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_AppendFormat_fnRecorder) NoSeq() *MoqTime_genType_AppendFormat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AppendFormat(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_AppendFormat_fnRecorder) ReturnResults(result1 []byte) *MoqTime_genType_AppendFormat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqTime_genType_AppendFormat_doFn
		DoReturnFn MoqTime_genType_AppendFormat_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_AppendFormat_fnRecorder) AndDo(fn MoqTime_genType_AppendFormat_doFn) *MoqTime_genType_AppendFormat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_AppendFormat_fnRecorder) DoReturnResults(fn MoqTime_genType_AppendFormat_doReturnFn) *MoqTime_genType_AppendFormat_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
		}
		Sequence   uint32
		DoFn       MoqTime_genType_AppendFormat_doFn
		DoReturnFn MoqTime_genType_AppendFormat_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_AppendFormat_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_AppendFormat_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AppendFormat {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_AppendFormat_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_AppendFormat_paramsKey]*MoqTime_genType_AppendFormat_results{},
		}
		r.Moq.ResultsByParams_AppendFormat = append(r.Moq.ResultsByParams_AppendFormat, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AppendFormat) {
			copy(r.Moq.ResultsByParams_AppendFormat[insertAt+1:], r.Moq.ResultsByParams_AppendFormat[insertAt:0])
			r.Moq.ResultsByParams_AppendFormat[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AppendFormat(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_AppendFormat_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_AppendFormat_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_AppendFormat_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
				}
				Sequence   uint32
				DoFn       MoqTime_genType_AppendFormat_doFn
				DoReturnFn MoqTime_genType_AppendFormat_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_AppendFormat(params MoqTime_genType_AppendFormat_params) string {
	return fmt.Sprintf("AppendFormat(%#v, %#v)", params.B, params.Layout)
}

func (m *MoqTime_genType) ParamsKey_AppendFormat(params MoqTime_genType_AppendFormat_params, anyParams uint64) MoqTime_genType_AppendFormat_paramsKey {
	m.Scene.T.Helper()
	var bUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.AppendFormat.B == moq.ParamIndexByValue {
			m.Scene.T.Fatalf("The b parameter of the AppendFormat function can't be indexed by value")
		}
		bUsedHash = hash.DeepHash(params.B)
	}
	var layoutUsed string
	var layoutUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.AppendFormat.Layout == moq.ParamIndexByValue {
			layoutUsed = params.Layout
		} else {
			layoutUsedHash = hash.DeepHash(params.Layout)
		}
	}
	return MoqTime_genType_AppendFormat_paramsKey{
		Params: struct{ Layout string }{
			Layout: layoutUsed,
		},
		Hashes: struct {
			B      hash.Hash
			Layout hash.Hash
		}{
			B:      bUsedHash,
			Layout: layoutUsedHash,
		},
	}
}

func (m *MoqTime_genType_recorder) After(u time.Time) *MoqTime_genType_After_fnRecorder {
	return &MoqTime_genType_After_fnRecorder{
		Params: MoqTime_genType_After_params{
			U: u,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_After_fnRecorder) Any() *MoqTime_genType_After_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_After(r.Params))
		return nil
	}
	return &MoqTime_genType_After_anyParams{Recorder: r}
}

func (a *MoqTime_genType_After_anyParams) U() *MoqTime_genType_After_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTime_genType_After_fnRecorder) Seq() *MoqTime_genType_After_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_After(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_After_fnRecorder) NoSeq() *MoqTime_genType_After_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_After(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_After_fnRecorder) ReturnResults(result1 bool) *MoqTime_genType_After_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_After_doFn
		DoReturnFn MoqTime_genType_After_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_After_fnRecorder) AndDo(fn MoqTime_genType_After_doFn) *MoqTime_genType_After_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_After_fnRecorder) DoReturnResults(fn MoqTime_genType_After_doReturnFn) *MoqTime_genType_After_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_After_doFn
		DoReturnFn MoqTime_genType_After_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_After_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_After_resultsByParams
	for n, res := range r.Moq.ResultsByParams_After {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_After_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_After_paramsKey]*MoqTime_genType_After_results{},
		}
		r.Moq.ResultsByParams_After = append(r.Moq.ResultsByParams_After, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_After) {
			copy(r.Moq.ResultsByParams_After[insertAt+1:], r.Moq.ResultsByParams_After[insertAt:0])
			r.Moq.ResultsByParams_After[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_After(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_After_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_After_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_After_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqTime_genType_After_doFn
				DoReturnFn MoqTime_genType_After_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_After(params MoqTime_genType_After_params) string {
	return fmt.Sprintf("After(%#v)", params.U)
}

func (m *MoqTime_genType) ParamsKey_After(params MoqTime_genType_After_params, anyParams uint64) MoqTime_genType_After_paramsKey {
	m.Scene.T.Helper()
	var uUsed time.Time
	var uUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.After.U == moq.ParamIndexByValue {
			uUsed = params.U
		} else {
			uUsedHash = hash.DeepHash(params.U)
		}
	}
	return MoqTime_genType_After_paramsKey{
		Params: struct{ U time.Time }{
			U: uUsed,
		},
		Hashes: struct{ U hash.Hash }{
			U: uUsedHash,
		},
	}
}

func (m *MoqTime_genType_recorder) Before(u time.Time) *MoqTime_genType_Before_fnRecorder {
	return &MoqTime_genType_Before_fnRecorder{
		Params: MoqTime_genType_Before_params{
			U: u,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Before_fnRecorder) Any() *MoqTime_genType_Before_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Before(r.Params))
		return nil
	}
	return &MoqTime_genType_Before_anyParams{Recorder: r}
}

func (a *MoqTime_genType_Before_anyParams) U() *MoqTime_genType_Before_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTime_genType_Before_fnRecorder) Seq() *MoqTime_genType_Before_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Before(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Before_fnRecorder) NoSeq() *MoqTime_genType_Before_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Before(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Before_fnRecorder) ReturnResults(result1 bool) *MoqTime_genType_Before_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Before_doFn
		DoReturnFn MoqTime_genType_Before_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Before_fnRecorder) AndDo(fn MoqTime_genType_Before_doFn) *MoqTime_genType_Before_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Before_fnRecorder) DoReturnResults(fn MoqTime_genType_Before_doReturnFn) *MoqTime_genType_Before_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Before_doFn
		DoReturnFn MoqTime_genType_Before_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Before_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Before_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Before {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Before_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Before_paramsKey]*MoqTime_genType_Before_results{},
		}
		r.Moq.ResultsByParams_Before = append(r.Moq.ResultsByParams_Before, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Before) {
			copy(r.Moq.ResultsByParams_Before[insertAt+1:], r.Moq.ResultsByParams_Before[insertAt:0])
			r.Moq.ResultsByParams_Before[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Before(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Before_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Before_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Before_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Before_doFn
				DoReturnFn MoqTime_genType_Before_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Before(params MoqTime_genType_Before_params) string {
	return fmt.Sprintf("Before(%#v)", params.U)
}

func (m *MoqTime_genType) ParamsKey_Before(params MoqTime_genType_Before_params, anyParams uint64) MoqTime_genType_Before_paramsKey {
	m.Scene.T.Helper()
	var uUsed time.Time
	var uUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Before.U == moq.ParamIndexByValue {
			uUsed = params.U
		} else {
			uUsedHash = hash.DeepHash(params.U)
		}
	}
	return MoqTime_genType_Before_paramsKey{
		Params: struct{ U time.Time }{
			U: uUsed,
		},
		Hashes: struct{ U hash.Hash }{
			U: uUsedHash,
		},
	}
}

func (m *MoqTime_genType_recorder) Equal(u time.Time) *MoqTime_genType_Equal_fnRecorder {
	return &MoqTime_genType_Equal_fnRecorder{
		Params: MoqTime_genType_Equal_params{
			U: u,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Equal_fnRecorder) Any() *MoqTime_genType_Equal_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Equal(r.Params))
		return nil
	}
	return &MoqTime_genType_Equal_anyParams{Recorder: r}
}

func (a *MoqTime_genType_Equal_anyParams) U() *MoqTime_genType_Equal_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTime_genType_Equal_fnRecorder) Seq() *MoqTime_genType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Equal(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Equal_fnRecorder) NoSeq() *MoqTime_genType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Equal(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Equal_fnRecorder) ReturnResults(result1 bool) *MoqTime_genType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Equal_doFn
		DoReturnFn MoqTime_genType_Equal_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Equal_fnRecorder) AndDo(fn MoqTime_genType_Equal_doFn) *MoqTime_genType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Equal_fnRecorder) DoReturnResults(fn MoqTime_genType_Equal_doReturnFn) *MoqTime_genType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Equal_doFn
		DoReturnFn MoqTime_genType_Equal_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Equal_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Equal_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Equal {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Equal_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Equal_paramsKey]*MoqTime_genType_Equal_results{},
		}
		r.Moq.ResultsByParams_Equal = append(r.Moq.ResultsByParams_Equal, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Equal) {
			copy(r.Moq.ResultsByParams_Equal[insertAt+1:], r.Moq.ResultsByParams_Equal[insertAt:0])
			r.Moq.ResultsByParams_Equal[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Equal(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Equal_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Equal_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Equal_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Equal_doFn
				DoReturnFn MoqTime_genType_Equal_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Equal(params MoqTime_genType_Equal_params) string {
	return fmt.Sprintf("Equal(%#v)", params.U)
}

func (m *MoqTime_genType) ParamsKey_Equal(params MoqTime_genType_Equal_params, anyParams uint64) MoqTime_genType_Equal_paramsKey {
	m.Scene.T.Helper()
	var uUsed time.Time
	var uUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Equal.U == moq.ParamIndexByValue {
			uUsed = params.U
		} else {
			uUsedHash = hash.DeepHash(params.U)
		}
	}
	return MoqTime_genType_Equal_paramsKey{
		Params: struct{ U time.Time }{
			U: uUsed,
		},
		Hashes: struct{ U hash.Hash }{
			U: uUsedHash,
		},
	}
}

func (m *MoqTime_genType_recorder) IsZero() *MoqTime_genType_IsZero_fnRecorder {
	return &MoqTime_genType_IsZero_fnRecorder{
		Params:   MoqTime_genType_IsZero_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_IsZero_fnRecorder) Any() *MoqTime_genType_IsZero_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsZero(r.Params))
		return nil
	}
	return &MoqTime_genType_IsZero_anyParams{Recorder: r}
}

func (r *MoqTime_genType_IsZero_fnRecorder) Seq() *MoqTime_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsZero(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_IsZero_fnRecorder) NoSeq() *MoqTime_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_IsZero(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_IsZero_fnRecorder) ReturnResults(result1 bool) *MoqTime_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_IsZero_doFn
		DoReturnFn MoqTime_genType_IsZero_doReturnFn
	}{
		Values: &struct {
			Result1 bool
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_IsZero_fnRecorder) AndDo(fn MoqTime_genType_IsZero_doFn) *MoqTime_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_IsZero_fnRecorder) DoReturnResults(fn MoqTime_genType_IsZero_doReturnFn) *MoqTime_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 bool
		}
		Sequence   uint32
		DoFn       MoqTime_genType_IsZero_doFn
		DoReturnFn MoqTime_genType_IsZero_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_IsZero_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_IsZero_resultsByParams
	for n, res := range r.Moq.ResultsByParams_IsZero {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_IsZero_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_IsZero_paramsKey]*MoqTime_genType_IsZero_results{},
		}
		r.Moq.ResultsByParams_IsZero = append(r.Moq.ResultsByParams_IsZero, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_IsZero) {
			copy(r.Moq.ResultsByParams_IsZero[insertAt+1:], r.Moq.ResultsByParams_IsZero[insertAt:0])
			r.Moq.ResultsByParams_IsZero[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_IsZero(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_IsZero_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_IsZero_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_IsZero_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 bool
				}
				Sequence   uint32
				DoFn       MoqTime_genType_IsZero_doFn
				DoReturnFn MoqTime_genType_IsZero_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_IsZero(params MoqTime_genType_IsZero_params) string {
	return fmt.Sprintf("IsZero()")
}

func (m *MoqTime_genType) ParamsKey_IsZero(params MoqTime_genType_IsZero_params, anyParams uint64) MoqTime_genType_IsZero_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_IsZero_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Date() *MoqTime_genType_Date_fnRecorder {
	return &MoqTime_genType_Date_fnRecorder{
		Params:   MoqTime_genType_Date_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Date_fnRecorder) Any() *MoqTime_genType_Date_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Date(r.Params))
		return nil
	}
	return &MoqTime_genType_Date_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Date_fnRecorder) Seq() *MoqTime_genType_Date_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Date(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Date_fnRecorder) NoSeq() *MoqTime_genType_Date_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Date(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Date_fnRecorder) ReturnResults(year int, month time.Month, day int) *MoqTime_genType_Date_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Year  int
			Month time.Month
			Day   int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Date_doFn
		DoReturnFn MoqTime_genType_Date_doReturnFn
	}{
		Values: &struct {
			Year  int
			Month time.Month
			Day   int
		}{
			Year:  year,
			Month: month,
			Day:   day,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Date_fnRecorder) AndDo(fn MoqTime_genType_Date_doFn) *MoqTime_genType_Date_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Date_fnRecorder) DoReturnResults(fn MoqTime_genType_Date_doReturnFn) *MoqTime_genType_Date_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Year  int
			Month time.Month
			Day   int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Date_doFn
		DoReturnFn MoqTime_genType_Date_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Date_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Date_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Date {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Date_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Date_paramsKey]*MoqTime_genType_Date_results{},
		}
		r.Moq.ResultsByParams_Date = append(r.Moq.ResultsByParams_Date, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Date) {
			copy(r.Moq.ResultsByParams_Date[insertAt+1:], r.Moq.ResultsByParams_Date[insertAt:0])
			r.Moq.ResultsByParams_Date[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Date(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Date_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Date_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Date_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Year  int
					Month time.Month
					Day   int
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Date_doFn
				DoReturnFn MoqTime_genType_Date_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Date(params MoqTime_genType_Date_params) string {
	return fmt.Sprintf("Date()")
}

func (m *MoqTime_genType) ParamsKey_Date(params MoqTime_genType_Date_params, anyParams uint64) MoqTime_genType_Date_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Date_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Year() *MoqTime_genType_Year_fnRecorder {
	return &MoqTime_genType_Year_fnRecorder{
		Params:   MoqTime_genType_Year_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Year_fnRecorder) Any() *MoqTime_genType_Year_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Year(r.Params))
		return nil
	}
	return &MoqTime_genType_Year_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Year_fnRecorder) Seq() *MoqTime_genType_Year_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Year(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Year_fnRecorder) NoSeq() *MoqTime_genType_Year_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Year(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Year_fnRecorder) ReturnResults(result1 int) *MoqTime_genType_Year_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Year_doFn
		DoReturnFn MoqTime_genType_Year_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Year_fnRecorder) AndDo(fn MoqTime_genType_Year_doFn) *MoqTime_genType_Year_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Year_fnRecorder) DoReturnResults(fn MoqTime_genType_Year_doReturnFn) *MoqTime_genType_Year_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Year_doFn
		DoReturnFn MoqTime_genType_Year_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Year_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Year_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Year {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Year_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Year_paramsKey]*MoqTime_genType_Year_results{},
		}
		r.Moq.ResultsByParams_Year = append(r.Moq.ResultsByParams_Year, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Year) {
			copy(r.Moq.ResultsByParams_Year[insertAt+1:], r.Moq.ResultsByParams_Year[insertAt:0])
			r.Moq.ResultsByParams_Year[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Year(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Year_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Year_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Year_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Year_doFn
				DoReturnFn MoqTime_genType_Year_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Year(params MoqTime_genType_Year_params) string {
	return fmt.Sprintf("Year()")
}

func (m *MoqTime_genType) ParamsKey_Year(params MoqTime_genType_Year_params, anyParams uint64) MoqTime_genType_Year_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Year_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Month() *MoqTime_genType_Month_fnRecorder {
	return &MoqTime_genType_Month_fnRecorder{
		Params:   MoqTime_genType_Month_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Month_fnRecorder) Any() *MoqTime_genType_Month_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Month(r.Params))
		return nil
	}
	return &MoqTime_genType_Month_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Month_fnRecorder) Seq() *MoqTime_genType_Month_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Month(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Month_fnRecorder) NoSeq() *MoqTime_genType_Month_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Month(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Month_fnRecorder) ReturnResults(result1 time.Month) *MoqTime_genType_Month_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Month
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Month_doFn
		DoReturnFn MoqTime_genType_Month_doReturnFn
	}{
		Values: &struct {
			Result1 time.Month
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Month_fnRecorder) AndDo(fn MoqTime_genType_Month_doFn) *MoqTime_genType_Month_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Month_fnRecorder) DoReturnResults(fn MoqTime_genType_Month_doReturnFn) *MoqTime_genType_Month_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Month
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Month_doFn
		DoReturnFn MoqTime_genType_Month_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Month_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Month_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Month {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Month_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Month_paramsKey]*MoqTime_genType_Month_results{},
		}
		r.Moq.ResultsByParams_Month = append(r.Moq.ResultsByParams_Month, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Month) {
			copy(r.Moq.ResultsByParams_Month[insertAt+1:], r.Moq.ResultsByParams_Month[insertAt:0])
			r.Moq.ResultsByParams_Month[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Month(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Month_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Month_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Month_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 time.Month
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Month_doFn
				DoReturnFn MoqTime_genType_Month_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Month(params MoqTime_genType_Month_params) string {
	return fmt.Sprintf("Month()")
}

func (m *MoqTime_genType) ParamsKey_Month(params MoqTime_genType_Month_params, anyParams uint64) MoqTime_genType_Month_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Month_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Day() *MoqTime_genType_Day_fnRecorder {
	return &MoqTime_genType_Day_fnRecorder{
		Params:   MoqTime_genType_Day_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Day_fnRecorder) Any() *MoqTime_genType_Day_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Day(r.Params))
		return nil
	}
	return &MoqTime_genType_Day_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Day_fnRecorder) Seq() *MoqTime_genType_Day_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Day(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Day_fnRecorder) NoSeq() *MoqTime_genType_Day_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Day(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Day_fnRecorder) ReturnResults(result1 int) *MoqTime_genType_Day_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Day_doFn
		DoReturnFn MoqTime_genType_Day_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Day_fnRecorder) AndDo(fn MoqTime_genType_Day_doFn) *MoqTime_genType_Day_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Day_fnRecorder) DoReturnResults(fn MoqTime_genType_Day_doReturnFn) *MoqTime_genType_Day_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Day_doFn
		DoReturnFn MoqTime_genType_Day_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Day_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Day_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Day {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Day_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Day_paramsKey]*MoqTime_genType_Day_results{},
		}
		r.Moq.ResultsByParams_Day = append(r.Moq.ResultsByParams_Day, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Day) {
			copy(r.Moq.ResultsByParams_Day[insertAt+1:], r.Moq.ResultsByParams_Day[insertAt:0])
			r.Moq.ResultsByParams_Day[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Day(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Day_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Day_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Day_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Day_doFn
				DoReturnFn MoqTime_genType_Day_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Day(params MoqTime_genType_Day_params) string {
	return fmt.Sprintf("Day()")
}

func (m *MoqTime_genType) ParamsKey_Day(params MoqTime_genType_Day_params, anyParams uint64) MoqTime_genType_Day_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Day_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Weekday() *MoqTime_genType_Weekday_fnRecorder {
	return &MoqTime_genType_Weekday_fnRecorder{
		Params:   MoqTime_genType_Weekday_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Weekday_fnRecorder) Any() *MoqTime_genType_Weekday_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Weekday(r.Params))
		return nil
	}
	return &MoqTime_genType_Weekday_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Weekday_fnRecorder) Seq() *MoqTime_genType_Weekday_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Weekday(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Weekday_fnRecorder) NoSeq() *MoqTime_genType_Weekday_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Weekday(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Weekday_fnRecorder) ReturnResults(result1 time.Weekday) *MoqTime_genType_Weekday_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Weekday
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Weekday_doFn
		DoReturnFn MoqTime_genType_Weekday_doReturnFn
	}{
		Values: &struct {
			Result1 time.Weekday
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Weekday_fnRecorder) AndDo(fn MoqTime_genType_Weekday_doFn) *MoqTime_genType_Weekday_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Weekday_fnRecorder) DoReturnResults(fn MoqTime_genType_Weekday_doReturnFn) *MoqTime_genType_Weekday_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Weekday
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Weekday_doFn
		DoReturnFn MoqTime_genType_Weekday_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Weekday_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Weekday_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Weekday {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Weekday_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Weekday_paramsKey]*MoqTime_genType_Weekday_results{},
		}
		r.Moq.ResultsByParams_Weekday = append(r.Moq.ResultsByParams_Weekday, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Weekday) {
			copy(r.Moq.ResultsByParams_Weekday[insertAt+1:], r.Moq.ResultsByParams_Weekday[insertAt:0])
			r.Moq.ResultsByParams_Weekday[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Weekday(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Weekday_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Weekday_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Weekday_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 time.Weekday
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Weekday_doFn
				DoReturnFn MoqTime_genType_Weekday_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Weekday(params MoqTime_genType_Weekday_params) string {
	return fmt.Sprintf("Weekday()")
}

func (m *MoqTime_genType) ParamsKey_Weekday(params MoqTime_genType_Weekday_params, anyParams uint64) MoqTime_genType_Weekday_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Weekday_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) ISOWeek() *MoqTime_genType_ISOWeek_fnRecorder {
	return &MoqTime_genType_ISOWeek_fnRecorder{
		Params:   MoqTime_genType_ISOWeek_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_ISOWeek_fnRecorder) Any() *MoqTime_genType_ISOWeek_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ISOWeek(r.Params))
		return nil
	}
	return &MoqTime_genType_ISOWeek_anyParams{Recorder: r}
}

func (r *MoqTime_genType_ISOWeek_fnRecorder) Seq() *MoqTime_genType_ISOWeek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ISOWeek(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_ISOWeek_fnRecorder) NoSeq() *MoqTime_genType_ISOWeek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ISOWeek(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_ISOWeek_fnRecorder) ReturnResults(year, week int) *MoqTime_genType_ISOWeek_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Year, Week int }
		Sequence   uint32
		DoFn       MoqTime_genType_ISOWeek_doFn
		DoReturnFn MoqTime_genType_ISOWeek_doReturnFn
	}{
		Values: &struct{ Year, Week int }{
			Year: year,
			Week: week,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_ISOWeek_fnRecorder) AndDo(fn MoqTime_genType_ISOWeek_doFn) *MoqTime_genType_ISOWeek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_ISOWeek_fnRecorder) DoReturnResults(fn MoqTime_genType_ISOWeek_doReturnFn) *MoqTime_genType_ISOWeek_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Year, Week int }
		Sequence   uint32
		DoFn       MoqTime_genType_ISOWeek_doFn
		DoReturnFn MoqTime_genType_ISOWeek_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_ISOWeek_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_ISOWeek_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ISOWeek {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_ISOWeek_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_ISOWeek_paramsKey]*MoqTime_genType_ISOWeek_results{},
		}
		r.Moq.ResultsByParams_ISOWeek = append(r.Moq.ResultsByParams_ISOWeek, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ISOWeek) {
			copy(r.Moq.ResultsByParams_ISOWeek[insertAt+1:], r.Moq.ResultsByParams_ISOWeek[insertAt:0])
			r.Moq.ResultsByParams_ISOWeek[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ISOWeek(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_ISOWeek_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_ISOWeek_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_ISOWeek_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Year, Week int }
				Sequence   uint32
				DoFn       MoqTime_genType_ISOWeek_doFn
				DoReturnFn MoqTime_genType_ISOWeek_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_ISOWeek(params MoqTime_genType_ISOWeek_params) string {
	return fmt.Sprintf("ISOWeek()")
}

func (m *MoqTime_genType) ParamsKey_ISOWeek(params MoqTime_genType_ISOWeek_params, anyParams uint64) MoqTime_genType_ISOWeek_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_ISOWeek_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Clock() *MoqTime_genType_Clock_fnRecorder {
	return &MoqTime_genType_Clock_fnRecorder{
		Params:   MoqTime_genType_Clock_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Clock_fnRecorder) Any() *MoqTime_genType_Clock_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Clock(r.Params))
		return nil
	}
	return &MoqTime_genType_Clock_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Clock_fnRecorder) Seq() *MoqTime_genType_Clock_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Clock(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Clock_fnRecorder) NoSeq() *MoqTime_genType_Clock_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Clock(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Clock_fnRecorder) ReturnResults(hour, min, sec int) *MoqTime_genType_Clock_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Hour, Min, Sec int }
		Sequence   uint32
		DoFn       MoqTime_genType_Clock_doFn
		DoReturnFn MoqTime_genType_Clock_doReturnFn
	}{
		Values: &struct{ Hour, Min, Sec int }{
			Hour: hour,
			Min:  min,
			Sec:  sec,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Clock_fnRecorder) AndDo(fn MoqTime_genType_Clock_doFn) *MoqTime_genType_Clock_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Clock_fnRecorder) DoReturnResults(fn MoqTime_genType_Clock_doReturnFn) *MoqTime_genType_Clock_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{ Hour, Min, Sec int }
		Sequence   uint32
		DoFn       MoqTime_genType_Clock_doFn
		DoReturnFn MoqTime_genType_Clock_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Clock_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Clock_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Clock {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Clock_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Clock_paramsKey]*MoqTime_genType_Clock_results{},
		}
		r.Moq.ResultsByParams_Clock = append(r.Moq.ResultsByParams_Clock, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Clock) {
			copy(r.Moq.ResultsByParams_Clock[insertAt+1:], r.Moq.ResultsByParams_Clock[insertAt:0])
			r.Moq.ResultsByParams_Clock[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Clock(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Clock_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Clock_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Clock_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{ Hour, Min, Sec int }
				Sequence   uint32
				DoFn       MoqTime_genType_Clock_doFn
				DoReturnFn MoqTime_genType_Clock_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Clock(params MoqTime_genType_Clock_params) string {
	return fmt.Sprintf("Clock()")
}

func (m *MoqTime_genType) ParamsKey_Clock(params MoqTime_genType_Clock_params, anyParams uint64) MoqTime_genType_Clock_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Clock_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Hour() *MoqTime_genType_Hour_fnRecorder {
	return &MoqTime_genType_Hour_fnRecorder{
		Params:   MoqTime_genType_Hour_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Hour_fnRecorder) Any() *MoqTime_genType_Hour_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Hour(r.Params))
		return nil
	}
	return &MoqTime_genType_Hour_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Hour_fnRecorder) Seq() *MoqTime_genType_Hour_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Hour(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Hour_fnRecorder) NoSeq() *MoqTime_genType_Hour_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Hour(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Hour_fnRecorder) ReturnResults(result1 int) *MoqTime_genType_Hour_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Hour_doFn
		DoReturnFn MoqTime_genType_Hour_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Hour_fnRecorder) AndDo(fn MoqTime_genType_Hour_doFn) *MoqTime_genType_Hour_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Hour_fnRecorder) DoReturnResults(fn MoqTime_genType_Hour_doReturnFn) *MoqTime_genType_Hour_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Hour_doFn
		DoReturnFn MoqTime_genType_Hour_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Hour_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Hour_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Hour {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Hour_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Hour_paramsKey]*MoqTime_genType_Hour_results{},
		}
		r.Moq.ResultsByParams_Hour = append(r.Moq.ResultsByParams_Hour, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Hour) {
			copy(r.Moq.ResultsByParams_Hour[insertAt+1:], r.Moq.ResultsByParams_Hour[insertAt:0])
			r.Moq.ResultsByParams_Hour[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Hour(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Hour_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Hour_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Hour_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Hour_doFn
				DoReturnFn MoqTime_genType_Hour_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Hour(params MoqTime_genType_Hour_params) string {
	return fmt.Sprintf("Hour()")
}

func (m *MoqTime_genType) ParamsKey_Hour(params MoqTime_genType_Hour_params, anyParams uint64) MoqTime_genType_Hour_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Hour_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Minute() *MoqTime_genType_Minute_fnRecorder {
	return &MoqTime_genType_Minute_fnRecorder{
		Params:   MoqTime_genType_Minute_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Minute_fnRecorder) Any() *MoqTime_genType_Minute_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Minute(r.Params))
		return nil
	}
	return &MoqTime_genType_Minute_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Minute_fnRecorder) Seq() *MoqTime_genType_Minute_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Minute(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Minute_fnRecorder) NoSeq() *MoqTime_genType_Minute_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Minute(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Minute_fnRecorder) ReturnResults(result1 int) *MoqTime_genType_Minute_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Minute_doFn
		DoReturnFn MoqTime_genType_Minute_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Minute_fnRecorder) AndDo(fn MoqTime_genType_Minute_doFn) *MoqTime_genType_Minute_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Minute_fnRecorder) DoReturnResults(fn MoqTime_genType_Minute_doReturnFn) *MoqTime_genType_Minute_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Minute_doFn
		DoReturnFn MoqTime_genType_Minute_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Minute_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Minute_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Minute {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Minute_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Minute_paramsKey]*MoqTime_genType_Minute_results{},
		}
		r.Moq.ResultsByParams_Minute = append(r.Moq.ResultsByParams_Minute, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Minute) {
			copy(r.Moq.ResultsByParams_Minute[insertAt+1:], r.Moq.ResultsByParams_Minute[insertAt:0])
			r.Moq.ResultsByParams_Minute[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Minute(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Minute_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Minute_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Minute_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Minute_doFn
				DoReturnFn MoqTime_genType_Minute_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Minute(params MoqTime_genType_Minute_params) string {
	return fmt.Sprintf("Minute()")
}

func (m *MoqTime_genType) ParamsKey_Minute(params MoqTime_genType_Minute_params, anyParams uint64) MoqTime_genType_Minute_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Minute_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Second() *MoqTime_genType_Second_fnRecorder {
	return &MoqTime_genType_Second_fnRecorder{
		Params:   MoqTime_genType_Second_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Second_fnRecorder) Any() *MoqTime_genType_Second_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Second(r.Params))
		return nil
	}
	return &MoqTime_genType_Second_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Second_fnRecorder) Seq() *MoqTime_genType_Second_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Second(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Second_fnRecorder) NoSeq() *MoqTime_genType_Second_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Second(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Second_fnRecorder) ReturnResults(result1 int) *MoqTime_genType_Second_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Second_doFn
		DoReturnFn MoqTime_genType_Second_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Second_fnRecorder) AndDo(fn MoqTime_genType_Second_doFn) *MoqTime_genType_Second_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Second_fnRecorder) DoReturnResults(fn MoqTime_genType_Second_doReturnFn) *MoqTime_genType_Second_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Second_doFn
		DoReturnFn MoqTime_genType_Second_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Second_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Second_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Second {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Second_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Second_paramsKey]*MoqTime_genType_Second_results{},
		}
		r.Moq.ResultsByParams_Second = append(r.Moq.ResultsByParams_Second, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Second) {
			copy(r.Moq.ResultsByParams_Second[insertAt+1:], r.Moq.ResultsByParams_Second[insertAt:0])
			r.Moq.ResultsByParams_Second[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Second(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Second_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Second_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Second_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Second_doFn
				DoReturnFn MoqTime_genType_Second_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Second(params MoqTime_genType_Second_params) string {
	return fmt.Sprintf("Second()")
}

func (m *MoqTime_genType) ParamsKey_Second(params MoqTime_genType_Second_params, anyParams uint64) MoqTime_genType_Second_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Second_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Nanosecond() *MoqTime_genType_Nanosecond_fnRecorder {
	return &MoqTime_genType_Nanosecond_fnRecorder{
		Params:   MoqTime_genType_Nanosecond_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Nanosecond_fnRecorder) Any() *MoqTime_genType_Nanosecond_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Nanosecond(r.Params))
		return nil
	}
	return &MoqTime_genType_Nanosecond_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Nanosecond_fnRecorder) Seq() *MoqTime_genType_Nanosecond_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Nanosecond(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Nanosecond_fnRecorder) NoSeq() *MoqTime_genType_Nanosecond_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Nanosecond(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Nanosecond_fnRecorder) ReturnResults(result1 int) *MoqTime_genType_Nanosecond_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Nanosecond_doFn
		DoReturnFn MoqTime_genType_Nanosecond_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Nanosecond_fnRecorder) AndDo(fn MoqTime_genType_Nanosecond_doFn) *MoqTime_genType_Nanosecond_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Nanosecond_fnRecorder) DoReturnResults(fn MoqTime_genType_Nanosecond_doReturnFn) *MoqTime_genType_Nanosecond_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Nanosecond_doFn
		DoReturnFn MoqTime_genType_Nanosecond_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Nanosecond_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Nanosecond_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Nanosecond {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Nanosecond_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Nanosecond_paramsKey]*MoqTime_genType_Nanosecond_results{},
		}
		r.Moq.ResultsByParams_Nanosecond = append(r.Moq.ResultsByParams_Nanosecond, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Nanosecond) {
			copy(r.Moq.ResultsByParams_Nanosecond[insertAt+1:], r.Moq.ResultsByParams_Nanosecond[insertAt:0])
			r.Moq.ResultsByParams_Nanosecond[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Nanosecond(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Nanosecond_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Nanosecond_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Nanosecond_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Nanosecond_doFn
				DoReturnFn MoqTime_genType_Nanosecond_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Nanosecond(params MoqTime_genType_Nanosecond_params) string {
	return fmt.Sprintf("Nanosecond()")
}

func (m *MoqTime_genType) ParamsKey_Nanosecond(params MoqTime_genType_Nanosecond_params, anyParams uint64) MoqTime_genType_Nanosecond_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Nanosecond_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) YearDay() *MoqTime_genType_YearDay_fnRecorder {
	return &MoqTime_genType_YearDay_fnRecorder{
		Params:   MoqTime_genType_YearDay_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_YearDay_fnRecorder) Any() *MoqTime_genType_YearDay_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_YearDay(r.Params))
		return nil
	}
	return &MoqTime_genType_YearDay_anyParams{Recorder: r}
}

func (r *MoqTime_genType_YearDay_fnRecorder) Seq() *MoqTime_genType_YearDay_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_YearDay(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_YearDay_fnRecorder) NoSeq() *MoqTime_genType_YearDay_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_YearDay(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_YearDay_fnRecorder) ReturnResults(result1 int) *MoqTime_genType_YearDay_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_YearDay_doFn
		DoReturnFn MoqTime_genType_YearDay_doReturnFn
	}{
		Values: &struct {
			Result1 int
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_YearDay_fnRecorder) AndDo(fn MoqTime_genType_YearDay_doFn) *MoqTime_genType_YearDay_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_YearDay_fnRecorder) DoReturnResults(fn MoqTime_genType_YearDay_doReturnFn) *MoqTime_genType_YearDay_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_YearDay_doFn
		DoReturnFn MoqTime_genType_YearDay_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_YearDay_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_YearDay_resultsByParams
	for n, res := range r.Moq.ResultsByParams_YearDay {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_YearDay_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_YearDay_paramsKey]*MoqTime_genType_YearDay_results{},
		}
		r.Moq.ResultsByParams_YearDay = append(r.Moq.ResultsByParams_YearDay, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_YearDay) {
			copy(r.Moq.ResultsByParams_YearDay[insertAt+1:], r.Moq.ResultsByParams_YearDay[insertAt:0])
			r.Moq.ResultsByParams_YearDay[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_YearDay(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_YearDay_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_YearDay_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_YearDay_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int
				}
				Sequence   uint32
				DoFn       MoqTime_genType_YearDay_doFn
				DoReturnFn MoqTime_genType_YearDay_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_YearDay(params MoqTime_genType_YearDay_params) string {
	return fmt.Sprintf("YearDay()")
}

func (m *MoqTime_genType) ParamsKey_YearDay(params MoqTime_genType_YearDay_params, anyParams uint64) MoqTime_genType_YearDay_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_YearDay_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Add(d time.Duration) *MoqTime_genType_Add_fnRecorder {
	return &MoqTime_genType_Add_fnRecorder{
		Params: MoqTime_genType_Add_params{
			D: d,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Add_fnRecorder) Any() *MoqTime_genType_Add_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	return &MoqTime_genType_Add_anyParams{Recorder: r}
}

func (a *MoqTime_genType_Add_anyParams) D() *MoqTime_genType_Add_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTime_genType_Add_fnRecorder) Seq() *MoqTime_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Add_fnRecorder) NoSeq() *MoqTime_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Add(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Add_fnRecorder) ReturnResults(result1 time.Time) *MoqTime_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Add_doFn
		DoReturnFn MoqTime_genType_Add_doReturnFn
	}{
		Values: &struct {
			Result1 time.Time
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Add_fnRecorder) AndDo(fn MoqTime_genType_Add_doFn) *MoqTime_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Add_fnRecorder) DoReturnResults(fn MoqTime_genType_Add_doReturnFn) *MoqTime_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Add_doFn
		DoReturnFn MoqTime_genType_Add_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Add_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Add_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Add {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Add_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Add_paramsKey]*MoqTime_genType_Add_results{},
		}
		r.Moq.ResultsByParams_Add = append(r.Moq.ResultsByParams_Add, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Add) {
			copy(r.Moq.ResultsByParams_Add[insertAt+1:], r.Moq.ResultsByParams_Add[insertAt:0])
			r.Moq.ResultsByParams_Add[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Add(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Add_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Add_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Add_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 time.Time
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Add_doFn
				DoReturnFn MoqTime_genType_Add_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Add(params MoqTime_genType_Add_params) string {
	return fmt.Sprintf("Add(%#v)", params.D)
}

func (m *MoqTime_genType) ParamsKey_Add(params MoqTime_genType_Add_params, anyParams uint64) MoqTime_genType_Add_paramsKey {
	m.Scene.T.Helper()
	var dUsed time.Duration
	var dUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Add.D == moq.ParamIndexByValue {
			dUsed = params.D
		} else {
			dUsedHash = hash.DeepHash(params.D)
		}
	}
	return MoqTime_genType_Add_paramsKey{
		Params: struct{ D time.Duration }{
			D: dUsed,
		},
		Hashes: struct{ D hash.Hash }{
			D: dUsedHash,
		},
	}
}

func (m *MoqTime_genType_recorder) Sub(u time.Time) *MoqTime_genType_Sub_fnRecorder {
	return &MoqTime_genType_Sub_fnRecorder{
		Params: MoqTime_genType_Sub_params{
			U: u,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Sub_fnRecorder) Any() *MoqTime_genType_Sub_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	return &MoqTime_genType_Sub_anyParams{Recorder: r}
}

func (a *MoqTime_genType_Sub_anyParams) U() *MoqTime_genType_Sub_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTime_genType_Sub_fnRecorder) Seq() *MoqTime_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Sub_fnRecorder) NoSeq() *MoqTime_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Sub(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Sub_fnRecorder) ReturnResults(result1 time.Duration) *MoqTime_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Duration
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Sub_doFn
		DoReturnFn MoqTime_genType_Sub_doReturnFn
	}{
		Values: &struct {
			Result1 time.Duration
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Sub_fnRecorder) AndDo(fn MoqTime_genType_Sub_doFn) *MoqTime_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Sub_fnRecorder) DoReturnResults(fn MoqTime_genType_Sub_doReturnFn) *MoqTime_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Duration
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Sub_doFn
		DoReturnFn MoqTime_genType_Sub_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Sub_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Sub_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Sub {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Sub_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Sub_paramsKey]*MoqTime_genType_Sub_results{},
		}
		r.Moq.ResultsByParams_Sub = append(r.Moq.ResultsByParams_Sub, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Sub) {
			copy(r.Moq.ResultsByParams_Sub[insertAt+1:], r.Moq.ResultsByParams_Sub[insertAt:0])
			r.Moq.ResultsByParams_Sub[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Sub(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Sub_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Sub_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Sub_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 time.Duration
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Sub_doFn
				DoReturnFn MoqTime_genType_Sub_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Sub(params MoqTime_genType_Sub_params) string {
	return fmt.Sprintf("Sub(%#v)", params.U)
}

func (m *MoqTime_genType) ParamsKey_Sub(params MoqTime_genType_Sub_params, anyParams uint64) MoqTime_genType_Sub_paramsKey {
	m.Scene.T.Helper()
	var uUsed time.Time
	var uUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Sub.U == moq.ParamIndexByValue {
			uUsed = params.U
		} else {
			uUsedHash = hash.DeepHash(params.U)
		}
	}
	return MoqTime_genType_Sub_paramsKey{
		Params: struct{ U time.Time }{
			U: uUsed,
		},
		Hashes: struct{ U hash.Hash }{
			U: uUsedHash,
		},
	}
}

func (m *MoqTime_genType_recorder) AddDate(years int, months int, days int) *MoqTime_genType_AddDate_fnRecorder {
	return &MoqTime_genType_AddDate_fnRecorder{
		Params: MoqTime_genType_AddDate_params{
			Years:  years,
			Months: months,
			Days:   days,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_AddDate_fnRecorder) Any() *MoqTime_genType_AddDate_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddDate(r.Params))
		return nil
	}
	return &MoqTime_genType_AddDate_anyParams{Recorder: r}
}

func (a *MoqTime_genType_AddDate_anyParams) Years() *MoqTime_genType_AddDate_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (a *MoqTime_genType_AddDate_anyParams) Months() *MoqTime_genType_AddDate_fnRecorder {
	a.Recorder.AnyParams |= 1 << 1
	return a.Recorder
}

func (a *MoqTime_genType_AddDate_anyParams) Days() *MoqTime_genType_AddDate_fnRecorder {
	a.Recorder.AnyParams |= 1 << 2
	return a.Recorder
}

func (r *MoqTime_genType_AddDate_fnRecorder) Seq() *MoqTime_genType_AddDate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddDate(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_AddDate_fnRecorder) NoSeq() *MoqTime_genType_AddDate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_AddDate(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_AddDate_fnRecorder) ReturnResults(result1 time.Time) *MoqTime_genType_AddDate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_AddDate_doFn
		DoReturnFn MoqTime_genType_AddDate_doReturnFn
	}{
		Values: &struct {
			Result1 time.Time
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_AddDate_fnRecorder) AndDo(fn MoqTime_genType_AddDate_doFn) *MoqTime_genType_AddDate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_AddDate_fnRecorder) DoReturnResults(fn MoqTime_genType_AddDate_doReturnFn) *MoqTime_genType_AddDate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_AddDate_doFn
		DoReturnFn MoqTime_genType_AddDate_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_AddDate_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_AddDate_resultsByParams
	for n, res := range r.Moq.ResultsByParams_AddDate {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_AddDate_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_AddDate_paramsKey]*MoqTime_genType_AddDate_results{},
		}
		r.Moq.ResultsByParams_AddDate = append(r.Moq.ResultsByParams_AddDate, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_AddDate) {
			copy(r.Moq.ResultsByParams_AddDate[insertAt+1:], r.Moq.ResultsByParams_AddDate[insertAt:0])
			r.Moq.ResultsByParams_AddDate[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_AddDate(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_AddDate_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_AddDate_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_AddDate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 time.Time
				}
				Sequence   uint32
				DoFn       MoqTime_genType_AddDate_doFn
				DoReturnFn MoqTime_genType_AddDate_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_AddDate(params MoqTime_genType_AddDate_params) string {
	return fmt.Sprintf("AddDate(%#v, %#v, %#v)", params.Years, params.Months, params.Days)
}

func (m *MoqTime_genType) ParamsKey_AddDate(params MoqTime_genType_AddDate_params, anyParams uint64) MoqTime_genType_AddDate_paramsKey {
	m.Scene.T.Helper()
	var yearsUsed int
	var yearsUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.AddDate.Years == moq.ParamIndexByValue {
			yearsUsed = params.Years
		} else {
			yearsUsedHash = hash.DeepHash(params.Years)
		}
	}
	var monthsUsed int
	var monthsUsedHash hash.Hash
	if anyParams&(1<<1) == 0 {
		if m.Runtime.ParameterIndexing.AddDate.Months == moq.ParamIndexByValue {
			monthsUsed = params.Months
		} else {
			monthsUsedHash = hash.DeepHash(params.Months)
		}
	}
	var daysUsed int
	var daysUsedHash hash.Hash
	if anyParams&(1<<2) == 0 {
		if m.Runtime.ParameterIndexing.AddDate.Days == moq.ParamIndexByValue {
			daysUsed = params.Days
		} else {
			daysUsedHash = hash.DeepHash(params.Days)
		}
	}
	return MoqTime_genType_AddDate_paramsKey{
		Params: struct {
			Years  int
			Months int
			Days   int
		}{
			Years:  yearsUsed,
			Months: monthsUsed,
			Days:   daysUsed,
		},
		Hashes: struct {
			Years  hash.Hash
			Months hash.Hash
			Days   hash.Hash
		}{
			Years:  yearsUsedHash,
			Months: monthsUsedHash,
			Days:   daysUsedHash,
		},
	}
}

func (m *MoqTime_genType_recorder) UTC() *MoqTime_genType_UTC_fnRecorder {
	return &MoqTime_genType_UTC_fnRecorder{
		Params:   MoqTime_genType_UTC_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_UTC_fnRecorder) Any() *MoqTime_genType_UTC_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UTC(r.Params))
		return nil
	}
	return &MoqTime_genType_UTC_anyParams{Recorder: r}
}

func (r *MoqTime_genType_UTC_fnRecorder) Seq() *MoqTime_genType_UTC_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UTC(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_UTC_fnRecorder) NoSeq() *MoqTime_genType_UTC_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UTC(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_UTC_fnRecorder) ReturnResults(result1 time.Time) *MoqTime_genType_UTC_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_UTC_doFn
		DoReturnFn MoqTime_genType_UTC_doReturnFn
	}{
		Values: &struct {
			Result1 time.Time
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_UTC_fnRecorder) AndDo(fn MoqTime_genType_UTC_doFn) *MoqTime_genType_UTC_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_UTC_fnRecorder) DoReturnResults(fn MoqTime_genType_UTC_doReturnFn) *MoqTime_genType_UTC_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_UTC_doFn
		DoReturnFn MoqTime_genType_UTC_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_UTC_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_UTC_resultsByParams
	for n, res := range r.Moq.ResultsByParams_UTC {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_UTC_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_UTC_paramsKey]*MoqTime_genType_UTC_results{},
		}
		r.Moq.ResultsByParams_UTC = append(r.Moq.ResultsByParams_UTC, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_UTC) {
			copy(r.Moq.ResultsByParams_UTC[insertAt+1:], r.Moq.ResultsByParams_UTC[insertAt:0])
			r.Moq.ResultsByParams_UTC[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_UTC(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_UTC_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_UTC_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_UTC_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 time.Time
				}
				Sequence   uint32
				DoFn       MoqTime_genType_UTC_doFn
				DoReturnFn MoqTime_genType_UTC_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_UTC(params MoqTime_genType_UTC_params) string {
	return fmt.Sprintf("UTC()")
}

func (m *MoqTime_genType) ParamsKey_UTC(params MoqTime_genType_UTC_params, anyParams uint64) MoqTime_genType_UTC_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_UTC_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Local() *MoqTime_genType_Local_fnRecorder {
	return &MoqTime_genType_Local_fnRecorder{
		Params:   MoqTime_genType_Local_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Local_fnRecorder) Any() *MoqTime_genType_Local_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Local(r.Params))
		return nil
	}
	return &MoqTime_genType_Local_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Local_fnRecorder) Seq() *MoqTime_genType_Local_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Local(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Local_fnRecorder) NoSeq() *MoqTime_genType_Local_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Local(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Local_fnRecorder) ReturnResults(result1 time.Time) *MoqTime_genType_Local_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Local_doFn
		DoReturnFn MoqTime_genType_Local_doReturnFn
	}{
		Values: &struct {
			Result1 time.Time
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Local_fnRecorder) AndDo(fn MoqTime_genType_Local_doFn) *MoqTime_genType_Local_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Local_fnRecorder) DoReturnResults(fn MoqTime_genType_Local_doReturnFn) *MoqTime_genType_Local_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Local_doFn
		DoReturnFn MoqTime_genType_Local_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Local_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Local_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Local {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Local_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Local_paramsKey]*MoqTime_genType_Local_results{},
		}
		r.Moq.ResultsByParams_Local = append(r.Moq.ResultsByParams_Local, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Local) {
			copy(r.Moq.ResultsByParams_Local[insertAt+1:], r.Moq.ResultsByParams_Local[insertAt:0])
			r.Moq.ResultsByParams_Local[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Local(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Local_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Local_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Local_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 time.Time
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Local_doFn
				DoReturnFn MoqTime_genType_Local_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Local(params MoqTime_genType_Local_params) string {
	return fmt.Sprintf("Local()")
}

func (m *MoqTime_genType) ParamsKey_Local(params MoqTime_genType_Local_params, anyParams uint64) MoqTime_genType_Local_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Local_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) In(loc *time.Location) *MoqTime_genType_In_fnRecorder {
	return &MoqTime_genType_In_fnRecorder{
		Params: MoqTime_genType_In_params{
			Loc: loc,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_In_fnRecorder) Any() *MoqTime_genType_In_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_In(r.Params))
		return nil
	}
	return &MoqTime_genType_In_anyParams{Recorder: r}
}

func (a *MoqTime_genType_In_anyParams) Loc() *MoqTime_genType_In_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTime_genType_In_fnRecorder) Seq() *MoqTime_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_In(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_In_fnRecorder) NoSeq() *MoqTime_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_In(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_In_fnRecorder) ReturnResults(result1 time.Time) *MoqTime_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_In_doFn
		DoReturnFn MoqTime_genType_In_doReturnFn
	}{
		Values: &struct {
			Result1 time.Time
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_In_fnRecorder) AndDo(fn MoqTime_genType_In_doFn) *MoqTime_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_In_fnRecorder) DoReturnResults(fn MoqTime_genType_In_doReturnFn) *MoqTime_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_In_doFn
		DoReturnFn MoqTime_genType_In_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_In_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_In_resultsByParams
	for n, res := range r.Moq.ResultsByParams_In {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_In_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_In_paramsKey]*MoqTime_genType_In_results{},
		}
		r.Moq.ResultsByParams_In = append(r.Moq.ResultsByParams_In, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_In) {
			copy(r.Moq.ResultsByParams_In[insertAt+1:], r.Moq.ResultsByParams_In[insertAt:0])
			r.Moq.ResultsByParams_In[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_In(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_In_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_In_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_In_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 time.Time
				}
				Sequence   uint32
				DoFn       MoqTime_genType_In_doFn
				DoReturnFn MoqTime_genType_In_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_In(params MoqTime_genType_In_params) string {
	return fmt.Sprintf("In(%#v)", params.Loc)
}

func (m *MoqTime_genType) ParamsKey_In(params MoqTime_genType_In_params, anyParams uint64) MoqTime_genType_In_paramsKey {
	m.Scene.T.Helper()
	var locUsed *time.Location
	var locUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.In.Loc == moq.ParamIndexByValue {
			locUsed = params.Loc
		} else {
			locUsedHash = hash.DeepHash(params.Loc)
		}
	}
	return MoqTime_genType_In_paramsKey{
		Params: struct{ Loc *time.Location }{
			Loc: locUsed,
		},
		Hashes: struct{ Loc hash.Hash }{
			Loc: locUsedHash,
		},
	}
}

func (m *MoqTime_genType_recorder) Location() *MoqTime_genType_Location_fnRecorder {
	return &MoqTime_genType_Location_fnRecorder{
		Params:   MoqTime_genType_Location_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Location_fnRecorder) Any() *MoqTime_genType_Location_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Location(r.Params))
		return nil
	}
	return &MoqTime_genType_Location_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Location_fnRecorder) Seq() *MoqTime_genType_Location_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Location(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Location_fnRecorder) NoSeq() *MoqTime_genType_Location_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Location(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Location_fnRecorder) ReturnResults(result1 *time.Location) *MoqTime_genType_Location_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *time.Location
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Location_doFn
		DoReturnFn MoqTime_genType_Location_doReturnFn
	}{
		Values: &struct {
			Result1 *time.Location
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Location_fnRecorder) AndDo(fn MoqTime_genType_Location_doFn) *MoqTime_genType_Location_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Location_fnRecorder) DoReturnResults(fn MoqTime_genType_Location_doReturnFn) *MoqTime_genType_Location_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 *time.Location
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Location_doFn
		DoReturnFn MoqTime_genType_Location_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Location_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Location_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Location {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Location_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Location_paramsKey]*MoqTime_genType_Location_results{},
		}
		r.Moq.ResultsByParams_Location = append(r.Moq.ResultsByParams_Location, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Location) {
			copy(r.Moq.ResultsByParams_Location[insertAt+1:], r.Moq.ResultsByParams_Location[insertAt:0])
			r.Moq.ResultsByParams_Location[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Location(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Location_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Location_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Location_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 *time.Location
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Location_doFn
				DoReturnFn MoqTime_genType_Location_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Location(params MoqTime_genType_Location_params) string {
	return fmt.Sprintf("Location()")
}

func (m *MoqTime_genType) ParamsKey_Location(params MoqTime_genType_Location_params, anyParams uint64) MoqTime_genType_Location_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Location_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Zone() *MoqTime_genType_Zone_fnRecorder {
	return &MoqTime_genType_Zone_fnRecorder{
		Params:   MoqTime_genType_Zone_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Zone_fnRecorder) Any() *MoqTime_genType_Zone_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Zone(r.Params))
		return nil
	}
	return &MoqTime_genType_Zone_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Zone_fnRecorder) Seq() *MoqTime_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Zone(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Zone_fnRecorder) NoSeq() *MoqTime_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Zone(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Zone_fnRecorder) ReturnResults(name string, offset int) *MoqTime_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Name   string
			Offset int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Zone_doFn
		DoReturnFn MoqTime_genType_Zone_doReturnFn
	}{
		Values: &struct {
			Name   string
			Offset int
		}{
			Name:   name,
			Offset: offset,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Zone_fnRecorder) AndDo(fn MoqTime_genType_Zone_doFn) *MoqTime_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Zone_fnRecorder) DoReturnResults(fn MoqTime_genType_Zone_doReturnFn) *MoqTime_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Name   string
			Offset int
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Zone_doFn
		DoReturnFn MoqTime_genType_Zone_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Zone_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Zone_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Zone {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Zone_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Zone_paramsKey]*MoqTime_genType_Zone_results{},
		}
		r.Moq.ResultsByParams_Zone = append(r.Moq.ResultsByParams_Zone, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Zone) {
			copy(r.Moq.ResultsByParams_Zone[insertAt+1:], r.Moq.ResultsByParams_Zone[insertAt:0])
			r.Moq.ResultsByParams_Zone[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Zone(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Zone_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Zone_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Zone_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Name   string
					Offset int
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Zone_doFn
				DoReturnFn MoqTime_genType_Zone_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Zone(params MoqTime_genType_Zone_params) string {
	return fmt.Sprintf("Zone()")
}

func (m *MoqTime_genType) ParamsKey_Zone(params MoqTime_genType_Zone_params, anyParams uint64) MoqTime_genType_Zone_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Zone_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Unix() *MoqTime_genType_Unix_fnRecorder {
	return &MoqTime_genType_Unix_fnRecorder{
		Params:   MoqTime_genType_Unix_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Unix_fnRecorder) Any() *MoqTime_genType_Unix_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Unix(r.Params))
		return nil
	}
	return &MoqTime_genType_Unix_anyParams{Recorder: r}
}

func (r *MoqTime_genType_Unix_fnRecorder) Seq() *MoqTime_genType_Unix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Unix(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Unix_fnRecorder) NoSeq() *MoqTime_genType_Unix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Unix(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Unix_fnRecorder) ReturnResults(result1 int64) *MoqTime_genType_Unix_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Unix_doFn
		DoReturnFn MoqTime_genType_Unix_doReturnFn
	}{
		Values: &struct {
			Result1 int64
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Unix_fnRecorder) AndDo(fn MoqTime_genType_Unix_doFn) *MoqTime_genType_Unix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Unix_fnRecorder) DoReturnResults(fn MoqTime_genType_Unix_doReturnFn) *MoqTime_genType_Unix_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Unix_doFn
		DoReturnFn MoqTime_genType_Unix_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Unix_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Unix_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Unix {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Unix_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Unix_paramsKey]*MoqTime_genType_Unix_results{},
		}
		r.Moq.ResultsByParams_Unix = append(r.Moq.ResultsByParams_Unix, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Unix) {
			copy(r.Moq.ResultsByParams_Unix[insertAt+1:], r.Moq.ResultsByParams_Unix[insertAt:0])
			r.Moq.ResultsByParams_Unix[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Unix(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Unix_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Unix_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Unix_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int64
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Unix_doFn
				DoReturnFn MoqTime_genType_Unix_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Unix(params MoqTime_genType_Unix_params) string {
	return fmt.Sprintf("Unix()")
}

func (m *MoqTime_genType) ParamsKey_Unix(params MoqTime_genType_Unix_params, anyParams uint64) MoqTime_genType_Unix_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_Unix_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) UnixNano() *MoqTime_genType_UnixNano_fnRecorder {
	return &MoqTime_genType_UnixNano_fnRecorder{
		Params:   MoqTime_genType_UnixNano_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_UnixNano_fnRecorder) Any() *MoqTime_genType_UnixNano_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnixNano(r.Params))
		return nil
	}
	return &MoqTime_genType_UnixNano_anyParams{Recorder: r}
}

func (r *MoqTime_genType_UnixNano_fnRecorder) Seq() *MoqTime_genType_UnixNano_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnixNano(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_UnixNano_fnRecorder) NoSeq() *MoqTime_genType_UnixNano_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_UnixNano(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_UnixNano_fnRecorder) ReturnResults(result1 int64) *MoqTime_genType_UnixNano_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqTime_genType_UnixNano_doFn
		DoReturnFn MoqTime_genType_UnixNano_doReturnFn
	}{
		Values: &struct {
			Result1 int64
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_UnixNano_fnRecorder) AndDo(fn MoqTime_genType_UnixNano_doFn) *MoqTime_genType_UnixNano_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_UnixNano_fnRecorder) DoReturnResults(fn MoqTime_genType_UnixNano_doReturnFn) *MoqTime_genType_UnixNano_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 int64
		}
		Sequence   uint32
		DoFn       MoqTime_genType_UnixNano_doFn
		DoReturnFn MoqTime_genType_UnixNano_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_UnixNano_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_UnixNano_resultsByParams
	for n, res := range r.Moq.ResultsByParams_UnixNano {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_UnixNano_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_UnixNano_paramsKey]*MoqTime_genType_UnixNano_results{},
		}
		r.Moq.ResultsByParams_UnixNano = append(r.Moq.ResultsByParams_UnixNano, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_UnixNano) {
			copy(r.Moq.ResultsByParams_UnixNano[insertAt+1:], r.Moq.ResultsByParams_UnixNano[insertAt:0])
			r.Moq.ResultsByParams_UnixNano[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_UnixNano(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_UnixNano_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_UnixNano_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_UnixNano_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 int64
				}
				Sequence   uint32
				DoFn       MoqTime_genType_UnixNano_doFn
				DoReturnFn MoqTime_genType_UnixNano_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_UnixNano(params MoqTime_genType_UnixNano_params) string {
	return fmt.Sprintf("UnixNano()")
}

func (m *MoqTime_genType) ParamsKey_UnixNano(params MoqTime_genType_UnixNano_params, anyParams uint64) MoqTime_genType_UnixNano_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_UnixNano_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) MarshalBinary() *MoqTime_genType_MarshalBinary_fnRecorder {
	return &MoqTime_genType_MarshalBinary_fnRecorder{
		Params:   MoqTime_genType_MarshalBinary_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_MarshalBinary_fnRecorder) Any() *MoqTime_genType_MarshalBinary_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalBinary(r.Params))
		return nil
	}
	return &MoqTime_genType_MarshalBinary_anyParams{Recorder: r}
}

func (r *MoqTime_genType_MarshalBinary_fnRecorder) Seq() *MoqTime_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalBinary(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_MarshalBinary_fnRecorder) NoSeq() *MoqTime_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalBinary(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_MarshalBinary_fnRecorder) ReturnResults(result1 []byte, result2 error) *MoqTime_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_MarshalBinary_doFn
		DoReturnFn MoqTime_genType_MarshalBinary_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_MarshalBinary_fnRecorder) AndDo(fn MoqTime_genType_MarshalBinary_doFn) *MoqTime_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_MarshalBinary_fnRecorder) DoReturnResults(fn MoqTime_genType_MarshalBinary_doReturnFn) *MoqTime_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_MarshalBinary_doFn
		DoReturnFn MoqTime_genType_MarshalBinary_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_MarshalBinary_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_MarshalBinary_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MarshalBinary {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_MarshalBinary_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_MarshalBinary_paramsKey]*MoqTime_genType_MarshalBinary_results{},
		}
		r.Moq.ResultsByParams_MarshalBinary = append(r.Moq.ResultsByParams_MarshalBinary, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MarshalBinary) {
			copy(r.Moq.ResultsByParams_MarshalBinary[insertAt+1:], r.Moq.ResultsByParams_MarshalBinary[insertAt:0])
			r.Moq.ResultsByParams_MarshalBinary[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MarshalBinary(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_MarshalBinary_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_MarshalBinary_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_MarshalBinary_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqTime_genType_MarshalBinary_doFn
				DoReturnFn MoqTime_genType_MarshalBinary_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_MarshalBinary(params MoqTime_genType_MarshalBinary_params) string {
	return fmt.Sprintf("MarshalBinary()")
}

func (m *MoqTime_genType) ParamsKey_MarshalBinary(params MoqTime_genType_MarshalBinary_params, anyParams uint64) MoqTime_genType_MarshalBinary_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_MarshalBinary_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) GobEncode() *MoqTime_genType_GobEncode_fnRecorder {
	return &MoqTime_genType_GobEncode_fnRecorder{
		Params:   MoqTime_genType_GobEncode_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_GobEncode_fnRecorder) Any() *MoqTime_genType_GobEncode_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	return &MoqTime_genType_GobEncode_anyParams{Recorder: r}
}

func (r *MoqTime_genType_GobEncode_fnRecorder) Seq() *MoqTime_genType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_GobEncode_fnRecorder) NoSeq() *MoqTime_genType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_GobEncode(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_GobEncode_fnRecorder) ReturnResults(result1 []byte, result2 error) *MoqTime_genType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_GobEncode_doFn
		DoReturnFn MoqTime_genType_GobEncode_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_GobEncode_fnRecorder) AndDo(fn MoqTime_genType_GobEncode_doFn) *MoqTime_genType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_GobEncode_fnRecorder) DoReturnResults(fn MoqTime_genType_GobEncode_doReturnFn) *MoqTime_genType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_GobEncode_doFn
		DoReturnFn MoqTime_genType_GobEncode_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_GobEncode_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_GobEncode_resultsByParams
	for n, res := range r.Moq.ResultsByParams_GobEncode {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_GobEncode_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_GobEncode_paramsKey]*MoqTime_genType_GobEncode_results{},
		}
		r.Moq.ResultsByParams_GobEncode = append(r.Moq.ResultsByParams_GobEncode, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_GobEncode) {
			copy(r.Moq.ResultsByParams_GobEncode[insertAt+1:], r.Moq.ResultsByParams_GobEncode[insertAt:0])
			r.Moq.ResultsByParams_GobEncode[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_GobEncode(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_GobEncode_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_GobEncode_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_GobEncode_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqTime_genType_GobEncode_doFn
				DoReturnFn MoqTime_genType_GobEncode_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_GobEncode(params MoqTime_genType_GobEncode_params) string {
	return fmt.Sprintf("GobEncode()")
}

func (m *MoqTime_genType) ParamsKey_GobEncode(params MoqTime_genType_GobEncode_params, anyParams uint64) MoqTime_genType_GobEncode_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_GobEncode_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) MarshalJSON() *MoqTime_genType_MarshalJSON_fnRecorder {
	return &MoqTime_genType_MarshalJSON_fnRecorder{
		Params:   MoqTime_genType_MarshalJSON_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_MarshalJSON_fnRecorder) Any() *MoqTime_genType_MarshalJSON_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalJSON(r.Params))
		return nil
	}
	return &MoqTime_genType_MarshalJSON_anyParams{Recorder: r}
}

func (r *MoqTime_genType_MarshalJSON_fnRecorder) Seq() *MoqTime_genType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalJSON(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_MarshalJSON_fnRecorder) NoSeq() *MoqTime_genType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalJSON(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_MarshalJSON_fnRecorder) ReturnResults(result1 []byte, result2 error) *MoqTime_genType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_MarshalJSON_doFn
		DoReturnFn MoqTime_genType_MarshalJSON_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_MarshalJSON_fnRecorder) AndDo(fn MoqTime_genType_MarshalJSON_doFn) *MoqTime_genType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_MarshalJSON_fnRecorder) DoReturnResults(fn MoqTime_genType_MarshalJSON_doReturnFn) *MoqTime_genType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_MarshalJSON_doFn
		DoReturnFn MoqTime_genType_MarshalJSON_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_MarshalJSON_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_MarshalJSON_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MarshalJSON {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_MarshalJSON_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_MarshalJSON_paramsKey]*MoqTime_genType_MarshalJSON_results{},
		}
		r.Moq.ResultsByParams_MarshalJSON = append(r.Moq.ResultsByParams_MarshalJSON, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MarshalJSON) {
			copy(r.Moq.ResultsByParams_MarshalJSON[insertAt+1:], r.Moq.ResultsByParams_MarshalJSON[insertAt:0])
			r.Moq.ResultsByParams_MarshalJSON[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MarshalJSON(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_MarshalJSON_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_MarshalJSON_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_MarshalJSON_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqTime_genType_MarshalJSON_doFn
				DoReturnFn MoqTime_genType_MarshalJSON_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_MarshalJSON(params MoqTime_genType_MarshalJSON_params) string {
	return fmt.Sprintf("MarshalJSON()")
}

func (m *MoqTime_genType) ParamsKey_MarshalJSON(params MoqTime_genType_MarshalJSON_params, anyParams uint64) MoqTime_genType_MarshalJSON_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_MarshalJSON_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) MarshalText() *MoqTime_genType_MarshalText_fnRecorder {
	return &MoqTime_genType_MarshalText_fnRecorder{
		Params:   MoqTime_genType_MarshalText_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_MarshalText_fnRecorder) Any() *MoqTime_genType_MarshalText_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	return &MoqTime_genType_MarshalText_anyParams{Recorder: r}
}

func (r *MoqTime_genType_MarshalText_fnRecorder) Seq() *MoqTime_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_MarshalText_fnRecorder) NoSeq() *MoqTime_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_MarshalText(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_MarshalText_fnRecorder) ReturnResults(result1 []byte, result2 error) *MoqTime_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_MarshalText_doFn
		DoReturnFn MoqTime_genType_MarshalText_doReturnFn
	}{
		Values: &struct {
			Result1 []byte
			Result2 error
		}{
			Result1: result1,
			Result2: result2,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_MarshalText_fnRecorder) AndDo(fn MoqTime_genType_MarshalText_doFn) *MoqTime_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_MarshalText_fnRecorder) DoReturnResults(fn MoqTime_genType_MarshalText_doReturnFn) *MoqTime_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 []byte
			Result2 error
		}
		Sequence   uint32
		DoFn       MoqTime_genType_MarshalText_doFn
		DoReturnFn MoqTime_genType_MarshalText_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_MarshalText_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_MarshalText_resultsByParams
	for n, res := range r.Moq.ResultsByParams_MarshalText {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_MarshalText_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_MarshalText_paramsKey]*MoqTime_genType_MarshalText_results{},
		}
		r.Moq.ResultsByParams_MarshalText = append(r.Moq.ResultsByParams_MarshalText, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_MarshalText) {
			copy(r.Moq.ResultsByParams_MarshalText[insertAt+1:], r.Moq.ResultsByParams_MarshalText[insertAt:0])
			r.Moq.ResultsByParams_MarshalText[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_MarshalText(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_MarshalText_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_MarshalText_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_MarshalText_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 []byte
					Result2 error
				}
				Sequence   uint32
				DoFn       MoqTime_genType_MarshalText_doFn
				DoReturnFn MoqTime_genType_MarshalText_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_MarshalText(params MoqTime_genType_MarshalText_params) string {
	return fmt.Sprintf("MarshalText()")
}

func (m *MoqTime_genType) ParamsKey_MarshalText(params MoqTime_genType_MarshalText_params, anyParams uint64) MoqTime_genType_MarshalText_paramsKey {
	m.Scene.T.Helper()
	return MoqTime_genType_MarshalText_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqTime_genType_recorder) Truncate(d time.Duration) *MoqTime_genType_Truncate_fnRecorder {
	return &MoqTime_genType_Truncate_fnRecorder{
		Params: MoqTime_genType_Truncate_params{
			D: d,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Truncate_fnRecorder) Any() *MoqTime_genType_Truncate_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Truncate(r.Params))
		return nil
	}
	return &MoqTime_genType_Truncate_anyParams{Recorder: r}
}

func (a *MoqTime_genType_Truncate_anyParams) D() *MoqTime_genType_Truncate_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTime_genType_Truncate_fnRecorder) Seq() *MoqTime_genType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Truncate(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Truncate_fnRecorder) NoSeq() *MoqTime_genType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Truncate(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Truncate_fnRecorder) ReturnResults(result1 time.Time) *MoqTime_genType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Truncate_doFn
		DoReturnFn MoqTime_genType_Truncate_doReturnFn
	}{
		Values: &struct {
			Result1 time.Time
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Truncate_fnRecorder) AndDo(fn MoqTime_genType_Truncate_doFn) *MoqTime_genType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Truncate_fnRecorder) DoReturnResults(fn MoqTime_genType_Truncate_doReturnFn) *MoqTime_genType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Truncate_doFn
		DoReturnFn MoqTime_genType_Truncate_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Truncate_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Truncate_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Truncate {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Truncate_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Truncate_paramsKey]*MoqTime_genType_Truncate_results{},
		}
		r.Moq.ResultsByParams_Truncate = append(r.Moq.ResultsByParams_Truncate, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Truncate) {
			copy(r.Moq.ResultsByParams_Truncate[insertAt+1:], r.Moq.ResultsByParams_Truncate[insertAt:0])
			r.Moq.ResultsByParams_Truncate[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Truncate(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Truncate_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Truncate_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Truncate_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 time.Time
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Truncate_doFn
				DoReturnFn MoqTime_genType_Truncate_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Truncate(params MoqTime_genType_Truncate_params) string {
	return fmt.Sprintf("Truncate(%#v)", params.D)
}

func (m *MoqTime_genType) ParamsKey_Truncate(params MoqTime_genType_Truncate_params, anyParams uint64) MoqTime_genType_Truncate_paramsKey {
	m.Scene.T.Helper()
	var dUsed time.Duration
	var dUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Truncate.D == moq.ParamIndexByValue {
			dUsed = params.D
		} else {
			dUsedHash = hash.DeepHash(params.D)
		}
	}
	return MoqTime_genType_Truncate_paramsKey{
		Params: struct{ D time.Duration }{
			D: dUsed,
		},
		Hashes: struct{ D hash.Hash }{
			D: dUsedHash,
		},
	}
}

func (m *MoqTime_genType_recorder) Round(d time.Duration) *MoqTime_genType_Round_fnRecorder {
	return &MoqTime_genType_Round_fnRecorder{
		Params: MoqTime_genType_Round_params{
			D: d,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqTime_genType_Round_fnRecorder) Any() *MoqTime_genType_Round_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Round(r.Params))
		return nil
	}
	return &MoqTime_genType_Round_anyParams{Recorder: r}
}

func (a *MoqTime_genType_Round_anyParams) D() *MoqTime_genType_Round_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqTime_genType_Round_fnRecorder) Seq() *MoqTime_genType_Round_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Round(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqTime_genType_Round_fnRecorder) NoSeq() *MoqTime_genType_Round_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Round(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqTime_genType_Round_fnRecorder) ReturnResults(result1 time.Time) *MoqTime_genType_Round_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Round_doFn
		DoReturnFn MoqTime_genType_Round_doReturnFn
	}{
		Values: &struct {
			Result1 time.Time
		}{
			Result1: result1,
		},
		Sequence: sequence,
	})
	return r
}

func (r *MoqTime_genType_Round_fnRecorder) AndDo(fn MoqTime_genType_Round_doFn) *MoqTime_genType_Round_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqTime_genType_Round_fnRecorder) DoReturnResults(fn MoqTime_genType_Round_doReturnFn) *MoqTime_genType_Round_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values *struct {
			Result1 time.Time
		}
		Sequence   uint32
		DoFn       MoqTime_genType_Round_doFn
		DoReturnFn MoqTime_genType_Round_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqTime_genType_Round_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqTime_genType_Round_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Round {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqTime_genType_Round_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqTime_genType_Round_paramsKey]*MoqTime_genType_Round_results{},
		}
		r.Moq.ResultsByParams_Round = append(r.Moq.ResultsByParams_Round, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Round) {
			copy(r.Moq.ResultsByParams_Round[insertAt+1:], r.Moq.ResultsByParams_Round[insertAt:0])
			r.Moq.ResultsByParams_Round[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Round(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqTime_genType_Round_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqTime_genType_Round_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqTime_genType_Round_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values *struct {
					Result1 time.Time
				}
				Sequence   uint32
				DoFn       MoqTime_genType_Round_doFn
				DoReturnFn MoqTime_genType_Round_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqTime_genType) PrettyParams_Round(params MoqTime_genType_Round_params) string {
	return fmt.Sprintf("Round(%#v)", params.D)
}

func (m *MoqTime_genType) ParamsKey_Round(params MoqTime_genType_Round_params, anyParams uint64) MoqTime_genType_Round_paramsKey {
	m.Scene.T.Helper()
	var dUsed time.Duration
	var dUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.Round.D == moq.ParamIndexByValue {
			dUsed = params.D
		} else {
			dUsedHash = hash.DeepHash(params.D)
		}
	}
	return MoqTime_genType_Round_paramsKey{
		Params: struct{ D time.Duration }{
			D: dUsed,
		},
		Hashes: struct{ D hash.Hash }{
			D: dUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqTime_genType) Reset() {
	m.ResultsByParams_String = nil
	m.ResultsByParams_Format = nil
	m.ResultsByParams_AppendFormat = nil
	m.ResultsByParams_After = nil
	m.ResultsByParams_Before = nil
	m.ResultsByParams_Equal = nil
	m.ResultsByParams_IsZero = nil
	m.ResultsByParams_Date = nil
	m.ResultsByParams_Year = nil
	m.ResultsByParams_Month = nil
	m.ResultsByParams_Day = nil
	m.ResultsByParams_Weekday = nil
	m.ResultsByParams_ISOWeek = nil
	m.ResultsByParams_Clock = nil
	m.ResultsByParams_Hour = nil
	m.ResultsByParams_Minute = nil
	m.ResultsByParams_Second = nil
	m.ResultsByParams_Nanosecond = nil
	m.ResultsByParams_YearDay = nil
	m.ResultsByParams_Add = nil
	m.ResultsByParams_Sub = nil
	m.ResultsByParams_AddDate = nil
	m.ResultsByParams_UTC = nil
	m.ResultsByParams_Local = nil
	m.ResultsByParams_In = nil
	m.ResultsByParams_Location = nil
	m.ResultsByParams_Zone = nil
	m.ResultsByParams_Unix = nil
	m.ResultsByParams_UnixNano = nil
	m.ResultsByParams_MarshalBinary = nil
	m.ResultsByParams_GobEncode = nil
	m.ResultsByParams_MarshalJSON = nil
	m.ResultsByParams_MarshalText = nil
	m.ResultsByParams_Truncate = nil
	m.ResultsByParams_Round = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqTime_genType) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_String {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_String(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Format {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Format(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AppendFormat {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AppendFormat(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_After {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_After(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Before {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Before(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Equal {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Equal(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_IsZero {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_IsZero(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Date {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Date(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Year {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Year(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Month {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Month(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Day {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Day(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Weekday {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Weekday(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ISOWeek {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ISOWeek(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Clock {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Clock(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Hour {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Hour(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Minute {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Minute(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Second {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Second(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Nanosecond {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Nanosecond(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_YearDay {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_YearDay(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Add {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Add(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Sub {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Sub(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_AddDate {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_AddDate(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_UTC {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_UTC(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Local {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Local(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_In {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_In(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Location {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Location(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Zone {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Zone(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Unix {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Unix(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_UnixNano {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_UnixNano(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MarshalBinary {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MarshalBinary(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_GobEncode {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_GobEncode(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MarshalJSON {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MarshalJSON(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_MarshalText {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_MarshalText(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Truncate {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Truncate(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Round {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Round(results.Params))
			}
		}
	}
}
